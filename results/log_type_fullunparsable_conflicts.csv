/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/api/Api.java;<<<<<<< MINE
                error.printStackTrace();
=======
                cb.onSearchFailed(error);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
     * @param requestQueue
=======
     * @param requestQueue The {@link RequestQueue} to set
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
     * Note - If an {@link ImageManager} has not yet been set via
     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
     *
     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     * @see #setRequestQueue(com.android.volley.RequestQueue)
     * @see #isImageManagerSet()
     * @see #isRequestQueueSet()
     *
=======
     * <p>
     * Note - If an {@link ImageManager} has not yet been set via
     * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
     * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
     * </p>
     *
     * <p>
     * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
     * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
     * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
     * </p>
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     * @see #setRequestQueue(com.android.volley.RequestQueue)
     * @see #isImageManagerSet()
     * @see #isRequestQueueSet()
     *
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
         * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
         * for File models, defaults to {@link FileLoader}.
=======
         * Set the {@link ModelLoader} for the model.
         *
         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
         * defaults to {@link FileLoader}.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
         * the given model
=======
         * the given model. This must be called on the main thread.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Transformation.java;<<<<<<< MINE
            return TransformationUtils.centerCrop(pool.get(outWidth, outHeight, bitmap.getConfig()), bitmap, outWidth, outHeight);
=======
            final Bitmap toRuse = pool.get(outWidth, outHeight, bitmap.getConfig());
            return ImageResizer.centerCrop(toRuse, bitmap, outWidth, outHeight);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Transformation.java;<<<<<<< MINE
            return TransformationUtils.fitInSpace(bitmap, outWidth, outHeight);
=======

            return ImageResizer.fitCenter(bitmap, pool, outWidth, outHeight);
>>>>>>> YOURS
/home/arthur/analysis/projects/coreNLP/revisions/rev_7fd0b96_c8b050c/rev_7fd0b96-c8b050c/src/edu/stanford/nlp/sentiment/RNNOptions.java;<<<<<<< MINE
      unkWord = args[argIndex] + 1;
=======
      unkWord = args[argIndex + 1];
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    protected DiskLruCacheWrapper(DiskLruCache diskLruCache) {
        this.diskLruCache = diskLruCache;
        this.safeKeyGenerator = new SafeKeyGenerator();
=======
    private synchronized DiskLruCache getDiskCache() throws IOException {
        if (diskLruCache == null) {
            diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
        }
        return diskLruCache;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
            result = new LoadToken(cb, job, task.getId());
=======
            result = new LoadToken(cb, job);
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) { // only for tests, so we can ignore the tag
        this(-1, new MethodSignature(name, desc), Type.getType(owner), kind);
=======
    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {
        // only for tests, so we can ignore the tag and access
        this(0, -1, new MethodSignature(name, desc), Type.getType(owner), kind);
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
    public MethodInfo(int tag, MethodSignature signature, Type owner, MethodKind kind) {
=======
    public MethodInfo(int access, int tag, MethodSignature signature, Type owner, MethodKind kind) {
        this.access = access;
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
                .addValue("(" + tag + ")")
=======
                .addValue("(tag=" + tag + ", access=" + access + ")")
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/UpdateRelocatedMethodInvocations.java;<<<<<<< MINE
    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {
=======
    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassAnalyzer analyzer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/AddMethodDefaultImplementations.java;<<<<<<< MINE
    public AddMethodDefaultImplementations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {
=======
    public AddMethodDefaultImplementations(ClassVisitor next, ClassAnalyzer analyzer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    @Override
    public ModelLoader<GlideUrl, InputStream> build(Context context,
        MultiModelLoaderFactory multiFactory) {
      return new VolleyUrlLoader(requestQueue);
=======
    private final RequestQueue requestQueue;
    private final VolleyRequestFactory requestFactory;

    public VolleyUrlLoader(RequestQueue requestQueue) {
        this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
    }

    public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
        this.requestQueue = requestQueue;
        this.requestFactory = requestFactory;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    public void teardown() {
      // Do nothing, this instance doesn't own the request queue.
=======
    public DataFetcher<InputStream> getResourceFetcher(GlideUrl url, int width, int height) {
        return new VolleyStreamFetcher(
            requestQueue, url, new VolleyRequestFuture<InputStream>(), requestFactory);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public Priority getPriority() {
      return priority;
=======
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toURL().toString();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority));

        requestFuture.setRequest(requestQueue.add(request));

        return requestFuture.get();
    }

    @Override
    public void cleanup() {
        // Do nothing.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
  private Engine engine;
  private BitmapPool bitmapPool;
  private MemoryCache memoryCache;
  private ExecutorService sourceService;
  private ExecutorService diskCacheService;
  private DecodeFormat decodeFormat;
  private DiskCache.Factory diskCacheFactory;

  public GlideBuilder(Context context) {
    this.context = context.getApplicationContext();
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
   * to store and retrieve reused {@link android.graphics.Bitmap}s.
   *
   * @param bitmapPool The pool to use.
   * @return This builder.
   */
  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
    this.bitmapPool = bitmapPool;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
   * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
   *
   * @param memoryCache The cache to use.
   * @return This builder.
   */
  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
    this.memoryCache = memoryCache;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
   * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
   *
   * @param diskCache The disk cache to use.
   * @return This builder.
   * @deprecated Creating a disk cache directory on the main thread causes strict mode violations,
   * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
   * Scheduled to be removed in Glide 4.0.
   */
  @Deprecated
  public GlideBuilder setDiskCache(final DiskCache diskCache) {
    return setDiskCache(new DiskCache.Factory() {
      @Override
      public DiskCache build() {
        return diskCache;
      }
    });
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use
   * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
   * com.bumptech.glide.load.engine.Resource} data on disk.
   *
   * @param diskCacheFactory The disk cche factory to use.
   * @return This builder.
   */
  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
    this.diskCacheFactory = diskCacheFactory;
    return this;
  }

  /**
   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
   *
   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
   * for thumbnail requests to work properly. </p>
   *
   * @param service The ExecutorService to use.
   * @return This builder.
   * @see #setDiskCacheService(java.util.concurrent.ExecutorService)
   * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
   */
  public GlideBuilder setResizeService(ExecutorService service) {
    this.sourceService = service;
    return this;
  }

  /**
   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
   *
   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
   * for thumbnail requests to work properly. </p>
   *
   * @param service The ExecutorService to use.
   * @return This builder.
   * @see #setResizeService(java.util.concurrent.ExecutorService)
   * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
   */
  public GlideBuilder setDiskCacheService(ExecutorService service) {
    this.diskCacheService = service;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
   * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
   * android.graphics.Bitmap}s they decode.
   *
   * <p> Decode format is always a suggestion, not a requirement. See {@link
   * com.bumptech.glide.load.DecodeFormat} for more details. </p>
   *
   * <p> If you instantiate and use a custom decoder, it will use {@link
   * com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default. </p>
   *
   * <p> Calls to this method are ignored on KitKat and Lollipop. See #301. </p>
   *
   * @param decodeFormat The format to use.
   * @return This builder.
   */
  public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
    if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {
      this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");
      }
    } else {
      this.decodeFormat = decodeFormat;
    }
    return this;
  }

  // For testing.
  GlideBuilder setEngine(Engine engine) {
    this.engine = engine;
    return this;
  }

  Glide createGlide() {
    if (sourceService == null) {
      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
      sourceService = new FifoPriorityThreadPoolExecutor(cores);
    }
    if (diskCacheService == null) {
      diskCacheService = new FifoPriorityThreadPoolExecutor(1);
    }

    MemorySizeCalculator calculator = new MemorySizeCalculator(context);
    if (bitmapPool == null) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        int size = calculator.getBitmapPoolSize();
        if (DecodeFormat.REQUIRE_ARGB_8888) {
          bitmapPool = new LruBitmapPool(size, Collections.singleton(Bitmap.Config.ARGB_8888));
        } else {
          bitmapPool = new LruBitmapPool(size);
        }
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
=======
    private Engine engine;
    private BitmapPool bitmapPool;
    private MemoryCache memoryCache;
    private ExecutorService sourceService;
    private ExecutorService diskCacheService;
    private DecodeFormat decodeFormat;
    private DiskCache.Factory diskCacheFactory;

    public GlideBuilder(Context context) {
        this.context = context.getApplicationContext();
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use to store and
     * retrieve reused {@link android.graphics.Bitmap}s.
     *
     * @param bitmapPool The pool to use.
     * @return This builder.
     */
    public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
        this.bitmapPool = bitmapPool;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
     * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
     *
     * @param memoryCache  The cache to use.
     * @return This builder.
     */
    public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
        this.memoryCache = memoryCache;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
     * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
     *
     * @deprecated Creating a disk cache directory on the main thread causes strict mode violations, use
     * {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead. Scheduled to be removed
     * in Glide 4.0.
     * @param diskCache The disk cache to use.
     * @return This builder.
     */
    @Deprecated
    public GlideBuilder setDiskCache(final DiskCache diskCache) {
        return setDiskCache(new DiskCache.Factory() {
            @Override
            public DiskCache build() {
                return diskCache;
            }
        });
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use to construct
     * the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store
     * {@link com.bumptech.glide.load.engine.Resource} data on disk.
     *
     * @param diskCacheFactory The disk cche factory to use.
     * @return This builder.
     */
    public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
        this.diskCacheFactory = diskCacheFactory;
        return this;
    }

    /**
     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
     * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
     *
     * <p>
     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
     *     requests to work properly.
     * </p>
     *
     * @see #setDiskCacheService(java.util.concurrent.ExecutorService)
     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
     *
     * @param service The ExecutorService to use.
     * @return This builder.
     */
    public GlideBuilder setResizeService(ExecutorService service) {
        this.sourceService = service;
        return this;
    }

    /**
     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
     * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
     *
     * <p>
     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
     *     requests to work properly.
     * </p>
     *
     * @see #setResizeService(java.util.concurrent.ExecutorService)
     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
     *
     * @param service The ExecutorService to use.
     * @return This builder.
     */
    public GlideBuilder setDiskCacheService(ExecutorService service) {
        this.diskCacheService = service;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all the default
     * decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap}s they
     * decode.
     *
     * <p>
     *     Decode format is always a suggestion, not a requirement. See {@link com.bumptech.glide.load.DecodeFormat} for
     *     more details.
     * </p>
     *
     * <p>
     *     If you instantiate and use a custom decoder, it will use
     *     {@link com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default.
     * </p>
     *
     * <p>
     *     Calls to this method are ignored on KitKat and Lollipop. See #301.
     * </p>
     *
     * @param decodeFormat The format to use.
     * @return This builder.
     */
    public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
        this.decodeFormat = decodeFormat;
        return this;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
    if (engine == null) {
      engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);
    }
=======
        MemorySizeCalculator calculator = new MemorySizeCalculator(context);
        if (bitmapPool == null) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                int size = calculator.getBitmapPoolSize();
                bitmapPool = new LruBitmapPool(size);
            } else {
                bitmapPool = new BitmapPoolAdapter();
            }
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    @Override
    public String getId() {
      return "AT_MOST.com.bumptech.glide.load.data.bitmap";
=======
    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }

        boolean hasAlpha = false;
        // We probably only need 25, but this is safer (particularly since the buffer size is > 1024).
        is.mark(1024);
        try {
            hasAlpha = new ImageHeaderParser(is).hasAlpha();
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }

        return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
    private final OkHttpClient client;
    private final GlideUrl url;
    private InputStream stream;
    private ResponseBody responseBody;

    public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
        this.client = client;
        this.url = url;
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private final OkHttpClient client;
  private final GlideUrl url;
  private InputStream stream;
  private ResponseBody responseBody;

  public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
    this.client = client;
    this.url = url;
  }

  @Override
  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    @Override
    public void cleanup() {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignored
            }
        }
        if (responseBody != null) {
            try {
                responseBody.close();
            } catch (IOException e) {
                // Ignored.
            }
=======
      @Override
      public void onResponse(Response response) throws IOException {
        if (response.isSuccessful()) {
          String contentLength = response.header(CONTENT_LENGTH_HEADER);
          responseBody = response.body();
          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
        } else if (Logs.isEnabled(Log.DEBUG)) {
          Logs.log(Log.DEBUG, "OkHttp got error response: " + response.code() + ", "
              + response.message());
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE

    @Override
    public String getId() {
        return url.getCacheKey();
=======
    if (responseBody != null) {
      try {
        responseBody.close();
      } catch (IOException e) {
        // Ignored.
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {

        @Override
        public Request<byte[]> create(
                    String url, VolleyRequestFuture<InputStream> future,
                    Request.Priority priority, Map<String, String> headers) {
            return new GlideRequest(url, future, priority, headers);
        }

    };

    private final RequestQueue requestQueue;
    private final VolleyRequestFactory requestFactory;
    private final GlideUrl url;
    private VolleyRequestFuture<InputStream> requestFuture;

    @SuppressWarnings("unused")
    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
        this(requestQueue, url,  null);
=======
  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
    @Override
    public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
        Request.Priority priority, Map<String, String> headers) {
      return new GlideRequest(url, callback, priority, headers);
    }
  };

  private final RequestQueue requestQueue;
  private final VolleyRequestFactory requestFactory;
  private final GlideUrl url;
  private volatile Request<byte[]> request;

  @SuppressWarnings("unused")
  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
    this(requestQueue, url, DEFAULT_REQUEST_FACTORY);
  }

  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
      VolleyRequestFactory requestFactory) {
    this.requestQueue = requestQueue;
    this.url = url;
    this.requestFactory = requestFactory;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
        url.getHeaders());
    requestQueue.add(request);
  }

  @Override
  public void cleanup() {
    // Do nothing.
  }

  @Override
  public void cancel() {
    Request<byte[]> local = request;
    if (local != null) {
      local.cancel();
    }
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  private static Request.Priority glideToVolleyPriority(Priority priority) {
    switch (priority) {
      case LOW:
        return Request.Priority.LOW;
      case HIGH:
        return Request.Priority.HIGH;
      case IMMEDIATE:
        return Request.Priority.IMMEDIATE;
      default:
        return Request.Priority.NORMAL;
    }
  }

  /**
   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
   * results on volley's background thread.
   */
  public static class GlideRequest extends Request<byte[]> {
    private final DataCallback<? super InputStream> callback;
    private final Priority priority;
    private final Map<String, String> headers;

    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority) {
      this(url, callback, priority, Collections.<String, String>emptyMap());
    }

    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority,
        Map<String, String> headers) {
      super(Method.GET, url, null);
      this.callback = callback;
      this.priority = priority;
      this.headers = headers;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toStringUrl();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority), url.getHeaders());

        requestFuture.setRequest(requestQueue.add(request));

        return requestFuture.get();
=======
    public Priority getPriority() {
      return priority;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public String getId() {
        return url.getCacheKey();
=======
    protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
      callback.onDataReady(new ByteArrayInputStream(response.data));
      return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java;<<<<<<< MINE
     * <p>
     *     Status will update per frame to allow the caller to tell whether or not the current frame was decoded
     *     successfully and/or completely. Format and open failures persist across frames.
     * </p>
     */
    public int getStatus() {
        return status;
    }

    /**
     * Move the animation frame counter forward.
     */
    public void advance() {
        framePointer = (framePointer + 1) % header.frameCount;
    }

    /**
     * Gets display duration for specified frame.
     *
     * @param n int index of frame.
     * @return delay in milliseconds.
     */
    public int getDelay(int n) {
        int delay = -1;
        if ((n >= 0) && (n < header.frameCount)) {
            delay = header.frames.get(n).delay;
        }
        return delay;
    }

    /**
     * Gets display duration for the upcoming frame in ms.
     */
    public int getNextDelay() {
        if (header.frameCount <= 0 || framePointer < 0) {
            return -1;
        }

        return getDelay(framePointer);
    }

    /**
     * Gets the number of frames read from file.
     *
     * @return frame count.
     */
    public int getFrameCount() {
        return header.frameCount;
    }

    /**
     * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
     *
     * @return frame index.
     */
    public int getCurrentFrameIndex() {
        return framePointer;
    }

    public void resetFrameIndex() {
        framePointer = -1;
    }

    /**
     * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
     *
     * @return iteration count if one was specified, else 1.
     */
    public int getLoopCount() {
        return header.loopCount;
    }

    /**
     * Get the next frame in the animation sequence.
     *
     * @return Bitmap representation of frame.
     */
    public synchronized Bitmap getNextFrame() {
        if (header.frameCount <= 0 || framePointer < 0) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer=" + framePointer);
            }
            status = STATUS_FORMAT_ERROR;
        }
        if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Unable to decode frame, status=" + status);
            }
            return null;
        }
        status = STATUS_OK;

        GifFrame currentFrame = header.frames.get(framePointer);
        GifFrame previousFrame = null;
        int previousIndex = framePointer - 1;
        if (previousIndex >= 0) {
            previousFrame = header.frames.get(previousIndex);
        }

        // Set the appropriate color table.
        if (currentFrame.lct == null) {
            act = header.gct;
        } else {
            act = currentFrame.lct;
            if (header.bgIndex == currentFrame.transIndex) {
                header.bgColor = 0;
            }
        }

        int save = 0;
        if (currentFrame.transparency) {
            save = act[currentFrame.transIndex];
            // Set transparent color if specified.
            act[currentFrame.transIndex] = 0;
        }
        if (act == null) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "No Valid Color Table");
            }
            // No color table defined.
            status = STATUS_FORMAT_ERROR;
            return null;
        }

        // Transfer pixel data to image.
        Bitmap result = setPixels(currentFrame, previousFrame);

        // Reset the transparent pixel in the color table
        if (currentFrame.transparency) {
            act[currentFrame.transIndex] = save;
        }

        return result;
    }

    /**
     * Reads GIF image from stream.
     *
     * @param is containing GIF file.
     * @return read status code (0 = no errors).
     */
    public int read(InputStream is, int contentLength) {
        if (is != null) {
            try {
                int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
                ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
                int nRead;
                byte[] data = new byte[16384];
                while ((nRead = is.read(data, 0, data.length)) != -1) {
                    buffer.write(data, 0, nRead);
                }
                buffer.flush();

                read(buffer.toByteArray());
            } catch (IOException e) {
                Log.w(TAG, "Error reading data from stream", e);
            }
        } else {
            status = STATUS_OPEN_ERROR;
        }

        try {
            if (is != null) {
                is.close();
            }
        } catch (IOException e) {
            Log.w(TAG, "Error closing stream", e);
        }

        return status;
    }

    public void clear() {
        header = null;
        data = null;
        mainPixels = null;
        mainScratch = null;
        if (previousImage != null) {
            bitmapProvider.release(previousImage);
        }
        previousImage = null;
    }

    public void setData(GifHeader header, byte[] data) {
        this.header = header;
        this.data = data;
        this.status = STATUS_OK;
        framePointer = INITIAL_FRAME_POINTER;
        // Initialize the raw data buffer.
        rawData = ByteBuffer.wrap(data);
        rawData.rewind();
        rawData.order(ByteOrder.LITTLE_ENDIAN);


        // No point in specially saving an old frame if we're never going to use it.
        savePrevious = false;
        for (GifFrame frame : header.frames) {
            if (frame.dispose == DISPOSAL_PREVIOUS) {
                savePrevious = true;
                break;
            }
        }

        // Now that we know the size, init scratch arrays.
        mainPixels = new byte[header.width * header.height];
        mainScratch = new int[header.width * header.height];
    }

    private GifHeaderParser getHeaderParser() {
        if (parser == null) {
            parser = new GifHeaderParser();
        }
        return parser;
    }

    /**
     * Reads GIF image from byte array.
     *
     * @param data containing GIF file.
     * @return read status code (0 = no errors).
     */
    public int read(byte[] data) {
        this.data = data;
        this.header = getHeaderParser().setData(data).parseHeader();
        if (data != null) {
            // Initialize the raw data buffer.
            rawData = ByteBuffer.wrap(data);
            rawData.rewind();
            rawData.order(ByteOrder.LITTLE_ENDIAN);

            // Now that we know the size, init scratch arrays.
            mainPixels = new byte[header.width * header.height];
            mainScratch = new int[header.width * header.height];

            // No point in specially saving an old frame if we're never going to use it.
            savePrevious = false;
            for (GifFrame frame : header.frames) {
                if (frame.dispose == DISPOSAL_PREVIOUS) {
                    savePrevious = true;
                    break;
                }
            }
        }

        return status;
    }

    /**
     * Creates new frame image from current data (and previous frames as specified by their disposition codes).
     */
    private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {

        int width = header.width;
        int height = header.height;

        // Final location of blended pixels.
        final int[] dest = mainScratch;

        // fill in starting image contents based on last image's dispose code
        if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
            // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our mainScratch
            // and therefore so will our dest array.
            if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
                // Start with a canvas filled with the background color
                int c = 0;
                if (!currentFrame.transparency) {
                    c = header.bgColor;
                }
                Arrays.fill(dest, c);
            } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
                // Start with the previous frame
                previousImage.getPixels(dest, 0, width, 0, 0, width, height);
            }
        }

        // Decode pixels for this frame  into the global pixels[] scratch.
        decodeBitmapData(currentFrame);

        // Copy each source line to the appropriate place in the destination.
        int pass = 1;
        int inc = 8;
        int iline = 0;
        for (int i = 0; i < currentFrame.ih; i++) {
            int line = i;
            if (currentFrame.interlace) {
                if (iline >= currentFrame.ih) {
                    pass++;
                    switch (pass) {
                        case 2:
                            iline = 4;
                            break;
                        case 3:
                            iline = 2;
                            inc = 4;
                            break;
                        case 4:
                            iline = 1;
                            inc = 2;
                            break;
                        default:
                            break;
                    }
                }
                line = iline;
                iline += inc;
            }
            line += currentFrame.iy;
            if (line < header.height) {
                int k = line * header.width;
                // Start of line in dest.
                int dx = k + currentFrame.ix;
                // End of dest line.
                int dlim = dx + currentFrame.iw;
                if ((k + header.width) < dlim) {
                    // Past dest edge.
                    dlim = k + header.width;
                }
                // Start of line in source.
                int sx = i * currentFrame.iw;
                while (dx < dlim) {
                    // Map color and insert in destination.
                    int index = ((int) mainPixels[sx++]) & 0xff;
                    int c = act[index];
                    if (c != 0) {
                        dest[dx] = c;
                    }
                    dx++;
                }
            }
        }

        // Copy pixels into previous image
        if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
            || currentFrame.dispose == DISPOSAL_NONE)) {
            if (previousImage == null) {
                previousImage = getNextBitmap();
            }
            previousImage.setPixels(dest, 0, width, 0, 0, width, height);
        }

        // Set pixels for current image.
        Bitmap result = getNextBitmap();
        result.setPixels(dest, 0, width, 0, 0, width, height);
        return result;
    }

    /**
     * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
     */
    private void decodeBitmapData(GifFrame frame) {
        if (frame != null) {
            // Jump to the frame start position.
            rawData.position(frame.bufferFrameStart);
        }

        int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
        int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count, i, datum,
                dataSize, first, top, bi, pi;

        if (mainPixels == null || mainPixels.length < npix) {
            // Allocate new pixel array.
            mainPixels = new byte[npix];
        }
        if (prefix == null) {
            prefix = new short[MAX_STACK_SIZE];
        }
        if (suffix == null) {
            suffix = new byte[MAX_STACK_SIZE];
        }
        if (pixelStack == null) {
            pixelStack = new byte[MAX_STACK_SIZE + 1];
        }

        // Initialize GIF data stream decoder.
        dataSize = read();
        clear = 1 << dataSize;
        endOfInformation = clear + 1;
        available = clear + 2;
        oldCode = NULL_CODE;
        codeSize = dataSize + 1;
        codeMask = (1 << codeSize) - 1;
        for (code = 0; code < clear; code++) {
            // XXX ArrayIndexOutOfBoundsException.
            prefix[code] = 0;
            suffix[code] = (byte) code;
        }

        // Decode GIF pixel stream.
        datum = bits = count = first = top = pi = bi = 0;
        for (i = 0; i < npix; ) {
            // Load bytes until there are enough bits for a code.
            if (count == 0) {
                // Read a new data block.
                count = readBlock();
                if (count <= 0) {
                    status = STATUS_PARTIAL_DECODE;
                    break;
                }
                bi = 0;
            }

            datum += (((int) block[bi]) & 0xff) << bits;
            bits += 8;
            bi++;
            count--;

            while (bits >= codeSize) {
                // Get the next code.
                code = datum & codeMask;
                datum >>= codeSize;
                bits -= codeSize;

                // Interpret the code.
                if (code == clear) {
                    // Reset decoder.
                    codeSize = dataSize + 1;
                    codeMask = (1 << codeSize) - 1;
                    available = clear + 2;
                    oldCode = NULL_CODE;
                    continue;
                }

                if (code > available) {
                    status = STATUS_PARTIAL_DECODE;
                    break;
                }

                if (code == endOfInformation) {
                    break;
                }

                if (oldCode == NULL_CODE) {
                    pixelStack[top++] = suffix[code];
                    oldCode = code;
                    first = code;
                    continue;
                }
                inCode = code;
                if (code >= available) {
                    pixelStack[top++] = (byte) first;
                    code = oldCode;
                }
                while (code >= clear) {
                    pixelStack[top++] = suffix[code];
                    code = prefix[code];
                }
                first = ((int) suffix[code]) & 0xff;
                pixelStack[top++] = (byte) first;

                // Add a new string to the string table.
                if (available < MAX_STACK_SIZE) {
                    prefix[available] = (short) oldCode;
                    suffix[available] = (byte) first;
                    available++;
                    if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
                        codeSize++;
                        codeMask += available;
                    }
                }
                oldCode = inCode;

                while (top > 0) {
                    // Pop a pixel off the pixel stack.
                    top--;
                    mainPixels[pi++] = pixelStack[top];
                    i++;
                }
            }
        }

        // Clear missing pixels.
        for (i = pi; i < npix; i++) {
            mainPixels[i] = 0;
        }
    }

    /**
     * Reads a single byte from the input stream.
     */
    private int read() {
        int curByte = 0;
        try {
            curByte = rawData.get() & 0xFF;
        } catch (Exception e) {
            status = STATUS_FORMAT_ERROR;
        }
        return curByte;
    }

    /**
     * Reads next variable length block from input.
     *
     * @return number of bytes stored in "buffer".
     */
    private int readBlock() {
        int blockSize = read();
        int n = 0;
        if (blockSize > 0) {
            try {
                int count;
                while (n < blockSize) {
                    count = blockSize - n;
                    rawData.get(block, n, count);

                    n += count;
                }
            } catch (Exception e) {
                Log.w(TAG, "Error Reading Block", e);
                status = STATUS_FORMAT_ERROR;
            }
        }
        return n;
    }

    private Bitmap getNextBitmap() {
        Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
        if (result == null) {
            result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
        }
        setAlpha(result);
        return result;
    }

    @TargetApi(12)
    private static void setAlpha(Bitmap bitmap) {
        if (Build.VERSION.SDK_INT >= 12) {
            bitmap.setHasAlpha(true);
        }
=======
     * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
     *               android.graphics.Bitmap}.
     */
    Bitmap obtain(int width, int height, Bitmap.Config config);

    /**
     * Releases the given Bitmap back to the pool.
     */
    void release(Bitmap bitmap);
  }

  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
    this(provider);
    setData(gifHeader, rawData);
  }

  public GifDecoder(BitmapProvider provider) {
    this.bitmapProvider = provider;
    header = new GifHeader();
  }

  public int getWidth() {
    return header.width;
  }

  public int getHeight() {
    return header.height;
  }

  public ByteBuffer getData() {
    return rawData;
  }

  /**
   * Returns the current status of the decoder.
   *
   * <p> Status will update per frame to allow the caller to tell whether or not the current frame
   * was decoded successfully and/or completely. Format and open failures persist across frames.
   * </p>
   */
  public int getStatus() {
    return status;
  }

  /**
   * Move the animation frame counter forward.
   */
  public void advance() {
    framePointer = (framePointer + 1) % header.frameCount;
  }

  /**
   * Gets display duration for specified frame.
   *
   * @param n int index of frame.
   * @return delay in milliseconds.
   */
  public int getDelay(int n) {
    int delay = -1;
    if ((n >= 0) && (n < header.frameCount)) {
      delay = header.frames.get(n).delay;
    }
    return delay;
  }

  /**
   * Gets display duration for the upcoming frame in ms.
   */
  public int getNextDelay() {
    if (header.frameCount <= 0 || framePointer < 0) {
      return -1;
    }

    return getDelay(framePointer);
  }

  /**
   * Gets the number of frames read from file.
   *
   * @return frame count.
   */
  public int getFrameCount() {
    return header.frameCount;
  }

  /**
   * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
   *
   * @return frame index.
   */
  public int getCurrentFrameIndex() {
    return framePointer;
  }

  public void resetFrameIndex() {
    framePointer = -1;
  }

  /**
   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
   *
   * @return iteration count if one was specified, else 1.
   */
  public int getLoopCount() {
    return header.loopCount;
  }

  /**
   * Get the next frame in the animation sequence.
   *
   * @return Bitmap representation of frame.
   */
  public synchronized Bitmap getNextFrame() {
    if (header.frameCount <= 0 || framePointer < 0) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
            + framePointer);
      }
      status = STATUS_FORMAT_ERROR;
    }
    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "Unable to decode frame, status=" + status);
      }
      return null;
    }
    status = STATUS_OK;

    GifFrame currentFrame = header.frames.get(framePointer);
    GifFrame previousFrame = null;
    int previousIndex = framePointer - 1;
    if (previousIndex >= 0) {
      previousFrame = header.frames.get(previousIndex);
    }

    // Set the appropriate color table.
    if (currentFrame.lct == null) {
      act = header.gct;
    } else {
      act = currentFrame.lct;
      if (header.bgIndex == currentFrame.transIndex) {
        header.bgColor = 0;
      }
    }

    int save = 0;
    if (currentFrame.transparency) {
      save = act[currentFrame.transIndex];
      // Set transparent color if specified.
      act[currentFrame.transIndex] = 0;
    }
    if (act == null) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "No Valid Color Table");
      }
      // No color table defined.
      status = STATUS_FORMAT_ERROR;
      return null;
    }

    // Transfer pixel data to image.
    Bitmap result = setPixels(currentFrame, previousFrame);

    // Reset the transparent pixel in the color table
    if (currentFrame.transparency) {
      act[currentFrame.transIndex] = save;
    }

    return result;
  }

  /**
   * Reads GIF image from stream.
   *
   * @param is containing GIF file.
   * @return read status code (0 = no errors).
   */
  public int read(InputStream is, int contentLength) {
    if (is != null) {
      try {
        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
        int nRead;
        byte[] data = new byte[16384];
        while ((nRead = is.read(data, 0, data.length)) != -1) {
          buffer.write(data, 0, nRead);
        }
        buffer.flush();

        read(buffer.toByteArray());
      } catch (IOException e) {
        Log.w(TAG, "Error reading data from stream", e);
      }
    } else {
      status = STATUS_OPEN_ERROR;
    }

    try {
      if (is != null) {
        is.close();
      }
    } catch (IOException e) {
      Log.w(TAG, "Error closing stream", e);
    }

    return status;
  }

  public void clear() {
    header = null;
    mainPixels = null;
    mainScratch = null;
    if (previousImage != null) {
      bitmapProvider.release(previousImage);
    }
    previousImage = null;
    rawData = null;
  }

  public synchronized void setData(GifHeader header, byte[] data) {
    setData(header, ByteBuffer.wrap(data));
  }

  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
    this.status = STATUS_OK;
    this.header = header;
    framePointer = INITIAL_FRAME_POINTER;
    // Initialize the raw data buffer.
    rawData = buffer.asReadOnlyBuffer();
    rawData.rewind();
    rawData.order(ByteOrder.LITTLE_ENDIAN);

    // No point in specially saving an old frame if we're never going to use it.
    savePrevious = false;
    for (GifFrame frame : header.frames) {
      if (frame.dispose == DISPOSAL_PREVIOUS) {
        savePrevious = true;
        break;
      }
    }

    // Now that we know the size, init scratch arrays.
    mainPixels = new byte[header.width * header.height];
    mainScratch = new int[header.width * header.height];
  }

  private GifHeaderParser getHeaderParser() {
    if (parser == null) {
      parser = new GifHeaderParser();
    }
    return parser;
  }

  /**
   * Reads GIF image from byte array.
   *
   * @param data containing GIF file.
   * @return read status code (0 = no errors).
   */
  public synchronized int read(byte[] data) {
    this.header = getHeaderParser().setData(data).parseHeader();
    if (data != null) {
      // Initialize the raw data buffer.
      rawData = ByteBuffer.wrap(data);
      rawData.rewind();
      rawData.order(ByteOrder.LITTLE_ENDIAN);

      // Now that we know the size, init scratch arrays.
      mainPixels = new byte[header.width * header.height];
      mainScratch = new int[header.width * header.height];

      // No point in specially saving an old frame if we're never going to use it.
      savePrevious = false;
      for (GifFrame frame : header.frames) {
        if (frame.dispose == DISPOSAL_PREVIOUS) {
          savePrevious = true;
          break;
        }
      }
    }

    return status;
  }

  /**
   * Creates new frame image from current data (and previous frames as specified by their
   * disposition codes).
   */
  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {

    int width = header.width;
    int height = header.height;

    // Final location of blended pixels.
    final int[] dest = mainScratch;

    // fill in starting image contents based on last image's dispose code
    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
      // mainScratch
      // and therefore so will our dest array.
      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
        // Start with a canvas filled with the background color
        int c = 0;
        if (!currentFrame.transparency) {
          c = header.bgColor;
        }
        Arrays.fill(dest, c);
      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
        // Start with the previous frame
        previousImage.getPixels(dest, 0, width, 0, 0, width, height);
      }
    }

    // Decode pixels for this frame  into the global pixels[] scratch.
    decodeBitmapData(currentFrame);

    // Copy each source line to the appropriate place in the destination.
    int pass = 1;
    int inc = 8;
    int iline = 0;
    for (int i = 0; i < currentFrame.ih; i++) {
      int line = i;
      if (currentFrame.interlace) {
        if (iline >= currentFrame.ih) {
          pass++;
          switch (pass) {
            case 2:
              iline = 4;
              break;
            case 3:
              iline = 2;
              inc = 4;
              break;
            case 4:
              iline = 1;
              inc = 2;
              break;
            default:
              break;
          }
        }
        line = iline;
        iline += inc;
      }
      line += currentFrame.iy;
      if (line < header.height) {
        int k = line * header.width;
        // Start of line in dest.
        int dx = k + currentFrame.ix;
        // End of dest line.
        int dlim = dx + currentFrame.iw;
        if ((k + header.width) < dlim) {
          // Past dest edge.
          dlim = k + header.width;
        }
        // Start of line in source.
        int sx = i * currentFrame.iw;
        while (dx < dlim) {
          // Map color and insert in destination.
          int index = ((int) mainPixels[sx++]) & 0xff;
          int c = act[index];
          if (c != 0) {
            dest[dx] = c;
          }
          dx++;
        }
      }
    }

    // Copy pixels into previous image
    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
        || currentFrame.dispose == DISPOSAL_NONE)) {
      if (previousImage == null) {
        previousImage = getNextBitmap();
      }
      previousImage.setPixels(dest, 0, width, 0, 0, width, height);
    }

    // Set pixels for current image.
    Bitmap result = getNextBitmap();
    result.setPixels(dest, 0, width, 0, 0, width, height);
    return result;
  }

  /**
   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
   */
  private void decodeBitmapData(GifFrame frame) {
    if (frame != null) {
      // Jump to the frame start position.
      rawData.position(frame.bufferFrameStart);
    }

    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
        i, datum,
        dataSize, first, top, bi, pi;

    if (mainPixels == null || mainPixels.length < npix) {
      // Allocate new pixel array.
      mainPixels = new byte[npix];
    }
    if (prefix == null) {
      prefix = new short[MAX_STACK_SIZE];
    }
    if (suffix == null) {
      suffix = new byte[MAX_STACK_SIZE];
    }
    if (pixelStack == null) {
      pixelStack = new byte[MAX_STACK_SIZE + 1];
    }

    // Initialize GIF data stream decoder.
    dataSize = read();
    clear = 1 << dataSize;
    endOfInformation = clear + 1;
    available = clear + 2;
    oldCode = NULL_CODE;
    codeSize = dataSize + 1;
    codeMask = (1 << codeSize) - 1;
    for (code = 0; code < clear; code++) {
      // XXX ArrayIndexOutOfBoundsException.
      prefix[code] = 0;
      suffix[code] = (byte) code;
    }

    // Decode GIF pixel stream.
    datum = bits = count = first = top = pi = bi = 0;
    for (i = 0; i < npix; ) {
      // Load bytes until there are enough bits for a code.
      if (count == 0) {
        // Read a new data block.
        count = readBlock();
        if (count <= 0) {
          status = STATUS_PARTIAL_DECODE;
          break;
        }
        bi = 0;
      }

      datum += (((int) block[bi]) & 0xff) << bits;
      bits += 8;
      bi++;
      count--;

      while (bits >= codeSize) {
        // Get the next code.
        code = datum & codeMask;
        datum >>= codeSize;
        bits -= codeSize;

        // Interpret the code.
        if (code == clear) {
          // Reset decoder.
          codeSize = dataSize + 1;
          codeMask = (1 << codeSize) - 1;
          available = clear + 2;
          oldCode = NULL_CODE;
          continue;
        }

        if (code > available) {
          status = STATUS_PARTIAL_DECODE;
          break;
        }

        if (code == endOfInformation) {
          break;
        }

        if (oldCode == NULL_CODE) {
          pixelStack[top++] = suffix[code];
          oldCode = code;
          first = code;
          continue;
        }
        inCode = code;
        if (code >= available) {
          pixelStack[top++] = (byte) first;
          code = oldCode;
        }
        while (code >= clear) {
          pixelStack[top++] = suffix[code];
          code = prefix[code];
        }
        first = ((int) suffix[code]) & 0xff;
        pixelStack[top++] = (byte) first;

        // Add a new string to the string table.
        if (available < MAX_STACK_SIZE) {
          prefix[available] = (short) oldCode;
          suffix[available] = (byte) first;
          available++;
          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
            codeSize++;
            codeMask += available;
          }
        }
        oldCode = inCode;

        while (top > 0) {
          // Pop a pixel off the pixel stack.
          top--;
          mainPixels[pi++] = pixelStack[top];
          i++;
        }
      }
    }

    // Clear missing pixels.
    for (i = pi; i < npix; i++) {
      mainPixels[i] = 0;
    }
  }

  /**
   * Reads a single byte from the input stream.
   */
  private int read() {
    int curByte = 0;
    try {
      curByte = rawData.get() & 0xFF;
    } catch (Exception e) {
      status = STATUS_FORMAT_ERROR;
    }
    return curByte;
  }

  /**
   * Reads next variable length block from input.
   *
   * @return number of bytes stored in "buffer".
   */
  private int readBlock() {
    int blockSize = read();
    int n = 0;
    if (blockSize > 0) {
      try {
        int count;
        while (n < blockSize) {
          count = blockSize - n;
          rawData.get(block, n, count);

          n += count;
        }
      } catch (Exception e) {
        Log.w(TAG, "Error Reading Block", e);
        status = STATUS_FORMAT_ERROR;
      }
    }
    return n;
  }

  private Bitmap getNextBitmap() {
    Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
    if (result == null) {
      result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
    }
    setAlpha(result);
    return result;
  }

  @TargetApi(12)
  private static void setAlpha(Bitmap bitmap) {
    if (Build.VERSION.SDK_INT >= 12) {
      bitmap.setHasAlpha(true);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
    private static final String PARENT_TAG = "parent";
    private RetrieverHarness[] harnesses;
    private RequestManagerRetriever retriever;
    private int initialSdkVersion;

    @Before
    public void setUp() {
        retriever = new RequestManagerRetriever();

        harnesses = new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };

        initialSdkVersion = Build.VERSION.SDK_INT;
        Util.setSdkVersionInt(18);
    }

    @After
    public void tearDown() {
        Util.setSdkVersionInt(initialSdkVersion);

        Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
        assertThat(retriever.pendingRequestManagerFragments).isEmpty();
        assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
    }

    @Test
    public void testCreatesNewFragmentIfNoneExists() {
        for (RetrieverHarness harness : harnesses) {
            harness.doGet();

            Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
        }
    }

    @Test
    public void testReturnsNewManagerIfNoneExists() {
        for (RetrieverHarness harness : harnesses) {
            assertNotNull(harness.doGet());
        }
    }

    @Test
    public void testReturnsExistingRequestManagerIfExists() {
        for (RetrieverHarness harness : harnesses) {
            RequestManager requestManager = mock(RequestManager.class);

            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);

            assertEquals(requestManager, harness.doGet());
        }
    }

    @Test
    public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);

            assertNotNull(harness.doGet());
        }
    }

    @Test
    public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
            RequestManager first = harness.doGet();
            RequestManager second = harness.doGet();

            assertEquals(first, second);
        }
    }

    @Test
    public void testHasValidTag() {
        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
    }

    @Test
    public void testCanGetRequestManagerFromActivity() {
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
        RequestManager manager = retriever.get(activity);
        assertEquals(manager, retriever.get(activity));
    }

    @Test
    public void testSupportCanGetRequestManagerFromActivity() {
        FragmentActivity fragmentActivity = Robolectric.buildActivity(FragmentActivity.class).create().start().get();
        RequestManager manager = retriever.get(fragmentActivity);
        assertEquals(manager, retriever.get(fragmentActivity));
    }

    @Test
    public void testCanGetRequestManagerFromFragment() {
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();
        activity.getFragmentManager()
                .beginTransaction()
                .add(fragment, PARENT_TAG)
                .commit();
        activity.getFragmentManager().executePendingTransactions();

        RequestManager manager = retriever.get(fragment);
        assertEquals(manager, retriever.get(fragment));
    }

    @Test
    public void testSupportCanGetRequestManagerFromFragment() {
        FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
        Fragment fragment = new Fragment();
        activity.getSupportFragmentManager()
                .beginTransaction()
                .add(fragment, PARENT_TAG)
                .commit();
        activity.getSupportFragmentManager().executePendingTransactions();

        RequestManager manager = retriever.get(fragment);
        assertEquals(manager, retriever.get(fragment));
    }

    @Test
    public void testCanGetRequestManagerFromDetachedFragment() {
      helpTestCanGetRequestManagerFromDetachedFragment();
    }

    @Test
    public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
      helpTestCanGetRequestManagerFromDetachedFragment();
    }

    private void helpTestCanGetRequestManagerFromDetachedFragment() {
      Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
      android.app.Fragment fragment = new android.app.Fragment();
      activity.getFragmentManager()
        .beginTransaction()
        .add(fragment, PARENT_TAG)
        .detach(fragment)
=======
  private static final String PARENT_TAG = "parent";
  private RetrieverHarness[] harnesses;
  private RequestManagerRetriever retriever;
  private int initialSdkVersion;

  @Before
  public void setUp() {
    retriever = new RequestManagerRetriever();

    harnesses =
        new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };

    initialSdkVersion = Build.VERSION.SDK_INT;
    Util.setSdkVersionInt(18);
  }

  @After
  public void tearDown() {
    Util.setSdkVersionInt(initialSdkVersion);

    Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
    assertThat(retriever.pendingRequestManagerFragments).isEmpty();
    assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
  }

  @Test
  public void testCreatesNewFragmentIfNoneExists() {
    for (RetrieverHarness harness : harnesses) {
      harness.doGet();

      Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
      assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
    }
  }

  @Test
  public void testReturnsNewManagerIfNoneExists() {
    for (RetrieverHarness harness : harnesses) {
      assertNotNull(harness.doGet());
    }
  }

  @Test
  public void testReturnsExistingRequestManagerIfExists() {
    for (RetrieverHarness harness : harnesses) {
      RequestManager requestManager = mock(RequestManager.class);

      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);

      assertEquals(requestManager, harness.doGet());
    }
  }

  @Test
  public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);

      assertNotNull(harness.doGet());
    }
  }

  @Test
  public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
      RequestManager first = harness.doGet();
      RequestManager second = harness.doGet();

      assertEquals(first, second);
    }
  }

  @Test
  public void testHasValidTag() {
    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
        RequestManagerRetriever.FRAGMENT_TAG);
  }

  @Test
  public void testCanGetRequestManagerFromActivity() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
    RequestManager manager = retriever.get(activity);
    assertEquals(manager, retriever.get(activity));
  }

  @Test
  public void testSupportCanGetRequestManagerFromActivity() {
    FragmentActivity fragmentActivity =
        Robolectric.buildActivity(FragmentActivity.class).create().start().get();
    RequestManager manager = retriever.get(fragmentActivity);
    assertEquals(manager, retriever.get(fragmentActivity));
  }

  @Test
  public void testCanGetRequestManagerFromFragment() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();
    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
    activity.getFragmentManager().executePendingTransactions();

    RequestManager manager = retriever.get(fragment);
    assertEquals(manager, retriever.get(fragment));
  }

  @Test
  public void testSupportCanGetRequestManagerFromFragment() {
    FragmentActivity activity =
        Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
    Fragment fragment = new Fragment();
    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
    activity.getSupportFragmentManager().executePendingTransactions();

    RequestManager manager = retriever.get(fragment);
    assertEquals(manager, retriever.get(fragment));
  }

  @Test
  public void testCanGetRequestManagerFromDetachedFragment() {
    helpTestCanGetRequestManagerFromDetachedFragment();
  }

  @Test
  public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
    helpTestCanGetRequestManagerFromDetachedFragment();
  }

  private void helpTestCanGetRequestManagerFromDetachedFragment() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();
    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).detach(fragment)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
      activity.getFragmentManager().executePendingTransactions();

      assertTrue(fragment.isDetached());
      retriever.get(fragment);
    }

    @Test
    public void testSupportCanGetRequestManagerFromDetachedFragment() {
      helpTestSupportCanGetRequestManagerFromDetachedFragment();
    }

    @Test
    public void testSupportCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
      helpTestSupportCanGetRequestManagerFromDetachedFragment();
    }

    private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
      FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
      Fragment fragment = new Fragment();
      activity.getSupportFragmentManager()
              .beginTransaction()
              .add(fragment, PARENT_TAG)
              .detach(fragment)
              .commit();
      activity.getSupportFragmentManager().executePendingTransactions();

      assertTrue(fragment.isDetached());
      retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfFragmentNotAttached() {
        android.app.Fragment fragment = new android.app.Fragment();
        retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfSupportFragmentNotAttached() {
        Fragment fragment = new Fragment();
        retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfActivityDestroyed() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        harness.getController().pause().stop().destroy();
        harness.doGet();
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfFragmentActivityDestroyed() {
        SupportRetrieverHarness harness = new SupportRetrieverHarness();
        harness.getController().pause().stop().destroy();
        harness.doGet();
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullContext() {
        retriever.get((Context) null);
    }

    @Test
    public void testChecksIfContextIsFragmentActivity() {
        SupportRetrieverHarness harness = new SupportRetrieverHarness();
        RequestManager requestManager = harness.doGet();

        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
    }

    @Test
    public void testChecksIfContextIsActivity() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        RequestManager requestManager = harness.doGet();

        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
    }

    @Test
    public void testHandlesContextWrappersForActivities() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        RequestManager requestManager = harness.doGet();
        ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());

        assertEquals(requestManager, retriever.get(contextWrapper));
    }

    @Test
    public void testHandlesContextWrappersForApplication() {
        ContextWrapper contextWrapper = new ContextWrapper(Robolectric.application);
        RequestManager requestManager = retriever.get(Robolectric.application);

        assertEquals(requestManager, retriever.get(contextWrapper));
    }

    @Test
    public void testReturnsNonNullManagerIfGivenApplicationContext() {
        assertNotNull(retriever.get(Robolectric.application));
    }

    @Test
    public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
        RequestManager manager = retriever.get(Robolectric.application);
        assertFalse(manager.isPaused());
    }

    @Test
    public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
        RequestManager manager = retriever.get(Robolectric.application);
        manager.pauseRequests();
        manager = retriever.get(Robolectric.application);
        assertTrue(manager.isPaused());
    }

    @Test
    public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread() throws InterruptedException {
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                retriever.get(Robolectric.application);
            }
        });
    }

    // See Issue #117: https://github.com/bumptech/glide/issues/117.
    @Test
    public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
        // Robolectric by default runs messages posted to the main looper synchronously, the framework does not. We post
        // to the main thread here to work around an issue caused by a recursive method call so we need (and reasonably
        // expect) our message to not run immediately
        Robolectric.shadowOf(Looper.getMainLooper()).pause();
        Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
        Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
        Activity activity = mock(Activity.class);
        when(activity.getApplicationContext()).thenReturn(Robolectric.application);
        when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(activity));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        Activity spyActivity = Mockito.spy(activity);
        when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyActivity));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
        Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();

        activity.getFragmentManager()
                .beginTransaction().add(fragment, "test")
                .commit();
        android.app.Fragment spyFragment = Mockito.spy(fragment);
        when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyFragment));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();

        activity.getFragmentManager()
                .beginTransaction().add(fragment, "test")
                .commit();
        android.app.Fragment spyFragment = Mockito.spy(fragment);
        when(spyFragment.getChildFragmentManager()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyFragment));
    }

    private interface RetrieverHarness {

        public ActivityController getController();

        public RequestManager doGet();

        public boolean hasFragmentWithTag(String tag);

        public void addFragmentWithTag(String tag, RequestManager manager);
    }

    public class DefaultRetrieverHarness implements RetrieverHarness {
        private final ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class);
        private final android.app.Fragment parent;

        public DefaultRetrieverHarness() {
            this.parent = new android.app.Fragment();

            controller.create();
            controller.get().getFragmentManager()
                .beginTransaction()
                .add(parent, PARENT_TAG)
                .commitAllowingStateLoss();
            controller.get().getFragmentManager().executePendingTransactions();
            controller.start().resume();
        }

        @Override
        public ActivityController getController() {
            return controller;
        }

        @Override
        public RequestManager doGet() {
            return retriever.get(controller.get());
        }

        @Override
        public boolean hasFragmentWithTag(String tag) {
            return null != controller.get()
                .getFragmentManager()
                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
        }

        @Override
        public void addFragmentWithTag(String tag, RequestManager requestManager) {
            RequestManagerFragment fragment = new RequestManagerFragment();
            fragment.setRequestManager(requestManager);
            controller.get().getFragmentManager()
                    .beginTransaction()
                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getFragmentManager().executePendingTransactions();
        }
    }

    public class SupportRetrieverHarness implements RetrieverHarness {
        private final ActivityController<FragmentActivity> controller = Robolectric.buildActivity(
                FragmentActivity.class);
        private final Fragment parent;

        public SupportRetrieverHarness() {
            this.parent = new Fragment();

            controller.create();
            controller.get().getSupportFragmentManager()
                    .beginTransaction()
                    .add(parent, PARENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getSupportFragmentManager().executePendingTransactions();
            controller.start().resume();
        }

        @Override
        public ActivityController getController() {
            return controller;
        }

        @Override
        public RequestManager doGet() {
            return retriever.get(controller.get());
        }

        @Override
        public boolean hasFragmentWithTag(String tag) {
            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
                    != null;
        }
=======
    activity.getFragmentManager().executePendingTransactions();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java;<<<<<<< MINE
        InOrder order = inOrder(thumb, full);
        order.verify(thumb).clear();
        order.verify(full).clear();
    }

    @Test
    public void testRecyclesRequestsWhenRecycled() {
        coordinator.recycle();
        verify(thumb).recycle();
        verify(full).recycle();
    }

    @Test
    public void testIsPausedWhenFullIsPaused() {
        when(full.isPaused()).thenReturn(true);
        assertTrue(coordinator.isPaused());
    }

    @Test
    public void testPausesBothRequestsWhenPaused() {
        coordinator.pause();
        verify(full).pause();
        verify(thumb).pause();
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
        coordinator = new ThumbnailRequestCoordinator();
        coordinator.setRequests(full, thumb);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentDoesNotAllowSetImageAndFullDoesNotHaveResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        when(full.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumb() {
        assertFalse(coordinator.canNotifyStatusChanged(thumb));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.isAnyResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotifyStatusChangedIfParentAllowsNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        when(thumb.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);

        when(parent.isAnyResourceSet()).thenReturn(true);
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);

        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsNotCompleteIfNeitherRequestIsComplete() {
        assertFalse(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfFullIsComplete() {
        when(full.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        assertFalse(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(parent).onRequestSuccess(eq(coordinator));
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testDoesNotClearThumbOnThumbRequestComplete() {
        coordinator.onRequestSuccess(thumb);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        coordinator.onRequestSuccess(full);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotNotifyParentOnThumbRequestComplete() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(thumb);
=======
        return null;
      }
    }).when(thumb).begin();

    coordinator.begin();

    verify(full, never()).begin();
  }

  @Test
  public void testCallsClearOnRequestsWhenCleared() {
    coordinator.clear();
    InOrder order = inOrder(thumb, full);
    order.verify(thumb).clear();
    order.verify(full).clear();
  }

  @Test
  public void testRecyclesRequestsWhenRecycled() {
    coordinator.recycle();
    verify(thumb).recycle();
    verify(full).recycle();
  }

  @Test
  public void testIsPausedWhenFullIsPaused() {
    when(full.isPaused()).thenReturn(true);
    assertTrue(coordinator.isPaused());
  }

  @Test
  public void testPausesBothRequestsWhenPaused() {
    coordinator.pause();
    verify(full).pause();
    verify(thumb).pause();
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
    coordinator = new ThumbnailRequestCoordinator();
    coordinator.setRequests(full, thumb);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canSetImage(full));
  }

  @Test
  public void
  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotSetImageForThumbIfNotAllowedByParentAndFullDoesNotHaveResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    when(full.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumb() {
    assertFalse(coordinator.canNotifyStatusChanged(thumb));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.isAnyResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotifyStatusChangedIfParentAllowsNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    when(thumb.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);

    when(parent.isAnyResourceSet()).thenReturn(true);
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);

    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsNotCompleteIfNeitherRequestIsComplete() {
    assertFalse(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfFullIsComplete() {
    when(full.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfThumbIsComplete() {
    when(thumb.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    assertFalse(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(parent).onRequestSuccess(eq(coordinator));
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testDoesNotClearThumbOnThumbRequestComplete() {
    coordinator.onRequestSuccess(thumb);
    verify(thumb, never()).clear();

  }

  @Test
  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
      when(thumb.isComplete()).thenReturn(true);
      coordinator.onRequestSuccess(full);
      verify(thumb, never()).clear();
  }

  @Test
  public void testDoesNotNotifyParentOnThumbRequestComplete() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(thumb);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@RunWith(JUnit4.class)
=======
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
    @Test
    public void testReturnsUnknownTypeForEmptyData() throws IOException {
        InputStream is = new ByteArrayInputStream(new byte[0]);
        ImageHeaderParser parser = new ImageHeaderParser(is);
        assertEquals(ImageType.UNKNOWN, parser.getType());
    }

    // Test for #286.
    @Test
    public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(is);
        assertEquals(-1, parser.getOrientation());
=======
    protected PartialReadInputStream(InputStream in) {
        super(in);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
    // Test for #387.
    @Test
    public void testHandlesPartialReads() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }

    // Test for #387.
    @Test
    public void testHandlesPartialSkips() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }

    @Test
    public void testHandlesSometimesZeroSkips() throws IOException {
        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
        ImageHeaderParser parser = new ImageHeaderParser(new SometimesZeroSkipInputStream(is));
        assertEquals(ImageType.PNG, parser.getType());
    }

    private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
        byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
        System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
        result[result.length - 1] = (byte) bitDepth;
        return result;
=======
    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int toActuallyRead = byteCount / 2;
        if (byteCount == 1) {
            toActuallyRead = 1;
        }
        return super.read(buffer, byteOffset, toActuallyRead);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
@RunWith(JUnit4.class)
=======
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java;<<<<<<< MINE
    @Test
    public void testIssue387() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        assertThat(new ImageHeaderParser(is).getOrientation()).isEqualTo(6);
    }

    @Test
    public void testLandscape() throws IOException {
        for (int i = 1; i <= 8; i++) {
            assertOrientation("Landscape", i);
        }
=======
  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIssue387() throws IOException {
      InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
      assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
  }

  @Test
  public void testLandscape() throws IOException {
    for (int i = 1; i <= 8; i++) {
      assertOrientation("Landscape", i);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    private final Set<LifecycleListener> lifecycleListeners =
            Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
    private boolean isStarted;
    private boolean isDestroyed;

    /**
     * Adds the given listener to the list of listeners to be notified on each lifecycle event.
     *
     * <p>
     *     The latest lifecycle event will be called on the given listener synchronously in this method. If the
     *     activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be called, and same for onStart and
     *     onDestroy.
     * </p>
     *
     * <p>
     *     Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once will have their
     *     lifecycle methods called more than once. It is the caller's responsibility to avoid adding listeners
     *     multiple times.
     * </p>
     */
    @Override
    public void addListener(LifecycleListener listener) {
        lifecycleListeners.add(listener);

        if (isDestroyed) {
            listener.onDestroy();
        } else if (isStarted) {
            listener.onStart();
        } else {
            listener.onStop();
        }
=======
  private final Set<LifecycleListener> lifecycleListeners =
      Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
  private boolean isStarted;
  private boolean isDestroyed;

  /**
   * Adds the given listener to the list of listeners to be notified on each lifecycle event.
   *
   * <p> The latest lifecycle event will be called on the given listener synchronously in this
   * method. If the activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be
   * called, and same for onStart and onDestroy. </p>
   *
   * <p> Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
   * will have their lifecycle methods called more than once. It is the caller's responsibility to
   * avoid adding listeners multiple times. </p>
   */
  @Override
  public void addListener(LifecycleListener listener) {
    lifecycleListeners.add(listener);

    if (isDestroyed) {
      listener.onDestroy();
    } else if (isStarted) {
      listener.onStart();
    } else {
      listener.onStop();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onStart() {
        isStarted = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStart();
        }
=======
  @Override
  public void removeListener(LifecycleListener listener) {
    lifecycleListeners.remove(listener);
  }

  void onStart() {
    isStarted = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStart();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onStop() {
        isStarted = false;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStop();
        }
=======
  void onStop() {
    isStarted = false;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStop();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onDestroy() {
        isDestroyed = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onDestroy();
        }
=======
  void onDestroy() {
    isDestroyed = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onDestroy();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
 * <p>  Users wishing to replace the class for handling URLs must register a factory using GlideUrl. </p>
=======
 * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
 * URL, call {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache
 * key, call {@link #getCacheKey()}. </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
    public ImageType getType() throws IOException {
        int firstTwoBytes = streamReader.getUInt16();
=======
  private byte[] getExifSegment() throws IOException {
    short segmentId, segmentType;
    int segmentLength;
    while (true) {
      segmentId = reader.getUInt8();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        // JPEG.
        if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
            return JPEG;
=======
      if (segmentId != SEGMENT_START_ID) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Unknown segmentId=" + segmentId);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;
        // PNG.
        if (firstFourBytes == PNG_HEADER) {
            // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type
            streamReader.skip(25 - 4);
            int alpha = streamReader.getByte();
            // A RGB indexed PNG can also have transparency. Better safe than sorry!
            return alpha >= 3 ? PNG_A : PNG;
        }
=======
      segmentType = reader.getUInt8();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            if (segmentType != EXIF_SEGMENT_TYPE) {
                long skipped = streamReader.skip(segmentLength);
                if (skipped != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to skip enough data"
                            + ", type: " + segmentType
                            + ", wanted to skip: " + segmentLength
                            + ", but actually skipped: " + skipped);
                    }
                    return null;
                }
            } else {
                byte[] segmentData = new byte[segmentLength];
                int read = streamReader.read(segmentData);
                if (read != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to read segment data"
                            + ", type: " + segmentType
                            + ", length: " + segmentLength
                            + ", actually read: " + read);
                    }
                    return null;
                } else {
                    return segmentData;
                }
            }
        }
    }
=======
      // We only want orientation.
      if (tagType != ORIENTATION_TAG_TYPE) {
        continue;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            // 12 is max format code.
            if (formatCode < 1 || formatCode > 12) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Got invalid format code=" + formatCode);
                }
                continue;
            }
=======
      if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
        }
        continue;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
                        + " componentCount=" + componentCount);
            }
=======
    return -1;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) {
        final ByteArrayPool byteArrayPool = ByteArrayPool.get();
        final byte[] bytesForOptions = byteArrayPool.getBytes();
        final byte[] bytesForStream = byteArrayPool.getBytes();
        final BitmapFactory.Options options = getDefaultOptions();

        // Use to fix the mark limit to avoid allocating buffers that fit entire images.
        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(
                is, bytesForStream);
        // Use to retrieve exceptions thrown while reading.
        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine
        // if a Bitmap is partially decoded, consider removing.
        ExceptionCatchingInputStream exceptionStream =
                ExceptionCatchingInputStream.obtain(bufferedStream);
        // Use to read data.
        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the
        // full image even when the header decode fails and/or overflows our read buffer. See #283.
        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
        try {
            exceptionStream.mark(MARK_POSITION);
            int orientation = 0;
            try {
                orientation = new ImageHeaderParser(exceptionStream).getOrientation();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot determine the image orientation from header", e);
                }
            } finally {
                try {
                    exceptionStream.reset();
                } catch (IOException e) {
                    if (Log.isLoggable(TAG, Log.WARN)) {
                        Log.w(TAG, "Cannot reset the input stream", e);
                    }
                }
            }

            options.inTempStorage = bytesForOptions;

            final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
            final int inWidth = inDimens[0];
            final int inHeight = inDimens[1];

            final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);

            final Bitmap downsampled =
                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
                            decodeFormat);

            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
            // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,
            // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.
            final Exception streamException = exceptionStream.getException();
            if (streamException != null) {
                throw new RuntimeException(streamException);
            }

            Bitmap rotated = null;
            if (downsampled != null) {
                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);

                if (!downsampled.equals(rotated) && !pool.put(downsampled)) {
                    downsampled.recycle();
                }
            }

            return rotated;
        } finally {
            byteArrayPool.releaseBytes(bytesForOptions);
            byteArrayPool.releaseBytes(bytesForStream);
            exceptionStream.release();
            releaseOptions(options);
        }
    }

    private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? inHeight : outHeight;
        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? inWidth : outWidth;

        final int exactSampleSize;
        if (degreesToRotate == 90 || degreesToRotate == 270) {
            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
            // decreased to near our target's height and the image height is decreased to near our target width.
            //noinspection SuspiciousNameCombination
            exactSampleSize = getSampleSize(inHeight, inWidth, targetWidth, targetHeight);
        } else {
            exactSampleSize = getSampleSize(inWidth, inHeight, targetWidth, targetHeight);
        }

        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
        // http://stackoverflow.com/a/17379704/800716.
        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);

        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
        return Math.max(1, powerOfTwoSampleSize);
    }

    private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBufferedInputStream  bufferedStream,
            BitmapFactory.Options options, BitmapPool pool, int inWidth, int inHeight, int sampleSize,
            DecodeFormat decodeFormat) {
        // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
        Bitmap.Config config = getConfig(is, decodeFormat);
        options.inSampleSize = sampleSize;
        options.inPreferredConfig = config;
        if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) && shouldUsePool(is)) {
            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
            // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));
        }
        return decodeStream(is, bufferedStream, options);
    }

    private static boolean shouldUsePool(InputStream is) {
        // On KitKat+, any bitmap can be used to decode any other bitmap.
        if (Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) {
            return true;
        }

        is.mark(1024);
        try {
            final ImageHeaderParser.ImageType type = new ImageHeaderParser(is).getType();
            // cannot reuse bitmaps when decoding images that are not PNG or JPG.
            // look at : https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
            return TYPES_THAT_USE_POOL.contains(type);
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine the image type from header", e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }
        return false;
    }

    @SuppressWarnings("deprecation")
    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }

        boolean hasAlpha = false;
        // We probably only need 25, but this is safer (particularly since the buffer size is > 1024).
        is.mark(1024);
        try {
            hasAlpha = new ImageHeaderParser(is).hasAlpha();
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }

        return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
    }

    /**
     * Determine the amount of downsampling to use for a load given the dimensions of the image to be downsampled and
     * the dimensions of the view/target the image will be displayed in.
     *
     * @see android.graphics.BitmapFactory.Options#inSampleSize
     *
     * @param inWidth The width in pixels of the image to be downsampled.
     * @param inHeight The height in piexels of the image to be downsampled.
     * @param outWidth The width in pixels of the view/target the image will be displayed in.
     * @param outHeight The height in pixels of the view/target the imag will be displayed in.
     * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
     *          android.graphics.BitmapFactory.Options)}.
     */
    protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);

    /**
     * A method for getting the dimensions of an image from the given InputStream.
     *
     * @param is The InputStream representing the image.
     * @param options The options to pass to
     *          {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
     *              android.graphics.BitmapFactory.Options)}.
     * @return an array containing the dimensions of the image in the form {width, height}.
     */
    public int[] getDimensions(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
            BitmapFactory.Options options) {
        options.inJustDecodeBounds = true;
        decodeStream(is, bufferedStream, options);
        options.inJustDecodeBounds = false;
        return new int[] { options.outWidth, options.outHeight };
    }

    private static Bitmap decodeStream(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
            BitmapFactory.Options options) {
         if (options.inJustDecodeBounds) {
             // This is large, but jpeg headers are not size bounded so we need something large enough to minimize
             // the possibility of not being able to fit enough of the header in the buffer to get the image size so
             // that we don't fail to load images. The BufferedInputStream will create a new buffer of 2x the
             // original size each time we use up the buffer space without passing the mark so this is a maximum
             // bound on the buffer size, not a default. Most of the time we won't go past our pre-allocated 16kb.
             is.mark(MARK_POSITION);
         } else {
             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid
             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our
             // current buffer size here. See issue #225.
             bufferedStream.fixMarkLimit();
         }

        final Bitmap result = BitmapFactory.decodeStream(is, null, options);

        try {
            if (options.inJustDecodeBounds) {
                is.reset();
            }
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception loading inDecodeBounds=" + options.inJustDecodeBounds
                        + " sample=" + options.inSampleSize, e);
            }
        }

        return result;
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
            options.inBitmap = recycled;
        }
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static synchronized BitmapFactory.Options getDefaultOptions() {
        BitmapFactory.Options decodeBitmapOptions;
        synchronized (OPTIONS_QUEUE) {
            decodeBitmapOptions = OPTIONS_QUEUE.poll();
        }
        if (decodeBitmapOptions == null) {
            decodeBitmapOptions = new BitmapFactory.Options();
            resetOptions(decodeBitmapOptions);
        }

        return decodeBitmapOptions;
    }

    private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
        resetOptions(decodeBitmapOptions);
        synchronized (OPTIONS_QUEUE) {
            OPTIONS_QUEUE.offer(decodeBitmapOptions);
        }
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
        decodeBitmapOptions.inTempStorage = null;
        decodeBitmapOptions.inDither = false;
        decodeBitmapOptions.inScaled = false;
        decodeBitmapOptions.inSampleSize = 1;
        decodeBitmapOptions.inPreferredConfig = null;
        decodeBitmapOptions.inJustDecodeBounds = false;
        decodeBitmapOptions.outWidth = 0;
        decodeBitmapOptions.outHeight = 0;
        decodeBitmapOptions.outMimeType = null;

        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT)  {
            decodeBitmapOptions.inBitmap = null;
            decodeBitmapOptions.inMutable = true;
        }
=======
    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
      // Do nothing.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
    public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
=======
    if (cacheDir != null) {
      diskCache = DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
    public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName, int diskCacheSize) {
        super(new CacheDirectoryGetter() {
            @Override
            public File getCacheDirectory() {
                File cacheDirectory = context.getCacheDir();
                if (cacheDirectory == null) {
                    return null;
                }
                if (diskCacheName != null) {
                    return new File(cacheDirectory, diskCacheName);
                }
                return cacheDirectory;
            }
        }, diskCacheSize);
=======
    if (diskCache == null) {
      diskCache = new DiskCacheAdapter();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    private static final int APP_VERSION = 1;
    private static final int VALUE_COUNT = 1;
    private static DiskLruCacheWrapper wrapper = null;

    private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
    private final SafeKeyGenerator safeKeyGenerator;
    private final File directory;
    private final int maxSize;
    private DiskLruCache diskLruCache;

    /**
     * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
     * a different directory and/or size, it will be returned instead and the new arguments
     * will be ignored.
     *
     * @param directory The directory for the disk cache
     * @param maxSize The max size for the disk cache
     * @return The new disk cache with the given arguments, or the current cache if one already exists
     */
    public static synchronized DiskCache get(File directory, int maxSize) {
        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!
        if (wrapper == null) {
            wrapper = new DiskLruCacheWrapper(directory, maxSize);
=======
  private static final int APP_VERSION = 1;
  private static final int VALUE_COUNT = 1;
  private static DiskLruCacheWrapper wrapper = null;

  private final SafeKeyGenerator safeKeyGenerator;
  private final File directory;
  private final int maxSize;
  private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
  private DiskLruCache diskLruCache;

  /**
   * Get a DiskCache in the given directory and size. If a disk cache has already been created with
   * a different directory and/or size, it will be returned instead and the new arguments will be
   * ignored.
   *
   * @param directory The directory for the disk cache
   * @param maxSize   The max size for the disk cache
   * @return The new disk cache with the given arguments, or the current cache if one already exists
   */
  public static synchronized DiskCache get(File directory, int maxSize) {
    // TODO calling twice with different arguments makes it return the cache for the same
    // directory, it's public!
    if (wrapper == null) {
      wrapper = new DiskLruCacheWrapper(directory, maxSize);
    }
    return wrapper;
  }

  protected DiskLruCacheWrapper(File directory, int maxSize) {
    this.directory = directory;
    this.maxSize = maxSize;
    this.safeKeyGenerator = new SafeKeyGenerator();
  }

  private synchronized DiskLruCache getDiskCache() throws IOException {
    if (diskLruCache == null) {
      diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
    }
    return diskLruCache;
  }

  @Override
  public File get(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, "Get: Obtained: " + safeKey + " for for Key: " + key);
    }
    File result = null;
    try {
      // It is possible that the there will be a put in between these two gets. If so that shouldn't
      // be a problem because we will always put the same value at the same key so our input streams
      // will still represent the same data.
      final DiskLruCache.Value value = getDiskCache().get(safeKey);
      if (value != null) {
        result = value.getFile(0);
      }
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to get from disk cache", e);
      }
    }
    return result;
  }

  @Override
  public void put(Key key, Writer writer) {
    // We want to make sure that puts block so that data is available when put completes. We may
    // actually not write any data if we find that data is written by the time we acquire the lock.
    writeLocker.acquire(key);
    try {
      String safeKey = safeKeyGenerator.getSafeKey(key);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
      }
      try {
        // We assume we only need to put once, so if data was written while we were trying to get
        // the lock, we can simply abort.
        DiskLruCache diskCache = getDiskCache();
        Value current = diskCache.get(safeKey);
        if (current != null) {
          return;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
        return result;
    }

    @Override
    public void put(Key key, Writer writer) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        writeLocker.acquire(key);
        try {
            DiskLruCache.Editor editor = getDiskCache().edit(safeKey);
            // Editor will be null if there are two concurrent puts. In the worst case we will just silently fail.
            if (editor != null) {
                try {
                    File file = editor.getFile(0);
                    if (writer.write(file)) {
                        editor.commit();
                    }
                } finally {
                    editor.abortUnlessCommitted();
                }
            }
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to put to disk cache", e);
            }
        } finally {
            writeLocker.release(key);
        }
    }

    @Override
    public void delete(Key key) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        try {
            getDiskCache().remove(safeKey);
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to delete from disk cache", e);
            }
=======
      } catch (IOException e) {
        if (Log.isLoggable(TAG, Log.WARN)) {
          Log.w(TAG, "Unable to put to disk cache", e);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    }

    @Override
    public synchronized void clear() {
        try {
            getDiskCache().delete();
            resetDiskCache();
        }  catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to clear disk cache", e);
            }
        }
    }
=======
      }
    } finally {
      writeLocker.release(key);
    }
  }

  @Override
  public void delete(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    try {
      getDiskCache().remove(safeKey);
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to delete from disk cache", e);
      }
    }
  }

  @Override
  public synchronized void clear() {
    try {
      getDiskCache().delete();
      resetDiskCache();
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to clear disk cache", e);
      }
    }
  }

  private synchronized void resetDiskCache() {
    diskLruCache = null;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/okio/revisions/rev_89e1341_c8a36a6/rev_89e1341-c8a36a6/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java;<<<<<<< MINE
    // +---+---+=======
  private void consumeTrailer() throws IOException {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_157aa0a_bed3057/rev_157aa0a-bed3057/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloRequest>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloRequest>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_157aa0a_bed3057/rev_157aa0a-bed3057/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloReply>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloReply>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_41f1155_a287a11/rev_41f1155-a287a11/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloRequest>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloRequest>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_41f1155_a287a11/rev_41f1155-a287a11/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloReply>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloReply>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractServerStream.java;<<<<<<< MINE
    this.listener = Preconditions.checkNotNull(listener, "listener");
=======
    this.listener = checkNotNull(listener);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractServerStream.java;<<<<<<< MINE
    return this.listener;
=======
    return listener;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      if (this.onReadyThreshold <= numSentBytesQueued && onReadyThreshold > numSentBytesQueued) {
        shouldNotifyOnReady = true;
      }
      this.onReadyThreshold = onReadyThreshold;
      doNotify = needToNotifyOnReady();
    }
    if (doNotify) {
      listener().onReady();
=======
      return onReadyThreshold;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
    Preconditions.checkNotNull(message, "message");
=======
    checkNotNull(message);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
        if (allocated && numSentBytesQueued < onReadyThreshold) {
          return true;
        }
=======
        return allocated && numSentBytesQueued < onReadyThreshold;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  protected void onStreamAllocated() {
    boolean doNotify;
=======
  protected final void onStreamAllocated() {
    checkState(listener() != null);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      if (allocated) {
        throw new IllegalStateException("Already allocated");
      }
=======
      checkState(!allocated, "Already allocated");
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      doNotify = needToNotifyOnReady();
=======
      boolean belowThresholdAfter = numSentBytesQueued < onReadyThreshold;
      doNotify = !belowThresholdBefore && belowThresholdAfter;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  /**
   * Determines whether or not we need to call the {@link StreamListener#onReady()} handler now.
   * Calling this method has the side-effect of unsetting {@link #shouldNotifyOnReady} so the
   * handler should always be invoked immediately after calling this method.
   */
  @GuardedBy("onReadyLock")
  private boolean needToNotifyOnReady() {
    if (shouldNotifyOnReady && isReady()) {
      // Returning true here counts as a call to the onReady callback, so
      // unset the flag.
      shouldNotifyOnReady = false;
      return true;
=======
  @VisibleForTesting
  final void notifyIfReady() {
    boolean doNotify = false;
    synchronized (onReadyLock) {
      doNotify = isReady();
    }
    if (doNotify) {
      listener().onReady();
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  private Phase verifyNextPhase(Phase currentPhase, Phase nextPhase) {
=======
  @VisibleForTesting
  Phase verifyNextPhase(Phase currentPhase, Phase nextPhase) {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java;<<<<<<< MINE
        method,new Metadata.Headers(), listener);
    stream.setOnReadyThreshold(HEADER_LENGTH + 20);
=======
        method, new Metadata.Headers(), listener);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/java/examples/src/com/pubnub/examples/PubnubPushSampleCode.java;<<<<<<< MINE
    private static void usage(Options options) {

        HelpFormatter formatter = new HelpFormatter();
        formatter.printHelp("Publisher", options);
    }

    public void start() {


    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        Options options = new Options();
        String publish_key = "demo-36";
        String subscribe_key = "demo-36";
        boolean nativ = false;
        boolean gcm = false;
        boolean apns = false;

        String channel = "demo";

        String origin = "gcm-beta";

        String auth_key = "";

        CommandLine cmd = null;

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
                withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
                withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
                withType(String.class).withDescription("Origin ( Ex. pubsub )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
                withType(String.class).withDescription("Auth Key").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
                withType(String.class).withDescription("Secret Key ( default: 'my_channel' )").create());

        options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());

        options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());

        options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());

        CommandLineParser parser = new BasicParser();
        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e1) {
            usage(options);
            return;
        }

        if (cmd.hasOption("publish_key")) {
            try {
                publish_key = cmd.getOptionValue("publish_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("subscribe_key")) {
            try {
                subscribe_key = cmd.getOptionValue("subscribe_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("origin")) {
            try {
                origin = cmd.getOptionValue("origin");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("channel")) {
            try {
                channel = cmd.getOptionValue("channel");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("auth_key")) {
            try {
                auth_key = cmd.getOptionValue("auth_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("apns")) {
            try {
                apns = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("gcm")) {
            try {
                gcm = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        if (cmd.hasOption("native")) {
            try {
                nativ = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
        pubnub.setAuthKey(auth_key);
        pubnub.setCacheBusting(false);
        pubnub.setOrigin(origin);

        // Create APNS message

        PnApnsMessage apnsMessage = new PnApnsMessage();
        apnsMessage.setApsAlert("Game update 49ers touchdown");
        apnsMessage.setApsBadge(2);

        try {
            apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
            apnsMessage.put("score", new JSONArray().put(7).put(0));
        } catch (JSONException e1) {

        }

        // Create GCM Message

        PnGcmMessage gcmMessage = new PnGcmMessage();

        JSONObject jso = new JSONObject();
        try {
            jso.put("summary", "Game update 49ers touchdown");
            jso.put("lastplay", "5yd run up the middle");
        } catch (JSONException e) {

        }

        gcmMessage.setData(jso);


        Callback callback = new Callback() {
            @Override
            public void successCallback(String channel, Object response) {
                System.out.println(response);
                pubnub.shutdown();
            }

            @Override
            public void errorCallback(String channel, PubnubError error) {
                System.out.println(error);
                pubnub.shutdown();
            }
        };

        PubnubSender sender = new PubnubSender(channel, pubnub, callback);

        PnMessage message = null;

        if (apns && gcm) {
            message = new PnMessage(sender, apnsMessage, gcmMessage);
        } else if (apns) {
            message = new PnMessage(sender, apnsMessage);
        } else if (gcm) {
            message = new PnMessage(sender, gcmMessage);
        }
        if (message == null) message = new PnMessage(sender);
        if (nativ) {
            try {
                message.put("test", "hi");
            } catch (JSONException e1) {

            }
        }

        try {
            message.publish();
        } catch (PubnubSenderMissingException e) {
            System.out.println("Set Sender");
        }

=======
		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp( "Publisher", options );
	}
	
	public void start() {
		
	
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Options options = new Options();
		String publish_key = "demo-36";
		String subscribe_key = "demo-36";
		boolean nativ = false;
		boolean gcm = false;
		boolean apns = false;
		
		String channel = "my_channel";
		
		String origin = "pubsub";
		
		String auth_key = "";
		
		CommandLine cmd = null;
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
				withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
				withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
				withType(String.class).withDescription("Origin ( Ex. pubsub )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
				withType(String.class).withDescription("Auth Key").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
				withType(String.class).withDescription("Channel ( default: 'my_channel' )").create());
		
		options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());
		
		options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());
		
		options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());
		
		CommandLineParser parser = new BasicParser();
		try {
			cmd = parser.parse( options, args);
		} catch (ParseException e1) {
			usage(options);return;
		}
		
		if (cmd.hasOption("publish_key")) {
			try {
				publish_key = cmd.getOptionValue("publish_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("subscribe_key")) {
			try {
				subscribe_key = cmd.getOptionValue("subscribe_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("origin")) {
			try {
				origin = cmd.getOptionValue("origin");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("channel")) {
			try {
				channel = cmd.getOptionValue("channel");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("auth_key")) {
			try {
				auth_key = cmd.getOptionValue("auth_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("apns")) {
			try {
				apns = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		if (cmd.hasOption("gcm")) {
			try {
				gcm = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		
		if (cmd.hasOption("native")) {
			try {
				nativ = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		
		final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
		pubnub.setAuthKey(auth_key);
		pubnub.setCacheBusting(false);
		pubnub.setOrigin(origin);
		
		// Create APNS message
		
		PnApnsMessage apnsMessage = new PnApnsMessage();
		apnsMessage.setApsAlert("Game update 49ers touchdown");
		apnsMessage.setApsBadge(2);
		
		try {
			apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
			apnsMessage.put("score", new JSONArray().put(7).put(0));
		} catch (JSONException e1) {

		}
		
		// Create GCM Message	
		
		PnGcmMessage gcmMessage = new PnGcmMessage();
		
		JSONObject jso = new JSONObject();
		try {
			jso.put("summary", "Game update 49ers touchdown");
			jso.put("lastplay", "5yd run up the middle");
		} catch (JSONException e) {

		}

		gcmMessage.setData(jso);
		
		
		Callback callback = new Callback() {
			@Override
			public void successCallback(String channel, Object response) {
				System.out.println(response);
				pubnub.shutdown();
			}
			@Override
			public void errorCallback(String channel, PubnubError error) {
				System.out.println(error);
				pubnub.shutdown();
			}			
		};
		
		PubnubSender sender = new PubnubSender(channel, pubnub, callback);
		
		PnMessage message = null;
		
		if (apns && gcm) {
			message = new PnMessage(sender, apnsMessage, gcmMessage);
		} else if (apns) {
			message = new PnMessage(sender, apnsMessage);
		} else if (gcm) {
			message = new PnMessage(sender, gcmMessage);
		}
		if (message == null) message = new PnMessage(sender);
		if (nativ) {
			try {
				message.put("test","hi");
			} catch (JSONException e1) {

			}
		}
		
		try {
			message.publish();
		} catch (PubnubSenderMissingException e) {
			System.out.println("Set Sender");
		}
		
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/android/examples/PubnubExample/src/com/pubnub/examples/pubnubExample10/MainActivity.java;<<<<<<< MINE
            protected String doInBackground(Void... params) {
                String msg = "";
                try {
                    if (gcm == null) {
                        gcm = GoogleCloudMessaging.getInstance(context);
                    }
                    REG_ID = gcm.register(SENDER_ID);
                    Log.d("RegisterActivity", "registerInBackground - regId: "
                            + REG_ID);
                    msg = "Device registered, registration ID=" + REG_ID;

                    storeRegistrationId(context, REG_ID);
                } catch (IOException ex) {
                    msg = "Error :" + ex.getMessage();
                    Log.d("RegisterActivity", "Error: " + msg);
                }
                Log.d("RegisterActivity", "AsyncTask completed: " + msg);
                return msg;
=======
            public void onClick(DialogInterface dialog, int which) {
            	   		
        		if (TextUtils.isEmpty(REG_ID)) {
        		      Toast.makeText(getApplicationContext(),
        			          "GCM Registration id not set. Register to GCM and try again.",
        			          Toast.LENGTH_LONG).show();
        		      return ;
        		}
                String channel = edChannelName.getText().toString();
				pubnub.enablePushNotificationsOnChannel(channel, REG_ID, new Callback() {
				    @Override
				    public void successCallback(String channel,
				    Object message) {
				        notifyUser("GCM ADD : " + message);
				    }
				    @Override
				    public void errorCallback(String channel,
				    PubnubError error) {
				        notifyUser("GCM ADD : " + error);
				    }
				});
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_35c7f03_449a6c6/rev_35c7f03-449a6c6/java/srcPubnubApi/com/pubnub/api/PubnubUtilCore.java;<<<<<<< MINE
        Hashtable ht, String delimiter) {
=======
        Hashtable ht, String delimiter, String exclude) {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_8e4119c_6dbe265/rev_8e4119c-6dbe265/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("uuid", UUID);
        
        HttpRequest hreq = new HttpRequest(urlargs, parameters,
                new ResponseHandler() {
=======
        _leave(",", params);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_c2d55ac_4efc0ab/rev_c2d55ac-4efc0ab/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java;<<<<<<< MINE
    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, TYPE_OTHER);
=======
    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_c2d55ac_4efc0ab/rev_c2d55ac-4efc0ab/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java;<<<<<<< MINE
      case TYPE_SS_VOD:
=======
      case DemoUtil.TYPE_SS:
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java;<<<<<<< MINE
    DemoPlayer.Listener, DemoPlayer.TextListener, AudioCapabilitiesReceiver.Listener {
=======
    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener {

  private static final String TAG = "FullPlayerActivity";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java;<<<<<<< MINE
        DemoUtil.TYPE_SS, false),
=======
        DemoUtil.TYPE_SS, false, false),
    new Sample("Apple master playlist (HLS)", "uid:hls:applemaster",
        "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/"
        + "bipbop_4x3_variant.m3u8", DemoUtil.TYPE_HLS, false, false),
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);
=======
        return true;
    }

    
    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }
    
    private void channelGroupLeave(String group) {
    	channelGroupLeave(group, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        if (auth_key != null && auth_key.length() > 0 ) parameters.put("auth", auth_key);

        String[] urlComponents = {getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                this.SUBSCRIBE_KEY
=======
    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }
   
    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
    	_leave(channels, channelGroups, params, null);
    }
    
    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
    	_leave(PubnubUtil.joinString(channels, ","),
    			PubnubUtil.joinString(channelGroups, ","), params, callback);
    }
    
    private void _leave(String[] channels, String[] channelGroups) {
    	_leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    } 
    
    
    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
    	_leave(PubnubUtil.joinString(channels, ","),
    			PubnubUtil.joinString(channelGroups, ","), PubnubUtil.hashtableClone(this.params), callback);
    }    
    
    private void _leave(String channel, String channelGroup, Callback callback) {
    	_leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }
    
    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {
    	
    	final Callback cb = getWrappedCallback(callback);
    	
    	if (PubnubUtil.isEmptyString(channel) &&
    			PubnubUtil.isEmptyString(channelGroup))
    		return;
    	
    	if (PubnubUtil.isEmptyString(channel)) channel = ",";
    	
        String[] urlArgs = {getPubnubUrl(), "v2/presence/sub_key",
                this.SUBSCRIBE_KEY, "channel", PubnubUtil.urlEncode(channel), "leave"
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
=======
        params.put("uuid", UUID);
        

        if (!PubnubUtil.isEmptyString(channelGroup))
        	params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                        invokeCallback(group, response, "payload", cb, 6);
=======
                    	cb.successCallback(null, response);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                        cb.errorCallback(group, error);
=======
                    	cb.errorCallback(null, error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
=======
    /**
     * Unsubscribe from channel group
     *
     * @param group to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group to unsubscribe
     * @param callback Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[]{group}, callback);
    }
    
    
    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups to unsubscribe
     * @param callback Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                    e1.getPubnubError());
            return null;
=======
    /**
     * Unsubscribe from presence channel.
     *
     * @param channel channel name as String.
     */
    public void unsubscribePresence(String channel) {
    	unsubscribePresence(channel, null);
    }
    
    /**
     * Unsubscribe from all channels and channel groups.
     * 
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                this.SUBSCRIBE_KEY
        };
=======
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }
    
    /**
     * Unsubscribe from all channels and channel groups.
     */    
    public void unsubscribeAll() {
    	unsubscribeAll(null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
                new ResponseHandler() {
                    public void handleResponse(HttpRequest hreq, String response) {
                        invokeCallback(channel, response, "payload", cb, 2);
                    }
=======
    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
    	unsubscribeAllChannels(null);
    }
    
    /**
     * Unsubscribe from all channels.
     * 
     * @param callback Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                    public void handleError(HttpRequest hreq, PubnubError error) {
                        cb.errorCallback(channel, error);
                        return;
                    }
                });
=======
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        return _request(hreq, (sync)?null:nonSubscribeManager);
=======
    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
    	channelGroupUnsubscribeAllGroups(null);
    }
    
    /**
     * Unsubscribe from all channel groups.
     * 
     * @param callback Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE
            encoded = Files.readAllBytes(Paths.get(Pubnub.class.getClassLoader().getResource("version.properties").getPath()));
=======
            prop.load(in);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE
    protected final boolean validateParams() {
=======
    protected final void validateParams() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE
            return false;
=======
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_MESSAGE_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE

        if (channel == null || channel.length() == 0) {
            return false;
=======
        if (channel == null || channel.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CHANNEL_MISSING).build();
        }
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
        if (pubnub.getConfiguration().getPublishKey()==null || pubnub.getConfiguration().getPublishKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUBLISH_KEY_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE
    protected boolean validateParams() {
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE
            return false;
=======
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUSH_TYPE_MISSING).build();
        }
        if (deviceId == null || deviceId.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_DEVICE_ID_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/ListPushProvisions.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
        if (pushType == null) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUSH_TYPE_MISSING).build();
        }
        if (deviceId == null || deviceId.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_DEVICE_ID_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/Time.java;<<<<<<< MINE
    protected final boolean validateParams() {
        return true;
=======
    protected final void validateParams() throws PubNubException {

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (channelGroup==null || channelGroup.isEmpty())
        {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_GROUP_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroup.java;<<<<<<< MINE
        return true;
=======
        return !input.body().isError();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException
    {
        if (channelGroup==null || channelGroup.isEmpty())
        {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_GROUP_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException
    {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/presence/WhereNow.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_ENCRYPTION_ERROR = new PubNubError(PNERR_ENCRYPTION_ERROR,
=======
        public static final PubNubError PNERROBJ_TIMEOUT = new PubNubError(PNERR_TIMEOUT, "Timeout Occurred");

        public static final PubNubError PNERROBJ_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR, "Internal Error");

        public static final PubNubError PNERROBJ_ENCRYPTION_ERROR = new PubNubError(PNERR_ENCRYPTION_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_DECRYPTION_ERROR = new PubNubError(PNERR_DECRYPTION_ERROR, "Decryption Error. "
=======
        public static final PubNubError PNERROBJ_DECRYPTION_ERROR = new PubNubError(PNERR_DECRYPTION_ERROR, "Decryption Error. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_INVALID_JSON = new PubNubError(PNERR_INVALID_JSON, "Invalid Json. "
=======
        public static final PubNubError PNERROBJ_INVALID_JSON = new PubNubError(PNERR_INVALID_JSON, "Invalid Json. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_JSON_ERROR = new PubNubError(PNERR_JSON_ERROR,
=======
        public static final PubNubError PNERROBJ_JSON_ERROR = new PubNubError(PNERR_JSON_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_MALFORMED_URL = new PubNubError(PNERR_MALFORMED_URL, "Malformed URL ."
=======
        public static final PubNubError PNERROBJ_MALFORMED_URL = new PubNubError(PNERR_MALFORMED_URL, "Malformed URL ."
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_URL_OPEN = new PubNubError(PNERR_URL_OPEN, "Error opening url. "
=======
        public static final PubNubError PNERROBJ_URL_OPEN = new PubNubError(PNERR_URL_OPEN, "Error opening url. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_PROTOCOL_EXCEPTION = new PubNubError(PNERR_PROTOCOL_EXCEPTION,
=======
        public static final PubNubError PNERROBJ_PROTOCOL_EXCEPTION = new PubNubError(PNERR_PROTOCOL_EXCEPTION,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_CONNECT_EXCEPTION = new PubNubError(PNERR_CONNECT_EXCEPTION,
=======
        public static final PubNubError PNERROBJ_CONNECT_EXCEPTION = new PubNubError(PNERR_CONNECT_EXCEPTION,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_HTTP_RC_ERROR = new PubNubError(PNERR_HTTP_RC_ERROR,
=======
        public static final PubNubError PNERROBJ_HTTP_RC_ERROR = new PubNubError(PNERR_HTTP_RC_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_GETINPUTSTREAM = new PubNubError(PNERR_GETINPUTSTREAM,
=======
        public static final PubNubError PNERROBJ_GETINPUTSTREAM = new PubNubError(PNERR_GETINPUTSTREAM,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_READINPUT = new PubNubError(PNERR_READINPUT, "Unable to read Input Stream. "
=======
        public static final PubNubError PNERROBJ_READINPUT = new PubNubError(PNERR_READINPUT, "Unable to read Input Stream. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_BAD_REQUEST = new PubNubError(PNERR_BAD_REQUEST, "Bad request. "
=======
        public static final PubNubError PNERROBJ_BAD_REQUEST = new PubNubError(PNERR_BAD_REQUEST, "Bad request. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_BAD_GATEWAY = new PubNubError(PNERR_BAD_GATEWAY, "Bad Gateway. "
=======
        public static final PubNubError PNERROBJ_BAD_GATEWAY = new PubNubError(PNERR_BAD_GATEWAY, "Bad Gateway. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_5023_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR,
=======
        public static final PubNubError PNERROBJ_5023_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_DISCONN_AND_RESUB = new PubNubError(PNERR_DISCONN_AND_RESUB,
=======
        public static final PubNubError PNERROBJ_DISCONN_AND_RESUB = new PubNubError(PNERR_DISCONN_AND_RESUB,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_FORBIDDEN = new PubNubError(PNERR_FORBIDDEN, "Authentication Failure. "
=======
        public static final PubNubError PNERROBJ_FORBIDDEN = new PubNubError(PNERR_FORBIDDEN, "Authentication Failure. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_UNAUTHORIZED = new PubNubError(PNERR_UNAUTHORIZED, "Authentication Failure. "
=======
        public static final PubNubError PNERROBJ_UNAUTHORIZED = new PubNubError(PNERR_UNAUTHORIZED, "Authentication Failure. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_SECRET_KEY_MISSING = new PubNubError(PNERR_SECRET_KEY_MISSING,
=======
        public static final PubNubError PNERROBJ_SECRET_KEY_MISSING = new PubNubError(PNERR_SECRET_KEY_MISSING,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_ULSSIGN_ERROR = new PubNubError(PNERR_ULSSIGN_ERROR, "Invalid Signature . "
=======
        public static final PubNubError PNERROBJ_SUBSCRIBE_KEY_MISSING = new PubNubError(PNERR_SUBSCRIBE_KEY_MISSING,
                "ULS configuration failed. Subscribe Key not configured. ");

        public static final PubNubError PNERROBJ_PUBLISH_KEY_MISSING = new PubNubError(PNERR_PUBLISH_KEY_MISSING,
                "ULS configuration failed. Publish Key not configured. ");

        public static final PubNubError PNERROBJ_ULSSIGN_ERROR = new PubNubError(PNERR_ULSSIGN_ERROR, "Invalid Signature . "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_5075_NETWORK_ERROR = new PubNubError(PNERR_NETWORK_ERROR, "Network Error. "
=======
        public static final PubNubError PNERROBJ_5075_NETWORK_ERROR = new PubNubError(PNERR_NETWORK_ERROR, "Network Error. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_NOT_FOUND_ERROR = new PubNubError(PNERR_NOT_FOUND, "Page Not Found"
=======
        public static final PubNubError PNERROBJ_NOT_FOUND_ERROR = new PubNubError(PNERR_NOT_FOUND, "Page Not Found"
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals(null, segments.get(0).encryptionMethod);
=======
      assertEquals(false, segments.get(0).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(1).encryptionMethod);
=======
      assertEquals(true, segments.get(1).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals(HlsMediaPlaylist.ENCRYPTION_METHOD_NONE, segments.get(2).encryptionMethod);
=======
      assertEquals(false, segments.get(2).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(3).encryptionMethod);
=======
      assertEquals(true, segments.get(3).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(4).encryptionMethod);
=======
      assertEquals(true, segments.get(4).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      // 0xA7A == 2682.
=======
      // 0xA7B == 2683.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("A7A", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
=======
      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java;<<<<<<< MINE
      Pattern.compile(METHOD_ATTR + "=([^,.*]+)");
=======
      Pattern.compile(METHOD_ATTR + "=(" + METHOD_NONE + "|" + METHOD_AES128 + ")");
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java;<<<<<<< MINE
    if (HlsMediaPlaylist.ENCRYPTION_METHOD_AES_128.equals(segment.encryptionMethod)) {
=======
    if (segment.isEncrypted) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
        String encryptionMethod, String encryptionKeyUri, String encryptionIV,
        int byterangeOffset, int byterangeLength) {
=======
        boolean isEncrypted, String encryptionKeyUri, String encryptionIV, int byterangeOffset,
        int byterangeLength) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
      this.encryptionMethod = encryptionMethod;
=======
      this.isEncrypted = isEncrypted;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/PubNubUtil.java;<<<<<<< MINE
    /**
     * Returns decoded String
     *
     * @param sUrl
     *            , input string
     * @return , decoded string
     */
    public static String urlDecode(String sUrl) {
        try {
            return URLDecoder.decode(sUrl, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String preparePamArguments(Map<String, String> pamArgs){
=======
    public static String preparePamArguments(Map<String, String> pamArgs) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java;<<<<<<< MINE
            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264),
                seiReader);
=======
            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264), seiReader);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
        Assert.assertEquals("4.0.8", version);
=======
        Assert.assertEquals("4.0.9", version);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            outputText = crypto.decrypt(input.toString());
=======
            outputText = crypto.decrypt(inputText);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Message\"},\"b\":\"coolChan-bnel\"}]}")));
=======
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Message\"},\"b\":\"coolChannel\"}]}")));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
    public void GetVersionAndTimeStamp() throws PubNubException {
=======
    public void getVersionAndTimeStamp() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
        Assert.assertEquals("4.0.10", version);
=======
        Assert.assertEquals("4.0.11", version);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
    public void StopAndReconnect() throws PubNubException {
=======
    public void stopAndReconnect() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
        assertEquals(response.getTimetoken(), "14593046077243110");
=======
        assertTrue(response.getTimetoken().equals(14593046077243110L));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
                        return null;
=======
                        return this;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(15, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(15, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));

=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/Base64Test.java;<<<<<<< MINE
       Assert.assertEquals("YWJj", Base64.encodeToString("abc".getBytes(), 0).trim());
=======
       Assert.assertEquals("YWJj", Base64.encodeToString("abc".getBytes(Charset.forName("UTF-8")), 0).trim());
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
        if (channel.equals(subscriptionMatch)) {
=======
        if (channel != null && channel.equals(subscriptionMatch)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            if (associatedChannel != null) {
                associatedChannel = PubNubUtil.replaceLast(associatedChannel, "-pnpres", "");
=======
            if (channel != null) {
                strippedPresenceChannel = PubNubUtil.replaceLast(channel, "-pnpres", "");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            if (associatedSubscription != null) {
                associatedSubscription = PubNubUtil.replaceLast(associatedSubscription, "-pnpres", "");
=======
            if (subscriptionMatch != null) {
                strippedPresenceSubscription = PubNubUtil.replaceLast(subscriptionMatch, "-pnpres", "");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
                    .channel(associatedChannel)
                    .subscription(associatedSubscription)
=======
                    .channel(strippedPresenceChannel)
                    .subscription(strippedPresenceSubscription)
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
                    .channel(message.getChannel())
                    .subscription(message.getSubscriptionMatch())
=======
                    .channel(channel)
                    .subscription(subscriptionMatch)
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java;<<<<<<< MINE
      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
=======
      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java;<<<<<<< MINE
    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
=======
    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    checkForDiscontinuity(positionUs);
=======
    try {
      checkForDiscontinuity(positionUs);
    } catch (VpxDecoderException e) {
      notifyDecoderError(e);
      throw new ExoPlaybackException(e);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && vpxVideoSurfaceView != null) {
      vpxVideoSurfaceView.renderFrame(outputBuffer);
=======
    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null) {
      outputBufferRenderer.setOutputBuffer(outputBuffer);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void releaseOutputBuffer() throws VpxDecoderException {
    decoder.releaseOutputBuffer(outputBuffer);
    outputBuffer = null;
=======
  private void releaseOutputBuffer(VpxOutputBuffer buffer) throws VpxDecoderException {
    if (buffer != null) {
      decoder.releaseOutputBuffer(buffer);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void renderRgbFrame(OutputBuffer outputBuffer, boolean scale) {
=======
  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void checkForDiscontinuity(long positionUs) {
=======
  private void checkForDiscontinuity(long positionUs) throws VpxDecoderException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void flushDecoder() {
=======
  private void flushDecoder() throws VpxDecoderException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    } else if (messageType == MSG_SET_VPX_SURFACE_VIEW) {
      setVpxVideoSurfaceView((VpxVideoSurfaceView) message);
=======
    } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
      setOutputBufferRenderer((VpxOutputBufferRenderer) message);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    vpxVideoSurfaceView = null;
=======
    outputBufferRenderer = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void setVpxVideoSurfaceView(VpxVideoSurfaceView vpxVideoSurfaceView) {
    if (this.vpxVideoSurfaceView == vpxVideoSurfaceView) {
=======
  private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRenderer) {
    if (this.outputBufferRenderer == outputBufferRenderer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    this.vpxVideoSurfaceView = vpxVideoSurfaceView;
=======
    this.outputBufferRenderer = outputBufferRenderer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    outputMode =
        (vpxVideoSurfaceView != null) ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
=======
    outputMode = (outputBufferRenderer != null)
        ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void notifyIfVideoSizeChanged(final OutputBuffer outputBuffer) {
=======
  private void notifyIfVideoSizeChanged(final VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java;<<<<<<< MINE
  public void renderFrame(OutputBuffer outputBuffer) {
=======
  @Override
  public void setOutputBuffer(VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java;<<<<<<< MINE
  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer)
=======
  public int decode(ByteBuffer encoded, int size, VpxOutputBuffer outputBuffer)
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
      + "  float y = 1.164 * (texture2D(y_tex, interp_tc).r - 0.0625);\n"
      + "  float u = texture2D(u_tex, interp_tc).r - 0.5;\n"
      + "  float v = texture2D(v_tex, interp_tc).r - 0.5;\n"
      + "  gl_FragColor = vec4(y + 1.596 * v, "
      + "                      y - 0.391 * u - 0.813 * v, "
      + "                      y + 2.018 * u, "
      + "                      1.0);\n"
=======
      + "  vec3 yuv;"
      + "  yuv.x = texture2D(y_tex, interp_tc).r - 0.0625;\n"
      + "  yuv.y = texture2D(u_tex, interp_tc).r - 0.5;\n"
      + "  yuv.z = texture2D(v_tex, interp_tc).r - 0.5;\n"
      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);"
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
  public void setFrame(OutputBuffer outputBuffer) {
=======
  public synchronized void setFrame(VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(STYLE_SPANS[style.getStyle()], start, end,
=======
      builder.setSpan(new StyleSpan(style.getStyle()), start, end,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(STRIKETHROUGH_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
=======
      builder.setSpan(new StrikethroughSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(UNDERLINE_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
=======
      builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java;<<<<<<< MINE
    return ((position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE) / bitrate;
=======
    return (Math.max(0, position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE)
        / bitrate;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java;<<<<<<< MINE
    if (!isSeekable()) {
=======
    if (!isSeekable() || position < firstFramePosition) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
      parser.parse(inputStream);
      fail("Expected IOException");
    } catch (IOException expected) {
=======
      parser.parse(bytes, 0, bytes.length);
      fail("Expected ParserException");
    } catch (ParserException expected) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext()
        .getResources().getAssets().open(file);
    return (TtmlSubtitle) ttmlParser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), file);
    return ttmlParser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java;<<<<<<< MINE
  public Subtitle parse(InputStream inputStream) throws IOException {
    DataInputStream dataInputStream  = new DataInputStream(inputStream);
    String cueText = dataInputStream.readUTF();
=======
  public Subtitle parse(byte[] bytes, int offset, int length) {
    String cueText = new String(bytes, offset, length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
  public static void validateWebvttHeaderLine(BufferedReader input) throws IOException {
=======
  public static void validateWebvttHeaderLine(ParsableByteArray input) throws ParserException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
  public static Matcher findNextCueHeader(BufferedReader input) throws IOException {
=======
  public static Matcher findNextCueHeader(ParsableByteArray input) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
      InputStream inputStream = new ByteArrayInputStream(holder.data.array(), 0, holder.size);
      parsedSubtitle = parser.parse(inputStream);
    } catch (IOException e) {
=======
      parsedSubtitle = parser.parse(holder.data.array(), 0, holder.size);
    } catch (ParserException e) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
 * Parses {@link Subtitle}s from {@link InputStream}s.
=======
 * Parses {@link Subtitle}s from a byte array.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * Parses a {@link Subtitle} from the provided {@link InputStream}.
=======
   * Parses a {@link Subtitle} from the provided {@code byte[]}.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * @param inputStream The stream from which to parse the subtitle.
=======
   * @param bytes The array holding the subtitle data.
   * @param offset The offset of the subtitle data in bytes.
   * @param length The length of the subtitle data in bytes.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * @throws IOException If a problem occurred reading from the stream.
=======
   * @throws ParserException If a problem occurred parsing the subtitle data.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
  private void processSample() throws IOException {
    BufferedReader reader = new BufferedReader(
        new InputStreamReader(new ByteArrayInputStream(sampleData), C.UTF8_NAME));
=======
  private void processSample() throws ParserException {
    ParsableByteArray webvttData = new ParsableByteArray(sampleData);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
    WebvttParserUtil.validateWebvttHeaderLine(reader);
=======
    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
    while (!TextUtils.isEmpty(line = reader.readLine())) {
=======
    while (!TextUtils.isEmpty(line = webvttData.readLine())) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_93c2133_776da10/rev_93c2133-776da10/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java;<<<<<<< MINE
    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output<List<Id3Frame>> {
=======
    MappingTrackSelector.EventListener, MetadataRenderer.Output<Metadata> {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2c54363_8caaf0b/rev_2c54363-8caaf0b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java;<<<<<<< MINE
    MetadataRenderer.Output<List<Id3Frame>> {
=======
    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
      if (isAttachedToWindow()) {
=======
      if (isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
      view.setAlpha(enabled ? 1f : 0.3f);
=======
      setViewAlphaV11(view, enabled ? 1f : 0.3f);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_94a3640_55ca323/rev_94a3640-55ca323/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
        if(clazz == SSADecoder.class) {
          byte[] header = format.initializationData.get(1);
          String dlgfmt = new String(format.initializationData.get(0), "UTF-8");
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(byte[].class, String.class)
                  .newInstance(header, dlgfmt);
        }
        if (clazz == Cea608Decoder.class) {
=======
        if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_94a3640_55ca323/rev_94a3640-55ca323/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
        }
        else {
=======
        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
              .newInstance(format.accessibilityChannel);
        } else {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java;<<<<<<< MINE
    if (!haveSupportedTracks) {
      // Indicate that the default selection will be nothing.
      defaultView.setText(R.string.selection_default_none);
    } else if (haveAdaptiveTracks) {
=======
    if (haveAdaptiveTracks) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
   * @param userAgent The User-Agent string that should be used.
=======
   * @param userAgent An optional User-Agent string.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
      TransferListener<? super DataSource> listener) {
=======
  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
      @Nullable TransferListener<? super DataSource> listener) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
   * @param userAgent The User-Agent string that should be used.
=======
   * @param userAgent An optional User-Agent string.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
      TransferListener<? super DataSource> listener, CacheControl cacheControl) {
=======
  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
      @Nullable TransferListener<? super DataSource> listener,
      @Nullable CacheControl cacheControl) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertEquals(null, variants.get(2).format.codecs);
=======
    assertNull(variants.get(2).format.codecs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertEquals(null, variants.get(3).format.codecs);
=======
    assertNull(variants.get(3).format.codecs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java;<<<<<<< MINE
    playlistTracker.maybeThrowPlaylistRefreshError();
=======
    playlistTracker.maybeThrowPrimaryPlaylistRefreshError();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
    public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
=======
    /**
     * Creates an HLS url from a given http url.
     *
     * @param url The url.
     * @return An HLS url.
     */
    public static HlsUrl createMediaPlaylistHlsUrl(String url) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
      return new HlsUrl(baseUri, format);
=======
      return new HlsUrl(url, format);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
  /**
   * @param baseUri See {@link #baseUri}.
   * @param tags See {@link #tags}.
   * @param variants See {@link #variants}.
   * @param audios See {@link #audios}.
   * @param subtitles See {@link #subtitles}.
   * @param muxedAudioFormat See {@link #muxedAudioFormat}.
   * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
   */
  public HlsMasterPlaylist(String baseUri, List<String> tags, List<HlsUrl> variants,
      List<HlsUrl> audios, List<HlsUrl> subtitles, Format muxedAudioFormat,
      List<Format> muxedCaptionFormats) {
    super(baseUri, tags);
=======
  /**
   * @param baseUri The base uri. Used to resolve relative paths.
   * @param variants See {@link #variants}.
   * @param audios See {@link #audios}.
   * @param subtitles See {@link #subtitles}.
   * @param muxedAudioFormat See {@link #muxedAudioFormat}.
   * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
   */
  public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
      List<HlsUrl> subtitles, Format muxedAudioFormat, List<Format> muxedCaptionFormats) {
    super(baseUri);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
    this.muxedCaptionFormats = Collections.unmodifiableList(muxedCaptionFormats);
=======
    this.muxedCaptionFormats = muxedCaptionFormats != null
        ? Collections.unmodifiableList(muxedCaptionFormats) : null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
=======
  /**
   * Creates a playlist with a single variant.
   *
   * @param variantUrl The url of the single variant.
   * @return A master playlist with a single variant for the provided url.
   */
  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUrl) {
    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUrl));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
=======
   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
   *     information is available in the master playlist.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
=======
   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
   *     information is available in the master playlist.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
      if (!muxedCaptionFormats.isEmpty()) {
=======
      List<Format> closedCaptionFormats = muxedCaptionFormats;
      if (closedCaptionFormats != null) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
=======
          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, closedCaptionFormats));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java;<<<<<<< MINE
    array.skipBits(1);
=======
    array.skipBit();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
  public TtmlRegion() {
    this(Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
=======
  public TtmlRegion(String id) {
    this(id, Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
  public TtmlRegion(float position, float line, @Cue.LineType int lineType, float width) {
=======
  public TtmlRegion(String id, float position, float line, @Cue.LineType int lineType,
      @Cue.AnchorType int lineAnchor, float width) {
    this.id = id;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java;<<<<<<< MINE
              interpolate(pitchBuffer, position + i, oldSampleRate, newSampleRate);
=======
              interpolate(pitchBuffer, position * numChannels + i, oldSampleRate, newSampleRate);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
 * <li>Registered listeners are called on the thread that created the ExoPlayer instance.</li>
=======
 * <li>Registered listeners are called on the thread that created the ExoPlayer instance, unless
 * the thread that created the ExoPlayer instance does not have a {@link Looper}. In that case,
 * registered listeners will be called on the application's main thread.</li>
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
   * @deprecated Use {@link Player#REPEAT_MODE_OFF} instead.
   */
  @Deprecated
  @RepeatMode int REPEAT_MODE_OFF = Player.REPEAT_MODE_OFF;
  /**
   * @deprecated Use {@link Player#REPEAT_MODE_ONE} instead.
=======
   * Register a listener to receive events from the player. The listener's methods will be called on
   * the thread that was used to construct the player. However, if the thread used to construct the
   * player does not have a {@link Looper}, then the listener will be called on the main thread.
   *
   * @param listener The listener to register.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}. Available extension renderers are not used.
=======
   * Creates a {@link SimpleExoPlayer} instance. Available extension renderers are not used.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates an {@link ExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates an {@link ExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates an {@link ExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates an {@link ExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
   * Creates an instance.
   *
   * @param name The name of the {@link MediaCodec}.
   * @param mimeType A mime type supported by the {@link MediaCodec}.
   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
   * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
   * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
   * @return The created instance.
=======
   * Creates an instance.
   *
   * @param name The name of the {@link MediaCodec}.
   * @param mimeType A mime type supported by the {@link MediaCodec}.
   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
   * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
   * @return The created instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
  public static MediaCodecInfo newInstance(String name, String mimeType,
      CodecCapabilities capabilities, boolean forceDisableAdaptive, boolean forceSecure) {
    return new MediaCodecInfo(name, mimeType, capabilities, forceDisableAdaptive, forceSecure);
  }

  private MediaCodecInfo(String name, String mimeType, CodecCapabilities capabilities,
      boolean forceDisableAdaptive, boolean forceSecure) {
=======
  public static MediaCodecInfo newInstance(String name, String mimeType,
      CodecCapabilities capabilities, boolean forceDisableAdaptive) {
    return new MediaCodecInfo(name, mimeType, capabilities, forceDisableAdaptive);
  }

  private MediaCodecInfo(String name, String mimeType, CodecCapabilities capabilities,
      boolean forceDisableAdaptive) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
    adaptive = capabilities != null && isAdaptive(capabilities);
=======
    adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
    if (audioCapabilities.getMaxInputChannelCount() < channelCount) {
=======
    int maxInputChannelCount = adjustMaxInputChannelCount(name, mimeType,
        audioCapabilities.getMaxInputChannelCount());
    if (maxInputChannelCount < channelCount) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java;<<<<<<< MINE
    renderers = renderersFactory.createRenderers(new Handler(), componentListener,
        componentListener, componentListener, componentListener);
=======
    Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
    Handler eventHandler = new Handler(eventLooper);
    renderers = renderersFactory.createRenderers(eventHandler, componentListener, componentListener,
        componentListener, componentListener);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java;<<<<<<< MINE
      data = ByteBuffer.allocateDirect(size);
=======
      data = ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
=======
  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
    return areAdaptationCompatible(oldFormat, newFormat)
=======
    return areAdaptationCompatible(codecIsAdaptive, oldFormat, newFormat)
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
    if (reportedWidth != currentWidth || reportedHeight != currentHeight
=======
    if ((currentWidth != Format.NO_VALUE || currentHeight != Format.NO_VALUE)
      && (reportedWidth != currentWidth || reportedHeight != currentHeight
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
        || reportedPixelWidthHeightRatio != currentPixelWidthHeightRatio) {
=======
        || reportedPixelWidthHeightRatio != currentPixelWidthHeightRatio)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
      eventDispatcher.videoSizeChanged(currentWidth, currentHeight, currentUnappliedRotationDegrees,
          currentPixelWidthHeightRatio);
=======
      eventDispatcher.videoSizeChanged(reportedWidth, reportedHeight,
          reportedUnappliedRotationDegrees, reportedPixelWidthHeightRatio);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
=======
  protected CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
      if (areAdaptationCompatible(format, streamFormat)) {
=======
      if (areAdaptationCompatible(codecInfo.adaptive, format, streamFormat)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
   * Returns whether an adaptive codec with suitable {@link CodecMaxValues} will support adaptation
   * between two {@link Format}s.
=======
   * Returns whether a codec with suitable {@link CodecMaxValues} will support adaptation between
   * two {@link Format}s.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
   * @return Whether an adaptive codec with suitable {@link CodecMaxValues} will support adaptation
   *     between two {@link Format}s.
=======
   * @return Whether the codec will support adaptation between the two {@link Format}s.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static boolean areAdaptationCompatible(Format first, Format second) {
=======
  private static boolean areAdaptationCompatible(boolean codecIsAdaptive, Format first,
      Format second) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
        && getRotationDegrees(first) == getRotationDegrees(second);
=======
        && getRotationDegrees(first) == getRotationDegrees(second)
        && (codecIsAdaptive || (first.width == second.width && first.height == second.height));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java;<<<<<<< MINE
   * @param formats The track formats. Must not be null or contain null elements.
=======
   * @param formats The track formats. Must not be null, contain null elements or be of length 0.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory, int flags) {
=======
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
      @CacheDataSource.Flags int flags) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory, int flags,
      long maxCacheFileSize) {
=======
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
      @CacheDataSource.Flags int flags, long maxCacheFileSize) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
      Factory cacheReadDataSourceFactory,
      DataSink.Factory cacheWriteDataSinkFactory, int flags, EventListener eventListener) {
=======
      Factory cacheReadDataSourceFactory, DataSink.Factory cacheWriteDataSinkFactory,
      @CacheDataSource.Flags int flags, EventListener eventListener) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
      long skipped = inputStream.skip(dataSpec.position);
      if (skipped < dataSpec.position) {
=======
      long assertStartOffset = assetFileDescriptor.getStartOffset();
      long skipped = inputStream.skip(assertStartOffset + dataSpec.position) - assertStartOffset;
      if (skipped != dataSpec.position) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
        bytesRemaining = inputStream.available();
        if (bytesRemaining == 0) {
          // FileInputStream.available() returns 0 if the remaining length cannot be determined, or
          // if it's greater than Integer.MAX_VALUE. We don't know the true length in either case,
          // so treat as unbounded.
          bytesRemaining = C.LENGTH_UNSET;
=======
        bytesRemaining = assetFileDescriptor.getLength();
        if (bytesRemaining == AssetFileDescriptor.UNKNOWN_LENGTH) {
          // The asset must extend to the end of the file.
          bytesRemaining = inputStream.available();
          if (bytesRemaining == 0) {
            // FileInputStream.available() returns 0 if the remaining length cannot be determined,
            // or if it's greater than Integer.MAX_VALUE. We don't know the true length in either
            // case, so treat as unbounded.
            bytesRemaining = C.LENGTH_UNSET;
          }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
      data.skipBits(1); // qpprime_y_zero_transform_bypass_flag
=======
      data.skipBit(); // qpprime_y_zero_transform_bypass_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // gaps_in_frame_num_value_allowed_flag
=======
    data.skipBit(); // gaps_in_frame_num_value_allowed_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
      data.skipBits(1); // mb_adaptive_frame_field_flag
=======
      data.skipBit(); // mb_adaptive_frame_field_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // direct_8x8_inference_flag
=======
    data.skipBit(); // direct_8x8_inference_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // entropy_coding_mode_flag
=======
    data.skipBit(); // entropy_coding_mode_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
   * @param n The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
  public void skipBits(int n) {
    byteOffset += (n / 8);
    bitOffset += (n % 8);
=======
  public void skipBits(int numBits) {
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;
    skipBit();
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
   * @param n The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
  public void skipBits(int n) {
=======
  public void skipBits(int numBits) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    byteOffset += (n / 8);
    bitOffset += (n % 8);
=======
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
   * @param n The number of bits.
=======
   * @param numBits The number of bits.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
  public boolean canReadBits(int n) {
=======
  public boolean canReadBits(int numBits) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;
    skipBit();
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    if (numBits == 0) {
      return 0;
=======
    int returnValue = 0;
    bitOffset += numBits;
    while (bitOffset > 8) {
      bitOffset -= 8;
      returnValue |= (data[byteOffset] & 0xFF) << bitOffset;
      byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE

    int returnValue = 0;

    // Read as many whole bytes as we can.
    int wholeBytes = (numBits / 8);
    for (int i = 0; i < wholeBytes; i++) {
      int nextByteOffset = shouldSkipByte(byteOffset + 1) ? byteOffset + 2 : byteOffset + 1;
      int byteValue;
      if (bitOffset != 0) {
        byteValue = ((data[byteOffset] & 0xFF) << bitOffset)
            | ((data[nextByteOffset] & 0xFF) >>> (8 - bitOffset));
      } else {
        byteValue = data[byteOffset];
      }
      numBits -= 8;
      returnValue |= (byteValue & 0xFF) << numBits;
      byteOffset = nextByteOffset;
    }

    // Read any remaining bits.
    if (numBits > 0) {
      int nextBit = bitOffset + numBits;
      byte writeMask = (byte) (0xFF >> (8 - numBits));
      int nextByteOffset = shouldSkipByte(byteOffset + 1) ? byteOffset + 2 : byteOffset + 1;

      if (nextBit > 8) {
        // Combine bits from current byte and next byte.
        returnValue |= ((((data[byteOffset] & 0xFF) << (nextBit - 8)
            | ((data[nextByteOffset] & 0xFF) >> (16 - nextBit))) & writeMask));
        byteOffset = nextByteOffset;
      } else {
        // Bits to be read only within current byte.
        returnValue |= (((data[byteOffset] & 0xFF) >> (8 - nextBit)) & writeMask);
        if (nextBit == 8) {
          byteOffset = nextByteOffset;
        }
      }

      bitOffset = nextBit % 8;
=======
    returnValue |= (data[byteOffset] & 0xFF) >> 8 - bitOffset;
    returnValue &= 0xFFFFFFFF >>> (32 - numBits);
    if (bitOffset == 8) {
      bitOffset = 0;
      byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java;<<<<<<< MINE
    this.totalSamples = scratch.readBits(36);
=======
    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32)
        | (scratch.readBits(32) & 0xFFFFFFFFL);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java;<<<<<<< MINE
      + "([Zz]|((\\+|\\-)(\\d\\d):?(\\d\\d)))?");
=======
      + "([Zz]|((\\+|\\-)(\\d?\\d):?(\\d\\d)))?");
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory)
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**
=======
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory).
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
    extractors[6] = new TsExtractor(tsFlags);
=======
    extractors[6] = new TsExtractor(tsMode, tsFlags);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java;<<<<<<< MINE
    return durationUs == C.TIME_UNSET ? 0
        : firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
=======
    if (durationUs == C.TIME_UNSET) {
      return 0;
    }
    timeUs = Util.constrainValue(timeUs, 0, durationUs);
    return firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java;<<<<<<< MINE
            : MimeTypes.AUDIO_ULAW;
=======
            : MimeTypes.AUDIO_MLAW;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java;<<<<<<< MINE
      output.format(Format.createTextSampleFormat(idGenerator.getFormatId(), channelMimeType, null,
          Format.NO_VALUE, channelFormat.selectionFlags, channelFormat.language,
          channelFormat.accessibilityChannel, null));
=======
      String formatId = channelFormat.id != null ? channelFormat.id : idGenerator.getFormatId();
      output.format(Format.createTextSampleFormat(formatId, channelMimeType, null, Format.NO_VALUE,
          channelFormat.selectionFlags, channelFormat.language, channelFormat.accessibilityChannel,
          null));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
    bitArray.skipBits(1); // sps_temporal_id_nesting_flag
=======
    bitArray.skipBit(); // sps_temporal_id_nesting_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
      bitArray.skipBits(1); // separate_colour_plane_flag
=======
      bitArray.skipBit(); // separate_colour_plane_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
      bitArray.skipBits(1); // pcm_loop_filter_disabled_flag
=======
      bitArray.skipBit(); // pcm_loop_filter_disabled_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
        bitArray.skipBits(1); // delta_rps_sign
=======
        bitArray.skipBit(); // delta_rps_sign
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
            bitArray.skipBits(1); // use_delta_flag[j]
=======
            bitArray.skipBit(); // use_delta_flag[j]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
          bitArray.skipBits(1); // used_by_curr_pic_s0_flag[i]
=======
          bitArray.skipBit(); // used_by_curr_pic_s0_flag[i]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
          bitArray.skipBits(1); // used_by_curr_pic_s1_flag[i]
=======
          bitArray.skipBit(); // used_by_curr_pic_s1_flag[i]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    this.limit = limit * 8;
=======
    byteLimit = data.length;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (((data[byteOffset] & 0xFF) >> bitOffset) & 0x01) == 1;
    skipBits(1);
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    Assertions.checkState(getPosition() + numBits <= limit);
    if (numBits == 0) {
      return 0;
    }
    int result = 0;
    int bitCount = 0;
    if (bitOffset != 0) {
      bitCount = Math.min(numBits, 8 - bitOffset);
      int mask = 0xFF >>> (8 - bitCount);
      result = (data[byteOffset] >>> bitOffset) & mask;
      bitOffset += bitCount;
      if (bitOffset == 8) {
        byteOffset++;
        bitOffset = 0;
      }
    }

    if (numBits - bitCount > 7) {
      int numBytes = (numBits - bitCount) / 8;
      for (int i = 0; i < numBytes; i++) {
        result |= (data[byteOffset++] & 0xFFL) << bitCount;
        bitCount += 8;
      }
=======
    int tempByteOffset = byteOffset;
    int bitsRead = Math.min(numBits, 8 - bitOffset);
    int returnValue = ((data[tempByteOffset++] & 0xFF) >> bitOffset) & (0xFF >> (8 - bitsRead));
    while (bitsRead < numBits) {
      returnValue |= (data[tempByteOffset++] & 0xFF) << bitsRead;
      bitsRead += 8;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE

    if (numBits > bitCount) {
      int bitsOnNextByte = numBits - bitCount;
      int mask = 0xFF >>> (8 - bitsOnNextByte);
      result |= (data[byteOffset] & mask) << bitCount;
      bitOffset += bitsOnNextByte;
    }
    return result;
=======
    returnValue &= 0xFFFFFFFF >>> (32 - numBits);
    skipBits(numBits);
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
   * @param numberOfBits The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
  public void skipBits(int numberOfBits) {
    Assertions.checkState(getPosition() + numberOfBits <= limit);
    byteOffset += numberOfBits / 8;
    bitOffset += numberOfBits % 8;
=======
  public void skipBits(int numBits) {
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    return limit - getPosition();
=======
    return (byteLimit - byteOffset) * 8 - bitOffset;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
  /**
   * Returns the limit in bits.
   **/
  public int limit() {
    return limit;
=======
  private void assertValidOffset() {
    // It is fine for position to be at the end of the array, but no further.
    Assertions.checkState(byteOffset >= 0
        && (byteOffset < byteLimit || (byteOffset == byteLimit && bitOffset == 0)));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
    // Get the current and ideal selections.
=======
    // Stash the current selection, then make a new one.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
    Format currentFormat = getSelectedFormat();
    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
    Format idealFormat = getFormat(idealSelectedIndex);
    // Assume we can switch to the ideal selection.
    selectedIndex = idealSelectedIndex;
    // Revert back to the current selection if conditions are not suitable for switching.
    if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
      if (idealFormat.bitrate > currentFormat.bitrate
=======
    selectedIndex = determineIdealSelectedIndex(nowMs);
    if (selectedIndex == currentSelectedIndex) {
      return;
    }
    if (!isBlacklisted(currentSelectedIndex, nowMs)) {
      // Revert back to the current selection if conditions are not suitable for switching.
      Format currentFormat = getFormat(currentSelectedIndex);
      Format selectedFormat = getFormat(selectedIndex);
      if (selectedFormat.bitrate > currentFormat.bitrate
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
        // The ideal track is a higher quality, but we have insufficient buffer to safely switch
=======
        // The selected track is a higher quality, but we have insufficient buffer to safely switch
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
      } else if (idealFormat.bitrate < currentFormat.bitrate
=======
      } else if (selectedFormat.bitrate < currentFormat.bitrate
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
        // The ideal track is a lower quality, but we have sufficient buffer to defer switching
=======
        // The selected track is a lower quality, but we have sufficient buffer to defer switching
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
            DEFAULT_BUFFERED_COLOR);
=======
            getDefaultBufferedColor(playedColor));
        int unplayedColor = a.getInt(R.styleable.DefaultTimeBar_unplayed_color,
            getDefaultUnplayedColor(playedColor));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      scrubberPaint.setColor(OPAQUE_COLOR | DEFAULT_PLAYED_COLOR);
      progressPaint.setColor(DEFAULT_PLAYED_COLOR);
      bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
=======
      playedPaint.setColor(DEFAULT_PLAYED_COLOR);
      scrubberPaint.setColor(getDefaultScrubberColor(DEFAULT_PLAYED_COLOR));
      bufferedPaint.setColor(getDefaultBufferedColor(DEFAULT_PLAYED_COLOR));
      unplayedPaint.setColor(getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups,
      int adGroupCount) {
    Assertions.checkArgument(adGroupCount == 0
        || (adGroupTimesMs != null && playedAdGroups != null));
    this.adGroupCount = adGroupCount;
    this.adGroupTimesMs = adGroupTimesMs;
    this.playedAdGroups = playedAdGroups;
    update();
=======
  public void setAdBreakTimesMs(@Nullable long[] adBreakTimesMs, int adBreakCount) {
    Assertions.checkArgument(adBreakCount == 0 || adBreakTimesMs != null);
    this.adBreakCount = adBreakCount;
    this.adBreakTimesMs = adBreakTimesMs;
    update();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);
    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);
    setMeasuredDimension(measureWidth, measureHeight);
=======
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int height = heightMode == MeasureSpec.UNSPECIFIED ? touchTargetHeight
        : heightMode == MeasureSpec.EXACTLY ? heightSize : Math.min(touchTargetHeight, heightSize);
    setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      listener.onScrubStart(this);
=======
      listener.onScrubStart(this, getScrubberPosition());
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      int bufferedPixelWidth =
          (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = progressBar.left + bufferedPixelWidth;
      int scrubberPixelPosition =
          (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = progressBar.left + scrubberPixelPosition;
=======
      int bufferedPixelWidth = (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right);
      int scrubberPixelPosition = (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, progressPaint);
=======
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, unplayedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, progressPaint);
=======
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, unplayedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, scrubberPaint);
=======
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java;<<<<<<< MINE
   * @param rewindMs The rewind increment in milliseconds.
=======
   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
   *     rewind button to be disabled.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java;<<<<<<< MINE
   * @param fastForwardMs The fast forward increment in milliseconds.
=======
   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
   *     cause the fast forward button to be disabled.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
=======
    long durationMs = player.getDuration();
    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
    if (durationMs != C.TIME_UNSET) {
      seekPositionMs = Math.min(seekPositionMs, durationMs);
    }
    seekTo(seekPositionMs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    public void onScrubStart(TimeBar timeBar) {
=======
    public void onScrubStart(TimeBar timeBar, long position) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java;<<<<<<< MINE
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
=======
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
      }
    }
    return Arrays.copyOf(data, position);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs) throws IOException, InterruptedException {
    return consumeTestData(extractor, input, timeUs, false);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs, boolean retryFromStartIfLive) throws IOException, InterruptedException {
    FakeExtractorOutput output = new FakeExtractorOutput();
    extractor.init(output);
    consumeTestData(extractor, input, timeUs, output, retryFromStartIfLive);
    return output;
  }

  private static void consumeTestData(Extractor extractor, FakeExtractorInput input, long timeUs,
      FakeExtractorOutput output, boolean retryFromStartIfLive)
      throws IOException, InterruptedException {
    extractor.seek(input.getPosition(), timeUs);
    PositionHolder seekPositionHolder = new PositionHolder();
    int readResult = Extractor.RESULT_CONTINUE;
    while (readResult != Extractor.RESULT_END_OF_INPUT) {
      try {
        // Extractor.read should not read seekPositionHolder.position. Set it to a value that's
        // likely to cause test failure if a read does occur.
        seekPositionHolder.position = Long.MIN_VALUE;
        readResult = extractor.read(input, seekPositionHolder);
        if (readResult == Extractor.RESULT_SEEK) {
          long seekPosition = seekPositionHolder.position;
          Assertions.checkState(0 <= seekPosition && seekPosition <= Integer.MAX_VALUE);
          input.setPosition((int) seekPosition);
        }
      } catch (SimulatedIOException e) {
        if (!retryFromStartIfLive) {
          continue;
        }
        boolean isOnDemand = input.getLength() != C.LENGTH_UNSET
            || (output.seekMap != null && output.seekMap.getDurationUs() != C.TIME_UNSET);
        if (isOnDemand) {
          continue;
        }
        input.setPosition(0);
        for (int i = 0; i < output.numberOfTracks; i++) {
          output.trackOutputs.valueAt(i).clear();
        }
        extractor.seek(0, 0);
>>>>>>> YOURS
