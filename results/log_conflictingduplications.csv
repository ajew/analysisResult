revision;file;nodeIdentifier1;;nodeIdentifier2;conflict
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb.revisions;/library/src/com/bumptech/glide/resize/ImageManager.java;private boolean isCancelled ;private volatile boolean isCancelled ;
        private boolean isCancelled = false;
=======
        private volatile boolean isCancelled = false;


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java;@Test    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() ;@Test  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() ;
        InOrder order = inOrder(thumb, full);
        order.verify(thumb).clear();
        order.verify(full).clear();
    }

    @Test
    public void testRecyclesRequestsWhenRecycled() {
        coordinator.recycle();
        verify(thumb).recycle();
        verify(full).recycle();
    }

    @Test
    public void testIsPausedWhenFullIsPaused() {
        when(full.isPaused()).thenReturn(true);
        assertTrue(coordinator.isPaused());
    }

    @Test
    public void testPausesBothRequestsWhenPaused() {
        coordinator.pause();
        verify(full).pause();
        verify(thumb).pause();
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
        coordinator = new ThumbnailRequestCoordinator();
        coordinator.setRequests(full, thumb);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentDoesNotAllowSetImageAndFullDoesNotHaveResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        when(full.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumb() {
        assertFalse(coordinator.canNotifyStatusChanged(thumb));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.isAnyResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotifyStatusChangedIfParentAllowsNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        when(thumb.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);

        when(parent.isAnyResourceSet()).thenReturn(true);
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);

        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsNotCompleteIfNeitherRequestIsComplete() {
        assertFalse(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfFullIsComplete() {
        when(full.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        assertFalse(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(parent).onRequestSuccess(eq(coordinator));
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testDoesNotClearThumbOnThumbRequestComplete() {
        coordinator.onRequestSuccess(thumb);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        coordinator.onRequestSuccess(full);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotNotifyParentOnThumbRequestComplete() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(thumb);
=======
        return null;
      }
    }).when(thumb).begin();

    coordinator.begin();

    verify(full, never()).begin();
  }

  @Test
  public void testCallsClearOnRequestsWhenCleared() {
    coordinator.clear();
    InOrder order = inOrder(thumb, full);
    order.verify(thumb).clear();
    order.verify(full).clear();
  }

  @Test
  public void testRecyclesRequestsWhenRecycled() {
    coordinator.recycle();
    verify(thumb).recycle();
    verify(full).recycle();
  }

  @Test
  public void testIsPausedWhenFullIsPaused() {
    when(full.isPaused()).thenReturn(true);
    assertTrue(coordinator.isPaused());
  }

  @Test
  public void testPausesBothRequestsWhenPaused() {
    coordinator.pause();
    verify(full).pause();
    verify(thumb).pause();
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
    coordinator = new ThumbnailRequestCoordinator();
    coordinator.setRequests(full, thumb);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canSetImage(full));
  }

  @Test
  public void
  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotSetImageForThumbIfNotAllowedByParentAndFullDoesNotHaveResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    when(full.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumb() {
    assertFalse(coordinator.canNotifyStatusChanged(thumb));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.isAnyResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotifyStatusChangedIfParentAllowsNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    when(thumb.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);

    when(parent.isAnyResourceSet()).thenReturn(true);
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);

    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsNotCompleteIfNeitherRequestIsComplete() {
    assertFalse(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfFullIsComplete() {
    when(full.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfThumbIsComplete() {
    when(thumb.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    assertFalse(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(parent).onRequestSuccess(eq(coordinator));
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testDoesNotClearThumbOnThumbRequestComplete() {
    coordinator.onRequestSuccess(thumb);
    verify(thumb, never()).clear();

  }

  @Test
  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
      when(thumb.isComplete()).thenReturn(true);
      coordinator.onRequestSuccess(full);
      verify(thumb, never()).clear();
  }

  @Test
  public void testDoesNotNotifyParentOnThumbRequestComplete() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(thumb);


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java;Set<RequestManager> getDescendants();Set<RequestManager> getDescendants();
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context hierarchy
 * is provided by nesting in Activity and Fragments; the application context does not provide access to
 * any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();
}=======
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context
 * hierarchy is provided by nesting in Activity and Fragments; the application context does not
 * provide access to any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current
     * {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)            throws IOException ;private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,      Map<String, String> headers) throws IOException ;
    private static final String TAG = "HttpUrlFetcher";
    private static final String ENCODING_HEADER = "Accept-Encoding";
    private static final String DEFAULT_ENCODING = "identity";
    private static final int MAXIMUM_REDIRECTS = 5;
    private static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultHttpUrlConnectionFactory();

    private final GlideUrl glideUrl;
    private final HttpUrlConnectionFactory connectionFactory;

    private HttpURLConnection urlConnection;
    private InputStream stream;
    private volatile boolean isCancelled;

    public HttpUrlFetcher(GlideUrl glideUrl) {
        this(glideUrl, DEFAULT_CONNECTION_FACTORY);
    }

    // Visible for testing.
    HttpUrlFetcher(GlideUrl glideUrl, HttpUrlConnectionFactory connectionFactory) {
        this.glideUrl = glideUrl;
        this.connectionFactory = connectionFactory;
    }

    @Override
    public InputStream loadData(Priority priority) throws Exception {
        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
    }

    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)
            throws IOException {
        if (redirects >= MAXIMUM_REDIRECTS) {
            throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
        } else {
            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
            try {
                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
                    throw new IOException("In re-direct loop");
                }
            } catch (URISyntaxException e) {
                // Do nothing, this is best effort.
            }
        }
        urlConnection = connectionFactory.build(url);
        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
        }
        // Do our best to avoid gzip since it's both inefficient for images and also makes it more
        // difficult for us to detect and prevent partial content rendering. See #440.
        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {
            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);
        }
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);
        urlConnection.setDoInput(true);

        // Connect explicitly to avoid errors in decoders if connection fails.
        urlConnection.connect();
        if (isCancelled) {
            return null;
        }
        final int statusCode = urlConnection.getResponseCode();
        if (statusCode / 100 == 2) {
            return getStreamForSuccessfulRequest(urlConnection);
        } else if (statusCode / 100 == 3) {
            String redirectUrlString = urlConnection.getHeaderField("Location");
            if (TextUtils.isEmpty(redirectUrlString)) {
                throw new IOException("Received empty or null redirect url");
            }
            URL redirectUrl = new URL(url, redirectUrlString);
            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
        } else {
            if (statusCode == -1) {
                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
            }
            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
        }
    }
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private static final int MAXIMUM_REDIRECTS = 5;
  private static final int DEFAULT_TIMEOUT_MS = 2500;
  // Visible for testing.
  static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
      new DefaultHttpUrlConnectionFactory();

  private final GlideUrl glideUrl;
  private final int timeout;
  private final HttpUrlConnectionFactory connectionFactory;

  private HttpURLConnection urlConnection;
  private InputStream stream;
  private volatile boolean isCancelled;

  public HttpUrlFetcher(GlideUrl glideUrl) {
    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
  }

  // Visible for testing.
  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
    this.glideUrl = glideUrl;
    this.timeout = timeout;
    this.connectionFactory = connectionFactory;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    long startTime = LogTime.getLogTime();
    InputStream result = null;
    try {
      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
          glideUrl.getHeaders());
    } catch (IOException e) {
      if (Logs.isEnabled(Log.DEBUG)) {
        Logs.log(Log.DEBUG, "Failed to load data for url", e);
      }
    }
    if (Logs.isEnabled(Log.VERBOSE)) {
      Logs.log(Log.VERBOSE, "Finished http url fetcher fetch in "
          + LogTime.getElapsedMillis(startTime) + " ms and loaded "  + result);
    }
    callback.onDataReady(result);
  }

  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
            throw new IOException("In re-direct loop");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      String contentLength = urlConnection.getHeaderField(CONTENT_LENGTH_HEADER);
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
      return stream;
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField("Location");
      if (TextUtils.isEmpty(redirectUrlString)) {
          throw new IOException("Received empty or null redirect url");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else {
      if (statusCode == -1) {
          throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
      }
      throw new IOException("Request failed " + statusCode + ": "
          + urlConnection.getResponseMessage());
    }
  }

  @Override
  public void cleanup() {
    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }
    if (urlConnection != null) {
      urlConnection.disconnect();
    }
  }

  @Override
  public void cancel() {
    // TODO: we should consider disconnecting the url connection here, but we can't do so
    // directly because cancel is often called on the main thread.
    isCancelled = true;
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  interface HttpUrlConnectionFactory {
    HttpURLConnection build(URL url) throws IOException;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;private final Headers headers;private final Headers headers;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;private String safeStringUrl;private String safeStringUrl;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;public GlideUrl(URL url, Headers headers) ;public GlideUrl(URL url, Headers headers) ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;public GlideUrl(String url, Headers headers) ;public GlideUrl(String url, Headers headers) ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;public String toStringUrl() ;public String toStringUrl() ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;private String getSafeStringUrl() ;private String getSafeStringUrl() ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;public Map<String, String> getHeaders() ;public Map<String, String> getHeaders() ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;public String getCacheKey() ;public String getCacheKey() ;
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/Headers.java;Headers NONE = new Headers() ;Headers NONE = new Headers() ;
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 * Implementations must implement equals() and hashcode().
 */
public interface Headers {

    /** An empty Headers object that can be used if users don't want to provide headers. */
    Headers NONE = new Headers() {
        @Override
        public Map<String, String> getHeaders() {
            return Collections.emptyMap();
        }
    };

    Map<String, String> getHeaders();

}=======
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 *
 * <p> Implementations must implement equals() and hashcode(). </p>
 */
public interface Headers {

  /** An empty Headers object that can be used if users don't want to provide headers. */
  Headers NONE = new Headers() {
      @Override
      public Map<String, String> getHeaders() {
          return Collections.emptyMap();
      }
  };

  /**
   * Returns a non-null map containing a set of headers to apply to an http request.
   */
  Map<String, String> getHeaders();


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/model/Headers.java;Map<String, String> getHeaders();Map<String, String> getHeaders();
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 * Implementations must implement equals() and hashcode().
 */
public interface Headers {

    /** An empty Headers object that can be used if users don't want to provide headers. */
    Headers NONE = new Headers() {
        @Override
        public Map<String, String> getHeaders() {
            return Collections.emptyMap();
        }
    };

    Map<String, String> getHeaders();

}=======
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 *
 * <p> Implementations must implement equals() and hashcode(). </p>
 */
public interface Headers {

  /** An empty Headers object that can be used if users don't want to provide headers. */
  Headers NONE = new Headers() {
      @Override
      public Map<String, String> getHeaders() {
          return Collections.emptyMap();
      }
  };

  /**
   * Returns a non-null map containing a set of headers to apply to an http request.
   */
  Map<String, String> getHeaders();


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;private ResponseBody responseBody;private ResponseBody responseBody;
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
    private final OkHttpClient client;
    private final GlideUrl url;
    private InputStream stream;
    private ResponseBody responseBody;

    public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
        this.client = client;
        this.url = url;
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private final OkHttpClient client;
  private final GlideUrl url;
  private InputStream stream;
  private ResponseBody responseBody;

  public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
    this.client = client;
    this.url = url;
  }

  @Override
  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java;@Test    public void testIssue387() throws IOException ;@Test  public void testIssue387() throws IOException ;
    @Test
    public void testIssue387() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        assertThat(new ImageHeaderParser(is).getOrientation()).isEqualTo(6);
    }

    @Test
    public void testLandscape() throws IOException {
        for (int i = 1; i <= 8; i++) {
            assertOrientation("Landscape", i);
        }
=======
  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIssue387() throws IOException {
      InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
      assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
  }

  @Test
  public void testLandscape() throws IOException {
    for (int i = 1; i <= 8; i++) {
      assertOrientation("Landscape", i);


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private static final String TAG ;private static final String TAG ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private static final int UNKNOWN ;private static final int UNKNOWN ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private final long contentLength;private final int contentLength;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private int readSoFar;private int readSoFar;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;public static InputStream obtain(InputStream other, String contentLengthHeader) ;public static InputStream obtain(InputStream other, String contentLengthHeader) ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private static int parseContentLength(String contentLengthHeader) ;private static int parseContentLength(String contentLengthHeader) ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;@Override  public synchronized int available() throws IOException ;@Override  public synchronized int available() throws IOException ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;@Override  public synchronized int read() throws IOException ;@Override  public synchronized int read() throws IOException ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;@Override  public int read(byte[] buffer) throws IOException ;@Override  public int read(byte[] buffer) throws IOException ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;@Override  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException ;@Override  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;private int checkReadSoFarOrThrow(int read) throws IOException ;private int checkReadSoFarOrThrow(int read) throws IOException ;
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java;private RequestManagerTreeNode treeNode ;@Mock RequestManagerTreeNode treeNode ;
    private RequestManager manager;
    private ConnectivityMonitor connectivityMonitor;
    private RequestTracker requestTracker;
    private ConnectivityListener connectivityListener;
    private RequestManager.DefaultOptions options;
    private Lifecycle lifecycle = mock(Lifecycle.class);
    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);

    @Before
    public void setUp() {
        connectivityMonitor = mock(ConnectivityMonitor.class);
        ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
        when(factory.build(any(Context.class), any(ConnectivityMonitor.ConnectivityListener.class)))
                .thenAnswer(new Answer<ConnectivityMonitor>() {
                    @Override
                    public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
                        connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
                        return connectivityMonitor;
                    }
                });
        requestTracker = mock(RequestTracker.class);
        manager =
            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);
        options = mock(RequestManager.DefaultOptions.class);
        manager.setDefaultOptions(options);
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingGenericModelLoaderAndDataClass() {
        Float model = 1f;
        ModelLoader<Float, InputStream> modelLoader = mock(ModelLoader.class);
        GenericTranscodeRequest<Float, InputStream, Bitmap> builder = manager.using(modelLoader, InputStream.class)
                .load(model)
                .as(Bitmap.class);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingImageStreamModelLoader() {
        String model = "fake";
        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);
        DrawableTypeRequest<String> builder = manager.using(modelLoader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingByteArrayLoader() {
        byte[] model = new byte[] { 1, 4, 65, 2};
        StreamByteArrayLoader loader = mock(StreamByteArrayLoader.class);
        DrawableTypeRequest<byte[]> builder = manager.using(loader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingVideoFileDescriptorModelLoader() {
        String model = "fake";
        FileDescriptorModelLoader<String> modelLoader = mock(FileDescriptorModelLoader.class);
        DrawableTypeRequest<String> builder = manager.using(modelLoader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadString() {
        String model = "fake";
        DrawableTypeRequest<String> builder = manager.load(model);
        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadUri() {
        Uri uri = Uri.EMPTY;
        DrawableTypeRequest<Uri> builder = manager.load(uri);
        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadMediaStoreUri() {
        Uri uri = Uri.EMPTY;
        DrawableTypeRequest<Uri> builder = manager.loadFromMediaStore(uri, "image/jpeg", 123L, 0);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadResourceId() {
        int id = 123;
        DrawableTypeRequest<Integer> builder = manager.load(id);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadGenericFromImage() {
        ModelLoaderFactory<Double, InputStream> factory = mock(ModelLoaderFactory.class);
        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
        Glide.get(Robolectric.application).register(Double.class, InputStream.class, factory);
        Double model = 2.2;
        DrawableTypeRequest<Double> builder = manager.load(model);

        verify(options).apply(eq(builder));
        Glide.get(Robolectric.application).unregister(Double.class, InputStream.class);
    }

    @Test
    public void testAppliesDefaultOptionsToLoadUrl() throws MalformedURLException {
        URL url = new URL("http://www.google.com");
        DrawableTypeRequest<URL> builder = manager.load(url);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadFromImageByteWithId() {
        byte[] model = new byte[] { 1, 2, 4 };
        DrawableTypeRequest<byte[]> builder = manager.load(model, "fakeId");

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadFromImageBytes() {
        byte[] model = new byte[] { 5, 9, 23 };
        DrawableTypeRequest<byte[]> builder = manager.load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadGenericFromVideo() {
        ModelLoaderFactory<Float, InputStream> factory = mock(ModelLoaderFactory.class);
        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
        Glide.get(Robolectric.application).register(Float.class, InputStream.class, factory);
        Float model = 23.2f;
        DrawableTypeRequest<Float> builder = manager.load(model);

        verify(options).apply(eq(builder));
        Glide.get(Robolectric.application).unregister(Float.class, InputStream.class);
    }
=======
  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;private final DiskCacheWriteLocker writeLocker ;private final DiskCacheWriteLocker writeLocker ;
    private static final int APP_VERSION = 1;
    private static final int VALUE_COUNT = 1;
    private static DiskLruCacheWrapper wrapper = null;

    private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
    private final SafeKeyGenerator safeKeyGenerator;
    private final File directory;
    private final int maxSize;
    private DiskLruCache diskLruCache;

    /**
     * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
     * a different directory and/or size, it will be returned instead and the new arguments
     * will be ignored.
     *
     * @param directory The directory for the disk cache
     * @param maxSize The max size for the disk cache
     * @return The new disk cache with the given arguments, or the current cache if one already exists
     */
    public static synchronized DiskCache get(File directory, int maxSize) {
        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!
        if (wrapper == null) {
            wrapper = new DiskLruCacheWrapper(directory, maxSize);
=======
  private static final int APP_VERSION = 1;
  private static final int VALUE_COUNT = 1;
  private static DiskLruCacheWrapper wrapper = null;

  private final SafeKeyGenerator safeKeyGenerator;
  private final File directory;
  private final int maxSize;
  private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
  private DiskLruCache diskLruCache;

  /**
   * Get a DiskCache in the given directory and size. If a disk cache has already been created with
   * a different directory and/or size, it will be returned instead and the new arguments will be
   * ignored.
   *
   * @param directory The directory for the disk cache
   * @param maxSize   The max size for the disk cache
   * @return The new disk cache with the given arguments, or the current cache if one already exists
   */
  public static synchronized DiskCache get(File directory, int maxSize) {
    // TODO calling twice with different arguments makes it return the cache for the same
    // directory, it's public!
    if (wrapper == null) {
      wrapper = new DiskLruCacheWrapper(directory, maxSize);
    }
    return wrapper;
  }

  protected DiskLruCacheWrapper(File directory, int maxSize) {
    this.directory = directory;
    this.maxSize = maxSize;
    this.safeKeyGenerator = new SafeKeyGenerator();
  }

  private synchronized DiskLruCache getDiskCache() throws IOException {
    if (diskLruCache == null) {
      diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
    }
    return diskLruCache;
  }

  @Override
  public File get(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, "Get: Obtained: " + safeKey + " for for Key: " + key);
    }
    File result = null;
    try {
      // It is possible that the there will be a put in between these two gets. If so that shouldn't
      // be a problem because we will always put the same value at the same key so our input streams
      // will still represent the same data.
      final DiskLruCache.Value value = getDiskCache().get(safeKey);
      if (value != null) {
        result = value.getFile(0);
      }
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to get from disk cache", e);
      }
    }
    return result;
  }

  @Override
  public void put(Key key, Writer writer) {
    // We want to make sure that puts block so that data is available when put completes. We may
    // actually not write any data if we find that data is written by the time we acquire the lock.
    writeLocker.acquire(key);
    try {
      String safeKey = safeKeyGenerator.getSafeKey(key);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
      }
      try {
        // We assume we only need to put once, so if data was written while we were trying to get
        // the lock, we can simply abort.
        DiskLruCache diskCache = getDiskCache();
        Value current = diskCache.get(safeKey);
        if (current != null) {
          return;


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;@Override    public synchronized void clear() ;@Override  public synchronized void clear() ;
    }

    @Override
    public synchronized void clear() {
        try {
            getDiskCache().delete();
            resetDiskCache();
        }  catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to clear disk cache", e);
            }
        }
    }
=======
      }
    } finally {
      writeLocker.release(key);
    }
  }

  @Override
  public void delete(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    try {
      getDiskCache().remove(safeKey);
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to delete from disk cache", e);
      }
    }
  }

  @Override
  public synchronized void clear() {
    try {
      getDiskCache().delete();
      resetDiskCache();
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to clear disk cache", e);
      }
    }
  }

  private synchronized void resetDiskCache() {
    diskLruCache = null;
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private static final int SEGMENT_START_POSITION ;private static final int SEGMENT_START_POSITION ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private static final byte[] EXIF_SEGMENT = new byte[] ;private static final byte[] EXIF_SEGMENT = new byte[] ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private static final int SEGMENT_LENGTH ;private static final int SEGMENT_LENGTH ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private static final int ORIENTATION_POSITION ;private static final int ORIENTATION_POSITION ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private final byte orientation;private final byte orientation;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;private int position;private int position;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;public ExifOrientationStream(InputStream in, int orientation) ;public ExifOrientationStream(InputStream in, int orientation) ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public boolean markSupported() ;@Override  public boolean markSupported() ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public void mark(int readlimit) ;@Override  public void mark(int readlimit) ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public int read() throws IOException ;@Override  public int read() throws IOException ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException ;@Override  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public long skip(long byteCount) throws IOException ;@Override  public long skip(long byteCount) throws IOException ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;@Override    public void reset() throws IOException ;@Override  public void reset() throws IOException ;
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;@Test    public void testAppliesHeadersInGlideUrl() throws Exception ;@Test  public void testAppliesHeadersInGlideUrl() throws Exception ;
    @Before
    public void setUp() throws IOException {
        requestQueue = Volley.newRequestQueue(Robolectric.application);
        mockWebServer = new MockWebServer();
        mockWebServer.play();
    }

    @After
    public void tearDown() throws IOException {
        mockWebServer.shutdown();
        requestQueue.stop();
    }

    @Test
    public void testReturnsInputStreamOnStatusOk() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
                .setBody(expected)
                .setResponseCode(200));
        DataFetcher<InputStream> fetcher = getFetcher();
        InputStream is = fetcher.loadData(Priority.HIGH);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect301s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(301)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect302s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(302)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesUpToFiveRedirects() throws Exception {
        int numRedirects = 4;
        String expected = "redirectedData";
        String redirectBase = "/redirect";
        for (int i = 0; i < numRedirects; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
        }
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200).setBody(expected));

        InputStream is = getFetcher().loadData(Priority.NORMAL);
        assertEquals(expected, TestUtil.isToString(is));

        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
        for (int i = 0; i < numRedirects; i++) {
            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
        }
    }

    @Test
    public void testThrowsIfRedirectLocationIsEmpty() throws Exception {
        for (int i = 0; i < 2; i++) {
            mockWebServer.enqueue(new MockResponse().setResponseCode(301));
        }

        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Didn't get expected IOException");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(VolleyError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
        }
    }

    @Test
    public void testThrowsAfterTooManyRedirects() throws Exception {
        for (int i = 0; i < 20; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
        }
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);
        }
    }


    @Test
    public void testThrowsIfStatusCodeIs500() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIs400() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testAppliesHeadersInGlideUrl() throws Exception {
      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
      String headerField = "field";
      String headerValue = "value";
      Map<String, String> headersMap = new HashMap<String, String>();
      headersMap.put(headerField, headerValue);
      Headers headers = mock(Headers.class);
      when(headers.getHeaders()).thenReturn(headersMap);

      getFetcher(headers).loadData(Priority.HIGH);

      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
    }

    private DataFetcher<InputStream> getFetcher() {
      return getFetcher(Headers.NONE);
    }

    private DataFetcher<InputStream> getFetcher(Headers headers) {
        URL url = mockWebServer.getUrl(DEFAULT_PATH);
        VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
            @Override
            public InputStream get() throws InterruptedException, ExecutionException {
                for (int i = 0; i < 251 && !isDone(); i++) {
                    Thread.sleep(10);
                    Robolectric.runUiThreadTasks();
                }
                if (!isDone()) {
                    fail("Failed to get response from Volley in time");
                }
                return super.get();
            }
        };
        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);
    }

    /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
    @Implements(SystemClock.class)
    public static class FakeSystemClock extends ShadowSystemClock {

        @Implementation
        public static long elapsedRealtime() {
            // The default is to return something using the main looper, which doesn't exist on Volley's threads.
            return System.currentTimeMillis();
        }
=======
  private MockWebServer mockWebServer;
  private RequestQueue requestQueue;
  private ArgumentCaptor<InputStream> streamCaptor;
  private CountDownLatch waitForResponseLatch;

  @Before
  public void setUp() throws IOException {
    MockitoAnnotations.initMocks(this);

    waitForResponseLatch = new CountDownLatch(1);
    doAnswer(new Answer<Void>() {
      @Override
      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
        waitForResponseLatch.countDown();
        return null;
      }
    }).when(callback).onDataReady(any(InputStream.class));
    requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);
    mockWebServer = new MockWebServer();
    mockWebServer.play();

    streamCaptor = ArgumentCaptor.forClass(InputStream.class);
  }

  @After
  public void tearDown() throws IOException {
    mockWebServer.shutdown();
    requestQueue.stop();
  }

  @Test
  public void testReturnsInputStreamOnStatusOk() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setBody(expected).setResponseCode(200));
    DataFetcher<InputStream> fetcher = getFetcher();
    fetcher.loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect301s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect302s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesUpToFiveRedirects() throws Exception {
    int numRedirects = 4;
    String expected = "redirectedData";
    String redirectBase = "/redirect";
    for (int i = 0; i < numRedirects; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
    }
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());

    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
    for (int i = 0; i < numRedirects; i++) {
      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
    }
  }

  @Test
  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {
    for (int i = 0; i < 2; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301));
    }

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullAfterTooManyRedirects() throws Exception {
    for (int i = 0; i < 20; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
    }
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs500() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs400() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testAppliesHeadersInGlideUrl() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    String headerField = "field";
    String headerValue = "value";
    Map<String, String> headersMap = new HashMap<String, String>();
    headersMap.put(headerField, headerValue);
    Headers headers = mock(Headers.class);
    when(headers.getHeaders()).thenReturn(headersMap);

    getFetcher(headers).loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();

    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
  }

  private DataFetcher<InputStream> getFetcher() {
    return getFetcher(Headers.NONE);
  }

  private DataFetcher<InputStream> getFetcher(Headers headers) {
    URL url = mockWebServer.getUrl(DEFAULT_PATH);
    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
  }

  /**
   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
   */
  @Implements(SystemClock.class)
  public static class FakeSystemClock extends ShadowSystemClock {

    @Implementation
    public static long elapsedRealtime() {
      // The default is to return something using the main looper, which doesn't exist on
      // Volley's threads.
      return System.currentTimeMillis();


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;private DataFetcher<InputStream> getFetcher(Headers headers) ;private DataFetcher<InputStream> getFetcher(Headers headers) ;
    @Before
    public void setUp() throws IOException {
        requestQueue = Volley.newRequestQueue(Robolectric.application);
        mockWebServer = new MockWebServer();
        mockWebServer.play();
    }

    @After
    public void tearDown() throws IOException {
        mockWebServer.shutdown();
        requestQueue.stop();
    }

    @Test
    public void testReturnsInputStreamOnStatusOk() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
                .setBody(expected)
                .setResponseCode(200));
        DataFetcher<InputStream> fetcher = getFetcher();
        InputStream is = fetcher.loadData(Priority.HIGH);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect301s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(301)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect302s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(302)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesUpToFiveRedirects() throws Exception {
        int numRedirects = 4;
        String expected = "redirectedData";
        String redirectBase = "/redirect";
        for (int i = 0; i < numRedirects; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
        }
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200).setBody(expected));

        InputStream is = getFetcher().loadData(Priority.NORMAL);
        assertEquals(expected, TestUtil.isToString(is));

        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
        for (int i = 0; i < numRedirects; i++) {
            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
        }
    }

    @Test
    public void testThrowsIfRedirectLocationIsEmpty() throws Exception {
        for (int i = 0; i < 2; i++) {
            mockWebServer.enqueue(new MockResponse().setResponseCode(301));
        }

        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Didn't get expected IOException");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(VolleyError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
        }
    }

    @Test
    public void testThrowsAfterTooManyRedirects() throws Exception {
        for (int i = 0; i < 20; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
        }
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);
        }
    }


    @Test
    public void testThrowsIfStatusCodeIs500() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIs400() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testAppliesHeadersInGlideUrl() throws Exception {
      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
      String headerField = "field";
      String headerValue = "value";
      Map<String, String> headersMap = new HashMap<String, String>();
      headersMap.put(headerField, headerValue);
      Headers headers = mock(Headers.class);
      when(headers.getHeaders()).thenReturn(headersMap);

      getFetcher(headers).loadData(Priority.HIGH);

      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
    }

    private DataFetcher<InputStream> getFetcher() {
      return getFetcher(Headers.NONE);
    }

    private DataFetcher<InputStream> getFetcher(Headers headers) {
        URL url = mockWebServer.getUrl(DEFAULT_PATH);
        VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
            @Override
            public InputStream get() throws InterruptedException, ExecutionException {
                for (int i = 0; i < 251 && !isDone(); i++) {
                    Thread.sleep(10);
                    Robolectric.runUiThreadTasks();
                }
                if (!isDone()) {
                    fail("Failed to get response from Volley in time");
                }
                return super.get();
            }
        };
        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);
    }

    /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
    @Implements(SystemClock.class)
    public static class FakeSystemClock extends ShadowSystemClock {

        @Implementation
        public static long elapsedRealtime() {
            // The default is to return something using the main looper, which doesn't exist on Volley's threads.
            return System.currentTimeMillis();
        }
=======
  private MockWebServer mockWebServer;
  private RequestQueue requestQueue;
  private ArgumentCaptor<InputStream> streamCaptor;
  private CountDownLatch waitForResponseLatch;

  @Before
  public void setUp() throws IOException {
    MockitoAnnotations.initMocks(this);

    waitForResponseLatch = new CountDownLatch(1);
    doAnswer(new Answer<Void>() {
      @Override
      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
        waitForResponseLatch.countDown();
        return null;
      }
    }).when(callback).onDataReady(any(InputStream.class));
    requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);
    mockWebServer = new MockWebServer();
    mockWebServer.play();

    streamCaptor = ArgumentCaptor.forClass(InputStream.class);
  }

  @After
  public void tearDown() throws IOException {
    mockWebServer.shutdown();
    requestQueue.stop();
  }

  @Test
  public void testReturnsInputStreamOnStatusOk() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setBody(expected).setResponseCode(200));
    DataFetcher<InputStream> fetcher = getFetcher();
    fetcher.loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect301s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect302s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesUpToFiveRedirects() throws Exception {
    int numRedirects = 4;
    String expected = "redirectedData";
    String redirectBase = "/redirect";
    for (int i = 0; i < numRedirects; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
    }
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());

    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
    for (int i = 0; i < numRedirects; i++) {
      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
    }
  }

  @Test
  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {
    for (int i = 0; i < 2; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301));
    }

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullAfterTooManyRedirects() throws Exception {
    for (int i = 0; i < 20; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
    }
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs500() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs400() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testAppliesHeadersInGlideUrl() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    String headerField = "field";
    String headerValue = "value";
    Map<String, String> headersMap = new HashMap<String, String>();
    headersMap.put(headerField, headerValue);
    Headers headers = mock(Headers.class);
    when(headers.getHeaders()).thenReturn(headersMap);

    getFetcher(headers).loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();

    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
  }

  private DataFetcher<InputStream> getFetcher() {
    return getFetcher(Headers.NONE);
  }

  private DataFetcher<InputStream> getFetcher(Headers headers) {
    URL url = mockWebServer.getUrl(DEFAULT_PATH);
    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
  }

  /**
   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
   */
  @Implements(SystemClock.class)
  public static class FakeSystemClock extends ShadowSystemClock {

    @Implementation
    public static long elapsedRealtime() {
      // The default is to return something using the main looper, which doesn't exist on
      // Volley's threads.
      return System.currentTimeMillis();


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java;@Override    public void clear() ;@Override  public void clear() ;
    @Override
    public File get(Key key) {
        // no op, default for overriders
        return null;
    }

    @Override
    public void put(Key key, Writer writer) {
        // no op, default for overriders
    }

    @Override
    public void delete(Key key) {
        // no op, default for overriders
    }

    @Override
    public void clear() {
        // no op, default for overriders
    }
=======
  @Override
  public File get(Key key) {
    // no op, default for overriders
    return null;
  }

  @Override
  public void put(Key key, Writer writer) {
    // no op, default for overriders
  }

  @Override
  public void delete(Key key) {
    // no op, default for overriders
  }

  @Override
  public void clear() {
      // no op, default for overriders
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;@RunWith(RobolectricTestRunner.class)@Config(manifest ;@RunWith(RobolectricTestRunner.class)@Config(manifest ;
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}=======
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private LruByteArrayPool byteArrayPool;

  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;private InputStream openOrientationExample(boolean isLandscape, int item) ;private InputStream openOrientationExample(boolean isLandscape, int item) ;
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}=======
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private LruByteArrayPool byteArrayPool;

  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;@Test  public void testIncludesGivenExifOrientation() throws IOException ;@Test  public void testIncludesGivenExifOrientation() throws IOException ;
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}=======
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private LruByteArrayPool byteArrayPool;

  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }


/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873.revisions;/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java;void clear();void clear();
    /**
     * Write to a key in the cache. {@link Writer} is used so that the cache implementation can perform actions after
     * the write finishes, like commit (via atomic file rename).
     *
     * @param key The key to write to.
     * @param writer An interface that will write data given an OutputStream for the key.
     */
    void put(Key key, Writer writer);

    /**
     * Remove the key and value from the cache.
     *
     * @param key The key to remove.
     */
    void delete(Key key);

    /**
     * Clear the cache.
     */
    void clear();
=======
  /**
   * Get the cache for the value at the given key.
   *
   * <p> Note - This is potentially dangerous, someone may write a new value to the file at any
   * point in time and we won't know about it. </p>
   *
   * @param key The key in the cache.
   * @return An InputStream representing the data at key at the time get is called.
   */
  File get(Key key);

  /**
   * Write to a key in the cache. {@link Writer} is used so that the cache implementation can
   * perform actions after the write finishes, like commit (via atomic file rename).
   *
   * @param key    The key to write to.
   * @param writer An interface that will write data given an OutputStream for the key.
   */
  void put(Key key, Writer writer);

  /**
   * Remove the key and value from the cache.
   *
   * @param key The key to remove.
   */
  void delete(Key key);

  /**
   * Clear the cache.
   */
  void clear();


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java; enum Status ; enum Status ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private String subkey;private String subkey;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private String origin;private String origin;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private Map<String, String> channels;private Map<String, String> channels;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private String channelA;private String channelA;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private String channelB;private String channelB;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private JSONObject steps;private JSONObject steps;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private JSONArray events;private JSONArray events;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private Status result;private Status result;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private int id;private int id;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private String description;private String description;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private boolean ssl;private boolean ssl;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;private int currentStep ;private int currentStep ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) ;Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;void updateStatus() ;void updateStatus() ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;void printResult () ;void printResult () ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;void run() ;void run() ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;static List<Test> testsList ;static List<Test> testsList ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;static String client ;static String client ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1.revisions;/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;public static void main(String[] args) ;public static void main(String[] args) ;
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	


/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private static final int STATE_READING_HEADER ;private static final int STATE_READING_HEADER ;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private static final int HEADER_SIZE ;private static final int HEADER_SIZE ;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private int state;private int state;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private int bytesRead;private int bytesRead;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private boolean hasOutputFormat;private boolean hasOutputFormat;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private long frameDurationUs;private long frameDurationUs;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private int sampleSize;private int sampleSize;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;private long timeUs;private long timeUs;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;public MpaReader(TrackOutput output) ;public MpaReader(TrackOutput output) ;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;@Override    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) ;@Override  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) ;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844.revisions;/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;@Override    public void packetFinished() ;@Override  public void packetFinished() ;
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;private final Paint playedPaint;private final Paint playedPaint;
  private final Paint playedPaint;
=======
  private final Paint playedPaint;
  private final Paint scrubberPaint;


/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;private final Paint unplayedPaint;private final Paint unplayedPaint;
  private final Paint unplayedPaint;
  private final Paint adMarkerPaint;
  private final Paint playedAdMarkerPaint;
  private final Paint scrubberPaint;
=======
  private final Paint unplayedPaint;
  private final Paint adMarkerPaint;


/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;private static int getDefaultScrubberColor(int playedColor) ;private static int getDefaultScrubberColor(int playedColor) ;
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
  }

=======
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;private static int getDefaultUnplayedColor(int playedColor) ;private static int getDefaultUnplayedColor(int playedColor) ;
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
  }

=======
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;private static int getDefaultBufferedColor(int playedColor) ;private static int getDefaultBufferedColor(int playedColor) ;
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
  }

=======
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static final String TAG ;private static final String TAG ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static final int EGL_PROTECTED_CONTENT_EXT ;private static final int EGL_PROTECTED_CONTENT_EXT ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;public final boolean secure;public final boolean secure;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private final DummySurfaceThread thread;private final DummySurfaceThread thread;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private boolean threadReleased;private boolean threadReleased;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) ;private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;@Override  public void release() ;@Override  public void release() ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static void assertApiLevel17OrHigher() ;private static void assertApiLevel17OrHigher() ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java; private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,   Callback ; private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,   Callback ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static final int MSG_INIT ;private static final int MSG_INIT ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static final int MSG_UPDATE_TEXTURE ;private static final int MSG_UPDATE_TEXTURE ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private static final int MSG_RELEASE ;private static final int MSG_RELEASE ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private final int[] textureIdHolder;private final int[] textureIdHolder;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private Handler handler;private Handler handler;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private SurfaceTexture surfaceTexture;private SurfaceTexture surfaceTexture;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private Error initError;private Error initError;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private RuntimeException initException;private RuntimeException initException;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private DummySurface surface;private DummySurface surface;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;public DummySurfaceThread() ;public DummySurfaceThread() ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;public DummySurface init(boolean secure) ;public DummySurface init(boolean secure) ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;@Override    public void onFrameAvailable(SurfaceTexture surfaceTexture) ;@Override    public void onFrameAvailable(SurfaceTexture surfaceTexture) ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;@Override    public boolean handleMessage(Message msg) ;@Override    public boolean handleMessage(Message msg) ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private void initInternal(boolean secure) ;private void initInternal(boolean secure) ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;private void releaseInternal() ;private void releaseInternal() ;
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }



/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) ;public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) ;
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory)
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**
=======
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory).
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**


/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14.revisions;/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java;public static byte[] readToEnd(DataSource dataSource) throws IOException ;public static byte[] readToEnd(DataSource dataSource) throws IOException ;
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
=======
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
      }
    }
    return Arrays.copyOf(data, position);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs) throws IOException, InterruptedException {
    return consumeTestData(extractor, input, timeUs, false);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs, boolean retryFromStartIfLive) throws IOException, InterruptedException {
    FakeExtractorOutput output = new FakeExtractorOutput();
    extractor.init(output);
    consumeTestData(extractor, input, timeUs, output, retryFromStartIfLive);
    return output;
  }

  private static void consumeTestData(Extractor extractor, FakeExtractorInput input, long timeUs,
      FakeExtractorOutput output, boolean retryFromStartIfLive)
      throws IOException, InterruptedException {
    extractor.seek(input.getPosition(), timeUs);
    PositionHolder seekPositionHolder = new PositionHolder();
    int readResult = Extractor.RESULT_CONTINUE;
    while (readResult != Extractor.RESULT_END_OF_INPUT) {
      try {
        // Extractor.read should not read seekPositionHolder.position. Set it to a value that's
        // likely to cause test failure if a read does occur.
        seekPositionHolder.position = Long.MIN_VALUE;
        readResult = extractor.read(input, seekPositionHolder);
        if (readResult == Extractor.RESULT_SEEK) {
          long seekPosition = seekPositionHolder.position;
          Assertions.checkState(0 <= seekPosition && seekPosition <= Integer.MAX_VALUE);
          input.setPosition((int) seekPosition);
        }
      } catch (SimulatedIOException e) {
        if (!retryFromStartIfLive) {
          continue;
        }
        boolean isOnDemand = input.getLength() != C.LENGTH_UNSET
            || (output.seekMap != null && output.seekMap.getDurationUs() != C.TIME_UNSET);
        if (isOnDemand) {
          continue;
        }
        input.setPosition(0);
        for (int i = 0; i < output.numberOfTracks; i++) {
          output.trackOutputs.valueAt(i).clear();
        }
        extractor.seek(0, 0);


