file;linedbasedConf
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======
    private View searchLoading;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======
        searchLoading = findViewById(R.id.search_loading);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======
        searchLoading.setVisibility(View.VISIBLE);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======

            @Override
            public void onSearchFailed(Exception e) {
                if (currentSearch != searchCount) return;
                e.printStackTrace();

                Log.d("SEARCH: failed :(");
                searching.setVisibility(View.VISIBLE);
                searchLoading.setVisibility(View.INVISIBLE);
                searchTerm.setText(getString(R.string.search_failed, searchString));
            }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/api/Api.java;<<<<<<< MINE
=======
        public void onSearchFailed(Exception e);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/api/Api.java;<<<<<<< MINE
        Log.d("API: searching");
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/samples/flickr/src/com/bumptech/flickr/api/Api.java;<<<<<<< MINE
                error.printStackTrace();
=======
                cb.onSearchFailed(error);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
 * starting point and example.
 *
 * Note - This class is not thread safe.
=======
 * starting point and example.
 *
 * <p>
 * Note - This class is not thread safe.
 * </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
=======
    /**
     * Get the singleton.
     *
     * @return the singleton
     */
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
     * @param requestQueue
=======
     * @param requestQueue The {@link RequestQueue} to set
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
     * Note - If an {@link ImageManager} has not yet been set via
     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless
     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via
     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}
     *
     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via
     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you
     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     * @see #setRequestQueue(com.android.volley.RequestQueue)
     * @see #isImageManagerSet()
     * @see #isRequestQueueSet()
     *
=======
     * <p>
     * Note - If an {@link ImageManager} has not yet been set via
     * {@link #setImageManager(ImageManager) setImageManager}, one will be created during this call unless
     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)
     * getRequestQueue} via {@link Glide.Request#resizeWith(ImageLoader) resizeWith}
     * </p>
     *
     * <p>
     * Note - If the model is a {@link URL} and an {@link com.android.volley.RequestQueue} has not yet been set via
     * {@link #setRequestQueue(com.android.volley.RequestQueue) setRequestQueue}, one will be created during this call
     * unless you specify a {@link ModelLoader} via {@link Glide.Request#with(ModelLoader) with}.
     * </p>
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     * @see #setRequestQueue(com.android.volley.RequestQueue)
     * @see #isImageManagerSet()
     * @see #isRequestQueueSet()
     *
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
=======
     *
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
         * Set the {@link ModelLoader} for the model. For URL models, defaults to {@link UrlLoader},
         * for File models, defaults to {@link FileLoader}.
=======
         * Set the {@link ModelLoader} for the model.
         *
         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or
         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,
         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}
         * defaults to {@link FileLoader}.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
         * the given model
=======
         * the given model. This must be called on the main thread.
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/AckManager.java;<<<<<<< MINE
/**
 * Copyright 2012 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.corundumstudio.socketio;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import com.corundumstudio.socketio.parser.Packet;
import com.corundumstudio.socketio.scheduler.CancelableScheduler;
import com.corundumstudio.socketio.scheduler.SchedulerKey;
import com.corundumstudio.socketio.scheduler.SchedulerKey.Type;
import com.corundumstudio.socketio.transport.BaseClient;
import com.corundumstudio.socketio.utils.ConcurrentHashSet;

public class AckManager implements Disconnectable {

    private final AtomicLong ackIndex = new AtomicLong();
    private final Map<Long, AckCallback> ackCallbacks = new ConcurrentHashMap<Long, AckCallback>();
    private final ConcurrentMap<UUID, Set<Long>> clientCallbackIds = new ConcurrentHashMap<UUID, Set<Long>>();

    private final CancelableScheduler scheduler;

    public AckManager(CancelableScheduler scheduler) {
        super();
        this.scheduler = scheduler;
    }

    public void onAck(SocketIOClient client, Packet packet) {
        SchedulerKey key = new SchedulerKey(Type.ACK_TIMEOUT, client.getSessionId());
        scheduler.cancel(key);
        AckCallback callback = removeCallback(client.getSessionId(), packet.getAckId());
        if (callback != null) {
            callback.onSuccess();
        }
    }

    private AckCallback removeCallback(UUID sessionId, long index) {
        AckCallback callback = ackCallbacks.remove(index);
        if (callback != null) {
            Set<Long> callbackIds = clientCallbackIds.get(sessionId);
            if (callbackIds != null) {
                callbackIds.remove(index);
            }
        }
        return callback;
    }

    public long registerAck(UUID sessionId, final AckCallback callback) {
        Set<Long> callbackIds = clientCallbackIds.get(sessionId);
        if (callbackIds == null) {
            callbackIds = new ConcurrentHashSet<Long>();
            Set<Long> oldCallbackIds = clientCallbackIds.putIfAbsent(sessionId, callbackIds);
            if (oldCallbackIds != null) {
                callbackIds = oldCallbackIds;
            }
        }
        long index = ackIndex.incrementAndGet();
        callbackIds.add(index);
        ackCallbacks.put(index, callback);

        scheduleTimeout(index, sessionId, callback);

        return index;
    }

    private void scheduleTimeout(final long index, final UUID sessionId, final AckCallback callback) {
        if (callback.getTimeout() == -1) {
            return;
        }
        SchedulerKey key = new SchedulerKey(Type.ACK_TIMEOUT, sessionId);
        scheduler.schedule(key, new Runnable() {
            @Override
            public void run() {
                removeCallback(sessionId, index);
                callback.onTimeout();
            }
        }, callback.getTimeout(), TimeUnit.SECONDS);
    }

    @Override
    public void onDisconnect(BaseClient client) {
        Set<Long> callbackIds = clientCallbackIds.remove(client.getSessionId());
        if (callbackIds != null) {
            ackCallbacks.keySet().removeAll(callbackIds);
        }
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/AuthorizeHandler.java;<<<<<<< MINE
/**
 * Copyright 2012 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.corundumstudio.socketio;

import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelFutureListener;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpHeaders;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.netty.handler.codec.http.QueryStringDecoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.corundumstudio.socketio.messages.AuthorizeMessage;
import com.corundumstudio.socketio.namespace.Namespace;
import com.corundumstudio.socketio.namespace.NamespacesHub;
import com.corundumstudio.socketio.parser.Packet;
import com.corundumstudio.socketio.parser.PacketType;
import com.corundumstudio.socketio.scheduler.CancelableScheduler;
import com.corundumstudio.socketio.scheduler.SchedulerKey;
import com.corundumstudio.socketio.scheduler.SchedulerKey.Type;
import com.corundumstudio.socketio.transport.BaseClient;
import com.corundumstudio.socketio.utils.ConcurrentHashSet;

@Sharable
public class AuthorizeHandler extends SimpleChannelUpstreamHandler implements Disconnectable {

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final CancelableScheduler disconnectScheduler;
    private final Set<UUID> authorizedSessionIds = new ConcurrentHashSet<UUID>();

    private final String connectPath;
    private final Configuration configuration;
    private final NamespacesHub namespacesHub;

    public AuthorizeHandler(String connectPath, CancelableScheduler scheduler, Configuration configuration, NamespacesHub namespacesHub) {
        super();
        this.connectPath = connectPath;
        this.configuration = configuration;
        this.disconnectScheduler = scheduler;
        this.namespacesHub = namespacesHub;
    }

    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
        Object msg = e.getMessage();
        if (msg instanceof HttpRequest) {
            HttpRequest req = (HttpRequest) msg;
            Channel channel = ctx.getChannel();
            QueryStringDecoder queryDecoder = new QueryStringDecoder(req.getUri());
            if (!configuration.isAllowCustomRequests()
                    && !queryDecoder.getPath().startsWith(connectPath)) {
                HttpResponse res = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.BAD_REQUEST);
                ChannelFuture f = channel.write(res);
                f.addListener(ChannelFutureListener.CLOSE);
                return;
            }
            if (queryDecoder.getPath().equals(connectPath)) {
                authorize(channel, req, queryDecoder.getParameters());
                return;
            }
        }
        ctx.sendUpstream(e);
    }

    private void authorize(Channel channel, HttpRequest req, Map<String, List<String>> params)
            throws IOException {
        final UUID sessionId = UUID.randomUUID();
        authorizedSessionIds.add(sessionId);

        scheduleDisconnect(channel, sessionId);

        String transports = "websocket,xhr-polling";
        String heartbeatTimeoutVal = String.valueOf(configuration.getHeartbeatTimeout());
        if (!configuration.isHeartbeatsEnabled()) {
            heartbeatTimeoutVal = "";
        }

        String msg = sessionId + ":" + heartbeatTimeoutVal + ":" + configuration.getCloseTimeout() + ":" + transports;

        List<String> jsonpParams = params.get("jsonp");
        String jsonpParam = null;
        if (jsonpParams != null) {
            jsonpParam = jsonpParams.get(0);
        }
        String origin = req.getHeader(HttpHeaders.Names.ORIGIN);
        channel.write(new AuthorizeMessage(msg, jsonpParam, origin, sessionId));
        log.debug("New sessionId: {} authorized", sessionId);
    }

    private void scheduleDisconnect(Channel channel, final UUID sessionId) {
        ChannelFuture future = channel.getCloseFuture();
        future.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                SchedulerKey key = new SchedulerKey(Type.AUTHORIZE, sessionId);
                disconnectScheduler.schedule(key, new Runnable() {
                    @Override
                    public void run() {
                        authorizedSessionIds.remove(sessionId);
                        log.debug("Authorized sessionId: {} removed due to connection timeout", sessionId);
                    }
                }, configuration.getCloseTimeout(), TimeUnit.SECONDS);
            }
        });
    }

    public boolean isSessionAuthorized(UUID sessionId) {
        return authorizedSessionIds.contains(sessionId);
    }

    public void connect(BaseClient client) {
        SchedulerKey key = new SchedulerKey(Type.AUTHORIZE, client.getSessionId());
        disconnectScheduler.cancel(key);
        client.send(new Packet(PacketType.CONNECT));

        Namespace ns = namespacesHub.get(Namespace.DEFAULT_NAME);
        SocketIOClient nsClient = client.getChildClient(ns);
        namespacesHub.get(ns.getName()).onConnect(nsClient);
    }

    @Override
    public void onDisconnect(BaseClient client) {
        authorizedSessionIds.remove(client.getSessionId());
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/namespace/Namespace.java;<<<<<<< MINE
import com.corundumstudio.socketio.transport.NamespaceClient;
import com.corundumstudio.socketio.utils.ConcurrentHashSet;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_fa8e803_d216308/rev_fa8e803-d216308/library/tests/src/com/bumptech/glide/GlideTest.java;<<<<<<< MINE
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
=======
import com.bumptech.glide.presenter.target.Target;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_fa8e803_d216308/rev_fa8e803-d216308/library/tests/src/com/bumptech/glide/GlideTest.java;<<<<<<< MINE
    public void testClearingTagReplacesPresenter() {
        Glide.load("a").into(imageView);
        assertNotNull(imageView.getTag());
        imageView.setTag(null);
        Glide.load("b").into(imageView);
    }

    public void testObtainAndOfferToBitmapPool() {
        Bitmap small = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
        Bitmap large = Bitmap.createBitmap(512, 512, Bitmap.Config.RGB_565);
        BitmapPool bitmapPool = Glide.get().getImageManager(getInstrumentation().getContext()).getBitmapPool();
        bitmapPool.put(small);
        bitmapPool.put(large);

        assertEquals(small, bitmapPool.get(small.getWidth(), small.getHeight(), small.getConfig()));
        assertEquals(large, bitmapPool.get(large.getWidth(), large.getHeight(), large.getConfig()));
    }

=======
    public void testDifferentRequestListenersReplacesPresenter() {
        assertDifferentPresenters(
                Glide.load("a").listener(new Glide.RequestListener<String>() {

                    @Override
                    public void onException(Exception e, String model, Target target) {

                    }

                    @Override
                    public void onImageReady(String model, Target target) {
                    }
                }),
                Glide.load("a").listener(new Glide.RequestListener<String>() {
                    @Override
                    public void onException(Exception e, String model, Target target) {
                    }

                    @Override
                    public void onImageReady(String model, Target target) {
                    }
                })
        );
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_fa8e803_d216308/rev_fa8e803-d216308/library/tests/src/com/bumptech/glide/GlideTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_cb48509_620f041/rev_cb48509-620f041/src/main/java/com/corundumstudio/socketio/parser/JacksonJsonSupport.java;<<<<<<< MINE
import com.corundumstudio.socketio.utils.ConcurrentHashSet;
=======
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.node.ObjectNode;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
=======
import android.content.Context;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
import android.os.Handler;
=======
import android.util.Log;
import android.view.Display;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
=======
import android.view.ViewTreeObserver;
import android.view.WindowManager;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
public class ImageViewTarget extends ViewTarget<ImageView> {
    private final ImageView view;

    public ImageViewTarget(ImageView view) {
        super(view);
        this.view = view;
=======
public class ImageViewTarget implements Target {
    private static final String TAG = "ImageViewTarget";
    private final ImageView imageView;
    private final SizeDeterminer sizeDeterminer;
    private ImagePresenter imagePresenter;

    public ImageViewTarget(ImageView imageView) {
        this.imageView = imageView;
        this.sizeDeterminer = new SizeDeterminer(imageView);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
        view.setImageDrawable(placeholder);
=======
        imageView.setImageDrawable(placeholder);
    }

    @Override
    public void getSize(SizeReadyCallback cb) {
        sizeDeterminer.getSize(cb);
    }

    @Override
    public void startAnimation(Animation animation) {
        imageView.clearAnimation();

        imageView.startAnimation(animation);
    }

    @Override
    public void setImagePresenter(ImagePresenter imagePresenter) {
        this.imagePresenter = imagePresenter;
    }

    @Override
    public ImagePresenter getImagePresenter() {
        return imagePresenter;
    }

    @Override
    public int hashCode() {
        return imageView.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        } else if (!(o instanceof ImageViewTarget)) {
            return false;
        }
        ImageViewTarget other = (ImageViewTarget) o;
        return imageView.equals(other.imageView);
    }

    private static class SizeDeterminer {
        private final View view;
        private SizeReadyCallback cb;
        private SizeDeterminerLayoutListener layoutListener;

        private void checkCurrentDimens() {
            if (cb == null) return;

            boolean calledCallback = true;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else {
                calledCallback = false;
            }

            if (calledCallback) {
                cb = null;
                // Keep a reference to the layout listener and remove it here
                // rather than having the observer remove itself because the observer
                // we add the listener to will be almost immediately merged into
                // another observer and will therefore never be alive. If we instead
                // keep a reference to the listener and remove it here, we get the
                // current view tree observer and should succeed.
                ViewTreeObserver observer = view.getViewTreeObserver();
                if (observer.isAlive()) {
                    observer.removeGlobalOnLayoutListener(layoutListener);
                }
            }
        }

        public SizeDeterminer(View view) {
            this.view = view;
        }

        public void getSize(SizeReadyCallback cb) {
            this.cb = null;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else if (isUsingWrapContent()) {
                WindowManager windowManager =
                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
                Display display = windowManager.getDefaultDisplay();
                final int width = display.getWidth();
                final int height = display.getHeight();
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen" +
                            " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height " +
                            " for better performance.");
                }
                cb.onSizeReady(display.getWidth(), display.getHeight());
            } else {
                this.cb = cb;
                final ViewTreeObserver observer = view.getViewTreeObserver();
                layoutListener = new SizeDeterminerLayoutListener(this);
                observer.addOnGlobalLayoutListener(layoutListener);
            }
        }

        private boolean isViewSizeValid() {
            return view.getWidth() > 0 && view.getHeight() > 0;
        }

        private boolean isUsingWrapContent() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width == LayoutParams.WRAP_CONTENT
                    || layoutParams.height == LayoutParams.WRAP_CONTENT);
        }

        private boolean isLayoutParamsSizeValid() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width > 0 && layoutParams.height > 0);
        }

        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnGlobalLayoutListener {
            private final WeakReference<SizeDeterminer> sizeDeterminerRef;

            public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
                sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
            }

            @Override
            public void onGlobalLayout() {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
                }
                SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
                if (sizeDeterminer != null) {
                    sizeDeterminer.checkCurrentDimens();
                }
            }
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
=======
/*
 * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
 */
package com.bumptech.glide.resize.load;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.media.ExifInterface;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.resize.RecyclableBufferedInputStream;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;

import java.io.InputStream;
import java.util.LinkedList;
import java.util.Queue;

/**
 * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
 */
public class ImageResizer {
    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;

    private static final String TAG = "ImageResizer";
    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
    private final BitmapPool bitmapPool;

    private final BitmapFactory.Options defaultOptions;

    @TargetApi(11)
    public static BitmapFactory.Options getDefaultOptions() {
       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
       decodeBitmapOptions.inDither = false;
       decodeBitmapOptions.inScaled = false;
       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
       decodeBitmapOptions.inSampleSize = 1;
       if (CAN_RECYCLE)  {
           decodeBitmapOptions.inMutable = true;
       }
       return decodeBitmapOptions;
    }

    /**
     * Creates a new resizer that will not recycle Bitmaps
     */
    @SuppressWarnings("unused")
    public ImageResizer() {
        this(null, null);
    }

    @SuppressWarnings("unused")
    public ImageResizer(BitmapPool bitmapPool) {
        this(bitmapPool, null);
    }

    @SuppressWarnings("unused")
    @Deprecated
    public ImageResizer(BitmapFactory.Options options) {
        this(null, options);
    }

    /**
     * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
     *
     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
     */
    @Deprecated
    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
        if (bitmapPool == null) {
            this.bitmapPool = new BitmapPoolAdapter();
        } else {
            this.bitmapPool = bitmapPool;
        }

        if (defaultOptions == null) {
            this.defaultOptions = getDefaultOptions();
        } else {
            this.defaultOptions = defaultOptions;
        }
    }

    public Bitmap load(InputStream is) {
        return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight) {
        return load(is, outWidth, outHeight, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
        return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler) {
        return load(is, outWidth, outHeight, downsampler, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
        byte[] tempBytesForBis = getTempBytes();
        byte[] tempBytesForOptions = getTempBytes();

        BitmapFactory.Options options = getOptions();
        options.inTempStorage = tempBytesForOptions;

        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);

        final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
        final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);

        if (initial != result && !bitmapPool.put(initial)) {
            initial.recycle();
        }

        releaseTempBytes(tempBytesForBis);
        releaseTempBytes(tempBytesForOptions);

        return result;
    }

    private BitmapFactory.Options getOptions() {
        BitmapFactory.Options result = new BitmapFactory.Options();
        copyOptions(defaultOptions, result);
        return result;
    }

    private byte[] getTempBytes() {
        byte[] result;
        synchronized (tempQueue) {
            result = tempQueue.poll();
        }
        if (result == null) {
            result = new byte[TEMP_BYTES_SIZE];
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Created temp bytes");
            }
        }
        return result;
    }

    private void releaseTempBytes(byte[] bytes) {
        synchronized (tempQueue) {
            tempQueue.offer(bytes);
        }
    }

    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
        if (Build.VERSION.SDK_INT >= 11) {
            copyOptionsHoneycomb(from, to);
        } else if (Build.VERSION.SDK_INT >= 10) {
            copyOptionsGingerbreadMr1(from, to);
        } else {
            copyOptionsFroyo(from, to);
        }
    }

    @TargetApi(11)
    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsGingerbreadMr1(from, to);
        to.inMutable = from.inMutable;
    }

    @TargetApi(10)
    private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsFroyo(from, to);
        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
    }

    private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
        to.inDensity = from.inDensity;
        to.inDither = from.inDither;
        to.inInputShareable = from.inInputShareable;
        to.inPreferredConfig = from.inPreferredConfig;
        to.inPurgeable = from.inPurgeable;
        to.inSampleSize = from.inSampleSize;
        to.inScaled = from.inScaled;
        to.inScreenDensity = from.inScreenDensity;
        to.inTargetDensity = from.inTargetDensity;
    }

    /**
     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
     * as well.
     *
     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
     *                 into
     * @param toCrop The Bitmap to resize
     * @param width The width of the final Bitmap
     * @param height The height of the final Bitmap
     * @return The resized Bitmap (will be recycled if recycled is not null)
     */
    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
        if (toCrop == null) {
            return null;
        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
            return toCrop;
        }
        //from ImageView/Bitmap.createScaledBitmap
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
        final float scale;
        float dx = 0, dy = 0;
        Matrix m = new Matrix();
        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
            scale = (float) height / (float) toCrop.getHeight();
            dx = (width - toCrop.getWidth() * scale) * 0.5f;
        } else {
            scale = (float) width / (float) toCrop.getWidth();
            dy = (height - toCrop.getHeight() * scale) * 0.5f;
        }

        m.setScale(scale, scale);
        m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
        final Bitmap result;
        if (recycled != null) {
            result = recycled;
        } else {
            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
        }
        Canvas canvas = new Canvas(result);
        Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toCrop, m, paint);
        return result;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its width
     * matches the given width
     *
     * @param toShrink The Bitmap to shrink
     * @param width The width of the final Bitmap
     * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
     */
    public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
        Bitmap shrunk = toShrink;
        float widthPercent = ((float) width/toShrink.getWidth());
        if (widthPercent != 1) {
            int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
            shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its height
     * matches the given height
     *
     * @param toShrink The Bitmap to shrink
     * @param height The height of the final Bitmap
     * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
     *          height
     */
    public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
        Bitmap shrunk = toShrink;
        float heightPercent = ((float) height/toShrink.getHeight());
        if (heightPercent != 1) {
            int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
            shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
     * the original proportions
     *
     * @param toFit The Bitmap to shrink
     * @param width The width the final image will fit within
     * @param height The height the final image will fit within
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    @Deprecated
    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
        if (toFit == null) return null;

        if (height > width){
            return shrinkToWidth(toFit, width);
        } else {
            return shrinkToHeight(toFit, height);
        }
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain
     * the original proportions.
     *
     * @param toFit The Bitmap to shrink.
     * @param pool The BitmapPool to try to reuse a bitmap from.
     * @param width The width the final image will fit within.
     * @param height The height the final image will fit within.
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
         final float shrinkPercentage;
        final int targetWidth;
        final int targetHeight;
        if (height > width) {
            shrinkPercentage = width / (float) toFit.getWidth();
            targetWidth = width;
            targetHeight = Math.round(shrinkPercentage * toFit.getHeight());
        } else {
            shrinkPercentage = height / (float) toFit.getHeight();
            targetWidth = Math.round(shrinkPercentage * toFit.getWidth());
            targetHeight = height;
        }

        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
        if (toReuse == null) {
            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
        }
        Canvas canvas = new Canvas(toReuse);
        Matrix matrix = new Matrix();
        matrix.setScale(shrinkPercentage, shrinkPercentage);
        Paint paint = new Paint(ImageResizer.PAINT_FLAGS);
        canvas.drawBitmap(toFit, matrix, paint);

        return toReuse;
    }


    /**
     * Returns a matrix with rotation set based on Exif orientation tag.
     * If the orientation is undefined or 0 null is returned.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @return  A rotation in degrees based on exif orientation
     */
    public static int getOrientation(String pathToOriginal) {
        int degreesToRotate = 0;
        try{
            ExifInterface exif = new ExifInterface(pathToOriginal);
            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
                degreesToRotate = 90;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
                degreesToRotate = 180;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
                degreesToRotate = 270;
            }
        } catch (Exception e){
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
            }
        }
        return degreesToRotate;
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @param imageToOrient Image Bitmap to orient.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    @SuppressWarnings("unused")
    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
        int degreesToRotate = getOrientation(pathToOriginal);
        return rotateImage(imageToOrient, degreesToRotate);
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param imageToOrient Image Bitmap to orient.
     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
        try{
            if(degreesToRotate != 0) {
                Matrix matrix = new Matrix();
                matrix.setRotate(degreesToRotate);
                imageToOrient = Bitmap.createBitmap(
                        imageToOrient,
                        0,
                        0,
                        imageToOrient.getWidth(),
                        imageToOrient.getHeight(),
                        matrix,
                        true);
            }
        } catch (Exception e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception when trying to orient image", e);
            }
            e.printStackTrace();
        }
        return imageToOrient;
    }

    /**
     * Get the # of degrees an image must be rotated to match the given exif orientation.
     *
     * @param exifOrientation The exif orientation [1-8]
     * @return the number of degrees to rotate
     */
    public static int getExifOrientationDegrees(int exifOrientation) {
        final int degreesToRotate;
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_TRANSPOSE:
            case ExifInterface.ORIENTATION_ROTATE_90:
                degreesToRotate = 90;
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                degreesToRotate = 180;
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
            case ExifInterface.ORIENTATION_ROTATE_270:
                degreesToRotate = 270;
                break;
            default:
                degreesToRotate = 0;

        }
        return degreesToRotate;
    }

    /**
     * Rotate and/or flip the image to match the given exif orientation
     *
     * @param toOrient The bitmap to rotate/flip
     * @param pool A pool that may or may not contain an image of the necessary dimensions
     * @param exifOrientation the exif orientation [1-8]
     * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary
     */
    public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
        final Matrix matrix = new Matrix();
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                matrix.setScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
                matrix.setRotate(180);
                break;
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                matrix.setRotate(180);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_TRANSPOSE:
                matrix.setRotate(90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_90:
                matrix.setRotate(90);
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
                matrix.setRotate(-90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_270:
                matrix.setRotate(-90);
                break;
            default: //case ExifInterface.ORIENTATION_NORMAL
                return toOrient;
        }

        // From Bitmap.createBitmap.
        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
        matrix.mapRect(newRect);

        final int newWidth = Math.round(newRect.width());
        final int newHeight = Math.round(newRect.height());

        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
        if (result == null) {
            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
        }

        matrix.postTranslate(-newRect.left, -newRect.top);

        final Canvas canvas = new Canvas(result);
        final Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toOrient, matrix, paint);

        return result;
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Transformation.java;<<<<<<< MINE
            return TransformationUtils.centerCrop(pool.get(outWidth, outHeight, bitmap.getConfig()), bitmap, outWidth, outHeight);
=======
            final Bitmap toRuse = pool.get(outWidth, outHeight, bitmap.getConfig());
            return ImageResizer.centerCrop(toRuse, bitmap, outWidth, outHeight);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Transformation.java;<<<<<<< MINE
            return TransformationUtils.fitInSpace(bitmap, outWidth, outHeight);
=======

            return ImageResizer.fitCenter(bitmap, pool, outWidth, outHeight);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Downsampler.java;<<<<<<< MINE
        final Bitmap rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);
=======
        if (downsampled == null) {
            throw new IllegalArgumentException("Unable to decode image sample size: " + sampleSize + " inWidth: "
                    + inWidth + " inHeight: " + inHeight);
        }
        final Bitmap rotated = ImageResizer.rotateImageExif(downsampled, pool, orientation);
>>>>>>> YOURS
/home/arthur/analysis/projects/coreNLP/revisions/rev_7fd0b96_c8b050c/rev_7fd0b96-c8b050c/src/edu/stanford/nlp/sentiment/RNNOptions.java;<<<<<<< MINE
      unkWord = args[argIndex] + 1;
=======
      unkWord = args[argIndex + 1];
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======
import com.bumptech.glide.resize.ImageManager;
import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
import com.bumptech.glide.resize.cache.DiskCache;
import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
import com.bumptech.glide.resize.cache.LruMemoryCache;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
=======
import java.io.File;
import java.net.URL;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/FileLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.io.File;

/**
 * A simple model loader for {@link File}
 */
public class FileLoader implements ModelLoader<File> {

    public static class Factory implements ModelLoaderFactory<File> {
        @Override
        public ModelLoader<File> build(Context context, GenericLoaderFactory factories) {
            return new FileLoader(factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<File>> loaderClass() {
            return FileLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;

    public FileLoader(Context context) {
        this(Glide.buildModelLoader(Uri.class, context));
    }

    public FileLoader(ModelLoader<Uri> uriLoader) {
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(File model, int width, int height) {
        return uriLoader.getStreamLoader(Uri.fromFile(model), width, height);
    }

    @Override
    public String getId(File model) {
        //canonical is better, but also slower
        return model.getAbsolutePath();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/StringLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.io.File;

/**
 * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
 * {@link android.content.ContentResolver#openInputStream(android.net.Uri)}.
 */
public class StringLoader implements ModelLoader<String> {

    public static class Factory implements ModelLoaderFactory<String> {

        @Override
        public ModelLoader<String> build(Context context, GenericLoaderFactory factories) {
            return new StringLoader(factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<String>> loaderClass() {
            return StringLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;

    public StringLoader(Context context) {
        this(Glide.buildModelLoader(Uri.class, context));
    }

    public StringLoader(ModelLoader<Uri> uriLoader) {
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(final String model, final int width, final int height) {
        Uri uri = Uri.parse(model);

        final String scheme = uri.getScheme();
        if (scheme == null) {
            uri = Uri.fromFile(new File(model));
        }

        return uriLoader.getStreamLoader(uri, width, height);
    }

    @Override
    public String getId(String model) {
        return model;
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/UriLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.ContentResolver;
import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.LocalUriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.net.MalformedURLException;
import java.net.URL;

/**
 * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
 * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
 */
public class UriLoader implements ModelLoader<Uri> {
    public static class Factory implements ModelLoaderFactory<Uri> {

        @Override
        public ModelLoader<Uri> build(Context context, GenericLoaderFactory factories) {
            return new UriLoader(context, factories.buildModelLoader(URL.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Uri>> loaderClass() {
            return UriLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final Context context;
    private final ModelLoader<URL> urlLoader;

    public UriLoader(Context context) {
        this(context, Glide.buildModelLoader(URL.class, context));
    }

    public UriLoader(Context context, ModelLoader<URL> urlLoader) {
        this.context = context;
        this.urlLoader = urlLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Uri model, int width, int height) {
        final String scheme = model.getScheme();

        StreamLoader result = null;
        if (isLocalUri(scheme)) {
            result = new LocalUriLoader(context, model);
        } else if ("http".equals(scheme) || "https".equals(scheme)) {
            try {
                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        if (result == null) {
            throw new IllegalArgumentException("No stream loader for uri=" + model);
        }

        return result;
    }

    @Override
    public String getId(Uri model) {
        return model.toString();
    }

    private boolean isLocalUri(String scheme) {
        return ContentResolver.SCHEME_FILE.equals(scheme)
                || ContentResolver.SCHEME_CONTENT.equals(scheme)
                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/ResourceLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

/**
 * A model loader for handling resources. Model must be a resource id in the package of
 * the given context.
 */
public class ResourceLoader implements ModelLoader<Integer> {

    public static class Factory implements ModelLoaderFactory<Integer> {

        @Override
        public ModelLoader<Integer> build(Context context, GenericLoaderFactory factories) {
            return new ResourceLoader(context, factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Integer>> loaderClass() {
            return ResourceLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;
    private final Context context;

    public ResourceLoader(Context context) {
        this(context, Glide.buildModelLoader(Uri.class, context));
    }

    public ResourceLoader(Context context, ModelLoader<Uri> uriLoader) {
        this.context = context;
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Integer model, int width, int height) {
        Uri uri = Uri.parse("android.resource://" + context.getPackageName() + "/" + model.toString());
        return uriLoader.getStreamLoader(uri, width, height);
    }

    @Override
    public String getId(Integer model) {
        return model.toString();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
import com.bumptech.glide.resize.SafeKeyGenerator;
=======
import android.util.Log;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    protected DiskLruCacheWrapper(DiskLruCache diskLruCache) {
        this.diskLruCache = diskLruCache;
        this.safeKeyGenerator = new SafeKeyGenerator();
=======
    private synchronized DiskLruCache getDiskCache() throws IOException {
        if (diskLruCache == null) {
            diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
        }
        return diskLruCache;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
=======
                job.addCallback(cb);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
=======
            } else {
                job.addCallback(cb);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
            result = new LoadToken(cb, job, task.getId());
=======
            result = new LoadToken(cb, job);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
=======
                // Note: this is potentially dangerous. The runner asynchronously asks our jobs map for a job
                // matching our key after posting a runnable to the main thread and as a result, the job it gets back
                // may not be this job. We protect against this for cancellation by not delivering failures from
                // cancelled runners, so new jobs will not receive errors from cancelled jobs. However, new jobs may
                // receive results from old runners if the old runner was cancelled, but completed successfully anyway
                // because it received the cancellation too late.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
        private boolean isCancelled = false;
=======
        private volatile boolean isCancelled = false;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
=======
                    if (isCancelled) {
                        return;
                    }

>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
package com.bumptech.glide.samples.flickr;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import android.os.Bundle;
import android.os.StrictMode;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewPager;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockFragmentActivity;
import com.bumptech.glide.Glide;
import com.bumptech.glide.samples.flickr.api.Api;
import com.bumptech.glide.samples.flickr.api.Photo;

public class FlickrSearchActivity extends SherlockFragmentActivity {
    
    private static final String TAG = "FlickrSearchActivity";

    private int searchCount = 0;
    private EditText searchText;
    private View searching;
    private TextView searchTerm;
    private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
    private List<Photo> currentPhotos = new ArrayList<Photo>();
    private View searchLoading;

    private enum Page {
        SMALL,
        MEDIUM,
        LIST
    }

    private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {{
        put(Page.SMALL, R.string.small);
        put(Page.MEDIUM, R.string.medium);
        put(Page.LIST, R.string.list);
    }};

    @Override
    public void onAttachFragment(Fragment fragment) {
        super.onAttachFragment(fragment);
        if (!(fragment instanceof PhotoViewer)) {
            throw new IllegalStateException("Fragment class " + fragment.getClass() +
                    " does not implement PhotoViewer");
        } else {
            PhotoViewer photoViewer = (PhotoViewer) fragment;
            photoViewer.onPhotosUpdated(currentPhotos);
            if (!photoViewers.contains(photoViewer)) {
                photoViewers.add(photoViewer);
            }
        }
    }

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.flickr_search_activity);
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                .detectAll()
                .penaltyLog()
                .build());

        searching = findViewById(R.id.searching);
        searchLoading = findViewById(R.id.search_loading);
        searchTerm = (TextView) findViewById(R.id.search_term);

        searchText = (EditText) findViewById(R.id.search_text);
        searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
            @Override
            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
                    executeSearch();
                    return true;
                }
                return false;
            }
        });

        final Button search = (Button) findViewById(R.id.search);
        search.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                executeSearch();
            }
        });

        ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
        pager.setPageMargin(50);
        pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int i, float v, int i2) { }

            @Override
            public void onPageSelected(int position) {
                getSupportActionBar().getTabAt(position).select();
            }

            @Override
            public void onPageScrollStateChanged(int i) { }
        });


        final ActionBar actionBar = getSupportActionBar();
        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

        for (Page page : Page.values()) {
            final int textId = PAGE_TO_TITLE.get(page);
            actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
        }

        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
    }

    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        Glide.get().getImageManager(this).trimMemory(level);
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        Glide.get().getImageManager(this).clearMemory();
    }

    private void executeSearch() {
        final String searchString = searchText.getText().toString();
        searchText.getText().clear();

        if ("".equals(searchString.trim())) return;

        final int currentSearch = ++searchCount;

        searching.setVisibility(View.VISIBLE);
        searchLoading.setVisibility(View.VISIBLE);
        searchTerm.setText(getString(R.string.searching_for, searchString));

        Api.get(getApplicationContext()).search(searchString, new Api.SearchCallback() {
            @Override
            public void onSearchCompleted(List<Photo> photos) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Search completed, got " + photos.size() + " results");
                }
                searching.setVisibility(View.INVISIBLE);

                for (PhotoViewer viewer : photoViewers) {
                    viewer.onPhotosUpdated(photos);
                }

                currentPhotos = photos;
            }

            @Override
            public void onSearchFailed(Exception e) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.ERROR)) {
                    Log.e(TAG, "Search failed", e);
                }
                searching.setVisibility(View.VISIBLE);
                searchLoading.setVisibility(View.INVISIBLE);
                searchTerm.setText(getString(R.string.search_failed, searchString));
            }
        });
    }

    private static class TabListener implements ActionBar.TabListener {
        private final ViewPager pager;

        public TabListener(ViewPager pager) {
            this.pager = pager;
        }

        @Override
        public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
            pager.setCurrentItem(tab.getPosition());
        }

        @Override
        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }

        @Override
        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
    }

    private class FlickrPagerAdapter extends FragmentPagerAdapter {

        public FlickrPagerAdapter(FragmentManager fm) {
            super(fm);
        }

        @Override
        public Fragment getItem(int position) {
            return pageToFragment(position);
        }

        @Override
        public int getCount() {
            return Page.values().length;
        }

        private Fragment pageToFragment(int position) {
            Page page = Page.values()[position];
            if (page == Page.SMALL) {
                int pageSize = getPageSize(R.dimen.small_photo_side);
                return FlickrPhotoGrid.newInstance(pageSize, 30);
            } else if (page == Page.MEDIUM) {
                int pageSize = getPageSize(R.dimen.medium_photo_side);
                return FlickrPhotoGrid.newInstance(pageSize, 10);
            } else if (page == Page.LIST) {
                return FlickrPhotoList.newInstance();
            } else {
                throw new IllegalArgumentException("No fragment class for page=" + page);
            }
        }

        private int getPageSize(int id) {
            return getResources().getDimensionPixelSize(id);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/api/Api.java;<<<<<<< MINE
package com.bumptech.glide.samples.flickr.api;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.os.Build;
import android.util.Log;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;
import com.bumptech.glide.Glide;
import com.bumptech.glide.resize.ImageManager;
import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
import com.bumptech.glide.resize.cache.DiskCache;
import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
import com.bumptech.glide.resize.cache.LruMemoryCache;
import com.bumptech.glide.volley.VolleyUrlLoader;

public class Api {
    private static Api API;
    private static final String TAG = "FlickrApi";
    private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
    private static final String SIGNED_API_URL = "https://api.flickr.com/services/rest/?method=%s&format=json&api_key="
            + API_KEY;
    //incomplete size independent url for photos that can be cached per photo
    private static final String CACHEABLE_PHOTO_URL = "http://farm%s.staticflickr.com/%s/%s_%s_";

    private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
        put(75, "s");
        put(100, "t");
        put(150, "q");
        put(240, "m");
        put(320, "n");
        put(640, "z");
        put(1024, "b");
    }};
    private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
    static {
        SORTED_SIZE_KEYS.addAll(EDGE_TO_SIZE_KEY.keySet());
        Collections.sort(SORTED_SIZE_KEYS);
    }

    private final RequestQueue requestQueue;
    private final Context context;
    private static final String CACHE_NAME = "flickr_cache";

    private static String getSizeKey(int width, int height) {
        final int largestEdge = Math.max(width, height);

        String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
        for (int edge : SORTED_SIZE_KEYS) {
            if (largestEdge <= edge) {
                result = EDGE_TO_SIZE_KEY.get(edge);
                break;
            }
        }
        return result;
    }

    public interface SearchCallback {
        public void onSearchCompleted(List<Photo> photos);
        public void onSearchFailed(Exception e);
    }

    public static Api get(Context context) {
        if (API == null) {
            API = new Api(context);
        }
        return API;
    }

    protected Api(Context context) {
        this.context = context;
        requestQueue = Volley.newRequestQueue(context);

        final Glide glide = Glide.get();
        if (!glide.isImageManagerSet()) {
            File cacheDir = ImageManager.getPhotoCacheDir(context, CACHE_NAME);

            DiskCache diskCache = DiskLruCacheWrapper.get(cacheDir, 50 * 1024 * 1024);

            // When we can recycle bitmaps, the smaller our cache is, the more quickly our scrolling will become smooth
            // so prefer large bitmap pool and a small cache.
            final int safeMemCacheSize = ImageManager.getSafeMemoryCacheSize(context);
            glide.setImageManager(new ImageManager.Builder(context)
                    .setBitmapCompressQuality(70)
                    .setMemoryCache(new LruMemoryCache(
                            Build.VERSION.SDK_INT >= 11 ? safeMemCacheSize / 2 : safeMemCacheSize))
                    .setBitmapPool(new LruBitmapPool(
                            Build.VERSION.SDK_INT >= 11 ? Math.round(safeMemCacheSize * 1.5f) : safeMemCacheSize))
                    .setDiskCache(diskCache));
        }
        glide.register(URL.class, new VolleyUrlLoader.Factory(requestQueue));

    }

    public static String getPhotoURL(Photo photo, int width, int height) {
        return getPhotoUrl(photo, getSizeKey(width, height));
    }

    public static String getCacheableUrl(Photo photo) {
        return String.format(CACHEABLE_PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
    }

    private static String getUrlForMethod(String method) {
        return String.format(SIGNED_API_URL, method);
    }

    private static String getSearchUrl(String text) {
        return getUrlForMethod("flickr.photos.search") + "&text=" + text + "&per_page=300";
    }

    private static String getPhotoUrl(Photo photo, String sizeKey) {
        return photo.getPartialUrl() + sizeKey + ".jpg";
    }

    public void search(String text, final SearchCallback cb) {
        StringRequest request = new StringRequest(Request.Method.GET, getSearchUrl(text),
                new Response.Listener<String>() {
            @Override
            public void onResponse(String response) {
                try {
                    //cut out initial flickJsonApi(
                    JSONObject searchResults = new JSONObject(response.substring(14, response.length() - 1));
                    JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
                    List<Photo> results = new ArrayList<Photo>(photos.length());
                    for (int i = 0; i < photos.length(); i++) {
                        results.add(new Photo(photos.getJSONObject(i)));
                    }
                    cb.onSearchCompleted(results);
                } catch (JSONException e) {
                    cb.onSearchFailed(e);
                    if (Log.isLoggable(TAG, Log.ERROR)) {
                        Log.e(TAG, "Search failed response=" + response, e);
                    }
                }
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                cb.onSearchFailed(error);
            }
        });
        request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
        requestQueue.add(request);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.net.Uri;
import android.util.Log;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;
import com.bumptech.glide.loader.image.ImageLoader;
import com.bumptech.glide.loader.image.ImageManagerLoader;
import com.bumptech.glide.loader.model.FileLoader;
import com.bumptech.glide.loader.model.GenericLoaderFactory;
import com.bumptech.glide.loader.model.ModelLoader;
import com.bumptech.glide.loader.model.ModelLoaderFactory;
import com.bumptech.glide.loader.model.ResourceLoader;
import com.bumptech.glide.loader.model.StringLoader;
import com.bumptech.glide.loader.model.UriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;
import com.bumptech.glide.loader.transformation.CenterCrop;
import com.bumptech.glide.loader.transformation.FitCenter;
import com.bumptech.glide.loader.transformation.MultiTransformationLoader;
import com.bumptech.glide.loader.transformation.None;
import com.bumptech.glide.loader.transformation.TransformationLoader;
import com.bumptech.glide.presenter.ImagePresenter;
import com.bumptech.glide.presenter.target.ImageViewTarget;
import com.bumptech.glide.presenter.target.Target;

import com.bumptech.glide.resize.ImageManager;
import com.bumptech.glide.resize.load.Downsampler;
import com.bumptech.glide.resize.load.Transformation;
import com.bumptech.glide.volley.VolleyUrlLoader;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Map;
import java.util.WeakHashMap;

/**
 * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
 * {@link ImageLoader} and {@link ModelLoaderFactory}s. This class provides most of the functionality of
 * {@link ImagePresenter} with a simpler but less efficient interface. For more complicated cases it may be worth
 * considering using {@link ImagePresenter} and {@link com.bumptech.glide.presenter.ImagePresenter.Builder} directly.
 *
 * <p>
 * Note - This class is not thread safe.
 * </p>
 */
public class Glide {
    private static final String TAG = "Glide";
    private static final Glide GLIDE = new Glide();
    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();
    private final GenericLoaderFactory loaderFactory = new GenericLoaderFactory();

    private ImageManager imageManager = null;

    /**
     * A class for monitoring the status of a request while images load.
     *
     * @param <T> The type of the model being loaded
     */
    public interface RequestListener<T> {

        /**
         * Called when an exception occurs during a load. Will only be called if we currently want to display an image
         * for the given model in the given target. It is recommended to create a single instance per activity/fragment
         * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn.
         *
         * <p>
         *     It is safe to reload this or a different model or change what is displayed in the target at this point.
         *     For example:
         * <pre>
         * <code>
         *     public void onException(Exception e, T model, Target target) {
         *         target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
         *         Glide.load(model).into(target);
         *     }
         * </code>
         * </pre>
         * </p>
         *
         * <p>
         *     Note - if you want to reload this or any other model after an exception, you will need to include all
         *     relevant builder calls (like centerCrop, placeholder etc).
         * </p>
         *
         * @param e The exception, or null
         * @param model The model we were trying to load when the exception occurred
         * @param target The {@link Target} we were trying to load the image into
         */
        public abstract void onException(Exception e, T model, Target target);

        /**
         * Called when a load completes successfully, immediately after
         * {@link Target#onImageReady(android.graphics.Bitmap)}.
         *
         * @param model The specific model that was used to load the image.
         * @param target The target the model was loaded into.
         */
        public abstract void onImageReady(T model, Target target);
    }

    /**
     * Get the singleton.
     *
     * @return the singleton
     */
    public static Glide get() {
        return GLIDE;
    }

    protected Glide() {
        loaderFactory.register(File.class, new FileLoader.Factory());
        loaderFactory.register(Integer.class, new ResourceLoader.Factory());
        loaderFactory.register(String.class, new StringLoader.Factory());
        loaderFactory.register(Uri.class, new UriLoader.Factory());
        try {
            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");
            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());
        } catch (ClassNotFoundException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Volley not found, missing url loader");
            }
            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {
                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {
                    @Override
                    public StreamLoader getStreamLoader(URL model, int width, int height) {
                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");
                    }

                    @Override
                    public String getId(URL model) {
                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");
                    }
                };

                @Override
                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {
                    return errorUrlLoader;
                }

                @Override @SuppressWarnings("unchecked")
                public Class<? extends ModelLoader<URL>> loaderClass() {
                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();
                }

                @Override
                public void teardown() {
                }
            });
        }
    }

    /**
     * Return the current {@link ImageManager} or create and return a new one if one is not currently set.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)
     * @see #isImageManagerSet()
     *
     * @param context Any {@link Context}. This will not be retained passed this call
     * @return The current ImageManager
     */
    public ImageManager getImageManager(Context context) {
        if (!isImageManagerSet()) {
            setImageManager(new ImageManager.Builder(context));
        }
        return imageManager;
    }

    /**
     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
     * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder) setImageManager} to set an
     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an
     * easily accessible singleton.
     *
     * @return true iff an {@link ImageManager} is currently set
     */
    public boolean isImageManagerSet() {
        return imageManager != null;
    }

    /**
     * Set the {@link ImageManager} to use with {@link Glide.Request}.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     *
     * @param builder The builder that will be used to construct a new ImageManager
     */
    public void setImageManager(ImageManager.Builder builder) {
        setImageManager(builder.build());
    }

    /**
     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current
     * {@link ImageManager} if one has already been set.
     *
     * @see #isImageManagerSet()
     *
     * @param imageManager The ImageManager to use
     */
    public void setImageManager(ImageManager imageManager) {
        this.imageManager = imageManager;
    }

    /**
     * Use the given factory to build a {@link ModelLoader} for models of the given class. Generally the best use of
     * this method is to replace one of the default factories or add an implementation for other similar low level
     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred
     * because it directly links the model with the ModelLoader being used to load it.
     *
     * <p>
     *     Note - If a factory already exists for the given class, it will be replaced. If that factory is not being
     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}
     *     will be called.
     * </p>
     *
     * <p>
     *     Note - The factory must not be an anonymous inner class of an Activity or another object that cannot be
     *     retained statically.
     * </p>
     *
     * @param clazz The class
     * @param factory The factory to use
     * @param <T> The type of the model
     */
    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {
        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);
        if (removed != null) {
            removed.teardown();
        }
    }

    /**
     * Build a {@link ModelLoader} for the given model class using a registered factory.
     *
     * @param clazz The class to get a {@link ModelLoader} for
     * @param context Any context
     * @param <T> The type of the model
     * @return A new {@link ModelLoader} for the given model class
     * @throws IllegalArgumentException if no factory exists for the given class
     */
    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {
        return GLIDE.loaderFactory.buildModelLoader(clazz, context);
    }

    @SuppressWarnings("unchecked")
    private <T> ModelLoaderFactory<T> getFactory(T model) {
        return loaderFactory.getFactory((Class<T>) model.getClass());
    }

    private ImageViewTarget getImageViewTarget(ImageView imageView) {
        Object tag = imageView.getTag();
        ImageViewTarget result = null;
        if (tag instanceof ImageViewTarget) {
            result = (ImageViewTarget) tag;
        } else if (tag != null) {
            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");
        }

        return result;
    }

    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {
        ImageViewTarget result = getImageViewTarget(imageView);
        if (result == null) {
            result = new ImageViewTarget(imageView);
            imageView.setTag(result);
        }
        return result;
    }

    /**
     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load.
     *
     * <p>
     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default
     *     {@link ModelLoader}/{@link ModelLoaderFactory}. You can also optionally use this method to override the
     *     default {@link ModelLoader} for a model for which there is a default. If you would like to permanently
     *     use this factory for all model loads of the this factory's type, see
     *     {@link #register(Class, com.bumptech.glide.loader.model.ModelLoaderFactory)}.
     * </p>
     *
     * <p>
     *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to
     *     supply a custom {@link ModelLoaderFactory} here to do so, even if a default exists. Fetching a smaller image
     *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to
     *     download an image using the width and the height of the target, consider passing in a factory for a subclass
     *     of {@link com.bumptech.glide.loader.model.UrlModelLoader}
     * </p>
     *
     *
     * @param factory The {@link ModelLoaderFactory} to use to load an image from a given model
     * @param <T> The type of the model to load using this factory
     * @return A {@link ModelRequest} to set the specific model to load
     */
    public static <T> ModelRequest<T> using(ModelLoaderFactory<T> factory) {
        return new ModelRequest<T>(factory);
    }

    /**
     * Set the {@link ModelLoader} and therefore the model type to use for a new load.
     *
     * @see #using(com.bumptech.glide.loader.model.ModelLoaderFactory)
     *
     * @param modelLoader The model loader to use
     * @param <T> The type of the model to load using this loader
     * @return A {@link ModelRequest} to set the specific model to load
     */
    public static <T> ModelRequest<T> using(final ModelLoader<T> modelLoader) {
        return new ModelRequest<T>(new ModelLoaderFactory<T>() {
            @Override
            public ModelLoader<T> build(Context context, GenericLoaderFactory factories) {
                return modelLoader;
            }


            @Override @SuppressWarnings("unchecked")
            public Class<? extends ModelLoader<T>> loaderClass() {
                return (Class<ModelLoader<T>>) modelLoader.getClass();
            }

            @Override
            public void teardown() { }
        });
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link String} to load the image represented by the
     * given {@link String}. Defaults to {@link StringLoader.Factory} and {@link StringLoader} to load the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(String)
     *
     * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<String> load(String string) {
        return new Request<String>(string);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link Uri} to load the image at the given uri.
     * Defaults to {@link UriLoader.Factory} and {@link UriLoader}.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(android.net.Uri)
     *
     * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<Uri> load(Uri uri) {
        return new Request<Uri>(uri);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link URL} to load the image represented by the
     * given {@link URL}. Defaults to {@link VolleyUrlLoader.Factory} and {@link VolleyUrlLoader} to load the given
     * model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(java.net.URL)
     *
     * @param url The URL representing the image.
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<URL> load(URL url) {
        return new Request<URL>(url);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link File} to load the image represented by the
     * given {@link File}. Defaults to {@link FileLoader.Factory} and {@link FileLoader} to load the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(java.io.File)
     *
     * @param file The File containing the image
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<File> load(File file) {
        return new Request<File>(file);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link Integer} to load the image represented by the
     * given {@link Integer} resource id. Defaults to {@link ResourceLoader.Factory} and {@link ResourceLoader} to load
     * the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(Integer)
     *
     * @param resourceId the id of the resource containing the image
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<Integer> load(Integer resourceId) {
        return new Request<Integer>(resourceId);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for the given model type to load the image represented by
     * the given model.
     *
     * @param model The model to load
     * @param <T> The type of the model to load
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     * @throws IllegalArgumentException If no {@link ModelLoaderFactory} is registered for the given model type
     */
    public static <T> Request<T> load(T model) {
        return new Request<T>(model);
    }

    /**
     * @see #cancel(com.bumptech.glide.presenter.target.Target)
     */
    public static boolean cancel(ImageView imageView) {
        final Target target = GLIDE.getImageViewTarget(imageView);
        return target != null && cancel(target);
    }

    /**
     * Cancel any pending loads Glide may have for the target. After the load is cancelled Glide will not load
     * a placeholder or bitmap into the target so it is safe to do so yourself until you start another load.
     *
     * @param target The Target to cancel loads for
     * @return True iff Glide had ever been asked to load an image for this target
     */
    public static boolean cancel(Target target) {
        ImagePresenter current = target.getImagePresenter();
        final boolean cancelled = current != null;
        if (cancelled) {
            current.clear();
        }

        return cancelled;
    }

    /**
     * A helper class for building requests with custom {@link ModelLoader}s
     *
     * @param <T> The type of the model (and {@link ModelLoader}
     */
    public static class ModelRequest<T> {
        private final ModelLoaderFactory<T> factory;

        private ModelRequest(ModelLoaderFactory<T> factory) {
            this.factory = factory;
        }

        public Request<T> load(T model) {
            return new Request<T>(model, factory);
        }
    }

    /**
     * Sets a variety of type independent options including resizing, animations, and placeholders. Responsible
     * for building or retrieving an ImagePresenter for the given target and passing the ImagePresenter the given model.
     *
     * @param <T> The type of model that will be loaded into the target
     */
    @SuppressWarnings("unused") //public api
    public static class Request<T> {

        private Context context;
        private Target target;

        private ModelLoaderFactory<T> modelLoaderFactory;
        private final T model;

        private int animationId = -1;
        private int placeholderId = -1;
        private int errorId = -1;
        private Downsampler downsampler = Downsampler.AT_LEAST;
        private ArrayList<TransformationLoader<T>> transformationLoaders = new ArrayList<TransformationLoader<T>>();
        private RequestListener<T> requestListener;

        private Request(T model) {
            this(model, GLIDE.getFactory(model));
        }

        private Request(T model, ModelLoaderFactory<T> factory) {
            this.model = model;

            if (factory == null) {
                throw new IllegalArgumentException("No ModelLoaderFactory registered for class=" + model.getClass());
            }
            this.modelLoaderFactory = factory;
        }

        /**
         * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}.
         *
         * @see #downsample(com.bumptech.glide.resize.load.Downsampler)
         *
         * @return This Request
         */
        public Request<T> approximate() {
            return downsample(Downsampler.AT_LEAST);
        }

        /**
         * Load images at their original size using {@link Downsampler#NONE}.
         *
         * @see #downsample(com.bumptech.glide.resize.load.Downsampler)
         *
         * @return This Request
         */
        public Request<T> asIs() {
            return downsample(Downsampler.NONE);
        }

        /**
         * Load images using the given {@link Downsampler}. Replaces any existing downsampler. Defaults to
         * {@link Downsampler#AT_LEAST}
         *
         * @param downsampler The downsampler
         * @return This Request
         */
        public Request<T> downsample(Downsampler downsampler) {
            this.downsampler = downsampler;

            return this;
        }

        /**
         * Transform images using {@link com.bumptech.glide.loader.transformation.CenterCrop}.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @return This Request
         */
        public Request<T> centerCrop() {
            return transform(new CenterCrop<T>());
        }

        /**
         * Transform images using {@link com.bumptech.glide.loader.transformation.FitCenter}.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @return This Request
         */
        public Request<T> fitCenter() {
            return transform(new FitCenter<T>());
        }

        /**
         * Set an arbitrary transformation to apply after an image has been loaded into memory.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @param transformation The transformation to use
         * @return This Request
         */
        public Request<T> transform(final Transformation transformation) {
            return transform(new TransformationLoader<T>() {
                @Override
                public Transformation getTransformation(T model) {
                    return transformation;
                }

                @Override
                public String getId() {
                    return transformation.getId();
                }
            });
        }

        /**
         * Transform images with the given {@link TransformationLoader}. Appends this transformation onto any existing
         * transformations
         *
         * @param transformationLoader The loader to obtaian a transformation for a given model
         * @return This Request
         */
        public Request<T> transform(TransformationLoader<T> transformationLoader) {
            transformationLoaders.add(transformationLoader);

            return this;
        }

        /**
         * Sets an animation to run on the wrapped target when an image load finishes. Will only be run if the image
         * was loaded asynchronously (ie was not in the memory cache)
         *
         * @param animationId The resource id of the animation to run
         * @return This Request
         */
        public Request<T> animate(int animationId) {
            this.animationId = animationId;

            return this;
        }

        /**
         * Sets a resource to display while an image is loading
         *
         * @param resourceId The id of the resource to use as a placeholder
         * @return This Request
         */
        public Request<T> placeholder(int resourceId) {
            this.placeholderId = resourceId;

            return this;
        }

        /**
         * Sets a resource to display if a load fails
         *
         * @param resourceId The id of the resource to use as a placeholder
         * @return This request
         */
        public Request<T> error(int resourceId) {
            this.errorId = resourceId;

            return this;
        }

        /**
         * Sets a Request listener to monitor the image load. It's best to create a single instance of an exception
         * handler per type of request (usually activity/fragment) rather than pass one in per request to avoid some
         * redundant object allocation.
         *
         * @param requestListener The request listener to use
         * @return This request
         */
        public Request<T> listener(RequestListener<T> requestListener) {
            this.requestListener = requestListener;

            return this;
        }

        /**
         * Start loading the image into the view.
         *
         * <p>
         *     Note - This method will call {@link ImageView#setTag(Object)} and may silently overwrite any tag that
         *     might already be set on the view.
         * </p>
         *
         * @see ImagePresenter#setModel(Object)
         * @param imageView The view that will display the image
         */
        public void into(ImageView imageView) {
            //make an effort to support wrap content layout params. This will still blow
            //up if transformation doesn't handle wrap content, but its a start
            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
            if (layoutParams != null &&
                    (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {
                downsampler = Downsampler.NONE;
            }

            finish(imageView.getContext(), GLIDE.getImageViewTargetOrSet(imageView));
        }

        /**
         * Set the target the image will be loaded into.
         *
         * <p>
         *     Note - This method does not actually start loading the view. You must first pass in a {@link Context} to
         *     returned Request via {@link ContextRequest#with(android.content.Context)}.
         * </p>
         *
         * @param target The target to load te image for
         * @return A {@link ContextRequest} that can start the load
         */
        public ContextRequest into(Target target) {
            return new ContextRequest(this, target);
        }

        private void finish(Context context, Target target) {
            this.context = context;
            this.target = target;

            ImagePresenter<T> imagePresenter = getImagePresenter(target);
            imagePresenter.setModel(model);
        }

        /**
         * Creates the new {@link ImagePresenter} if one does not currently exist for the current target and sets it as
         * the target's ImagePresenter via {@link Target#setImagePresenter(com.bumptech.glide.presenter.ImagePresenter)}
         */
        @SuppressWarnings("unchecked")
        private ImagePresenter<T> getImagePresenter(Target target) {
            ImagePresenter<T> result = target.getImagePresenter();

            Metadata previous = GLIDE.metadataTracker.get(target);
            Metadata current = new Metadata(this);

            if (previous != null && result == null) {
                previous = null;
            }

            if (!current.isIdenticalTo(previous)) {
                if (result != null) {
                    result.clear();
                }

                result = buildImagePresenter(target);
                target.setImagePresenter(result);

                GLIDE.metadataTracker.put(target, current);
            }

            return result;
        }

        private ImagePresenter<T> buildImagePresenter(final Target target) {
            TransformationLoader<T> transformationLoader = getFinalTransformationLoader();

            ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
                    .setTarget(target, context)
                    .setModelLoader(modelLoaderFactory.build(context, GLIDE.loaderFactory))
                    .setImageLoader(new ImageManagerLoader(context, downsampler))
                    .setTransformationLoader(transformationLoader);

            if (animationId != -1 || requestListener != null) {
                final Animation animation;
                if (animationId != -1) {
                    animation = AnimationUtils.loadAnimation(context, animationId);
                } else {
                    animation = null;
                }
                builder.setImageReadyCallback(new ImagePresenter.ImageReadyCallback<T>() {
                    @Override
                    public void onImageReady(T model, Target target, boolean fromCache) {
                        if (animation != null && !fromCache) {
                            target.startAnimation(animation);
                        }
                        if (requestListener != null) {
                            requestListener.onImageReady(null, target);
                        }
                    }
                });
            }

            if (placeholderId != -1) {
                builder.setPlaceholderResource(placeholderId);
            }

            if (errorId != -1) {
                builder.setErrorResource(errorId);
            }

            if (requestListener != null) {
                builder.setExceptionHandler(new ImagePresenter.ExceptionHandler<T>() {
                    @Override
                    public void onException(Exception e, T model, boolean isCurrent) {
                        if (isCurrent) {
                            requestListener.onException(e, model, target);
                        }
                    }
                });
            }

            return builder.build();
        }

        private TransformationLoader<T> getFinalTransformationLoader() {
            switch (transformationLoaders.size()) {
                case 0:
                    return new None<T>();
                case 1:
                    return transformationLoaders.get(0);
                default:
                    return new MultiTransformationLoader<T>(transformationLoaders);
            }
        }

        private String getFinalTransformationId() {
            switch (transformationLoaders.size()) {
                case 0:
                    return Transformation.NONE.getId();
                case 1:
                    return transformationLoaders.get(0).getId();
                default:
                    StringBuilder sb = new StringBuilder();
                    for (TransformationLoader transformationLoader : transformationLoaders) {
                        sb.append(transformationLoader.getId());
                    }
                    return sb.toString();
            }
        }
    }

    /**
     * An request for the user to provide an {@link Context} to start an image load
     */
    public static class ContextRequest {
        private final Request request;
        private final Target target;

        private ContextRequest(Request request, Target target) {
            this.request = request;
            this.target = target;
        }

        /**
         * Start loading the image using the given context. The context will not be referenced statically so any
         * context is acceptable.
         *
         * @param context The context to use to help load the image
         */
        public void with(Context context) {
            request.finish(context, target);
        }
    }

    private static class Metadata {
        public final Class modelClass;
        public final Class modelLoaderClass;
        public final int animationId;
        public final int placeholderId;
        public final int errorId;

        private final String downsamplerId;
        private final String transformationId;
        private final Class requestListenerClass;

        public Metadata(Request request) {
            modelClass = request.model != null ? request.model.getClass() : null;
            modelLoaderClass = request.modelLoaderFactory.loaderClass();
            downsamplerId = request.downsampler.getId();
            transformationId = request.getFinalTransformationId();
            animationId = request.animationId;
            placeholderId = request.placeholderId;
            errorId = request.errorId;
            requestListenerClass = (request.requestListener != null ?
                    request.requestListener.getClass() : null);
        }

        //we don't want to change behavior in sets/maps, just be able to compare properties
        public boolean isIdenticalTo(Metadata metadata) {
            if (metadata == null) {
                return false;
            }
            if (animationId != metadata.animationId) {
                return false;
            }
            if (errorId != metadata.errorId) {
                return false;
            }
            if (placeholderId != metadata.placeholderId) {
                return false;
            }
            if (!downsamplerId.equals(metadata.downsamplerId)) {
                return false;
            }
            if (modelClass != null ? !modelClass.equals(metadata.modelClass) : metadata.modelClass != null) {
                return false;
            }
            if (!modelLoaderClass.equals(metadata.modelLoaderClass)) {
                return false;
            }
            if (!transformationId.equals(metadata.transformationId)) {
                return false;
            }
            if (requestListenerClass == null ? metadata.requestListenerClass != null :
                    !requestListenerClass.equals(metadata.requestListenerClass)) {
                return false;
            }

            return true;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
package com.bumptech.glide.presenter.target;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.Display;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.animation.Animation;
import android.widget.ImageView;
import com.bumptech.glide.presenter.ImagePresenter;

import java.lang.ref.WeakReference;

import static android.view.ViewGroup.LayoutParams;

/**
 * A target wrapping an ImageView. Obtains the runtime dimensions of the ImageView.
 */
public class ImageViewTarget implements Target {
    private static final String TAG = "ImageViewTarget";
    private final ImageView imageView;
    private final SizeDeterminer sizeDeterminer;
    private ImagePresenter imagePresenter;

    public ImageViewTarget(ImageView imageView) {
        this.imageView = imageView;
        this.sizeDeterminer = new SizeDeterminer(imageView);
    }

    @Override
    public void onImageReady(Bitmap bitmap) {
        imageView.setImageBitmap(bitmap);
    }

    @Override
    public void setPlaceholder(Drawable placeholder) {
        imageView.setImageDrawable(placeholder);
    }

    @Override
    public void getSize(SizeReadyCallback cb) {
        sizeDeterminer.getSize(cb);
    }

    @Override
    public void startAnimation(Animation animation) {
        imageView.clearAnimation();

        imageView.startAnimation(animation);
    }

    @Override
    public void setImagePresenter(ImagePresenter imagePresenter) {
        this.imagePresenter = imagePresenter;
    }

    @Override
    public ImagePresenter getImagePresenter() {
        return imagePresenter;
    }

    @Override
    public int hashCode() {
        return imageView.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        } else if (!(o instanceof ImageViewTarget)) {
            return false;
        }
        ImageViewTarget other = (ImageViewTarget) o;
        return imageView.equals(other.imageView);
    }

    private static class SizeDeterminer {
        private final View view;
        private SizeReadyCallback cb;
        private SizeDeterminerLayoutListener layoutListener;

        private void checkCurrentDimens() {
            if (cb == null) return;

            boolean calledCallback = true;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else {
                calledCallback = false;
            }

            if (calledCallback) {
                cb = null;
                // Keep a reference to the layout listener and remove it here
                // rather than having the observer remove itself because the observer
                // we add the listener to will be almost immediately merged into
                // another observer and will therefore never be alive. If we instead
                // keep a reference to the listener and remove it here, we get the
                // current view tree observer and should succeed.
                ViewTreeObserver observer = view.getViewTreeObserver();
                if (observer.isAlive()) {
                    observer.removeOnPreDrawListener(layoutListener);
                }
            }
        }

        public SizeDeterminer(View view) {
            this.view = view;
        }

        public void getSize(SizeReadyCallback cb) {
            this.cb = null;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else if (isUsingWrapContent()) {
                WindowManager windowManager =
                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
                Display display = windowManager.getDefaultDisplay();
                final int width = display.getWidth();
                final int height = display.getHeight();
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen" +
                            " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height " +
                            " for better performance.");
                }
                cb.onSizeReady(display.getWidth(), display.getHeight());
            } else {
                this.cb = cb;
                final ViewTreeObserver observer = view.getViewTreeObserver();
                layoutListener = new SizeDeterminerLayoutListener(this);
                observer.addOnPreDrawListener(layoutListener);
            }
        }

        private boolean isViewSizeValid() {
            return view.getWidth() > 0 && view.getHeight() > 0;
        }

        private boolean isUsingWrapContent() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width == LayoutParams.WRAP_CONTENT
                    || layoutParams.height == LayoutParams.WRAP_CONTENT);
        }

        private boolean isLayoutParamsSizeValid() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width > 0 && layoutParams.height > 0);
        }

        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {
            private final WeakReference<SizeDeterminer> sizeDeterminerRef;

            public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
                sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
            }

            @Override
            public boolean onPreDraw() {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
                }
                SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
                if (sizeDeterminer != null) {
                    sizeDeterminer.checkCurrentDimens();
                }
                return true;
            }
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/loader/model/UriLoader.java;<<<<<<< MINE
package com.bumptech.glide.loader.model;

import android.content.ContentResolver;
import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.LocalUriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.net.MalformedURLException;
import java.net.URL;

/**
 * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
 * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
 */
public class UriLoader implements ModelLoader<Uri> {
    public static class Factory implements ModelLoaderFactory<Uri> {

        @Override
        public ModelLoader<Uri> build(Context context, GenericLoaderFactory factories) {
            return new UriLoader(context, factories.buildModelLoader(URL.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Uri>> loaderClass() {
            return UriLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final Context context;
    private final ModelLoader<URL> urlLoader;

    public UriLoader(Context context) {
        this(context, Glide.buildModelLoader(URL.class, context));
    }

    public UriLoader(Context context, ModelLoader<URL> urlLoader) {
        this.context = context;
        this.urlLoader = urlLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Uri model, int width, int height) {
        final String scheme = model.getScheme();

        StreamLoader result = null;
        if (isLocalUri(scheme)) {
            result = new LocalUriLoader(context, model);
        } else if ("http".equals(scheme) || "https".equals(scheme)) {
            try {
                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    @Override
    public String getId(Uri model) {
        return model.toString();
    }

    private boolean isLocalUri(String scheme) {
        return ContentResolver.SCHEME_FILE.equals(scheme)
                || ContentResolver.SCHEME_CONTENT.equals(scheme)
                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/bitmap_recycle/SizeStrategy.java;<<<<<<< MINE
package com.bumptech.glide.resize.bitmap_recycle;

import android.annotation.TargetApi;
import android.graphics.Bitmap;

import java.util.TreeMap;

/**
 * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}. Requires KitKat
 * (API 19) or higher.
 */
@TargetApi(19)
class SizeStrategy implements LruPoolStrategy {
    private static final int MAX_SIZE_MULTIPLE = 4;
    private final KeyPool keyPool = new KeyPool();
    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();
    private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<Integer, Integer>();

    @Override
    public void put(Bitmap bitmap) {
        final Key key = keyPool.get(bitmap.getAllocationByteCount());

        groupedMap.put(key, bitmap);

        Integer current = sortedSizes.get(key.size);
        sortedSizes.put(key.size, current == null ? 1 : current + 1);
    }

    @Override
    public Bitmap get(int width, int height, Bitmap.Config config) {
        final int size = getSize(width, height, config);
        Key key = keyPool.get(size);

        Integer possibleSize = sortedSizes.ceilingKey(size);
        if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {
            keyPool.offer(key);
            key = keyPool.get(possibleSize);
        }

        // Do a get even if we know we don't have a bitmap so that the key moves to the front in the lru pool
        final Bitmap result = groupedMap.get(key);
        if (result != null) {
            result.reconfigure(width, height, config);
            decrementBitmapOfSize(possibleSize);
        }

        return result;
    }

    @Override
    public Bitmap removeLast() {
        Bitmap removed = groupedMap.removeLast();
        if (removed != null) {
            final int removedSize = removed.getAllocationByteCount();
            decrementBitmapOfSize(removedSize);
        }
        return removed;
    }

    private void decrementBitmapOfSize(Integer size) {
        Integer current = sortedSizes.get(size);
        if (current == 1) {
            sortedSizes.remove(size);
        } else {
            sortedSizes.put(size, current - 1);
        }
    }

    @Override
    public String logBitmap(Bitmap bitmap) {
        return getBitmapString(bitmap);
    }

    @Override
    public String logBitmap(int width, int height, Bitmap.Config config) {
        return getBitmapString(getSize(width, height, config));
    }

    @Override
    public int getSize(Bitmap bitmap) {
        return bitmap.getAllocationByteCount();
    }

    @Override
    public String toString() {
        String result = "SizeStrategy:\n  " + groupedMap + "\n  SortedSizes( ";
        boolean hadAtLeastOneKey = false;
        for (Integer size : sortedSizes.keySet()) {
            hadAtLeastOneKey = true;
            result += "{" + getBitmapString(size) + ":" + sortedSizes.get(size) + "}, ";
        }
        if (hadAtLeastOneKey) {
            result = result.substring(0, result.length() - 2);
        }
        return result + " )";
    }

    private static String getBitmapString(Bitmap bitmap) {
        return getBitmapString(bitmap.getAllocationByteCount());
    }

    private static String getBitmapString(int size) {
        return "[" + size + "]";
    }

    private static int getSize(int width, int height, Bitmap.Config config) {
        return width * height * getBytesPerPixel(config);
    }

    private static int getBytesPerPixel(Bitmap.Config config) {
      // a bitmap by decoding a gif has null "config" in certain environments.
      if (config == null) {
          return 4;
      }

      switch (config) {
          case ARGB_8888:
              return 4;
          case RGB_565:
              return 2;
          case ARGB_4444:
              return 2;
          case ALPHA_8:
              return 1;
          default:
              // We only use this to calculate sizes to get, so choosing 4 bytes per pixel is conservative and
              // probably forces us to get a larger bitmap than we really need. Since we can't tell for sure, probably
              // better safe than sorry.
              return 4;
        }
    }

    private static class KeyPool extends BaseKeyPool<Key> {

        public Key get(int size) {
            Key result = get();
            result.init(size);
            return result;
        }

        @Override
        protected Key create() {
            return new Key(this);
        }
    }

    private static class Key implements Poolable {
        private final KeyPool pool;
        private int size;

        private Key(KeyPool pool) {
            this.pool = pool;
        }

        public void init(int size) {
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Key key = (Key) o;

            return size == key.size;
        }

        @Override
        public int hashCode() {
            return size;
        }

        @Override
        public String toString() {
            return getBitmapString(size);
        }

        @Override
        public void offer() {
            pool.offer(this);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
/*
 * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
 */

package com.bumptech.glide.resize;

import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import com.bumptech.glide.loader.stream.StreamLoader;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.SerialBitmapReferenceCounter;
import com.bumptech.glide.resize.cache.DiskCache;
import com.bumptech.glide.resize.cache.DiskCacheAdapter;
import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
import com.bumptech.glide.resize.cache.LruMemoryCache;
import com.bumptech.glide.resize.cache.MemoryCache;
import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
import com.bumptech.glide.resize.load.Downsampler;
import com.bumptech.glide.resize.load.ImageResizer;
import com.bumptech.glide.resize.load.Transformation;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;

import static android.os.Process.THREAD_PRIORITY_BACKGROUND;

/**
 * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
 * sdk version, uses a combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
 * load and resize operations performed and to maximize the number of times Bitmaps are recycled as opposed to
 * allocated. If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if
 * possible.
 *
 * <p>
 * Note that Bitmap recycling is only available on Honeycomb and up.
 * </p>
 */
public class ImageManager {
    private static final String TAG = "ImageManager";
    private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
    private static final int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
    private static final int DEFAULT_BITMAP_COMPRESS_QUALITY = 90;
    private static final float MEMORY_SIZE_RATIO = 1f/10f;
    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final BitmapReferenceCounter bitmapReferenceCounter;
    private final int bitmapCompressQuality;
    private final BitmapPool bitmapPool;
    private final Map<String, ImageManagerJob> jobs = new HashMap<String, ImageManagerJob>();
    private final Bitmap.CompressFormat bitmapCompressFormat;
    private boolean shutdown = false;

    private final Handler mainHandler = new Handler();
    private final Handler bgHandler;
    private final ExecutorService executor;
    private final MemoryCache memoryCache;
    private final ImageResizer resizer;
    private final DiskCache diskCache;
    private final SafeKeyGenerator safeKeyGenerator = new SafeKeyGenerator();

    /**
     * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
     * This is a conservative estimate that has been safe for 2.2+ devices consistently. It is probably rather small
     * for newer devices.
     *
     * @param context A context
     * @return The maximum safe size for the memory cache for this devices in bytes
     */
    public static int getSafeMemoryCacheSize(Context context){
        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        return Math.round(MEMORY_SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
    }

    /**
     * Try to get the external cache directory if available and default to the internal. Use a default name for the
     * cache directory if no name is provided
     *
     * @param context A context
     * @return A File representing the default disk cache directory
     */
    public static File getPhotoCacheDir(Context context) {
        return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
    }

    /**
     * Try to get the external cache directory if available and default to the internal. Use a default name for the
     * cache directory if no name is provided
     *
     * @param context A context
     * @param cacheName The name of the subdirectory in which to store the cache
     * @return A File representing the default disk cache directory
     */
    @SuppressWarnings("ResultOfMethodCallIgnored")
    public static File getPhotoCacheDir(Context context, String cacheName) {
        File cacheDir = context.getCacheDir();
        if (cacheDir != null) {
            File result = new File(cacheDir, cacheName);
            result.mkdirs();
            return result;
        }
        if (Log.isLoggable(TAG, Log.ERROR)) {
            Log.e(TAG, "default disk cache dir is null");
        }
        return null;
    }

    @SuppressWarnings("unused")
    public static class Builder {
        private final Context context;

        private ExecutorService resizeService = null;
        private MemoryCache memoryCache = null;
        private DiskCache diskCache = null;

        private Bitmap.CompressFormat bitmapCompressFormat = null;
        private boolean recycleBitmaps = CAN_RECYCLE;

        @Deprecated
        public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();

        private BitmapPool bitmapPool;
        private BitmapReferenceCounter bitmapReferenceCounter;
        private int bitmapCompressQuality = DEFAULT_BITMAP_COMPRESS_QUALITY;

        /**
         * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
         * cache, and will recycle bitmaps if the device sdk version allows it.
         *
         * @param context Any context (will not be retained after build)
         */
        public Builder(Context context) {
            this.context = context;
            if (!CAN_RECYCLE) {
                bitmapPool = new BitmapPoolAdapter();
            }
        }

        /**
         * Builds an ImageManager. Any defaults that haven't been set will be set
         *
         * @return A new ImageManager
         */
        public ImageManager build() {
            setDefaults();

            return new ImageManager(this);
        }

        /**
         * Sets the service that will be used to load and resize images not yet in the disk cache.
         *
         * Defaults to a fixed thread pool with the number of threads equal to the number of available processors
         * where every thread is run at min priority.
         *
         * @param resizeService The executor service to use to resize images
         * @return This Builder
         */
        public Builder setResizeService(ExecutorService resizeService) {
            this.resizeService = resizeService;
            return this;
        }

        /**
         * Sets the format that will be used to write all bitmaps to disk in the disk cache (if one is present). By
         * default bitmaps without transparency are written as JPEGs for the fastest possible decodes and bitmaps with
         * transparency are written as PNGs to maximize quality. This will override the format used for all bitmaps,
         * regardless of whether or not they contain transparency.
         *
         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
         *
         *
         * @param bitmapCompressFormat The format to pass to
         *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
         *  to the disk cache
         * @return This Builder
         */
        public Builder setBitmapCompressFormat(Bitmap.CompressFormat bitmapCompressFormat) {
            this.bitmapCompressFormat = bitmapCompressFormat;
            return this;
        }

        /**
         * Set the compression quality for Bitmaps when writing them out to the disk cache.
         *
         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
         * @see #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)
         *
         * <Note>
         *     This will only apply to bitmaps saved to the disk cache as JPEGs (bitmaps with the RGB_565 config)
         * </Note>
         *
         * @param quality Hint for compression in range 0-100 with 0 being lowest and 100 being highest quality. Will
         *                only be applied for certain lossy compression formats
         * @return This Builder
         */
        public Builder setBitmapCompressQuality(int quality) {
            if (quality < 0) {
                throw new IllegalArgumentException("Bitmap compression quality must be >= 0");
            }
            this.bitmapCompressQuality = quality;
            return this;
        }

        /**
         * Set the implementation of a {@link BitmapPool} to use to store and retrieve recycled bitmaps based on their
         * width and height. Should be thread safe and size limited in some way to avoid OOM exceptions.
         *
         * @param bitmapPool The BitmapPool implementation to use
         * @return This Builder
         */
        public Builder setBitmapPool(BitmapPool bitmapPool) {
            if (CAN_RECYCLE) {
                this.bitmapPool = bitmapPool;
            }
            return this;
        }

        /**
         * Call to prevent the ImageManager from recycling bitmaps.
         *
         * @return This Builder
         */
        public Builder disableBitmapRecycling() {
            recycleBitmaps = false;
            return this;
        }

        /**
         * Set the memory cache implementation. See also
         * {@link com.bumptech.glide.resize.ImageManager.Builder#disableMemoryCache()}
         *
         * @param memoryCache The memory cache implementation to use
         * @return This Builder
         */
        public Builder setMemoryCache(MemoryCache memoryCache) {
            this.memoryCache = memoryCache;
            return this;
        }

        /**
         * Call to prevent the ImageManager from using a memory cache.
         *
         * @return This Builder
         */
        public Builder disableMemoryCache() {
            return setMemoryCache(new MemoryCacheAdapter());
        }

        /**
         * Set the disk cache implementation. See also
         *  {@link com.bumptech.glide.resize.ImageManager.Builder#disableDiskCache()}
         *
         * @param diskCache The disk cache implementation to use
         * @return This Builder
         */
        public Builder setDiskCache(DiskCache diskCache) {
            this.diskCache = diskCache;
            return this;
        }

        /**
         * Call to prevent the ImageManager from using a disk cache
         * @return This Builder
         */
        public Builder disableDiskCache() {
            return setDiskCache(new DiskCacheAdapter());
        }

        private void setDefaults() {
            if (resizeService == null) {
                final int numThreads = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);
                resizeService = Executors.newFixedThreadPool(numThreads, new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable runnable) {
                        final Thread result = new Thread(runnable);
                        result.setPriority(THREAD_PRIORITY_BACKGROUND);
                        return result;
                    }
                });
            }
            final int safeCacheSize = getSafeMemoryCacheSize(context);
            final boolean isLowMemoryDevice = isLowMemoryDevice(context);

            if (memoryCache == null) {
                // On low ram devices we double the default bitmap pool size by default so we decrease
                // the default memory cache size here to compensate.
                memoryCache = new LruMemoryCache(
                        !isLowMemoryDevice && recycleBitmaps ? safeCacheSize / 2 : safeCacheSize);
            }

            if (diskCache == null) {
                File cacheDir = getPhotoCacheDir(context);
                if (cacheDir != null) {
                    diskCache = DiskLruCacheWrapper.get(cacheDir, DEFAULT_DISK_CACHE_SIZE);
                }

                if (diskCache == null) {
                    diskCache = new DiskCacheAdapter();
                }
            }

            if (!recycleBitmaps) {
                bitmapPool = new BitmapPoolAdapter();
                bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
            } else {
                if (bitmapPool == null) {
                    bitmapPool = new LruBitmapPool(
                            isLowMemoryDevice ? safeCacheSize : 2 * safeCacheSize);
                }
                bitmapReferenceCounter = new SerialBitmapReferenceCounter(bitmapPool);
            }
        }
    }

    @TargetApi(19)
    private static boolean isLowMemoryDevice(Context context) {
        final ActivityManager activityManager =
                (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        return Build.VERSION.SDK_INT < 11 ||
                (Build.VERSION.SDK_INT >= 19 && activityManager.isLowRamDevice());
    }

    private ImageManager(Builder builder) {
        HandlerThread bgThread = new HandlerThread("image_manager_thread", THREAD_PRIORITY_BACKGROUND);
        bgThread.start();
        bgHandler = new Handler(bgThread.getLooper());
        executor = builder.resizeService;
        bitmapCompressFormat = builder.bitmapCompressFormat;
        bitmapCompressQuality = builder.bitmapCompressQuality;
        memoryCache = builder.memoryCache;
        diskCache = builder.diskCache;
        bitmapReferenceCounter = builder.bitmapReferenceCounter;
        bitmapPool = builder.bitmapPool;
        resizer = new ImageResizer(builder.bitmapPool, builder.decodeBitmapOptions);
        memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
            @Override
            public void onImageRemoved(Bitmap removed) {
                releaseBitmap(removed);
            }
        });
    }

    /**
     * Get the {@link BitmapPool} this ImageManager is using. If Bitmap recycling is not supported, an
     * {@link BitmapPoolAdapter} will be returned. For the pool to be useful you must return a bitmap to the pool for
     * every bitmap you obtain from the pool.
     *
     * <p>
     *     Note the BitmapPool api is likely to change in the near future to support some new features released in
     *     KitKat.
     * </p>
     *
     * @return The bitmap pool.
     */
    public BitmapPool getBitmapPool() {
        return bitmapPool;
    }

    /**
     * Load an image
     *
     * @param id A unique id for this image (it may include the width and height but is not required to)
     * @param streamLoader An object that can fetch the image for the given id, width, and height if it is not cached
     * @param transformation A transformation to apply to the image
     * @param downsampler A downsampler to load the image from disk
     * @param width The desired width of the final image
     * @param height The desired height of the final image
     * @param cb A callback to call when the image is ready
     * @return An {@link ImageManagerJob} that must be retained while the job is still relevant and that can be used
     *          to cancel a job if the image is no longer needed
     */
    public LoadToken getImage(String id, StreamLoader streamLoader, Transformation transformation,
                              Downsampler downsampler, int width, int height, LoadedCallback cb) {
        if (shutdown) return null;

        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);
        LoadToken result = null;
        if (!returnFromCache(key, cb)) {
            ImageManagerJob job = jobs.get(key);
            if (job == null) {
                ImageManagerRunner runner = new ImageManagerRunner(key, streamLoader, transformation, downsampler,
                        width, height);
                job = new ImageManagerJob(runner, key);
                jobs.put(key, job);
                job.addCallback(cb);
                runner.execute();
            } else {
                job.addCallback(cb);
            }
            result = new LoadToken(cb, job);
        }
        return result;
    }

    /**
     * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
     * that Bitmap. This will cause an exception if acquire was not called first, or if each call to release does not
     * come after a call to acquire. If the reference count drops to zero, places the Bitmap into a queue to be
     * recycled. Does nothing if recycling is disabled or impossible.
     *
     * @param b The releasedBitmap
     */
    public void releaseBitmap(final Bitmap b) {
        bitmapReferenceCounter.releaseBitmap(b);
    }

    public void clearMemory() {
        memoryCache.clearMemory();
        bitmapPool.clearMemory();
    }

    public void trimMemory(int level) {
        memoryCache.trimMemory(level);
        bitmapPool.trimMemory(level);
    }

    /**
     * Shuts down all of the background threads used by the ImageManager including the executor service
     */
    @SuppressWarnings("unused")
    public void shutdown() {
        shutdown = true;
        executor.shutdown();
        bgHandler.getLooper().quit();
    }

    private boolean returnFromCache(String key, LoadedCallback cb) {
        Bitmap inCache = memoryCache.get(key);
        boolean found = inCache != null;
        if (found) {
            bitmapReferenceCounter.acquireBitmap(inCache);
            cb.onLoadCompleted(inCache);
        }
        return found;
    }

    /**
     * A class for tracking a particular job in the {@link ImageManager}. Cancel does not guarantee that the
     * job will not finish, but rather is a best effort attempt.
     */
    private class ImageManagerJob {
        private final ImageManagerRunner runner;
        private final String key;
        private final List<LoadedCallback> cbs = new ArrayList<LoadedCallback>();

        public ImageManagerJob(ImageManagerRunner runner, String key) {
            this.runner = runner;
            this.key = key;
        }

        public void addCallback(LoadedCallback cb) {
            cbs.add(cb);
        }

        /**
         * Try to cancel the job. Does not guarantee that the job will not finish.
         */
        public void cancel(LoadedCallback cb) {
            cbs.remove(cb);
            if (cbs.size() == 0) {
                // Note: this is potentially dangerous. The runner asynchronously asks our jobs map for a job
                // matching our key after posting a runnable to the main thread and as a result, the job it gets back
                // may not be this job. We protect against this for cancellation by not delivering failures from
                // cancelled runners, so new jobs will not receive errors from cancelled jobs. However, new jobs may
                // receive results from old runners if the old runner was cancelled, but completed successfully anyway
                // because it received the cancellation too late.
                runner.cancel();
                if (jobs.get(key) == this) {
                    jobs.remove(key);
                }
            }
        }

        public void onLoadComplete(Bitmap result) {
            for (LoadedCallback cb : cbs) {
                bitmapReferenceCounter.acquireBitmap(result);
                cb.onLoadCompleted(result);
            }
            jobs.remove(key);
        }

        public void onLoadFailed(Exception e) {
            for (LoadedCallback cb : cbs) {
                cb.onLoadFailed(e);
            }
            jobs.remove(key);
        }
    }

    private void putInDiskCache(String key, final Bitmap bitmap) {
        diskCache.put(key, new DiskCache.Writer() {
            @Override
            public void write(OutputStream os) {
                Bitmap.CompressFormat compressFormat = getCompressFormat(bitmap);
                bitmap.compress(compressFormat, bitmapCompressQuality, os);
            }
        });
    }

    private Bitmap.CompressFormat getCompressFormat(Bitmap bitmap) {
        final Bitmap.CompressFormat format;
        if (bitmapCompressFormat != null) {
            format = bitmapCompressFormat;
        } else {
            if (bitmap.getConfig() == Bitmap.Config.RGB_565 || !bitmap.hasAlpha()) {
                format = Bitmap.CompressFormat.JPEG;
            } else {
                format = Bitmap.CompressFormat.PNG;
            }
        }
        return format;
    }

    private void putInMemoryCache(String key, final Bitmap bitmap) {
        final boolean inCache;
        inCache = memoryCache.contains(key);
        if (!inCache) {
            bitmapReferenceCounter.acquireBitmap(bitmap);
            memoryCache.put(key, bitmap);
        }
    }

    private class ImageManagerRunner implements Runnable {
        public final String key;
        public final int width;
        public final int height;
        private final StreamLoader streamLoader;
        private final Transformation transformation;
        private final Downsampler downsampler;

        private volatile Future<?> future;
        private volatile boolean isCancelled = false;

        public ImageManagerRunner(String key, StreamLoader sl, Transformation t, Downsampler d, int width, int height) {
            this.key = key;
            this.height = height;
            this.width = width;

            this.streamLoader = sl;
            this.transformation = t;
            this.downsampler = d;
        }

        private void execute() {
            bgHandler.post(this);
        }

        public void cancel() {
            if (isCancelled) {
                return;
            }
            isCancelled = true;

            bgHandler.removeCallbacks(this);

            final Future current = future;
            if (current != null) {
                current.cancel(false);
            }

            if (streamLoader != null) {
                streamLoader.cancel();
            }
        }

        @Override
        public void run() {
            Bitmap result = null;
            try {
                result = getFromDiskCache(key);
            } catch (Exception e) {
                handleException(e);
            }

            if (result == null) {
                try {
                    resizeWithPool();
                } catch (Exception e) {
                    handleException(e);
                }
            } else {
                finishResize(result, true);
            }
        }

        private Bitmap getFromDiskCache(String key) {
            Bitmap result = null;
            final InputStream is = diskCache.get(key);
            if (is != null) {
                result = resizer.load(is, width, height, Downsampler.NONE);
                if (result == null) {
                    diskCache.delete(key); //the image must have been corrupted
                }
            }
            return result;
        }

        private void resizeWithPool() {
            future = executor.submit(new Runnable() {
                @Override
                public void run() {

                    streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
                        @Override
                        public void onStreamReady(final InputStream is) {
                            if (isCancelled) {
                                return;
                            }

                            //this callback might be called on some other thread,
                            //we want to do resizing on our thread, especially if we're called
                            //back on the main thread, so we will resubmit
                            future = executor.submit(new Runnable() {
                                @Override
                                public void run() {
                                    try {
                                        final Bitmap result = resizeIfNotFound(is, downsampler, transformation);
                                        finishResize(result, false);
                                    } catch (Exception e) {
                                        handleException(e);
                                    }
                                }
                            });
                        }

                        @Override
                        public void onException(Exception e) {
                            handleException(e);
                        }
                    });
                }
            });
        }

        private Bitmap resizeIfNotFound(InputStream is, Downsampler downsampler, Transformation transformation) {
            return resizer.load(is, width, height, downsampler, transformation);
        }

        private void finishResize(final Bitmap result, boolean isInDiskCache) {
            if (result != null) {
                if (!isInDiskCache) {
                    putInDiskCache(key, result);
                }

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        // Acquire the bitmap for this runnable until we've finished notifying
                        // all consumers. This prevents the bitmap from being put in the bitmap pool
                        // before all consumers have a change to acquire the bitmap if one of the first
                        // consumers (usually the memory cache) synchronously releases the bitmap.
                        bitmapReferenceCounter.acquireBitmap(result);
                        putInMemoryCache(key, result);
                        final ImageManagerJob job = jobs.get(key);
                        if (job != null) {
                            job.onLoadComplete(result);
                        }
                        // All consumers have had their chance, it's now safe to release the
                        // bitmap.
                        bitmapReferenceCounter.releaseBitmap(result);
                    }
                });
            } else {
                handleException(null);
            }
        }

        private void handleException(final Exception e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Exception loading image", e);
            }
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (isCancelled) {
                        return;
                    }

                    final ImageManagerJob job = jobs.get(key);
                    if (job != null) {
                        job.onLoadFailed(e);
                    }
                }
            });
        }
    }

    public static class LoadToken {
        private final ImageManagerJob job;
        private final LoadedCallback cb;

        public LoadToken(LoadedCallback cb, ImageManagerJob job) {
            this.cb = cb;
            this.job = job;
        }

        public void cancel() {
            job.cancel(cb);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
/*
 * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
 */
package com.bumptech.glide.resize.load;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.media.ExifInterface;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.resize.RecyclableBufferedInputStream;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;

import java.io.InputStream;
import java.util.LinkedList;
import java.util.Queue;

/**
 * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
 */
public class ImageResizer {
    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;

    private static final String TAG = "ImageResizer";
    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
    private final BitmapPool bitmapPool;

    private final BitmapFactory.Options defaultOptions;

    @TargetApi(11)
    public static BitmapFactory.Options getDefaultOptions() {
       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
       decodeBitmapOptions.inDither = false;
       decodeBitmapOptions.inScaled = false;
       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
       decodeBitmapOptions.inSampleSize = 1;
       if (CAN_RECYCLE)  {
           decodeBitmapOptions.inMutable = true;
       }
       return decodeBitmapOptions;
    }

    /**
     * Creates a new resizer that will not recycle Bitmaps
     */
    @SuppressWarnings("unused")
    public ImageResizer() {
        this(null, null);
    }

    @SuppressWarnings("unused")
    public ImageResizer(BitmapPool bitmapPool) {
        this(bitmapPool, null);
    }

    @SuppressWarnings("unused")
    @Deprecated
    public ImageResizer(BitmapFactory.Options options) {
        this(null, options);
    }

    /**
     * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
     *
     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
     */
    @Deprecated
    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
        if (bitmapPool == null) {
            this.bitmapPool = new BitmapPoolAdapter();
        } else {
            this.bitmapPool = bitmapPool;
        }

        if (defaultOptions == null) {
            this.defaultOptions = getDefaultOptions();
        } else {
            this.defaultOptions = defaultOptions;
        }
    }

    public Bitmap load(InputStream is) {
        return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight) {
        return load(is, outWidth, outHeight, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
        return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler) {
        return load(is, outWidth, outHeight, downsampler, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
        byte[] tempBytesForBis = getTempBytes();
        byte[] tempBytesForOptions = getTempBytes();

        BitmapFactory.Options options = getOptions();
        options.inTempStorage = tempBytesForOptions;

        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);

        final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
        final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);

        if (initial != result && !bitmapPool.put(initial)) {
            initial.recycle();
        }

        releaseTempBytes(tempBytesForBis);
        releaseTempBytes(tempBytesForOptions);

        return result;
    }

    private BitmapFactory.Options getOptions() {
        BitmapFactory.Options result = new BitmapFactory.Options();
        copyOptions(defaultOptions, result);
        return result;
    }

    private byte[] getTempBytes() {
        byte[] result;
        synchronized (tempQueue) {
            result = tempQueue.poll();
        }
        if (result == null) {
            result = new byte[TEMP_BYTES_SIZE];
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Created temp bytes");
            }
        }
        return result;
    }

    private void releaseTempBytes(byte[] bytes) {
        synchronized (tempQueue) {
            tempQueue.offer(bytes);
        }
    }

    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
        if (Build.VERSION.SDK_INT >= 11) {
            copyOptionsHoneycomb(from, to);
        } else if (Build.VERSION.SDK_INT >= 10) {
            copyOptionsGingerbreadMr1(from, to);
        } else {
            copyOptionsFroyo(from, to);
        }
    }

    @TargetApi(11)
    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsGingerbreadMr1(from, to);
        to.inMutable = from.inMutable;
    }

    @TargetApi(10)
    private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsFroyo(from, to);
        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
    }

    private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
        to.inDensity = from.inDensity;
        to.inDither = from.inDither;
        to.inInputShareable = from.inInputShareable;
        to.inPreferredConfig = from.inPreferredConfig;
        to.inPurgeable = from.inPurgeable;
        to.inSampleSize = from.inSampleSize;
        to.inScaled = from.inScaled;
        to.inScreenDensity = from.inScreenDensity;
        to.inTargetDensity = from.inTargetDensity;
    }

    /**
     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
     * as well.
     *
     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
     *                 into
     * @param toCrop The Bitmap to resize
     * @param width The width of the final Bitmap
     * @param height The height of the final Bitmap
     * @return The resized Bitmap (will be recycled if recycled is not null)
     */
    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
        if (toCrop == null) {
            return null;
        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
            return toCrop;
        }
        //from ImageView/Bitmap.createScaledBitmap
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
        final float scale;
        float dx = 0, dy = 0;
        Matrix m = new Matrix();
        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
            scale = (float) height / (float) toCrop.getHeight();
            dx = (width - toCrop.getWidth() * scale) * 0.5f;
        } else {
            scale = (float) width / (float) toCrop.getWidth();
            dy = (height - toCrop.getHeight() * scale) * 0.5f;
        }

        m.setScale(scale, scale);
        m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
        final Bitmap result;
        if (recycled != null) {
            result = recycled;
        } else {
            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
        }
        Canvas canvas = new Canvas(result);
        Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toCrop, m, paint);
        return result;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its width
     * matches the given width
     *
     * @param toShrink The Bitmap to shrink
     * @param width The width of the final Bitmap
     * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
     */
    public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
        Bitmap shrunk = toShrink;
        float widthPercent = ((float) width/toShrink.getWidth());
        if (widthPercent != 1) {
            int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
            shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its height
     * matches the given height
     *
     * @param toShrink The Bitmap to shrink
     * @param height The height of the final Bitmap
     * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
     *          height
     */
    public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
        Bitmap shrunk = toShrink;
        float heightPercent = ((float) height/toShrink.getHeight());
        if (heightPercent != 1) {
            int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
            shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
     * the original proportions
     *
     * @param toFit The Bitmap to shrink
     * @param width The width the final image will fit within
     * @param height The height the final image will fit within
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    @Deprecated
    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
        if (toFit == null) return null;

        if (height > width){
            return shrinkToWidth(toFit, width);
        } else {
            return shrinkToHeight(toFit, height);
        }
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain
     * the original proportions.
     *
     * @param toFit The Bitmap to shrink.
     * @param pool The BitmapPool to try to reuse a bitmap from.
     * @param width The width the final image will fit within.
     * @param height The height the final image will fit within.
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
         final float shrinkPercentage;
        final int targetWidth;
        final int targetHeight;
        if (height > width) {
            shrinkPercentage = width / (float) toFit.getWidth();
            targetWidth = width;
            targetHeight = Math.round(shrinkPercentage * toFit.getHeight());
        } else {
            shrinkPercentage = height / (float) toFit.getHeight();
            targetWidth = Math.round(shrinkPercentage * toFit.getWidth());
            targetHeight = height;
        }

        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
        if (toReuse == null) {
            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
        }
        Canvas canvas = new Canvas(toReuse);
        Matrix matrix = new Matrix();
        matrix.setScale(shrinkPercentage, shrinkPercentage);
        Paint paint = new Paint(ImageResizer.PAINT_FLAGS);
        canvas.drawBitmap(toFit, matrix, paint);

        return toReuse;
    }


    /**
     * Returns a matrix with rotation set based on Exif orientation tag.
     * If the orientation is undefined or 0 null is returned.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @return  A rotation in degrees based on exif orientation
     */
    public static int getOrientation(String pathToOriginal) {
        int degreesToRotate = 0;
        try{
            ExifInterface exif = new ExifInterface(pathToOriginal);
            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
                degreesToRotate = 90;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
                degreesToRotate = 180;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
                degreesToRotate = 270;
            }
        } catch (Exception e){
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
            }
        }
        return degreesToRotate;
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @param imageToOrient Image Bitmap to orient.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    @SuppressWarnings("unused")
    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
        int degreesToRotate = getOrientation(pathToOriginal);
        return rotateImage(imageToOrient, degreesToRotate);
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param imageToOrient Image Bitmap to orient.
     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
        try{
            if(degreesToRotate != 0) {
                Matrix matrix = new Matrix();
                matrix.setRotate(degreesToRotate);
                imageToOrient = Bitmap.createBitmap(
                        imageToOrient,
                        0,
                        0,
                        imageToOrient.getWidth(),
                        imageToOrient.getHeight(),
                        matrix,
                        true);
            }
        } catch (Exception e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception when trying to orient image", e);
            }
            e.printStackTrace();
        }
        return imageToOrient;
    }

    /**
     * Get the # of degrees an image must be rotated to match the given exif orientation.
     *
     * @param exifOrientation The exif orientation [1-8]
     * @return the number of degrees to rotate
     */
    public static int getExifOrientationDegrees(int exifOrientation) {
        final int degreesToRotate;
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_TRANSPOSE:
            case ExifInterface.ORIENTATION_ROTATE_90:
                degreesToRotate = 90;
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                degreesToRotate = 180;
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
            case ExifInterface.ORIENTATION_ROTATE_270:
                degreesToRotate = 270;
                break;
            default:
                degreesToRotate = 0;

        }
        return degreesToRotate;
    }

    /**
     * Rotate and/or flip the image to match the given exif orientation
     *
     * @param toOrient The bitmap to rotate/flip
     * @param pool A pool that may or may not contain an image of the necessary dimensions
     * @param exifOrientation the exif orientation [1-8]
     * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary
     */
    public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
        final Matrix matrix = new Matrix();
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                matrix.setScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
                matrix.setRotate(180);
                break;
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                matrix.setRotate(180);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_TRANSPOSE:
                matrix.setRotate(90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_90:
                matrix.setRotate(90);
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
                matrix.setRotate(-90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_270:
                matrix.setRotate(-90);
                break;
            default: //case ExifInterface.ORIENTATION_NORMAL
                return toOrient;
        }

        // From Bitmap.createBitmap.
        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
        matrix.mapRect(newRect);

        final int newWidth = Math.round(newRect.width());
        final int newHeight = Math.round(newRect.height());

        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
        if (result == null) {
            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
        }

        matrix.postTranslate(-newRect.left, -newRect.top);

        final Canvas canvas = new Canvas(result);
        final Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toOrient, matrix, paint);

        return result;
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
=======
    public final int access;
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) { // only for tests, so we can ignore the tag
        this(-1, new MethodSignature(name, desc), Type.getType(owner), kind);
=======
    public MethodInfo(String name, String desc, Class<?> owner, MethodKind kind) {
        // only for tests, so we can ignore the tag and access
        this(0, -1, new MethodSignature(name, desc), Type.getType(owner), kind);
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
    public MethodInfo(int tag, MethodSignature signature, Type owner, MethodKind kind) {
=======
    public MethodInfo(int access, int tag, MethodSignature signature, Type owner, MethodKind kind) {
        this.access = access;
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/MethodInfo.java;<<<<<<< MINE
                .addValue("(" + tag + ")")
=======
                .addValue("(tag=" + tag + ", access=" + access + ")")
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/UpdateRelocatedMethodInvocations.java;<<<<<<< MINE
    private final ClassHierarchyAnalyzer analyzer;
=======
    private final ClassAnalyzer analyzer;
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/UpdateRelocatedMethodInvocations.java;<<<<<<< MINE
    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {
=======
    public UpdateRelocatedMethodInvocations(ClassVisitor next, ClassAnalyzer analyzer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/AddMethodDefaultImplementations.java;<<<<<<< MINE
    private final ClassHierarchyAnalyzer analyzer;
=======
    private final ClassAnalyzer analyzer;
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/retrolambda/src/main/java/net/orfjackal/retrolambda/interfaces/AddMethodDefaultImplementations.java;<<<<<<< MINE
    public AddMethodDefaultImplementations(ClassVisitor next, ClassHierarchyAnalyzer analyzer) {
=======
    public AddMethodDefaultImplementations(ClassVisitor next, ClassAnalyzer analyzer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/end-to-end-tests/src/test/java/net/orfjackal/retrolambda/test/anotherpackage/DifferentPackageBase.java;<<<<<<< MINE
=======
// Copyright Â© 2013-2016 Esko Luontola <www.orfjackal.net>
// This software is released under the Apache License 2.0.
// The license text is at http://www.apache.org/licenses/LICENSE-2.0

package net.orfjackal.retrolambda.test.anotherpackage;

public class DifferentPackageBase {
    protected static String value() {
        return "Hello";
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_42a30b8_b55a454/rev_42a30b8-b55a454/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                disconnectAndResubscribe();
=======
                disconnectAndResubscribe(error);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
  private final RequestQueue requestQueue;
=======
    /**
     * The default factory for {@link VolleyUrlLoader}s.
     */
    public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
        private static RequestQueue internalQueue;
        private RequestQueue requestQueue;
        private final VolleyRequestFactory requestFactory;

        private static RequestQueue getInternalQueue(Context context) {
            if (internalQueue == null) {
                synchronized (Factory.class) {
                    if (internalQueue == null) {
                        internalQueue = Volley.newRequestQueue(context);
                    }
                }
            }
            return internalQueue;
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    /**
     * Constructor for a new Factory that runs requests using a static singleton request queue.
     */
    public Factory(Context context) {
      this(getInternalQueue(context));
    }
=======
        /**
         * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
         */
        public Factory(RequestQueue requestQueue) {
            this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
        }

        /**
         * Constructor for a new Factory with a custom Volley request factory that runs requests
         * using the given {@link RequestQueue}.
         */
        public Factory(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
            this.requestFactory = requestFactory;
            this.requestQueue = requestQueue;
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    /**
     * Constructor for a new Factory that runs requests using the given {@link RequestQueue}.
     */
    public Factory(RequestQueue requestQueue) {
      this.requestQueue = requestQueue;
=======
        @Override
        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
            return new VolleyUrlLoader(requestQueue, requestFactory);
        }

        @Override
        public void teardown() {
            // Do nothing, this instance doesn't own the request queue.
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    @Override
    public ModelLoader<GlideUrl, InputStream> build(Context context,
        MultiModelLoaderFactory multiFactory) {
      return new VolleyUrlLoader(requestQueue);
=======
    private final RequestQueue requestQueue;
    private final VolleyRequestFactory requestFactory;

    public VolleyUrlLoader(RequestQueue requestQueue) {
        this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
    }

    public VolleyUrlLoader(RequestQueue requestQueue, VolleyRequestFactory requestFactory) {
        this.requestQueue = requestQueue;
        this.requestFactory = requestFactory;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    public void teardown() {
      // Do nothing, this instance doesn't own the request queue.
=======
    public DataFetcher<InputStream> getResourceFetcher(GlideUrl url, int width, int height) {
        return new VolleyStreamFetcher(
            requestQueue, url, new VolleyRequestFuture<InputStream>(), requestFactory);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
  private final RequestQueue requestQueue;
  private final GlideUrl url;
  private VolleyRequestFuture<InputStream> requestFuture;

  @SuppressWarnings("unused")
  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
    this(requestQueue, url, null);
  }

  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
      VolleyRequestFuture<InputStream> requestFuture) {
    this.requestQueue = requestQueue;
    this.url = url;
    this.requestFuture = requestFuture;
    if (requestFuture == null) {
      this.requestFuture = VolleyRequestFuture.newFuture();
    }
  }

  @Override
  public InputStream loadData(Priority priority) throws Exception {
    // Make sure the string url safely encodes non ascii characters.
    String stringUrl = url.toURL().toString();
    GlideRequest request =
        new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));

    requestFuture.setRequest(requestQueue.add(request));

    return requestFuture.get();
  }

  @Override
  public void cleanup() {
    // Do nothing.
  }

  @Override
  public String getId() {
    return url.toString();
  }

  @Override
  public void cancel() {
    VolleyRequestFuture<InputStream> localFuture = requestFuture;
    if (localFuture != null) {
      localFuture.cancel(true);
    }
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  private static Request.Priority glideToVolleyPriority(Priority priority) {
    switch (priority) {
      case LOW:
        return Request.Priority.LOW;
      case HIGH:
        return Request.Priority.HIGH;
      case IMMEDIATE:
        return Request.Priority.IMMEDIATE;
      default:
        return Request.Priority.NORMAL;

    }
  }

  private static class GlideRequest extends Request<byte[]> {
    private final VolleyRequestFuture<InputStream> future;
    private Priority priority;

    public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
      super(Method.GET, url, future);
      this.future = future;
      this.priority = priority;
=======
    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {

        @Override
        public Request<byte[]> create(
                    String url, VolleyRequestFuture<InputStream> future,
                    Request.Priority priority) {
            return new GlideRequest(url, future, priority);
        }

    };

    private final RequestQueue requestQueue;
    private final VolleyRequestFactory requestFactory;
    private final GlideUrl url;
    private VolleyRequestFuture<InputStream> requestFuture;

    @SuppressWarnings("unused")
    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
        this(requestQueue, url,  null);
    }

    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
            VolleyRequestFuture<InputStream> requestFuture) {
        this(requestQueue, url, requestFuture, DEFAULT_REQUEST_FACTORY);
    }

    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
            VolleyRequestFuture<InputStream> requestFuture, VolleyRequestFactory requestFactory) {
        this.requestQueue = requestQueue;
        this.url = url;
        this.requestFactory = requestFactory;
        this.requestFuture = requestFuture;
        if (requestFuture == null) {
            this.requestFuture = VolleyRequestFuture.newFuture();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public Priority getPriority() {
      return priority;
=======
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toURL().toString();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority));

        requestFuture.setRequest(requestQueue.add(request));

        return requestFuture.get();
    }

    @Override
    public void cleanup() {
        // Do nothing.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    protected void deliverResponse(byte[] response) {
      future.onResponse(new ByteArrayInputStream(response));
=======
    public void cancel() {
        VolleyRequestFuture<InputStream> localFuture = requestFuture;
        if (localFuture != null) {
            localFuture.cancel(true);
        }
    }

    private static Request.Priority glideToVolleyPriority(Priority priority) {
        switch (priority) {
            case LOW:
                return Request.Priority.LOW;
            case HIGH:
                return Request.Priority.HIGH;
            case IMMEDIATE:
                return Request.Priority.IMMEDIATE;
            default:
                return Request.Priority.NORMAL;

        }
    }

    private static class GlideRequest extends Request<byte[]> {
        private final VolleyRequestFuture<InputStream> future;
        private final Priority priority;

        public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
            super(Method.GET, url, future);
            this.future = future;
            this.priority = priority;
        }

        @Override
        public Priority getPriority() {
            return priority;
        }

        @Override
        protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
            return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
        }

        @Override
        protected void deliverResponse(byte[] response) {
            future.onResponse(new ByteArrayInputStream(response));
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java;<<<<<<< MINE
=======
package com.bumptech.glide;

import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.widget.ImageView;

import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.tests.BackgroundUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

@SuppressWarnings("unchecked")
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestBuilderTest {
    private RequestTracker requestTracker;

    @Before
    public void setUp() {
        requestTracker = mock(RequestTracker.class);
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsIfContextIsNull() {
        new GenericRequestBuilder(null, Object.class, mock(LoadProvider.class), Object.class, mock(Glide.class),
                requestTracker, mock(Lifecycle.class));
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsIfNonNullModelAndNullLoadProvider() {
        new GenericRequestBuilder(Robolectric.application, Object.class, null, Object.class, mock(Glide.class),
                requestTracker, mock(Lifecycle.class));
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenGlideAnimationFactoryIsNull() {
        getNullModelRequest().animate((GlideAnimationFactory) null);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideWidthLessThanZero() {
        getNullModelRequest().override(-1, 100);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideWidthEqualToZero() {
        getNullModelRequest().override(0, 100);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideHeightLessThanZero() {
        getNullModelRequest().override(100, -5);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideHeightEqualToZero() {
        getNullModelRequest().override(100, 0);
    }

    @Test
    public void testDoesNotThrowWhenWidthIsSizeOriginal() {
        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);
    }

    @Test
    public void testDoesNotThrowWhenHeightIsSizeOriginal() {
        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);
    }

    @Test
    public void testDoesNotThrowWhenModelAndLoaderNull() {
        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,
                mock(Lifecycle.class));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testProvidingSelfAsThumbnailThrows() {
        GenericRequestBuilder request = getNullModelRequest();
        request.thumbnail(request);
    }

    @Test(expected = IllegalStateException.class)
    public void testProvidingSelfAsChildOfThumbnailThrows() {
        GenericRequestBuilder first = getNullModelRequest();
        GenericRequestBuilder second = first.clone();
        second.thumbnail(first);
        first.thumbnail(second);
        first.into(mock(Target.class));
    }

    @Test
    public void testCanPassedClonedSelfToThumbnail() {
        GenericRequestBuilder first = getNullModelRequest();
        GenericRequestBuilder second = first.clone();
        GenericRequestBuilder third = second.clone();
        first.thumbnail(second.thumbnail(third)).into(mock(Target.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenDecoderSet() {
        getNullModelRequest().decoder(mock(ResourceDecoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenCacheDecoderSet() {
        getNullModelRequest().cacheDecoder(mock(ResourceDecoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenEncoderSet() {
        getNullModelRequest().encoder(mock(ResourceEncoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenDiskCacheStrategySet() {
        getNullModelRequest().diskCacheStrategy(DiskCacheStrategy.ALL);
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
        getNullModelRequest().into(mock(Target.class));
    }

    @Test
    public void testAddsNewRequestToRequestTracker() {
        getNullModelRequest().into(mock(Target.class));
        verify(requestTracker).runRequest(any(Request.class));
    }

    @Test
    public void testRemovesPreviousRequestFromRequestTracker() {
        Request previous = mock(Request.class);
        Target target = mock(Target.class);
        when(target.getRequest()).thenReturn(previous);

        getNullModelRequest().into(target);

        verify(requestTracker).removeRequest(eq(previous));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullTarget() {
        getNullModelRequest().into((Target) null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullView() {
        getNullModelRequest().into((ImageView) null);
    }

    @Test(expected = RuntimeException.class)
    public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
        final ImageView imageView = new ImageView(Robolectric.application);
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                getNullModelRequest().into(imageView);

            }
        });
    }

    @Test(expected = RuntimeException.class)
    public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
        final Target target = mock(Target.class);
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                getNullModelRequest().into(target);
            }
        });
    }

    private GenericRequestBuilder getNullModelRequest() {
        Glide glide = mock(Glide.class);
        when(glide.buildImageViewTarget(any(ImageView.class), any(Class.class))).thenReturn(
                mock(Target.class));
        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,
                mock(Lifecycle.class)).load(null);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.request;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestTest {
    private RequestHarness harness;

    /**
     * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
     * Both are in the middle of the hierarchy having multiple descendants and ancestors.
     */
    @SuppressWarnings("unchecked")
    private static class RequestHarness {
        ModelLoader<Number, Object> modelLoader;
        Engine engine = mock(Engine.class);
        Number model = 123456;
        Target<List> target = mock(Target.class);
        Context context = Robolectric.application;
        Resource<List> resource = mock(Resource.class);
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        Priority priority = Priority.NORMAL;
        int placeholderResourceId = 0;
        Drawable placeholderDrawable = null;
        int errorResourceId = 0;
        Transformation transformation = mock(Transformation.class);
        Drawable errorDrawable = null;
        LoadProvider<Number, Object, Object, List> loadProvider = mock(LoadProvider.class);
        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
        Encoder<Object> sourceEncoder = mock(Encoder.class);
        RequestListener<Number, List> requestListener = mock(RequestListener.class);
        boolean skipMemoryCache;
        GlideAnimationFactory<List> factory = mock(GlideAnimationFactory.class);
        int overrideWidth = -1;
        int overrideHeight = -1;
        List result = new ArrayList();
        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
        Key signature = mock(Key.class);

        public RequestHarness() {
            modelLoader = mock(ModelLoader.class);
            when(modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt()))
                    .thenReturn(mock(DataFetcher.class));
            when(loadProvider.getModelLoader()).thenReturn(modelLoader);
            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
            when(loadProvider.getEncoder()).thenReturn(encoder);
            when(loadProvider.getTranscoder()).thenReturn(transcoder);
            when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
            when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);

            when(resource.get()).thenReturn(result);
        }

        public GenericRequest<Number, Object, Object, List> getRequest() {
            return GenericRequest.obtain(loadProvider,
                    model,
                    signature,
                    context,
                    priority,
                    target,
                    1f,
                    placeholderDrawable,
                    placeholderResourceId,
                    errorDrawable,
                    errorResourceId,
                    requestListener,
                    requestCoordinator,
                    engine,
                    transformation,
                    List.class,
                    skipMemoryCache,
                    factory,
                    overrideWidth,
                    overrideHeight,
                    diskCacheStrategy);
        }
    }

    @Before
    public void setUp() {
        harness = new RequestHarness();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testReturnsWhenMissingCacheDecoderAndNeeded3() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingCacheDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenMissingTranscoder() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getTranscoder()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testThrowsWhenMissingModelLoader() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getModelLoader()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenTransformationIsNull() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            harness.transformation = null;

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testIsNotCompleteBeforeReceivingResource() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isComplete());
    }

    @Test
    public void testCanHandleNullResources() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);

        assertTrue(request.isFailed());
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleEmptyResources() {
        GenericRequest request = harness.getRequest();
        when(harness.resource.get()).thenReturn(null);

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleNonConformingResources() {
        GenericRequest request = harness.getRequest();
        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testIsNotFailedAfterClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.clear();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsPausedAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertTrue(request.isPaused());
    }

    @Test
    public void testIsNotCancelledAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertFalse(request.isCancelled());
    }

    @Test
    public void testIsNotPausedAfterBeginningWhilePaused() {
        GenericRequest request = harness.getRequest();
        request.pause();
        request.begin();

        assertFalse(request.isPaused());
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotFailedAfterBegin() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.begin();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsCompleteAfterReceivingResource() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        assertTrue(request.isComplete());
    }

    @Test
    public void testIsNotCompleteAfterClear() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);
        request.clear();

        assertFalse(request.isComplete());
    }

    @Test
    public void testIsCancelledAfterClear() {
        GenericRequest request = harness.getRequest();
        request.clear();

        assertTrue(request.isCancelled());
    }

    @Test
    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
        GenericRequest request = harness.getRequest();
        request.clear();
        request.clear();

        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
    }

    @Test
    public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Request request = (Request) invocation.getArguments()[0];
                assertFalse(request.isComplete());
                return true;
            }
        }).when(requestCoordinator).canSetImage(any(Request.class));

        harness.requestCoordinator = requestCoordinator;
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        verify(requestCoordinator).canSetImage(eq(request));
    }

    @Test
    public void testIsNotFailedWithoutException() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsFailedAfterException() {
        GenericRequest request = harness.getRequest();

        request.onException(new Exception("test"));
        assertTrue(request.isFailed());
    }

    @Test
    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onSizeReady(100, 100);
        request.onSizeReady(100, 100);

        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testIsFailedAfterNoResultAndNullException() {
        GenericRequest request = harness.getRequest();

        request.onException(null);
        assertTrue(request.isFailed());
    }

    @Test
    public void testEngineLoadPassedCorrectPriority() {
        Priority expected = Priority.HIGH;
        harness.priority = expected;
        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);

        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testEngineLoadCancelledOnCancel() {
        Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenReturn(loadStatus);

        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);
        request.cancel();

        verify(loadStatus).cancel();
    }

    @Test
    public void testResourceIsRecycledOnClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);
        request.clear();

        verify(harness.engine).release(eq(harness.resource));
    }

    @Test
    public void testPlaceholderResourceIsSet() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.placeholderResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableIsSet() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorResourceIsSetOnLoadFailed() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.errorResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableIsSetOnLoadFailed() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.errorDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void setTestPlaceholderDrawableSetOnNullModel() {
        Drawable placeholder = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(placeholder, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableSetOnNullModel() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(errorPlaceholder, target.currentPlaceholder);
    }

    @Test
    public void testIsNotRunningBeforeRunCalled() {
        assertFalse(harness.getRequest().isRunning());
    }

    @Test
    public void testIsRunningAfterRunCalled() {
        Request request = harness.getRequest();
        request.begin();
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterComplete() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onResourceReady(harness.resource);

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterFailing() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onException(new RuntimeException("Test"));

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterClear() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.clear();

        assertFalse(request.isRunning());
    }

    @Test
    public void testCallsTargetOnResourceReadyIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.target, never()).onResourceReady(any(List.class), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnExceptionIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        Exception exception = new IOException("test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(false);
        Exception exception = new IOException("Test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(true);

        request.onException(new IllegalArgumentException("test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testRequestListenerIsCalledWithResourceResult() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithModel() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), eq(harness.model), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithTarget() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
        final GenericRequest request = harness.getRequest();
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(),  any(DiskCacheStrategy.class),
                any(ResourceCallback.class))).thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        request.onResourceReady(harness.resource);
                        return null;
                    }
                });

        request.begin();
        request.onSizeReady(100, 100);
        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(true), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
        GenericRequest request = harness.getRequest();
        request.onSizeReady(100, 100);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(false), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
        harness.requestCoordinator = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(false));
    }

    @Test
    public void testTargetIsCalledWithAnimationFromFactory() {
        GenericRequest request = harness.getRequest();
        GlideAnimation<List> glideAnimation = mock(GlideAnimation.class);
        when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(glideAnimation);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), eq(glideAnimation));
    }

    @Test
    public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
        harness.overrideWidth = -1;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
        harness.overrideHeight = -1;
        harness.overrideWidth = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
        harness.overrideWidth = 100;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
        harness.overrideWidth = 1;
        harness.overrideHeight = 2;

        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(harness.overrideWidth), eq(harness.overrideHeight),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    @Test
    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
        harness.errorDrawable = new ColorDrawable(Color.RED);
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
        request.onException(new IOException("Test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testCanReRunCancelledRequests() {
        doAnswer(new CallSizeReady(100, 100)).when(harness.target)
                .getSize(any(SizeReadyCallback.class));
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenAnswer(new CallResourceCallback(harness.resource));
        GenericRequest request = harness.getRequest();

        request.begin();
        request.cancel();
        request.begin();

        verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testResourceOnlyReceivesOneGetOnResourceReady() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.resource, times(1)).get();
    }

    @Test
    public void testOnSizeReadyWithNullDataFetcherCallsOnException() {
        GenericRequest request = harness.getRequest();
        when(harness.modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt())).thenReturn(null);
        request.begin();
        request.onSizeReady(100, 100);

        verify(harness.requestListener).onException(any(Exception.class), any(Number.class), any(Target.class),
                anyBoolean());
    }

    @Test
    public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
        GenericRequest request = harness.getRequest();
        request.cancel();
        request.onSizeReady(100, 100);

        verify(harness.engine, never()).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testStartsLoadImmediatelyWhenGivenOverrideWithSizeOriginal() {
        harness.overrideWidth = Target.SIZE_ORIGINAL;
        harness.overrideHeight = Target.SIZE_ORIGINAL;
        GenericRequest<Number, Object, Object, List> request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(Target.SIZE_ORIGINAL), eq(Target.SIZE_ORIGINAL),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    private static class CallResourceCallback implements Answer {

        private Resource resource;

        public CallResourceCallback(Resource resource) {
            this.resource = resource;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            ResourceCallback cb = (ResourceCallback)
                    invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 1];
            cb.onResourceReady(resource);
            return null;
        }
    }

    private static class CallSizeReady implements Answer {

        private int width;
        private int height;

        public CallSizeReady(int width, int height) {
            this.width = width;
            this.height = height;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            SizeReadyCallback cb =
                    (SizeReadyCallback) invocationOnMock.getArguments()[0];
            cb.onSizeReady(width, height);
            return null;
        }
    }

    private Context mockContextToReturn(int resourceId, Drawable drawable) {
        Resources resources = mock(Resources.class);
        Context context = mock(Context.class);

        when(context.getApplicationContext()).thenReturn(context);
        when(context.getResources()).thenReturn(resources);
        when(resources.getDrawable(eq(resourceId))).thenReturn(drawable);

        return context;
    }

    private static class MockTarget implements Target {
        private Drawable currentPlaceholder;

        @Override
        public void onLoadCleared(Drawable placeholder) {
            currentPlaceholder = placeholder;
        }

        @Override
        public void onLoadStarted(Drawable placeholder) {
            currentPlaceholder = placeholder;

        }

        @Override
        public void onLoadFailed(Exception e, Drawable errorDrawable) {
            currentPlaceholder = errorDrawable;

        }

        @Override
        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
            currentPlaceholder = null;
        }


        @Override
        public void getSize(SizeReadyCallback cb) {
        }

        @Override
        public void setRequest(Request request) {
        }

        @Override
        public Request getRequest() {
            return null;
        }

        @Override
        public void onStart() {
        }

        @Override
        public void onStop() {

        }

        @Override
        public void onDestroy() {

        }
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.resource.bitmap;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.graphics.Bitmap;

import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.tests.Util;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class StreamBitmapDecoderTest {
    private DecoderHarness harness;

    @Before
    public void setUp() {
        harness = new DecoderHarness();
    }

    @Test
    public void testNonNullResourceIsReturned() {
        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
                eq(harness.height), eq(harness.decodeFormat))).thenReturn(harness.result);
        assertNotNull(harness.decode());
    }

    @Test
    public void testNullResourceIsReturnedForNullBitmap() {
        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
                eq(harness.height), eq(harness.decodeFormat))).thenReturn(null);
        assertNull(harness.decode());
    }

    @Test
    public void testHasValidId() {
        String downsamplerId = "downsamplerId";
        when(harness.downsampler.getId()).thenReturn(downsamplerId);

        String actualId = harness.decoder.getId();
        assertThat(actualId).contains(downsamplerId);
        assertThat(actualId).contains(harness.decodeFormat.toString());
        assertThat(actualId).contains(Util.getExpectedClassId(StreamBitmapDecoder.class));
    }

    private static class DecoderHarness {
        Downsampler downsampler = mock(Downsampler.class);
        BitmapPool bitmapPool = mock(BitmapPool.class);
        DecodeFormat decodeFormat = DecodeFormat.PREFER_ARGB_8888;
        InputStream source = new ByteArrayInputStream(new byte[0]);
        int width = 100;
        int height = 100;
        Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        StreamBitmapDecoder decoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);

        public DecoderHarness() {
        }

        public Resource decode() {
            return decoder.decode(source, width, height);
        }

    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
  private static final String TAG = "Glide";
  private final Context context;
=======
    private final Context context;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
  private Engine engine;
  private BitmapPool bitmapPool;
  private MemoryCache memoryCache;
  private ExecutorService sourceService;
  private ExecutorService diskCacheService;
  private DecodeFormat decodeFormat;
  private DiskCache.Factory diskCacheFactory;

  public GlideBuilder(Context context) {
    this.context = context.getApplicationContext();
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use
   * to store and retrieve reused {@link android.graphics.Bitmap}s.
   *
   * @param bitmapPool The pool to use.
   * @return This builder.
   */
  public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
    this.bitmapPool = bitmapPool;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
   * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
   *
   * @param memoryCache The cache to use.
   * @return This builder.
   */
  public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
    this.memoryCache = memoryCache;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
   * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
   *
   * @param diskCache The disk cache to use.
   * @return This builder.
   * @deprecated Creating a disk cache directory on the main thread causes strict mode violations,
   * use {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead.
   * Scheduled to be removed in Glide 4.0.
   */
  @Deprecated
  public GlideBuilder setDiskCache(final DiskCache diskCache) {
    return setDiskCache(new DiskCache.Factory() {
      @Override
      public DiskCache build() {
        return diskCache;
      }
    });
  }

  /**
   * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use
   * to construct the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store {@link
   * com.bumptech.glide.load.engine.Resource} data on disk.
   *
   * @param diskCacheFactory The disk cche factory to use.
   * @return This builder.
   */
  public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
    this.diskCacheFactory = diskCacheFactory;
    return this;
  }

  /**
   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
   *
   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
   * for thumbnail requests to work properly. </p>
   *
   * @param service The ExecutorService to use.
   * @return This builder.
   * @see #setDiskCacheService(java.util.concurrent.ExecutorService)
   * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
   */
  public GlideBuilder setResizeService(ExecutorService service) {
    this.sourceService = service;
    return this;
  }

  /**
   * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
   *
   * <p> Any implementation must order requests based on their {@link com.bumptech.glide.Priority}
   * for thumbnail requests to work properly. </p>
   *
   * @param service The ExecutorService to use.
   * @return This builder.
   * @see #setResizeService(java.util.concurrent.ExecutorService)
   * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
   */
  public GlideBuilder setDiskCacheService(ExecutorService service) {
    this.diskCacheService = service;
    return this;
  }

  /**
   * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all
   * the default decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link
   * android.graphics.Bitmap}s they decode.
   *
   * <p> Decode format is always a suggestion, not a requirement. See {@link
   * com.bumptech.glide.load.DecodeFormat} for more details. </p>
   *
   * <p> If you instantiate and use a custom decoder, it will use {@link
   * com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default. </p>
   *
   * <p> Calls to this method are ignored on KitKat and Lollipop. See #301. </p>
   *
   * @param decodeFormat The format to use.
   * @return This builder.
   */
  public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
    if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {
      this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");
      }
    } else {
      this.decodeFormat = decodeFormat;
    }
    return this;
  }

  // For testing.
  GlideBuilder setEngine(Engine engine) {
    this.engine = engine;
    return this;
  }

  Glide createGlide() {
    if (sourceService == null) {
      final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());
      sourceService = new FifoPriorityThreadPoolExecutor(cores);
    }
    if (diskCacheService == null) {
      diskCacheService = new FifoPriorityThreadPoolExecutor(1);
    }

    MemorySizeCalculator calculator = new MemorySizeCalculator(context);
    if (bitmapPool == null) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        int size = calculator.getBitmapPoolSize();
        if (DecodeFormat.REQUIRE_ARGB_8888) {
          bitmapPool = new LruBitmapPool(size, Collections.singleton(Bitmap.Config.ARGB_8888));
        } else {
          bitmapPool = new LruBitmapPool(size);
        }
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
=======
    private Engine engine;
    private BitmapPool bitmapPool;
    private MemoryCache memoryCache;
    private ExecutorService sourceService;
    private ExecutorService diskCacheService;
    private DecodeFormat decodeFormat;
    private DiskCache.Factory diskCacheFactory;

    public GlideBuilder(Context context) {
        this.context = context.getApplicationContext();
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} implementation to use to store and
     * retrieve reused {@link android.graphics.Bitmap}s.
     *
     * @param bitmapPool The pool to use.
     * @return This builder.
     */
    public GlideBuilder setBitmapPool(BitmapPool bitmapPool) {
        this.bitmapPool = bitmapPool;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.MemoryCache} implementation to store
     * {@link com.bumptech.glide.load.engine.Resource}s that are not currently in use.
     *
     * @param memoryCache  The cache to use.
     * @return This builder.
     */
    public GlideBuilder setMemoryCache(MemoryCache memoryCache) {
        this.memoryCache = memoryCache;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache} implementation to use to store
     * {@link com.bumptech.glide.load.engine.Resource} data and thumbnails.
     *
     * @deprecated Creating a disk cache directory on the main thread causes strict mode violations, use
     * {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead. Scheduled to be removed
     * in Glide 4.0.
     * @param diskCache The disk cache to use.
     * @return This builder.
     */
    @Deprecated
    public GlideBuilder setDiskCache(final DiskCache diskCache) {
        return setDiskCache(new DiskCache.Factory() {
            @Override
            public DiskCache build() {
                return diskCache;
            }
        });
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use to construct
     * the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store
     * {@link com.bumptech.glide.load.engine.Resource} data on disk.
     *
     * @param diskCacheFactory The disk cche factory to use.
     * @return This builder.
     */
    public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {
        this.diskCacheFactory = diskCacheFactory;
        return this;
    }

    /**
     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
     * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache.
     *
     * <p>
     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
     *     requests to work properly.
     * </p>
     *
     * @see #setDiskCacheService(java.util.concurrent.ExecutorService)
     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
     *
     * @param service The ExecutorService to use.
     * @return This builder.
     */
    public GlideBuilder setResizeService(ExecutorService service) {
        this.sourceService = service;
        return this;
    }

    /**
     * Sets the {@link java.util.concurrent.ExecutorService} implementation to use when retrieving
     * {@link com.bumptech.glide.load.engine.Resource}s that are currently in cache.
     *
     * <p>
     *     Any implementation must order requests based on their {@link com.bumptech.glide.Priority} for thumbnail
     *     requests to work properly.
     * </p>
     *
     * @see #setResizeService(java.util.concurrent.ExecutorService)
     * @see com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor
     *
     * @param service The ExecutorService to use.
     * @return This builder.
     */
    public GlideBuilder setDiskCacheService(ExecutorService service) {
        this.diskCacheService = service;
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.DecodeFormat} that will be the default format for all the default
     * decoders that can change the {@link android.graphics.Bitmap.Config} of the {@link android.graphics.Bitmap}s they
     * decode.
     *
     * <p>
     *     Decode format is always a suggestion, not a requirement. See {@link com.bumptech.glide.load.DecodeFormat} for
     *     more details.
     * </p>
     *
     * <p>
     *     If you instantiate and use a custom decoder, it will use
     *     {@link com.bumptech.glide.load.DecodeFormat#DEFAULT} as its default.
     * </p>
     *
     * <p>
     *     Calls to this method are ignored on KitKat and Lollipop. See #301.
     * </p>
     *
     * @param decodeFormat The format to use.
     * @return This builder.
     */
    public GlideBuilder setDecodeFormat(DecodeFormat decodeFormat) {
        this.decodeFormat = decodeFormat;
        return this;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
    if (engine == null) {
      engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);
    }
=======
        MemorySizeCalculator calculator = new MemorySizeCalculator(context);
        if (bitmapPool == null) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                int size = calculator.getBitmapPoolSize();
                bitmapPool = new LruBitmapPool(size);
            } else {
                bitmapPool = new BitmapPoolAdapter();
            }
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java;<<<<<<< MINE
  public SupportRequestManagerFragment() {
    this(new ActivityFragmentLifecycle());
  }

  // For testing only.
  @SuppressLint("ValidFragment")
  public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    this.lifecycle = lifecycle;
  }

  /**
   * Sets the current {@link com.bumptech.glide.RequestManager}.
   *
   * @param requestManager The manager to set.
   */
  public void setRequestManager(RequestManager requestManager) {
    this.requestManager = requestManager;
  }

  ActivityFragmentLifecycle getLifecycle() {
    return lifecycle;
  }

  /**
   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is set.
   */
  public RequestManager getRequestManager() {
    return requestManager;
  }

  @Override
  public void onStart() {
    super.onStart();
    lifecycle.onStart();
  }

  @Override
  public void onStop() {
    super.onStop();
    lifecycle.onStop();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
  }

  @Override
  public void onLowMemory() {
    super.onLowMemory();
    requestManager.onLowMemory();
  }
=======
    public SupportRequestManagerFragment() {
        this(new ActivityFragmentLifecycle());
    }

    // For testing only.
    @SuppressLint("ValidFragment")
    public SupportRequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
        this.lifecycle = lifecycle;
    }

    /**
     * Sets the current {@link com.bumptech.glide.RequestManager}.
     *
     * @param requestManager The manager to set.
     */
    public void setRequestManager(RequestManager requestManager) {
        this.requestManager = requestManager;
    }

    ActivityFragmentLifecycle getLifecycle() {
        return lifecycle;
    }

    /**
     * Returns the current {@link com.bumptech.glide.RequestManager} or null if none is set.
     */
    public RequestManager getRequestManager() {
        return requestManager;
    }

    @Override
    public void onStart() {
        super.onStart();
        lifecycle.onStart();
    }

    @Override
    public void onStop() {
        super.onStop();
        lifecycle.onStop();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        lifecycle.onDestroy();
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onLowMemory();
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java;<<<<<<< MINE
  public RequestManagerFragment() {
    this(new ActivityFragmentLifecycle());
  }

  // For testing only.
  @SuppressLint("ValidFragment")
  RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
    this.lifecycle = lifecycle;
  }

  /**
   * Sets the current {@link com.bumptech.glide.RequestManager}.
   *
   * @param requestManager The request manager to use.
   */
  public void setRequestManager(RequestManager requestManager) {
    this.requestManager = requestManager;
  }

  ActivityFragmentLifecycle getLifecycle() {
    return lifecycle;
  }

  /**
   * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
   */
  public RequestManager getRequestManager() {
    return requestManager;
  }

  @Override
  public void onStart() {
    super.onStart();
    lifecycle.onStart();
  }

  @Override
  public void onStop() {
    super.onStop();
    lifecycle.onStop();
  }

  @Override
  public void onDestroy() {
    super.onDestroy();
    lifecycle.onDestroy();
  }

  @Override
  public void onTrimMemory(int level) {
    requestManager.onTrimMemory(level);
  }

  @Override
  public void onLowMemory() {
    requestManager.onLowMemory();
  }
=======
    public RequestManagerFragment() {
        this(new ActivityFragmentLifecycle());
    }

    // For testing only.
    @SuppressLint("ValidFragment")
    RequestManagerFragment(ActivityFragmentLifecycle lifecycle) {
        this.lifecycle = lifecycle;
    }

    /**
     * Sets the current {@link com.bumptech.glide.RequestManager}.
     *
     * @param requestManager The request manager to use.
     */
    public void setRequestManager(RequestManager requestManager) {
        this.requestManager = requestManager;
    }

    ActivityFragmentLifecycle getLifecycle() {
        return lifecycle;
    }

    /**
     * Returns the current {@link com.bumptech.glide.RequestManager} or null if none exists.
     */
    public RequestManager getRequestManager() {
        return requestManager;
    }

    @Override
    public void onStart() {
        super.onStart();
        lifecycle.onStart();
    }

    @Override
    public void onStop() {
        super.onStop();
        lifecycle.onStop();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        lifecycle.onDestroy();
    }

    @Override
    public void onTrimMemory(int level) {
        // If an activity is re-created, onTrimMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onTrimMemory(level);
        }
    }

    @Override
    public void onLowMemory() {
        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onLowMemory();
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
=======
package com.bumptech.glide;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.MultiTransformation;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.UnitTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.ChildLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.FutureTarget;
import com.bumptech.glide.request.GenericRequest;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.RequestCoordinator;
import com.bumptech.glide.request.RequestFutureTarget;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.ThumbnailRequestCoordinator;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.animation.NoAnimation;
import com.bumptech.glide.request.animation.ViewAnimationFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
import com.bumptech.glide.request.target.PreloadTarget;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.signature.EmptySignature;
import com.bumptech.glide.util.Util;

import java.io.File;

/**
 * A generic class that can handle setting options and staring loads for generic resource types.
 *
 * @param <ModelType> The type of model representing the resource.
 * @param <DataType> The data type that the resource {@link com.bumptech.glide.load.model.ModelLoader} will provide that
 *                  can be decoded by the {@link com.bumptech.glide.load.ResourceDecoder}.
 * @param <ResourceType> The type of the resource that will be loaded.
 * @param <TranscodeType> The type of resource the decoded resource will be transcoded to.
 */
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable {
    protected final Class<ModelType> modelClass;
    protected final Context context;
    protected final Glide glide;
    protected final Class<TranscodeType> transcodeClass;
    protected final RequestTracker requestTracker;
    protected final Lifecycle lifecycle;
    private ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider;

    private ModelType model;
    private Key signature = EmptySignature.obtain();
    // model may occasionally be null, so to enforce that load() was called, set a boolean rather than relying on model
    // not to be null.
    private boolean isModelSet;
    private int placeholderId;
    private int errorId;
    private RequestListener<? super ModelType, TranscodeType> requestListener;
    private Float thumbSizeMultiplier;
    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
    private Float sizeMultiplier = 1f;
    private Drawable placeholderDrawable;
    private Drawable errorPlaceholder;
    private Priority priority = null;
    private boolean isCacheable = true;
    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
    private int overrideHeight = -1;
    private int overrideWidth = -1;
    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
    private Transformation<ResourceType> transformation = UnitTransformation.get();
    private boolean isTransformationSet;
    private boolean isThumbnailBuilt;

    GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        this(other.context, other.modelClass, loadProvider, transcodeClass, other.glide, other.requestTracker,
                other.lifecycle);
        this.model = other.model;
        this.isModelSet = other.isModelSet;
        this.signature = other.signature;
        this.diskCacheStrategy = other.diskCacheStrategy;
        this.isCacheable = other.isCacheable;
    }

    GenericRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {
        this.context = context;
        this.modelClass = modelClass;
        this.transcodeClass = transcodeClass;
        this.glide = glide;
        this.requestTracker = requestTracker;
        this.lifecycle = lifecycle;
        this.loadProvider = loadProvider != null
                ? new ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType>(loadProvider) : null;

        if (context == null) {
            throw new NullPointerException("Context can't be null");
        }
        if (modelClass != null && loadProvider == null) {
            throw new NullPointerException("LoadProvider must not be null");
        }
    }

    /**
     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before this request.
     * Best used for loading thumbnail resources that are smaller and will be loaded more quickly than the full size
     * resource. There are no guarantees about the order in which the requests will actually finish. However, if the
     * thumb request completes after the full request, the thumb resource will never replace the full resource.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        if (this.equals(thumbnailRequest)) {
            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
                    + "clone() on the request you are passing to thumbnail()");
        }
        this.thumbnailRequestBuilder = thumbnailRequest;

        return this;
    }

    /**
     * Loads a resource in an identical manner to this request except with the dimensions of the target multiplied
     * by the given size multiplier. If the thumbnail load completes before the fullsize load, the thumbnail will
     * be shown. If the thumbnail load completes afer the fullsize load, the thumbnail will not be shown.
     *
     * <p>
     *     Note - The thumbnail resource will be smaller than the size requested so the target (or {@link ImageView})
     *     must be able to scale the thumbnail appropriately. See {@link android.widget.ImageView.ScaleType}.
     * </p>
     *
     * <p>
     *     Almost all options will be copied from the original load, including the
     *     {@link com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder}, and
     *     {@link Transformation}s. However, {@link #placeholder(int)} and {@link #error(int)},
     *     and {@link #listener(RequestListener)} will only be used on the fullsize load and will not be copied for
     *     the thumbnail load.
     * </p>
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.thumbSizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Applies a multiplier to the {@link Target}'s size before loading the resource. Useful for loading thumbnails
     * or trying to avoid loading huge resources (particularly {@link android.graphics.Bitmap}s on devices with overly
     * dense screens.
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sizeMultiplier(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.sizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the original data.
     * By default, this decoder will only be used if the final transformed resource is not in the disk cache.
     *
     * @see #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param decoder The {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> decoder(
            ResourceDecoder<DataType, ResourceType> decoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setSourceDecoder(decoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the disk cache. By
     * default, this decoder will only be used if the final transformed resource is already in the disk cache.
     *
     * @see #decoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param cacheDecoder The decoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> cacheDecoder(
            ResourceDecoder<File, ResourceType> cacheDecoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setCacheDecoder(cacheDecoder);
        }

        return this;
    }

    /**
     * Sets the source encoder to use to encode the data retrieved by this request directly into cache. The returned
     * resource will then be decoded from the cached data.
     *
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param sourceEncoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sourceEncoder(
            Encoder<DataType> sourceEncoder) {
        if (loadProvider != null) {
            loadProvider.setSourceEncoder(sourceEncoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.
     *
     * <p>
     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal.
     *     Applications that use the same resource multiple times in multiple sizes and are willing to trade off some
     *     speed and disk space in return for lower bandwidth usage may want to consider using
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should
     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}.
     * </p>
     *
     * @param strategy The strategy to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(
            DiskCacheStrategy strategy) {
        this.diskCacheStrategy = strategy;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.Encoder} to use to encode the original data directly to cache. Will only
     * be used if the original data is not already in cache and if the
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} is set to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}.
     *
     * @see #sourceEncoder(com.bumptech.glide.load.Encoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param encoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> encoder(
            ResourceEncoder<ResourceType> encoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the encoder.
        if (loadProvider != null) {
            loadProvider.setEncoder(encoder);
        }

        return this;
    }

    /**
     * Sets the priority for this load.
     *
     * @param priority A priority.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> priority(
            Priority priority) {
        this.priority = priority;

        return this;
    }

    /**
     * Transform resources with the given {@link Transformation}s. Replaces any existing transformation or
     * transformations.
     *
     * @param transformations the transformations to apply in order.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transform(
            Transformation<ResourceType>... transformations) {
        isTransformationSet = true;
        if (transformations.length == 1) {
            transformation = transformations[0];
        } else {
            transformation = new MultiTransformation<ResourceType>(transformations);
        }

        return this;
    }

    /**
     * Removes the current {@link com.bumptech.glide.load.Transformation}.
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontTransform() {
        Transformation<ResourceType> transformation = UnitTransformation.get();
        return transform(transformation);
    }

    /**
     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use for this load.
     *
     * @see com.bumptech.glide.load.resource.transcode.UnitTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder
     *
     * @param transcoder The transcoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcoder(
            ResourceTranscoder<ResourceType, TranscodeType> transcoder) {
        if (loadProvider != null) {
            loadProvider.setTranscoder(transcoder);
        }

        return this;
    }

    /**
     * Removes any existing animation set on the builder. Will be overridden by subsequent calls that set an animation.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontAnimate() {
        GlideAnimationFactory<TranscodeType> animation = NoAnimation.getFactory();
        return animate(animation);
    }

    /**
     * Sets an animation to run on the wrapped target when an resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @param animationId The resource id of the animation to run
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
    }

    /**
     * Sets an animation to run on the wrapped target when a resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @see #animate(int)
     * @see #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)
     *
     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
     * views animating repeatedly. Use {@link #animate(int)} or
     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
     * Glide 4.0.
     * @param animation The animation to run
     * @return This request builder.
     */
    @Deprecated
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
        return animate(new ViewAnimationFactory<TranscodeType>(animation));
    }

    /**
     * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target may be wrapping
     * when a resource load finishes. Will only be run if the load was loaded asynchronously (ie was not in the
     * memory cache).
     *
     * @param animator The {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} to run.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            ViewPropertyAnimation.Animator animator) {
        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
    }

    GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            GlideAnimationFactory<TranscodeType> animationFactory) {
        if (animationFactory == null) {
            throw new NullPointerException("Animation factory must not be null!");
        }
        this.animationFactory = animationFactory;

        return this;
    }

    /**
     * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resourceto display while a resource
     * is loading.
     *
     * @param resourceId The id of the resource to use as a placeholder
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            int resourceId) {
        this.placeholderId = resourceId;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            Drawable drawable) {
        this.placeholderDrawable = drawable;

        return this;
    }

    /**
     * Sets a resource to display if a load fails.
     *
     * @param resourceId The id of the resource to use as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            int resourceId) {
        this.errorId = resourceId;

        return this;
    }

    /**
     * Sets a {@link Drawable} to display if a load fails.
     *
     * @param drawable The drawable to display.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            Drawable drawable) {
        this.errorPlaceholder = drawable;

        return this;
    }

    /**
     * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single instance of an
     * exception handler per type of request (usually activity/fragment) rather than pass one in per request to
     * avoid some redundant object allocation.
     *
     * @param requestListener The request listener to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        this.requestListener = requestListener;

        return this;
    }

    /**
     * Allows the loaded resource to skip the memory cache.
     *
     * <p>
     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not
     *     also skipping the memory cache, the resource will be cached in memory.
     * </p>
     *
     * @param skip True to allow the resource to skip the memory cache.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {
        this.isCacheable = !skip;

        return this;
    }

    /**
     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for
     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
     *
     * @param width The width in pixels to use to load the resource.
     * @param height The height in pixels to use to load the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
        if (!Util.isValidDimensions(width, height)) {
            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");
        }
        this.overrideWidth = width;
        this.overrideHeight = height;

        return this;
    }

    /**
     * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over
     * when cached data is invalidated.
     *
     * <p>
     *     Note - The signature does not replace the cache key, it is purely additive.
     * </p>
     *
     * @see com.bumptech.glide.signature.StringSignature
     *
     * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current state of the
     *                  model that will be mixed in to the cache key.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> signature(Key signature) {
        if (signature == null) {
            throw new NullPointerException("Signature must not be null");
        }
        this.signature = signature;
        return this;
    }

    /**
     * Sets the specific model to load data for.
     *
     * <p>
     *      This method must be called at least once before {@link #into(com.bumptech.glide.request.target.Target)} is
     *      called.
     * </p>
     *
     * @param model The model to load data for, or null.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {
        this.model = model;
        isModelSet = true;
        return this;
    }

    /**
     * Returns a copy of this request builder with all of the options set so far on this builder.
     *
     * <p>
     *     This method returns a "deep" copy in that all non-immutable arguments are copied such that changes to one
     *     builder will not affect the other builder. However, in addition to immutable arguments, the current model
     *     is not copied copied so changes to the model will affect both builders.
     * </p>
     */
    @SuppressWarnings("unchecked")
    @Override
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone() {
        try {
            GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone =
                    (GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>) super.clone();
            clone.loadProvider = loadProvider != null ? loadProvider.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Set the target the resource will be loaded into.
     *
     * @see Glide#clear(com.bumptech.glide.request.target.Target)
     *
     * @param target The target to load the resource into.
     * @return The given target.
     */
    public <Y extends Target<TranscodeType>> Y into(Y target) {
        Util.assertMainThread();
        if (target == null) {
            throw new IllegalArgumentException("You must pass in a non null Target");
        }
        if (!isModelSet) {
            throw new IllegalArgumentException("You must first set a model (try #load())");
        }

        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        Request request = buildRequest(target);
        target.setRequest(request);
        lifecycle.addListener(target);
        requestTracker.runRequest(request);

        return target;
    }

    /**
     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into the view, and frees
     * any resources Glide may have previously loaded into the view so they may be reused.
     *
     * @see Glide#clear(android.view.View)
     *
     * @param view The view to cancel previous loads for and load the new resource into.
     * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
     */
    public Target<TranscodeType> into(ImageView view) {
        Util.assertMainThread();
        if (view == null) {
            throw new IllegalArgumentException("You must pass in a non null View");
        }

        if (!isTransformationSet && view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                //$CASES-OMITTED$
                default:
                    // Do nothing.
            }
        }

        return into(glide.buildImageViewTarget(view, transcodeClass));
    }

    /**
     * Returns a future that can be used to do a blocking get on a background thread.
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     *
     * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
     *
     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
     *         resource in a blocking manner.
     */
    public FutureTarget<TranscodeType> into(int width, int height) {
        final RequestFutureTarget<ModelType, TranscodeType> target =
                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);

        // TODO: Currently all loads must be started on the main thread...
        glide.getMainHandler().post(new Runnable() {
            @Override
            public void run() {
                if (!target.isCancelled()) {
                    into(target);
                }
            }
        });

        return target;
    }

    /**
     * Preloads the resource into the cache using the given width and height.
     *
     * <p>
     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are
     *     available quickly.
     * </p>
     *
     *
     * @see com.bumptech.glide.ListPreloader
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload(int width, int height) {
        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
        return into(target);
    }

    /**
     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and height.
     * Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as the width and height.
     *
     * @see #preload(int, int)
     *
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload() {
        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
    }

    void applyCenterCrop() {
        // To be implemented by subclasses when possible.
    }

    void applyFitCenter() {
        // To be implemented by subclasses when possible.
    }

    private Priority getThumbnailPriority() {
        final Priority result;
        if (priority == Priority.LOW) {
            result = Priority.NORMAL;
        } else if (priority == Priority.NORMAL) {
            result = Priority.HIGH;
        } else {
            result = Priority.IMMEDIATE;
        }
        return result;
    }

    private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        isThumbnailBuilt = false;
        return buildRequestRecursive(target, null);
    }

    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }

    private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
            RequestCoordinator requestCoordinator) {
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
=======
package com.bumptech.glide.request;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.util.LogTime;
import com.bumptech.glide.util.Util;

import java.util.Queue;

/**
 * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given {@link Target}.
 *
 * @param <A> The type of the model that the resource will be loaded from.
 * @param <T> The type of the data that the resource will be loaded from.
 * @param <Z> The type of the resource that will be loaded.
 * @param <R> The type of the resource that will be transcoded from the loaded resource.
 */
public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,
        ResourceCallback {
    private static final String TAG = "GenericRequest";
    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);
    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);

    private enum Status {
        /** Created but not yet running. */
        PENDING,
        /** In the process of fetching media. */
        RUNNING,
        /** Waiting for a callback given to the Target to be called to determine target dimensions. */
        WAITING_FOR_SIZE,
        /** Finished loading media successfully. */
        COMPLETE,
        /** Failed to load media, may be restarted. */
        FAILED,
        /** Cancelled by the user, may not be restarted. */
        CANCELLED,
        /** Cleared by the user with a placeholder set, may not be restarted. */
        CLEARED,
        /** Temporarily paused by the system, may be restarted. */
        PAUSED,
    }

    private final String tag = String.valueOf(hashCode());

    private Key signature;
    private int placeholderResourceId;
    private int errorResourceId;
    private Context context;
    private Transformation<Z> transformation;
    private LoadProvider<A, T, Z, R> loadProvider;
    private RequestCoordinator requestCoordinator;
    private A model;
    private Class<R> transcodeClass;
    private boolean isMemoryCacheable;
    private Priority priority;
    private Target<R> target;
    private RequestListener<? super A, R> requestListener;
    private float sizeMultiplier;
    private Engine engine;
    private GlideAnimationFactory<R> animationFactory;
    private int overrideWidth;
    private int overrideHeight;
    private DiskCacheStrategy diskCacheStrategy;

    private Drawable placeholderDrawable;
    private Drawable errorDrawable;
    private boolean loadedFromMemoryCache;
    // doing our own type check
    private Resource<?> resource;
    private Engine.LoadStatus loadStatus;
    private long startTime;
    private Status status;

    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        @SuppressWarnings("unchecked")
        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
        if (request == null) {
            request = new GenericRequest<A, T, Z, R>();
        }
        request.init(loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderResourceId,
                errorDrawable,
                errorResourceId,
                requestListener,
                requestCoordinator,
                engine,
                transformation,
                transcodeClass,
                isMemoryCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
        return request;
    }

    private GenericRequest() {
        // just create, instances are reused with recycle/init
    }

    @Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }

    private void init(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        this.loadProvider = loadProvider;
        this.model = model;
        this.signature = signature;
        this.context = context.getApplicationContext();
        this.priority = priority;
        this.target = target;
        this.sizeMultiplier = sizeMultiplier;
        this.placeholderDrawable = placeholderDrawable;
        this.placeholderResourceId = placeholderResourceId;
        this.errorDrawable = errorDrawable;
        this.errorResourceId = errorResourceId;
        this.requestListener = requestListener;
        this.requestCoordinator = requestCoordinator;
        this.engine = engine;
        this.transformation = transformation;
        this.transcodeClass = transcodeClass;
        this.isMemoryCacheable = isMemoryCacheable;
        this.animationFactory = animationFactory;
        this.overrideWidth = overrideWidth;
        this.overrideHeight = overrideHeight;
        this.diskCacheStrategy = diskCacheStrategy;
        status = Status.PENDING;

        // We allow null models by just setting an error drawable. Null models will always have empty providers, we
        // simply skip our sanity checks in that unusual case.
        if (model != null) {
            check("ModelLoader", loadProvider.getModelLoader(), "try .using(ModelLoader)");
            check("Transcoder", loadProvider.getTranscoder(), "try .as*(Class).transcode(ResourceTranscoder)");
            check("Transformation", transformation, "try .transform(UnitTransformation.get())");
            if (diskCacheStrategy.cacheSource()) {
                check("SourceEncoder", loadProvider.getSourceEncoder(),
                        "try .sourceEncoder(Encoder) or .diskCacheStrategy(NONE/RESULT)");
            } else {
                check("SourceDecoder", loadProvider.getSourceDecoder(),
                        "try .decoder/.imageDecoder/.videoDecoder(ResourceDecoder) or .diskCacheStrategy(ALL/SOURCE)");
            }
            if (diskCacheStrategy.cacheSource() || diskCacheStrategy.cacheResult()) {
                // TODO if(resourceClass.isAssignableFrom(InputStream.class) it is possible to wrap sourceDecoder
                // and use it instead of cacheDecoder: new FileToStreamDecoder<Z>(sourceDecoder)
                // in that case this shouldn't throw
                check("CacheDecoder", loadProvider.getCacheDecoder(),
                        "try .cacheDecoder(ResouceDecoder) or .diskCacheStrategy(NONE)");
            }
            if (diskCacheStrategy.cacheResult()) {
                check("Encoder", loadProvider.getEncoder(),
                        "try .encode(ResourceEncoder) or .diskCacheStrategy(NONE/SOURCE)");
            }
        }
    }

    private static void check(String name, Object object, String suggestion) {
        if (object == null) {
            StringBuilder message = new StringBuilder(name);
            message.append(" must not be null");
            if (suggestion != null) {
                message.append(", ");
                message.append(suggestion);
            }
            throw new NullPointerException(message.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }

    /**
     * Cancels the current load but does not release any resources held by the request and continues to display
     * the loaded resource if the load completed before the call to cancel.
     *
     * <p>
     *     Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
     * </p>
     *
     * @see #clear()
     */
    void cancel() {
        status = Status.CANCELLED;
        if (loadStatus != null) {
            loadStatus.cancel();
            loadStatus = null;
        }
    }

    /**
     * Cancels the current load if it is in progress, clears any resources held onto by the request and replaces
     * the loaded resource if the load completed with the placeholder.
     *
     * <p>
     *     Cleared requests can be restarted with a subsequent call to {@link #begin()}
     * </p>
     *
     * @see #cancel()
     */
    @Override
    public void clear() {
        Util.assertMainThread();
        if (status == Status.CLEARED) {
            return;
        }
        cancel();
        // Resource must be released before canNotifyStatusChanged is called.
        if (resource != null) {
            releaseResource(resource);
        }
        if (canNotifyStatusChanged()) {
            target.onLoadCleared(getPlaceholderDrawable());
        }
        // Must be after cancel().
        status = Status.CLEARED;
    }

    @Override
    public boolean isPaused() {
        return status == Status.PAUSED;
    }

    @Override
    public void pause() {
        clear();
        status = Status.PAUSED;
    }

    private void releaseResource(Resource resource) {
        engine.release(resource);
        this.resource = null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isRunning() {
        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isComplete() {
        return status == Status.COMPLETE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isResourceSet() {
        return isComplete();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isCancelled() {
        return status == Status.CANCELLED || status == Status.CLEARED;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = getErrorDrawable();
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }

    private Drawable getErrorDrawable() {
        if (errorDrawable == null && errorResourceId > 0) {
            errorDrawable = context.getResources().getDrawable(errorResourceId);
        }
        return errorDrawable;
    }

    private Drawable getPlaceholderDrawable() {
        if (placeholderDrawable == null && placeholderResourceId > 0) {
            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
        }
        return placeholderDrawable;
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Got null fetcher from model loader"));
            return;
        }
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }

    private boolean canSetResource() {
        return requestCoordinator == null || requestCoordinator.canSetImage(this);
    }

    private boolean canNotifyStatusChanged() {
        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
    }

    private boolean isFirstReadyResource() {
        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
    }

    private void notifyLoadSuccess() {
      if (requestCoordinator != null) {
        requestCoordinator.onRequestSuccess(this);
      }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void onResourceReady(Resource<?> resource) {
        if (resource == null) {
            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
                    + " inside, but instead got null."));
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            onException(new Exception("Expected to receive an object of " + transcodeClass
                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
                    + " inside Resource{" + resource + "}."
                    + (received != null ? "" : " "
                        + "To indicate failure return a null Resource object, "
                        + "rather than a Resource object containing null data.")
            ));
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't set the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady(resource, (R) received);
    }

    /**
     * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
     *
     * @param resource original {@link Resource}, never <code>null</code>
     * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
     */
    private void onResourceReady(Resource<?> resource, R result) {
        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstReadyResource())) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstReadyResource());
            target.onResourceReady(result, animation);
        }

        status = Status.COMPLETE;
        this.resource = resource;
        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onException(Exception e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, "load failed", e);
        }

        status = Status.FAILED;
        //TODO: what if this is a thumbnail request?
        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {
            setErrorPlaceholder(e);
        }
    }

    private void logV(String message) {
        Log.v(TAG, message + " this: " + tag);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    @Override
    public String getId() {
      return "AT_MOST.com.bumptech.glide.load.data.bitmap";
=======
    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }

        boolean hasAlpha = false;
        // We probably only need 25, but this is safer (particularly since the buffer size is > 1024).
        is.mark(1024);
        try {
            hasAlpha = new ImageHeaderParser(is).hasAlpha();
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }

        return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java;<<<<<<< MINE
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        Bundle args = getArguments();
        photoSize = args.getInt(IMAGE_SIZE_KEY);
        thumbnail = args.getBoolean(THUMBNAIL_KEY);

        fullRequest = Glide.with(this)
                .from(Photo.class)
                .centerCrop()
                .crossFade(R.anim.fade_in, 150);

        thumbnailRequest = Glide.with(this)
                .from(Photo.class)
                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
                .crossFade(R.anim.fade_in, 150)
                .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);

        preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;

        final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);

        grid = (GridView) result.findViewById(R.id.images);
        grid.setColumnWidth(photoSize);
        adapter = new PhotoAdapter();
        grid.setAdapter(adapter);

        final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
                new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
        final ListPreloader<Photo> preloader =
                new ListPreloader<Photo>(adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
        grid.setOnScrollListener(preloader);
=======
  @Override
  public void onPhotosUpdated(List<Photo> photos) {
    currentPhotos = photos;
    if (adapter != null) {
      adapter.setPhotos(currentPhotos);
    }
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
import static com.bumptech.glide.request.RequestOptions.placeholderOf;

import android.app.Activity;
import android.content.ContentResolver;
import android.graphics.drawable.PictureDrawable;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

import com.bumptech.glide.Glide;
import com.bumptech.glide.RequestBuilder;

import java.io.File;

/**
 * Displays an SVG image loaded from an android raw resource.
 */
public class MainActivity extends Activity {
  private static final String TAG = "SVGActivity";

  private ImageView imageViewRes;
  private ImageView imageViewNet;
  private RequestBuilder<PictureDrawable> requestBuilder;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
    imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);

    requestBuilder = Glide.with(this)
        .as(PictureDrawable.class)
        .apply(placeholderOf(R.drawable.image_loading)
            .error(R.drawable.image_error))
        .transition(withCrossFade())
        .listener(new SvgSoftwareLayerSetter());
  }

  @Override
  protected void onStart() {
    super.onStart();
    reload();
  }

  public void clearCache(View v) {
    Log.w(TAG, "clearing cache");
    Glide.with(this).clear(imageViewRes);
    Glide.with(this).clear(imageViewNet);
    Glide.get(this).clearMemory();
    File cacheDir = Glide.getPhotoCacheDir(this);
    if (cacheDir.isDirectory()) {
      for (File child : cacheDir.listFiles()) {
        if (!child.delete()) {
          Log.w(TAG, "cannot delete: " + child);
        }
      }
    }
    reload();
  }

  public void cycleScaleType(View v) {
    ImageView.ScaleType curr = imageViewRes.getScaleType();
    Log.w(TAG, "cycle: current=" + curr);
    ImageView.ScaleType[] all = ImageView.ScaleType.values();
    int nextOrdinal = (curr.ordinal() + 1) % all.length;
    ImageView.ScaleType next = all[nextOrdinal];
    Log.w(TAG, "cycle: next=" + next);
    imageViewRes.setScaleType(next);
    imageViewNet.setScaleType(next);
    reload();
  }

  private void reload() {
    Log.w(TAG, "reloading");
    ((TextView) findViewById(R.id.button))
        .setText(getString(R.string.scaleType, imageViewRes.getScaleType()));
    loadRes();
    loadNet();
  }

  private void loadRes() {
    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
        + R.raw.android_toy_h);
    requestBuilder.load(uri).into(imageViewRes);
  }

  private void loadNet() {
    Uri uri = Uri.parse("http://www.clker.com/cliparts/u/Z/2/b/a/6/android-toy-h.svg");
    requestBuilder.load(uri).into(imageViewNet);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import android.graphics.Picture;
import android.graphics.drawable.PictureDrawable;

import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.resource.SimpleResource;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.caverock.androidsvg.SVG;

/**
 * Convert the {@link SVG}'s internal representation to an Android-compatible one
 * ({@link Picture}).
 */
public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
  @Override
  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
    SVG svg = toTranscode.get();
    Picture picture = svg.renderToPicture();
    PictureDrawable drawable = new PictureDrawable(picture);
    return new SimpleResource<PictureDrawable>(drawable);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDecoder.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import com.bumptech.glide.load.Options;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.resource.SimpleResource;
import com.caverock.androidsvg.SVG;
import com.caverock.androidsvg.SVGParseException;

import java.io.IOException;
import java.io.InputStream;

/**
 * Decodes an SVG internal representation from an {@link InputStream}.
 */
public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {

  @Override
  public boolean handles(InputStream source, Options options) throws IOException {
    // TODO: Can we tell?
    return true;
  }

  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
      throws IOException {
    try {
      SVG svg = SVG.getFromInputStream(source);
      return new SimpleResource<SVG>(svg);
    } catch (SVGParseException ex) {
      throw new IOException("Cannot load SVG from stream", ex);
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import android.annotation.TargetApi;
import android.graphics.drawable.PictureDrawable;
import android.os.Build;
import android.widget.ImageView;

import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.target.ImageViewTarget;
import com.bumptech.glide.request.target.Target;

/**
 * Listener which updates the {@link ImageView} to be software rendered, because
 * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
 * a hardware backed {@link android.graphics.Canvas Canvas}.
 */
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {

  @Override
  public boolean onLoadFailed(Object model, Target<PictureDrawable> target,
      boolean isFirstResource) {
    ImageView view = ((ImageViewTarget<?>) target).getView();
    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
    }
    return false;
  }

  @Override
  public boolean onResourceReady(PictureDrawable resource, Object model,
      Target<PictureDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
    ImageView view = ((ImageViewTarget<?>) target).getView();
    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
    }
    return false;
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
=======
import com.bumptech.glide.util.ContentLengthInputStream;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
=======
import com.squareup.okhttp.Response;
import com.squareup.okhttp.ResponseBody;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
=======
import java.util.Map;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    private static final String USER_AGENT_HEADER = "User-Agent";
    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");
    private final OkHttpClient client;
    private final GlideUrl url;
    private InputStream stream;
    private ResponseBody responseBody;

    public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
        this.client = client;
        this.url = url;
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private final OkHttpClient client;
  private final GlideUrl url;
  private InputStream stream;
  private ResponseBody responseBody;

  public OkHttpStreamFetcher(OkHttpClient client, GlideUrl url) {
    this.client = client;
    this.url = url;
  }

  @Override
  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {
    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());
    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    @Override
    public InputStream loadData(Priority priority) throws Exception {
        Request.Builder requestBuilder = new Request.Builder()
                .url(url.toStringUrl());

        boolean isUserAgentSet = false;
        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
            String key = headerEntry.getKey();
            requestBuilder.addHeader(key, headerEntry.getValue());
            isUserAgentSet |= USER_AGENT_HEADER.equalsIgnoreCase(key);
        }
        if (!isUserAgentSet) {
            requestBuilder.addHeader(USER_AGENT_HEADER, DEFAULT_USER_AGENT);
        }
        Request request = requestBuilder.build();

        Response response = client.newCall(request).execute();
        responseBody = response.body();
        if (!response.isSuccessful()) {
            throw new IOException("Request failed with code: " + response.code());
        }

        long contentLength = responseBody.contentLength();
        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
        return stream;
    }
=======
    client.newCall(request).enqueue(new com.squareup.okhttp.Callback() {
      @Override
      public void onFailure(Request request, IOException e) {
        if (Logs.isEnabled(Log.DEBUG)) {
          Logs.log(Log.DEBUG, "OkHttp failed to obtain result", e);
        }
        callback.onDataReady(null);
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    @Override
    public void cleanup() {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignored
            }
        }
        if (responseBody != null) {
            try {
                responseBody.close();
            } catch (IOException e) {
                // Ignored.
            }
=======
      @Override
      public void onResponse(Response response) throws IOException {
        if (response.isSuccessful()) {
          String contentLength = response.header(CONTENT_LENGTH_HEADER);
          responseBody = response.body();
          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
        } else if (Logs.isEnabled(Log.DEBUG)) {
          Logs.log(Log.DEBUG, "OkHttp got error response: " + response.code() + ", "
              + response.message());
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE

    @Override
    public String getId() {
        return url.getCacheKey();
=======
    if (responseBody != null) {
      try {
        responseBody.close();
      } catch (IOException e) {
        // Ignored.
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
=======
import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.isNull;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
import com.bumptech.glide.load.model.Headers;
import com.bumptech.glide.testutil.TestUtil;
=======
import com.bumptech.glide.load.model.Headers;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;
=======
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
    @Before
    public void setUp() throws IOException {
        requestQueue = Volley.newRequestQueue(Robolectric.application);
        mockWebServer = new MockWebServer();
        mockWebServer.play();
    }

    @After
    public void tearDown() throws IOException {
        mockWebServer.shutdown();
        requestQueue.stop();
    }

    @Test
    public void testReturnsInputStreamOnStatusOk() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
                .setBody(expected)
                .setResponseCode(200));
        DataFetcher<InputStream> fetcher = getFetcher();
        InputStream is = fetcher.loadData(Priority.HIGH);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect301s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(301)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesRedirect302s() throws Exception {
        String expected = "fakedata";
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(302)
            .setHeader("Location", mockWebServer.getUrl("/redirect")));
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(expected));
        InputStream is = getFetcher().loadData(Priority.LOW);
        assertEquals(expected, TestUtil.isToString(is));
    }

    @Test
    public void testHandlesUpToFiveRedirects() throws Exception {
        int numRedirects = 4;
        String expected = "redirectedData";
        String redirectBase = "/redirect";
        for (int i = 0; i < numRedirects; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
        }
        mockWebServer.enqueue(new MockResponse()
            .setResponseCode(200).setBody(expected));

        InputStream is = getFetcher().loadData(Priority.NORMAL);
        assertEquals(expected, TestUtil.isToString(is));

        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
        for (int i = 0; i < numRedirects; i++) {
            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
        }
    }

    @Test
    public void testThrowsIfRedirectLocationIsEmpty() throws Exception {
        for (int i = 0; i < 2; i++) {
            mockWebServer.enqueue(new MockResponse().setResponseCode(301));
        }

        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Didn't get expected IOException");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(VolleyError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIsNegativeOne() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
        }
    }

    @Test
    public void testThrowsAfterTooManyRedirects() throws Exception {
        for (int i = 0; i < 20; i++) {
            mockWebServer.enqueue(new MockResponse()
                    .setResponseCode(301)
                    .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
        }
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);
            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);
        }
    }


    @Test
    public void testThrowsIfStatusCodeIs500() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
        try {
            getFetcher().loadData(Priority.NORMAL);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testThrowsIfStatusCodeIs400() throws Exception {
        mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
        try {
            getFetcher().loadData(Priority.LOW);
            fail("Failed to get expected exception");
        } catch (ExecutionException e) {
            assertThat(e.getCause()).isInstanceOf(ServerError.class);
        }
    }

    @Test
    public void testAppliesHeadersInGlideUrl() throws Exception {
      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
      String headerField = "field";
      String headerValue = "value";
      Map<String, String> headersMap = new HashMap<String, String>();
      headersMap.put(headerField, headerValue);
      Headers headers = mock(Headers.class);
      when(headers.getHeaders()).thenReturn(headersMap);

      getFetcher(headers).loadData(Priority.HIGH);

      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
    }

    private DataFetcher<InputStream> getFetcher() {
      return getFetcher(Headers.NONE);
    }

    private DataFetcher<InputStream> getFetcher(Headers headers) {
        URL url = mockWebServer.getUrl(DEFAULT_PATH);
        VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
            @Override
            public InputStream get() throws InterruptedException, ExecutionException {
                for (int i = 0; i < 251 && !isDone(); i++) {
                    Thread.sleep(10);
                    Robolectric.runUiThreadTasks();
                }
                if (!isDone()) {
                    fail("Failed to get response from Volley in time");
                }
                return super.get();
            }
        };
        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);
    }

    /** A shadow clock that doesn't rely on running on an Android thread with a Looper. */
    @Implements(SystemClock.class)
    public static class FakeSystemClock extends ShadowSystemClock {

        @Implementation
        public static long elapsedRealtime() {
            // The default is to return something using the main looper, which doesn't exist on Volley's threads.
            return System.currentTimeMillis();
        }
=======
  private MockWebServer mockWebServer;
  private RequestQueue requestQueue;
  private ArgumentCaptor<InputStream> streamCaptor;
  private CountDownLatch waitForResponseLatch;

  @Before
  public void setUp() throws IOException {
    MockitoAnnotations.initMocks(this);

    waitForResponseLatch = new CountDownLatch(1);
    doAnswer(new Answer<Void>() {
      @Override
      public Void answer(InvocationOnMock invocationOnMock) throws Throwable {
        waitForResponseLatch.countDown();
        return null;
      }
    }).when(callback).onDataReady(any(InputStream.class));
    requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);
    mockWebServer = new MockWebServer();
    mockWebServer.play();

    streamCaptor = ArgumentCaptor.forClass(InputStream.class);
  }

  @After
  public void tearDown() throws IOException {
    mockWebServer.shutdown();
    requestQueue.stop();
  }

  @Test
  public void testReturnsInputStreamOnStatusOk() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setBody(expected).setResponseCode(200));
    DataFetcher<InputStream> fetcher = getFetcher();
    fetcher.loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect301s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(301)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesRedirect302s() throws Exception {
    String expected = "fakedata";
    mockWebServer.enqueue(new MockResponse().setResponseCode(302)
        .setHeader("Location", mockWebServer.getUrl("/redirect")));
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());
  }

  @Test
  public void testHandlesUpToFiveRedirects() throws Exception {
    int numRedirects = 4;
    String expected = "redirectedData";
    String redirectBase = "/redirect";
    for (int i = 0; i < numRedirects; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl(redirectBase + i)));
    }
    mockWebServer.enqueue(new MockResponse().setResponseCode(200).setBody(expected));

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(streamCaptor.capture());
    assertStreamOf(expected, streamCaptor.getValue());

    assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);
    for (int i = 0; i < numRedirects; i++) {
      assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);
    }
  }

  @Test
  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {
    for (int i = 0; i < 2; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301));
    }

    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(-1));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullAfterTooManyRedirects() throws Exception {
    for (int i = 0; i < 20; i++) {
      mockWebServer.enqueue(new MockResponse().setResponseCode(301)
          .setHeader("Location", mockWebServer.getUrl("/redirect" + i)));
    }
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs500() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(500).setBody("error"));
    getFetcher().loadData(Priority.NORMAL, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testReturnsNullIfStatusCodeIs400() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(400).setBody("error"));
    getFetcher().loadData(Priority.LOW, callback);
    waitForResponseLatch.await();
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testAppliesHeadersInGlideUrl() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    String headerField = "field";
    String headerValue = "value";
    Map<String, String> headersMap = new HashMap<String, String>();
    headersMap.put(headerField, headerValue);
    Headers headers = mock(Headers.class);
    when(headers.getHeaders()).thenReturn(headersMap);

    getFetcher(headers).loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();

    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
  }

  private DataFetcher<InputStream> getFetcher() {
    return getFetcher(Headers.NONE);
  }

  private DataFetcher<InputStream> getFetcher(Headers headers) {
    URL url = mockWebServer.getUrl(DEFAULT_PATH);
    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
  }

  /**
   * A shadow clock that doesn't rely on running on an Android thread with a Looper.
   */
  @Implements(SystemClock.class)
  public static class FakeSystemClock extends ShadowSystemClock {

    @Implementation
    public static long elapsedRealtime() {
      // The default is to return something using the main looper, which doesn't exist on
      // Volley's threads.
      return System.currentTimeMillis();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java;<<<<<<< MINE
=======
import java.util.Map;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java;<<<<<<< MINE
    /**
     * Returns a Volley request for the given image url. The given future should be set as a
     * listener or called when the request completes.
     */
    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority,
        Map<String, String> headers);
=======
  /**
   * Returns a Volley request for the given image url. The given future should be put as a
   * listener or called when the request completes.
   */

  Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
      Priority priority, Map<String, String> headers);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
import com.android.volley.AuthFailureError;
=======
import android.util.Log;

import com.android.volley.AuthFailureError;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
=======
import java.util.Collections;
import java.util.Map;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {

        @Override
        public Request<byte[]> create(
                    String url, VolleyRequestFuture<InputStream> future,
                    Request.Priority priority, Map<String, String> headers) {
            return new GlideRequest(url, future, priority, headers);
        }

    };

    private final RequestQueue requestQueue;
    private final VolleyRequestFactory requestFactory;
    private final GlideUrl url;
    private VolleyRequestFuture<InputStream> requestFuture;

    @SuppressWarnings("unused")
    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
        this(requestQueue, url,  null);
=======
  public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {
    @Override
    public Request<byte[]> create(String url, DataCallback<? super InputStream> callback,
        Request.Priority priority, Map<String, String> headers) {
      return new GlideRequest(url, callback, priority, headers);
    }
  };

  private final RequestQueue requestQueue;
  private final VolleyRequestFactory requestFactory;
  private final GlideUrl url;
  private volatile Request<byte[]> request;

  @SuppressWarnings("unused")
  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {
    this(requestQueue, url, DEFAULT_REQUEST_FACTORY);
  }

  public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,
      VolleyRequestFactory requestFactory) {
    this.requestQueue = requestQueue;
    this.url = url;
    this.requestFactory = requestFactory;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    request = requestFactory.create(url.toStringUrl(), callback, glideToVolleyPriority(priority),
        url.getHeaders());
    requestQueue.add(request);
  }

  @Override
  public void cleanup() {
    // Do nothing.
  }

  @Override
  public void cancel() {
    Request<byte[]> local = request;
    if (local != null) {
      local.cancel();
    }
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  private static Request.Priority glideToVolleyPriority(Priority priority) {
    switch (priority) {
      case LOW:
        return Request.Priority.LOW;
      case HIGH:
        return Request.Priority.HIGH;
      case IMMEDIATE:
        return Request.Priority.IMMEDIATE;
      default:
        return Request.Priority.NORMAL;
    }
  }

  /**
   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and
   * results on volley's background thread.
   */
  public static class GlideRequest extends Request<byte[]> {
    private final DataCallback<? super InputStream> callback;
    private final Priority priority;
    private final Map<String, String> headers;

    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority) {
      this(url, callback, priority, Collections.<String, String>emptyMap());
    }

    public GlideRequest(String url, DataCallback<? super InputStream> callback, Priority priority,
        Map<String, String> headers) {
      super(Method.GET, url, null);
      this.callback = callback;
      this.priority = priority;
      this.headers = headers;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toStringUrl();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority), url.getHeaders());

        requestFuture.setRequest(requestQueue.add(request));

        return requestFuture.get();
=======
    public Priority getPriority() {
      return priority;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public String getId() {
        return url.getCacheKey();
=======
    protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
      callback.onDataReady(new ByteArrayInputStream(response.data));
      return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
    public void cancel() {
        VolleyRequestFuture<InputStream> localFuture = requestFuture;
        if (localFuture != null) {
            localFuture.cancel(true);
        }
    }

    private static Request.Priority glideToVolleyPriority(Priority priority) {
        switch (priority) {
            case LOW:
                return Request.Priority.LOW;
            case HIGH:
                return Request.Priority.HIGH;
            case IMMEDIATE:
                return Request.Priority.IMMEDIATE;
            default:
                return Request.Priority.NORMAL;

        }
    }

    private static class GlideRequest extends Request<byte[]> {
        private final VolleyRequestFuture<InputStream> future;
        private final Priority priority;
        private final Map<String, String> headers;

        public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
          this(url, future, priority, Collections.<String, String>emptyMap());
        }

        public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority,
                  Map<String, String> headers) {
              super(Method.GET, url, future);
              this.future = future;
              this.priority = priority;
          this.headers = headers;
        }

        @Override
        public Map<String, String> getHeaders() throws AuthFailureError {
          return headers;
        }

        @Override
        public Priority getPriority() {
            return priority;
        }

        @Override
        protected Response<byte[]> parseNetworkResponse(NetworkResponse response) {
            return Response.success(response.data, HttpHeaderParser.parseCacheHeaders(response));
        }

        @Override
        protected void deliverResponse(byte[] response) {
            future.onResponse(new ByteArrayInputStream(response));
        }
=======
    protected void deliverResponse(byte[] response) {
      // Do nothing.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java;<<<<<<< MINE
     * <p>
     *     Status will update per frame to allow the caller to tell whether or not the current frame was decoded
     *     successfully and/or completely. Format and open failures persist across frames.
     * </p>
     */
    public int getStatus() {
        return status;
    }

    /**
     * Move the animation frame counter forward.
     */
    public void advance() {
        framePointer = (framePointer + 1) % header.frameCount;
    }

    /**
     * Gets display duration for specified frame.
     *
     * @param n int index of frame.
     * @return delay in milliseconds.
     */
    public int getDelay(int n) {
        int delay = -1;
        if ((n >= 0) && (n < header.frameCount)) {
            delay = header.frames.get(n).delay;
        }
        return delay;
    }

    /**
     * Gets display duration for the upcoming frame in ms.
     */
    public int getNextDelay() {
        if (header.frameCount <= 0 || framePointer < 0) {
            return -1;
        }

        return getDelay(framePointer);
    }

    /**
     * Gets the number of frames read from file.
     *
     * @return frame count.
     */
    public int getFrameCount() {
        return header.frameCount;
    }

    /**
     * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
     *
     * @return frame index.
     */
    public int getCurrentFrameIndex() {
        return framePointer;
    }

    public void resetFrameIndex() {
        framePointer = -1;
    }

    /**
     * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
     *
     * @return iteration count if one was specified, else 1.
     */
    public int getLoopCount() {
        return header.loopCount;
    }

    /**
     * Get the next frame in the animation sequence.
     *
     * @return Bitmap representation of frame.
     */
    public synchronized Bitmap getNextFrame() {
        if (header.frameCount <= 0 || framePointer < 0) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer=" + framePointer);
            }
            status = STATUS_FORMAT_ERROR;
        }
        if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Unable to decode frame, status=" + status);
            }
            return null;
        }
        status = STATUS_OK;

        GifFrame currentFrame = header.frames.get(framePointer);
        GifFrame previousFrame = null;
        int previousIndex = framePointer - 1;
        if (previousIndex >= 0) {
            previousFrame = header.frames.get(previousIndex);
        }

        // Set the appropriate color table.
        if (currentFrame.lct == null) {
            act = header.gct;
        } else {
            act = currentFrame.lct;
            if (header.bgIndex == currentFrame.transIndex) {
                header.bgColor = 0;
            }
        }

        int save = 0;
        if (currentFrame.transparency) {
            save = act[currentFrame.transIndex];
            // Set transparent color if specified.
            act[currentFrame.transIndex] = 0;
        }
        if (act == null) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "No Valid Color Table");
            }
            // No color table defined.
            status = STATUS_FORMAT_ERROR;
            return null;
        }

        // Transfer pixel data to image.
        Bitmap result = setPixels(currentFrame, previousFrame);

        // Reset the transparent pixel in the color table
        if (currentFrame.transparency) {
            act[currentFrame.transIndex] = save;
        }

        return result;
    }

    /**
     * Reads GIF image from stream.
     *
     * @param is containing GIF file.
     * @return read status code (0 = no errors).
     */
    public int read(InputStream is, int contentLength) {
        if (is != null) {
            try {
                int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
                ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
                int nRead;
                byte[] data = new byte[16384];
                while ((nRead = is.read(data, 0, data.length)) != -1) {
                    buffer.write(data, 0, nRead);
                }
                buffer.flush();

                read(buffer.toByteArray());
            } catch (IOException e) {
                Log.w(TAG, "Error reading data from stream", e);
            }
        } else {
            status = STATUS_OPEN_ERROR;
        }

        try {
            if (is != null) {
                is.close();
            }
        } catch (IOException e) {
            Log.w(TAG, "Error closing stream", e);
        }

        return status;
    }

    public void clear() {
        header = null;
        data = null;
        mainPixels = null;
        mainScratch = null;
        if (previousImage != null) {
            bitmapProvider.release(previousImage);
        }
        previousImage = null;
    }

    public void setData(GifHeader header, byte[] data) {
        this.header = header;
        this.data = data;
        this.status = STATUS_OK;
        framePointer = INITIAL_FRAME_POINTER;
        // Initialize the raw data buffer.
        rawData = ByteBuffer.wrap(data);
        rawData.rewind();
        rawData.order(ByteOrder.LITTLE_ENDIAN);


        // No point in specially saving an old frame if we're never going to use it.
        savePrevious = false;
        for (GifFrame frame : header.frames) {
            if (frame.dispose == DISPOSAL_PREVIOUS) {
                savePrevious = true;
                break;
            }
        }

        // Now that we know the size, init scratch arrays.
        mainPixels = new byte[header.width * header.height];
        mainScratch = new int[header.width * header.height];
    }

    private GifHeaderParser getHeaderParser() {
        if (parser == null) {
            parser = new GifHeaderParser();
        }
        return parser;
    }

    /**
     * Reads GIF image from byte array.
     *
     * @param data containing GIF file.
     * @return read status code (0 = no errors).
     */
    public int read(byte[] data) {
        this.data = data;
        this.header = getHeaderParser().setData(data).parseHeader();
        if (data != null) {
            // Initialize the raw data buffer.
            rawData = ByteBuffer.wrap(data);
            rawData.rewind();
            rawData.order(ByteOrder.LITTLE_ENDIAN);

            // Now that we know the size, init scratch arrays.
            mainPixels = new byte[header.width * header.height];
            mainScratch = new int[header.width * header.height];

            // No point in specially saving an old frame if we're never going to use it.
            savePrevious = false;
            for (GifFrame frame : header.frames) {
                if (frame.dispose == DISPOSAL_PREVIOUS) {
                    savePrevious = true;
                    break;
                }
            }
        }

        return status;
    }

    /**
     * Creates new frame image from current data (and previous frames as specified by their disposition codes).
     */
    private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {

        int width = header.width;
        int height = header.height;

        // Final location of blended pixels.
        final int[] dest = mainScratch;

        // fill in starting image contents based on last image's dispose code
        if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
            // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our mainScratch
            // and therefore so will our dest array.
            if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
                // Start with a canvas filled with the background color
                int c = 0;
                if (!currentFrame.transparency) {
                    c = header.bgColor;
                }
                Arrays.fill(dest, c);
            } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
                // Start with the previous frame
                previousImage.getPixels(dest, 0, width, 0, 0, width, height);
            }
        }

        // Decode pixels for this frame  into the global pixels[] scratch.
        decodeBitmapData(currentFrame);

        // Copy each source line to the appropriate place in the destination.
        int pass = 1;
        int inc = 8;
        int iline = 0;
        for (int i = 0; i < currentFrame.ih; i++) {
            int line = i;
            if (currentFrame.interlace) {
                if (iline >= currentFrame.ih) {
                    pass++;
                    switch (pass) {
                        case 2:
                            iline = 4;
                            break;
                        case 3:
                            iline = 2;
                            inc = 4;
                            break;
                        case 4:
                            iline = 1;
                            inc = 2;
                            break;
                        default:
                            break;
                    }
                }
                line = iline;
                iline += inc;
            }
            line += currentFrame.iy;
            if (line < header.height) {
                int k = line * header.width;
                // Start of line in dest.
                int dx = k + currentFrame.ix;
                // End of dest line.
                int dlim = dx + currentFrame.iw;
                if ((k + header.width) < dlim) {
                    // Past dest edge.
                    dlim = k + header.width;
                }
                // Start of line in source.
                int sx = i * currentFrame.iw;
                while (dx < dlim) {
                    // Map color and insert in destination.
                    int index = ((int) mainPixels[sx++]) & 0xff;
                    int c = act[index];
                    if (c != 0) {
                        dest[dx] = c;
                    }
                    dx++;
                }
            }
        }

        // Copy pixels into previous image
        if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
            || currentFrame.dispose == DISPOSAL_NONE)) {
            if (previousImage == null) {
                previousImage = getNextBitmap();
            }
            previousImage.setPixels(dest, 0, width, 0, 0, width, height);
        }

        // Set pixels for current image.
        Bitmap result = getNextBitmap();
        result.setPixels(dest, 0, width, 0, 0, width, height);
        return result;
    }

    /**
     * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
     */
    private void decodeBitmapData(GifFrame frame) {
        if (frame != null) {
            // Jump to the frame start position.
            rawData.position(frame.bufferFrameStart);
        }

        int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
        int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count, i, datum,
                dataSize, first, top, bi, pi;

        if (mainPixels == null || mainPixels.length < npix) {
            // Allocate new pixel array.
            mainPixels = new byte[npix];
        }
        if (prefix == null) {
            prefix = new short[MAX_STACK_SIZE];
        }
        if (suffix == null) {
            suffix = new byte[MAX_STACK_SIZE];
        }
        if (pixelStack == null) {
            pixelStack = new byte[MAX_STACK_SIZE + 1];
        }

        // Initialize GIF data stream decoder.
        dataSize = read();
        clear = 1 << dataSize;
        endOfInformation = clear + 1;
        available = clear + 2;
        oldCode = NULL_CODE;
        codeSize = dataSize + 1;
        codeMask = (1 << codeSize) - 1;
        for (code = 0; code < clear; code++) {
            // XXX ArrayIndexOutOfBoundsException.
            prefix[code] = 0;
            suffix[code] = (byte) code;
        }

        // Decode GIF pixel stream.
        datum = bits = count = first = top = pi = bi = 0;
        for (i = 0; i < npix; ) {
            // Load bytes until there are enough bits for a code.
            if (count == 0) {
                // Read a new data block.
                count = readBlock();
                if (count <= 0) {
                    status = STATUS_PARTIAL_DECODE;
                    break;
                }
                bi = 0;
            }

            datum += (((int) block[bi]) & 0xff) << bits;
            bits += 8;
            bi++;
            count--;

            while (bits >= codeSize) {
                // Get the next code.
                code = datum & codeMask;
                datum >>= codeSize;
                bits -= codeSize;

                // Interpret the code.
                if (code == clear) {
                    // Reset decoder.
                    codeSize = dataSize + 1;
                    codeMask = (1 << codeSize) - 1;
                    available = clear + 2;
                    oldCode = NULL_CODE;
                    continue;
                }

                if (code > available) {
                    status = STATUS_PARTIAL_DECODE;
                    break;
                }

                if (code == endOfInformation) {
                    break;
                }

                if (oldCode == NULL_CODE) {
                    pixelStack[top++] = suffix[code];
                    oldCode = code;
                    first = code;
                    continue;
                }
                inCode = code;
                if (code >= available) {
                    pixelStack[top++] = (byte) first;
                    code = oldCode;
                }
                while (code >= clear) {
                    pixelStack[top++] = suffix[code];
                    code = prefix[code];
                }
                first = ((int) suffix[code]) & 0xff;
                pixelStack[top++] = (byte) first;

                // Add a new string to the string table.
                if (available < MAX_STACK_SIZE) {
                    prefix[available] = (short) oldCode;
                    suffix[available] = (byte) first;
                    available++;
                    if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
                        codeSize++;
                        codeMask += available;
                    }
                }
                oldCode = inCode;

                while (top > 0) {
                    // Pop a pixel off the pixel stack.
                    top--;
                    mainPixels[pi++] = pixelStack[top];
                    i++;
                }
            }
        }

        // Clear missing pixels.
        for (i = pi; i < npix; i++) {
            mainPixels[i] = 0;
        }
    }

    /**
     * Reads a single byte from the input stream.
     */
    private int read() {
        int curByte = 0;
        try {
            curByte = rawData.get() & 0xFF;
        } catch (Exception e) {
            status = STATUS_FORMAT_ERROR;
        }
        return curByte;
    }

    /**
     * Reads next variable length block from input.
     *
     * @return number of bytes stored in "buffer".
     */
    private int readBlock() {
        int blockSize = read();
        int n = 0;
        if (blockSize > 0) {
            try {
                int count;
                while (n < blockSize) {
                    count = blockSize - n;
                    rawData.get(block, n, count);

                    n += count;
                }
            } catch (Exception e) {
                Log.w(TAG, "Error Reading Block", e);
                status = STATUS_FORMAT_ERROR;
            }
        }
        return n;
    }

    private Bitmap getNextBitmap() {
        Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
        if (result == null) {
            result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
        }
        setAlpha(result);
        return result;
    }

    @TargetApi(12)
    private static void setAlpha(Bitmap bitmap) {
        if (Build.VERSION.SDK_INT >= 12) {
            bitmap.setHasAlpha(true);
        }
=======
     * @param width  The width in pixels of the desired {@link android.graphics.Bitmap}.
     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}.
     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link
     *               android.graphics.Bitmap}.
     */
    Bitmap obtain(int width, int height, Bitmap.Config config);

    /**
     * Releases the given Bitmap back to the pool.
     */
    void release(Bitmap bitmap);
  }

  public GifDecoder(BitmapProvider provider, GifHeader gifHeader, ByteBuffer rawData) {
    this(provider);
    setData(gifHeader, rawData);
  }

  public GifDecoder(BitmapProvider provider) {
    this.bitmapProvider = provider;
    header = new GifHeader();
  }

  public int getWidth() {
    return header.width;
  }

  public int getHeight() {
    return header.height;
  }

  public ByteBuffer getData() {
    return rawData;
  }

  /**
   * Returns the current status of the decoder.
   *
   * <p> Status will update per frame to allow the caller to tell whether or not the current frame
   * was decoded successfully and/or completely. Format and open failures persist across frames.
   * </p>
   */
  public int getStatus() {
    return status;
  }

  /**
   * Move the animation frame counter forward.
   */
  public void advance() {
    framePointer = (framePointer + 1) % header.frameCount;
  }

  /**
   * Gets display duration for specified frame.
   *
   * @param n int index of frame.
   * @return delay in milliseconds.
   */
  public int getDelay(int n) {
    int delay = -1;
    if ((n >= 0) && (n < header.frameCount)) {
      delay = header.frames.get(n).delay;
    }
    return delay;
  }

  /**
   * Gets display duration for the upcoming frame in ms.
   */
  public int getNextDelay() {
    if (header.frameCount <= 0 || framePointer < 0) {
      return -1;
    }

    return getDelay(framePointer);
  }

  /**
   * Gets the number of frames read from file.
   *
   * @return frame count.
   */
  public int getFrameCount() {
    return header.frameCount;
  }

  /**
   * Gets the current index of the animation frame, or -1 if animation hasn't not yet started.
   *
   * @return frame index.
   */
  public int getCurrentFrameIndex() {
    return framePointer;
  }

  public void resetFrameIndex() {
    framePointer = -1;
  }

  /**
   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.
   *
   * @return iteration count if one was specified, else 1.
   */
  public int getLoopCount() {
    return header.loopCount;
  }

  /**
   * Get the next frame in the animation sequence.
   *
   * @return Bitmap representation of frame.
   */
  public synchronized Bitmap getNextFrame() {
    if (header.frameCount <= 0 || framePointer < 0) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "unable to decode frame, frameCount=" + header.frameCount + " framePointer="
            + framePointer);
      }
      status = STATUS_FORMAT_ERROR;
    }
    if (status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "Unable to decode frame, status=" + status);
      }
      return null;
    }
    status = STATUS_OK;

    GifFrame currentFrame = header.frames.get(framePointer);
    GifFrame previousFrame = null;
    int previousIndex = framePointer - 1;
    if (previousIndex >= 0) {
      previousFrame = header.frames.get(previousIndex);
    }

    // Set the appropriate color table.
    if (currentFrame.lct == null) {
      act = header.gct;
    } else {
      act = currentFrame.lct;
      if (header.bgIndex == currentFrame.transIndex) {
        header.bgColor = 0;
      }
    }

    int save = 0;
    if (currentFrame.transparency) {
      save = act[currentFrame.transIndex];
      // Set transparent color if specified.
      act[currentFrame.transIndex] = 0;
    }
    if (act == null) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "No Valid Color Table");
      }
      // No color table defined.
      status = STATUS_FORMAT_ERROR;
      return null;
    }

    // Transfer pixel data to image.
    Bitmap result = setPixels(currentFrame, previousFrame);

    // Reset the transparent pixel in the color table
    if (currentFrame.transparency) {
      act[currentFrame.transIndex] = save;
    }

    return result;
  }

  /**
   * Reads GIF image from stream.
   *
   * @param is containing GIF file.
   * @return read status code (0 = no errors).
   */
  public int read(InputStream is, int contentLength) {
    if (is != null) {
      try {
        int capacity = (contentLength > 0) ? (contentLength + 4096) : 16384;
        ByteArrayOutputStream buffer = new ByteArrayOutputStream(capacity);
        int nRead;
        byte[] data = new byte[16384];
        while ((nRead = is.read(data, 0, data.length)) != -1) {
          buffer.write(data, 0, nRead);
        }
        buffer.flush();

        read(buffer.toByteArray());
      } catch (IOException e) {
        Log.w(TAG, "Error reading data from stream", e);
      }
    } else {
      status = STATUS_OPEN_ERROR;
    }

    try {
      if (is != null) {
        is.close();
      }
    } catch (IOException e) {
      Log.w(TAG, "Error closing stream", e);
    }

    return status;
  }

  public void clear() {
    header = null;
    mainPixels = null;
    mainScratch = null;
    if (previousImage != null) {
      bitmapProvider.release(previousImage);
    }
    previousImage = null;
    rawData = null;
  }

  public synchronized void setData(GifHeader header, byte[] data) {
    setData(header, ByteBuffer.wrap(data));
  }

  public synchronized void setData(GifHeader header, ByteBuffer buffer) {
    this.status = STATUS_OK;
    this.header = header;
    framePointer = INITIAL_FRAME_POINTER;
    // Initialize the raw data buffer.
    rawData = buffer.asReadOnlyBuffer();
    rawData.rewind();
    rawData.order(ByteOrder.LITTLE_ENDIAN);

    // No point in specially saving an old frame if we're never going to use it.
    savePrevious = false;
    for (GifFrame frame : header.frames) {
      if (frame.dispose == DISPOSAL_PREVIOUS) {
        savePrevious = true;
        break;
      }
    }

    // Now that we know the size, init scratch arrays.
    mainPixels = new byte[header.width * header.height];
    mainScratch = new int[header.width * header.height];
  }

  private GifHeaderParser getHeaderParser() {
    if (parser == null) {
      parser = new GifHeaderParser();
    }
    return parser;
  }

  /**
   * Reads GIF image from byte array.
   *
   * @param data containing GIF file.
   * @return read status code (0 = no errors).
   */
  public synchronized int read(byte[] data) {
    this.header = getHeaderParser().setData(data).parseHeader();
    if (data != null) {
      // Initialize the raw data buffer.
      rawData = ByteBuffer.wrap(data);
      rawData.rewind();
      rawData.order(ByteOrder.LITTLE_ENDIAN);

      // Now that we know the size, init scratch arrays.
      mainPixels = new byte[header.width * header.height];
      mainScratch = new int[header.width * header.height];

      // No point in specially saving an old frame if we're never going to use it.
      savePrevious = false;
      for (GifFrame frame : header.frames) {
        if (frame.dispose == DISPOSAL_PREVIOUS) {
          savePrevious = true;
          break;
        }
      }
    }

    return status;
  }

  /**
   * Creates new frame image from current data (and previous frames as specified by their
   * disposition codes).
   */
  private Bitmap setPixels(GifFrame currentFrame, GifFrame previousFrame) {

    int width = header.width;
    int height = header.height;

    // Final location of blended pixels.
    final int[] dest = mainScratch;

    // fill in starting image contents based on last image's dispose code
    if (previousFrame != null && previousFrame.dispose > DISPOSAL_UNSPECIFIED) {
      // We don't need to do anything for DISPOSAL_NONE, if it has the correct pixels so will our
      // mainScratch
      // and therefore so will our dest array.
      if (previousFrame.dispose == DISPOSAL_BACKGROUND) {
        // Start with a canvas filled with the background color
        int c = 0;
        if (!currentFrame.transparency) {
          c = header.bgColor;
        }
        Arrays.fill(dest, c);
      } else if (previousFrame.dispose == DISPOSAL_PREVIOUS && previousImage != null) {
        // Start with the previous frame
        previousImage.getPixels(dest, 0, width, 0, 0, width, height);
      }
    }

    // Decode pixels for this frame  into the global pixels[] scratch.
    decodeBitmapData(currentFrame);

    // Copy each source line to the appropriate place in the destination.
    int pass = 1;
    int inc = 8;
    int iline = 0;
    for (int i = 0; i < currentFrame.ih; i++) {
      int line = i;
      if (currentFrame.interlace) {
        if (iline >= currentFrame.ih) {
          pass++;
          switch (pass) {
            case 2:
              iline = 4;
              break;
            case 3:
              iline = 2;
              inc = 4;
              break;
            case 4:
              iline = 1;
              inc = 2;
              break;
            default:
              break;
          }
        }
        line = iline;
        iline += inc;
      }
      line += currentFrame.iy;
      if (line < header.height) {
        int k = line * header.width;
        // Start of line in dest.
        int dx = k + currentFrame.ix;
        // End of dest line.
        int dlim = dx + currentFrame.iw;
        if ((k + header.width) < dlim) {
          // Past dest edge.
          dlim = k + header.width;
        }
        // Start of line in source.
        int sx = i * currentFrame.iw;
        while (dx < dlim) {
          // Map color and insert in destination.
          int index = ((int) mainPixels[sx++]) & 0xff;
          int c = act[index];
          if (c != 0) {
            dest[dx] = c;
          }
          dx++;
        }
      }
    }

    // Copy pixels into previous image
    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
        || currentFrame.dispose == DISPOSAL_NONE)) {
      if (previousImage == null) {
        previousImage = getNextBitmap();
      }
      previousImage.setPixels(dest, 0, width, 0, 0, width, height);
    }

    // Set pixels for current image.
    Bitmap result = getNextBitmap();
    result.setPixels(dest, 0, width, 0, 0, width, height);
    return result;
  }

  /**
   * Decodes LZW image data into pixel array. Adapted from John Cristy's BitmapMagick.
   */
  private void decodeBitmapData(GifFrame frame) {
    if (frame != null) {
      // Jump to the frame start position.
      rawData.position(frame.bufferFrameStart);
    }

    int npix = (frame == null) ? header.width * header.height : frame.iw * frame.ih;
    int available, clear, codeMask, codeSize, endOfInformation, inCode, oldCode, bits, code, count,
        i, datum,
        dataSize, first, top, bi, pi;

    if (mainPixels == null || mainPixels.length < npix) {
      // Allocate new pixel array.
      mainPixels = new byte[npix];
    }
    if (prefix == null) {
      prefix = new short[MAX_STACK_SIZE];
    }
    if (suffix == null) {
      suffix = new byte[MAX_STACK_SIZE];
    }
    if (pixelStack == null) {
      pixelStack = new byte[MAX_STACK_SIZE + 1];
    }

    // Initialize GIF data stream decoder.
    dataSize = read();
    clear = 1 << dataSize;
    endOfInformation = clear + 1;
    available = clear + 2;
    oldCode = NULL_CODE;
    codeSize = dataSize + 1;
    codeMask = (1 << codeSize) - 1;
    for (code = 0; code < clear; code++) {
      // XXX ArrayIndexOutOfBoundsException.
      prefix[code] = 0;
      suffix[code] = (byte) code;
    }

    // Decode GIF pixel stream.
    datum = bits = count = first = top = pi = bi = 0;
    for (i = 0; i < npix; ) {
      // Load bytes until there are enough bits for a code.
      if (count == 0) {
        // Read a new data block.
        count = readBlock();
        if (count <= 0) {
          status = STATUS_PARTIAL_DECODE;
          break;
        }
        bi = 0;
      }

      datum += (((int) block[bi]) & 0xff) << bits;
      bits += 8;
      bi++;
      count--;

      while (bits >= codeSize) {
        // Get the next code.
        code = datum & codeMask;
        datum >>= codeSize;
        bits -= codeSize;

        // Interpret the code.
        if (code == clear) {
          // Reset decoder.
          codeSize = dataSize + 1;
          codeMask = (1 << codeSize) - 1;
          available = clear + 2;
          oldCode = NULL_CODE;
          continue;
        }

        if (code > available) {
          status = STATUS_PARTIAL_DECODE;
          break;
        }

        if (code == endOfInformation) {
          break;
        }

        if (oldCode == NULL_CODE) {
          pixelStack[top++] = suffix[code];
          oldCode = code;
          first = code;
          continue;
        }
        inCode = code;
        if (code >= available) {
          pixelStack[top++] = (byte) first;
          code = oldCode;
        }
        while (code >= clear) {
          pixelStack[top++] = suffix[code];
          code = prefix[code];
        }
        first = ((int) suffix[code]) & 0xff;
        pixelStack[top++] = (byte) first;

        // Add a new string to the string table.
        if (available < MAX_STACK_SIZE) {
          prefix[available] = (short) oldCode;
          suffix[available] = (byte) first;
          available++;
          if (((available & codeMask) == 0) && (available < MAX_STACK_SIZE)) {
            codeSize++;
            codeMask += available;
          }
        }
        oldCode = inCode;

        while (top > 0) {
          // Pop a pixel off the pixel stack.
          top--;
          mainPixels[pi++] = pixelStack[top];
          i++;
        }
      }
    }

    // Clear missing pixels.
    for (i = pi; i < npix; i++) {
      mainPixels[i] = 0;
    }
  }

  /**
   * Reads a single byte from the input stream.
   */
  private int read() {
    int curByte = 0;
    try {
      curByte = rawData.get() & 0xFF;
    } catch (Exception e) {
      status = STATUS_FORMAT_ERROR;
    }
    return curByte;
  }

  /**
   * Reads next variable length block from input.
   *
   * @return number of bytes stored in "buffer".
   */
  private int readBlock() {
    int blockSize = read();
    int n = 0;
    if (blockSize > 0) {
      try {
        int count;
        while (n < blockSize) {
          count = blockSize - n;
          rawData.get(block, n, count);

          n += count;
        }
      } catch (Exception e) {
        Log.w(TAG, "Error Reading Block", e);
        status = STATUS_FORMAT_ERROR;
      }
    }
    return n;
  }

  private Bitmap getNextBitmap() {
    Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);
    if (result == null) {
      result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);
    }
    setAlpha(result);
    return result;
  }

  @TargetApi(12)
  private static void setAlpha(Bitmap bitmap) {
    if (Build.VERSION.SDK_INT >= 12) {
      bitmap.setHasAlpha(true);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java;<<<<<<< MINE
=======
import com.bumptech.glide.manager.RequestManagerTreeNode;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java;<<<<<<< MINE
    private RequestManager manager;
    private ConnectivityMonitor connectivityMonitor;
    private RequestTracker requestTracker;
    private ConnectivityListener connectivityListener;
    private RequestManager.DefaultOptions options;
    private Lifecycle lifecycle = mock(Lifecycle.class);
    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);

    @Before
    public void setUp() {
        connectivityMonitor = mock(ConnectivityMonitor.class);
        ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
        when(factory.build(any(Context.class), any(ConnectivityMonitor.ConnectivityListener.class)))
                .thenAnswer(new Answer<ConnectivityMonitor>() {
                    @Override
                    public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
                        connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
                        return connectivityMonitor;
                    }
                });
        requestTracker = mock(RequestTracker.class);
        manager =
            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);
        options = mock(RequestManager.DefaultOptions.class);
        manager.setDefaultOptions(options);
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingGenericModelLoaderAndDataClass() {
        Float model = 1f;
        ModelLoader<Float, InputStream> modelLoader = mock(ModelLoader.class);
        GenericTranscodeRequest<Float, InputStream, Bitmap> builder = manager.using(modelLoader, InputStream.class)
                .load(model)
                .as(Bitmap.class);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingImageStreamModelLoader() {
        String model = "fake";
        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);
        DrawableTypeRequest<String> builder = manager.using(modelLoader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingByteArrayLoader() {
        byte[] model = new byte[] { 1, 4, 65, 2};
        StreamByteArrayLoader loader = mock(StreamByteArrayLoader.class);
        DrawableTypeRequest<byte[]> builder = manager.using(loader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsWhenUsingVideoFileDescriptorModelLoader() {
        String model = "fake";
        FileDescriptorModelLoader<String> modelLoader = mock(FileDescriptorModelLoader.class);
        DrawableTypeRequest<String> builder = manager.using(modelLoader)
                .load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadString() {
        String model = "fake";
        DrawableTypeRequest<String> builder = manager.load(model);
        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadUri() {
        Uri uri = Uri.EMPTY;
        DrawableTypeRequest<Uri> builder = manager.load(uri);
        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadMediaStoreUri() {
        Uri uri = Uri.EMPTY;
        DrawableTypeRequest<Uri> builder = manager.loadFromMediaStore(uri, "image/jpeg", 123L, 0);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadResourceId() {
        int id = 123;
        DrawableTypeRequest<Integer> builder = manager.load(id);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadGenericFromImage() {
        ModelLoaderFactory<Double, InputStream> factory = mock(ModelLoaderFactory.class);
        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
        Glide.get(Robolectric.application).register(Double.class, InputStream.class, factory);
        Double model = 2.2;
        DrawableTypeRequest<Double> builder = manager.load(model);

        verify(options).apply(eq(builder));
        Glide.get(Robolectric.application).unregister(Double.class, InputStream.class);
    }

    @Test
    public void testAppliesDefaultOptionsToLoadUrl() throws MalformedURLException {
        URL url = new URL("http://www.google.com");
        DrawableTypeRequest<URL> builder = manager.load(url);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadFromImageByteWithId() {
        byte[] model = new byte[] { 1, 2, 4 };
        DrawableTypeRequest<byte[]> builder = manager.load(model, "fakeId");

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadFromImageBytes() {
        byte[] model = new byte[] { 5, 9, 23 };
        DrawableTypeRequest<byte[]> builder = manager.load(model);

        verify(options).apply(eq(builder));
    }

    @Test
    public void testAppliesDefaultOptionsToLoadGenericFromVideo() {
        ModelLoaderFactory<Float, InputStream> factory = mock(ModelLoaderFactory.class);
        when(factory.build(any(Context.class), any(GenericLoaderFactory.class))).thenReturn(mock(ModelLoader.class));
        Glide.get(Robolectric.application).register(Float.class, InputStream.class, factory);
        Float model = 23.2f;
        DrawableTypeRequest<Float> builder = manager.load(model);

        verify(options).apply(eq(builder));
        Glide.get(Robolectric.application).unregister(Float.class, InputStream.class);
    }
=======
  @Mock Lifecycle lifecycle = mock(Lifecycle.class);
  @Mock RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
    private static final String PARENT_TAG = "parent";
    private RetrieverHarness[] harnesses;
    private RequestManagerRetriever retriever;
    private int initialSdkVersion;

    @Before
    public void setUp() {
        retriever = new RequestManagerRetriever();

        harnesses = new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };

        initialSdkVersion = Build.VERSION.SDK_INT;
        Util.setSdkVersionInt(18);
    }

    @After
    public void tearDown() {
        Util.setSdkVersionInt(initialSdkVersion);

        Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
        assertThat(retriever.pendingRequestManagerFragments).isEmpty();
        assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
    }

    @Test
    public void testCreatesNewFragmentIfNoneExists() {
        for (RetrieverHarness harness : harnesses) {
            harness.doGet();

            Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
        }
    }

    @Test
    public void testReturnsNewManagerIfNoneExists() {
        for (RetrieverHarness harness : harnesses) {
            assertNotNull(harness.doGet());
        }
    }

    @Test
    public void testReturnsExistingRequestManagerIfExists() {
        for (RetrieverHarness harness : harnesses) {
            RequestManager requestManager = mock(RequestManager.class);

            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);

            assertEquals(requestManager, harness.doGet());
        }
    }

    @Test
    public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);

            assertNotNull(harness.doGet());
        }
    }

    @Test
    public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
            RequestManager first = harness.doGet();
            RequestManager second = harness.doGet();

            assertEquals(first, second);
        }
    }

    @Test
    public void testHasValidTag() {
        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
    }

    @Test
    public void testCanGetRequestManagerFromActivity() {
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
        RequestManager manager = retriever.get(activity);
        assertEquals(manager, retriever.get(activity));
    }

    @Test
    public void testSupportCanGetRequestManagerFromActivity() {
        FragmentActivity fragmentActivity = Robolectric.buildActivity(FragmentActivity.class).create().start().get();
        RequestManager manager = retriever.get(fragmentActivity);
        assertEquals(manager, retriever.get(fragmentActivity));
    }

    @Test
    public void testCanGetRequestManagerFromFragment() {
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();
        activity.getFragmentManager()
                .beginTransaction()
                .add(fragment, PARENT_TAG)
                .commit();
        activity.getFragmentManager().executePendingTransactions();

        RequestManager manager = retriever.get(fragment);
        assertEquals(manager, retriever.get(fragment));
    }

    @Test
    public void testSupportCanGetRequestManagerFromFragment() {
        FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
        Fragment fragment = new Fragment();
        activity.getSupportFragmentManager()
                .beginTransaction()
                .add(fragment, PARENT_TAG)
                .commit();
        activity.getSupportFragmentManager().executePendingTransactions();

        RequestManager manager = retriever.get(fragment);
        assertEquals(manager, retriever.get(fragment));
    }

    @Test
    public void testCanGetRequestManagerFromDetachedFragment() {
      helpTestCanGetRequestManagerFromDetachedFragment();
    }

    @Test
    public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
      helpTestCanGetRequestManagerFromDetachedFragment();
    }

    private void helpTestCanGetRequestManagerFromDetachedFragment() {
      Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
      android.app.Fragment fragment = new android.app.Fragment();
      activity.getFragmentManager()
        .beginTransaction()
        .add(fragment, PARENT_TAG)
        .detach(fragment)
=======
  private static final String PARENT_TAG = "parent";
  private RetrieverHarness[] harnesses;
  private RequestManagerRetriever retriever;
  private int initialSdkVersion;

  @Before
  public void setUp() {
    retriever = new RequestManagerRetriever();

    harnesses =
        new RetrieverHarness[] { new DefaultRetrieverHarness(), new SupportRetrieverHarness() };

    initialSdkVersion = Build.VERSION.SDK_INT;
    Util.setSdkVersionInt(18);
  }

  @After
  public void tearDown() {
    Util.setSdkVersionInt(initialSdkVersion);

    Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
    assertThat(retriever.pendingRequestManagerFragments).isEmpty();
    assertThat(retriever.pendingSupportRequestManagerFragments).isEmpty();
  }

  @Test
  public void testCreatesNewFragmentIfNoneExists() {
    for (RetrieverHarness harness : harnesses) {
      harness.doGet();

      Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
      assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
    }
  }

  @Test
  public void testReturnsNewManagerIfNoneExists() {
    for (RetrieverHarness harness : harnesses) {
      assertNotNull(harness.doGet());
    }
  }

  @Test
  public void testReturnsExistingRequestManagerIfExists() {
    for (RetrieverHarness harness : harnesses) {
      RequestManager requestManager = mock(RequestManager.class);

      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);

      assertEquals(requestManager, harness.doGet());
    }
  }

  @Test
  public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);

      assertNotNull(harness.doGet());
    }
  }

  @Test
  public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
      RequestManager first = harness.doGet();
      RequestManager second = harness.doGet();

      assertEquals(first, second);
    }
  }

  @Test
  public void testHasValidTag() {
    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
        RequestManagerRetriever.FRAGMENT_TAG);
  }

  @Test
  public void testCanGetRequestManagerFromActivity() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().get();
    RequestManager manager = retriever.get(activity);
    assertEquals(manager, retriever.get(activity));
  }

  @Test
  public void testSupportCanGetRequestManagerFromActivity() {
    FragmentActivity fragmentActivity =
        Robolectric.buildActivity(FragmentActivity.class).create().start().get();
    RequestManager manager = retriever.get(fragmentActivity);
    assertEquals(manager, retriever.get(fragmentActivity));
  }

  @Test
  public void testCanGetRequestManagerFromFragment() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();
    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
    activity.getFragmentManager().executePendingTransactions();

    RequestManager manager = retriever.get(fragment);
    assertEquals(manager, retriever.get(fragment));
  }

  @Test
  public void testSupportCanGetRequestManagerFromFragment() {
    FragmentActivity activity =
        Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
    Fragment fragment = new Fragment();
    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG).commit();
    activity.getSupportFragmentManager().executePendingTransactions();

    RequestManager manager = retriever.get(fragment);
    assertEquals(manager, retriever.get(fragment));
  }

  @Test
  public void testCanGetRequestManagerFromDetachedFragment() {
    helpTestCanGetRequestManagerFromDetachedFragment();
  }

  @Test
  public void testCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
    helpTestCanGetRequestManagerFromDetachedFragment();
  }

  private void helpTestCanGetRequestManagerFromDetachedFragment() {
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();
    activity.getFragmentManager().beginTransaction().add(fragment, PARENT_TAG).detach(fragment)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
      activity.getFragmentManager().executePendingTransactions();

      assertTrue(fragment.isDetached());
      retriever.get(fragment);
    }

    @Test
    public void testSupportCanGetRequestManagerFromDetachedFragment() {
      helpTestSupportCanGetRequestManagerFromDetachedFragment();
    }

    @Test
    public void testSupportCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
      Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
      helpTestSupportCanGetRequestManagerFromDetachedFragment();
    }

    private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
      FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
      Fragment fragment = new Fragment();
      activity.getSupportFragmentManager()
              .beginTransaction()
              .add(fragment, PARENT_TAG)
              .detach(fragment)
              .commit();
      activity.getSupportFragmentManager().executePendingTransactions();

      assertTrue(fragment.isDetached());
      retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfFragmentNotAttached() {
        android.app.Fragment fragment = new android.app.Fragment();
        retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfSupportFragmentNotAttached() {
        Fragment fragment = new Fragment();
        retriever.get(fragment);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfActivityDestroyed() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        harness.getController().pause().stop().destroy();
        harness.doGet();
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfFragmentActivityDestroyed() {
        SupportRetrieverHarness harness = new SupportRetrieverHarness();
        harness.getController().pause().stop().destroy();
        harness.doGet();
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullContext() {
        retriever.get((Context) null);
    }

    @Test
    public void testChecksIfContextIsFragmentActivity() {
        SupportRetrieverHarness harness = new SupportRetrieverHarness();
        RequestManager requestManager = harness.doGet();

        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
    }

    @Test
    public void testChecksIfContextIsActivity() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        RequestManager requestManager = harness.doGet();

        assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
    }

    @Test
    public void testHandlesContextWrappersForActivities() {
        DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
        RequestManager requestManager = harness.doGet();
        ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());

        assertEquals(requestManager, retriever.get(contextWrapper));
    }

    @Test
    public void testHandlesContextWrappersForApplication() {
        ContextWrapper contextWrapper = new ContextWrapper(Robolectric.application);
        RequestManager requestManager = retriever.get(Robolectric.application);

        assertEquals(requestManager, retriever.get(contextWrapper));
    }

    @Test
    public void testReturnsNonNullManagerIfGivenApplicationContext() {
        assertNotNull(retriever.get(Robolectric.application));
    }

    @Test
    public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
        RequestManager manager = retriever.get(Robolectric.application);
        assertFalse(manager.isPaused());
    }

    @Test
    public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
        RequestManager manager = retriever.get(Robolectric.application);
        manager.pauseRequests();
        manager = retriever.get(Robolectric.application);
        assertTrue(manager.isPaused());
    }

    @Test
    public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread() throws InterruptedException {
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                retriever.get(Robolectric.application);
            }
        });
    }

    // See Issue #117: https://github.com/bumptech/glide/issues/117.
    @Test
    public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
        // Robolectric by default runs messages posted to the main looper synchronously, the framework does not. We post
        // to the main thread here to work around an issue caused by a recursive method call so we need (and reasonably
        // expect) our message to not run immediately
        Robolectric.shadowOf(Looper.getMainLooper()).pause();
        Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
        Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
        Activity activity = mock(Activity.class);
        when(activity.getApplicationContext()).thenReturn(Robolectric.application);
        when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(activity));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        Activity spyActivity = Mockito.spy(activity);
        when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyActivity));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
        Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();

        activity.getFragmentManager()
                .beginTransaction().add(fragment, "test")
                .commit();
        android.app.Fragment spyFragment = Mockito.spy(fragment);
        when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyFragment));
    }

    @Test
    public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
        Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
        Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
        android.app.Fragment fragment = new android.app.Fragment();

        activity.getFragmentManager()
                .beginTransaction().add(fragment, "test")
                .commit();
        android.app.Fragment spyFragment = Mockito.spy(fragment);
        when(spyFragment.getChildFragmentManager()).thenThrow(new NoSuchMethodError());

        assertNotNull(retriever.get(spyFragment));
    }

    private interface RetrieverHarness {

        public ActivityController getController();

        public RequestManager doGet();

        public boolean hasFragmentWithTag(String tag);

        public void addFragmentWithTag(String tag, RequestManager manager);
    }

    public class DefaultRetrieverHarness implements RetrieverHarness {
        private final ActivityController<Activity> controller = Robolectric.buildActivity(Activity.class);
        private final android.app.Fragment parent;

        public DefaultRetrieverHarness() {
            this.parent = new android.app.Fragment();

            controller.create();
            controller.get().getFragmentManager()
                .beginTransaction()
                .add(parent, PARENT_TAG)
                .commitAllowingStateLoss();
            controller.get().getFragmentManager().executePendingTransactions();
            controller.start().resume();
        }

        @Override
        public ActivityController getController() {
            return controller;
        }

        @Override
        public RequestManager doGet() {
            return retriever.get(controller.get());
        }

        @Override
        public boolean hasFragmentWithTag(String tag) {
            return null != controller.get()
                .getFragmentManager()
                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
        }

        @Override
        public void addFragmentWithTag(String tag, RequestManager requestManager) {
            RequestManagerFragment fragment = new RequestManagerFragment();
            fragment.setRequestManager(requestManager);
            controller.get().getFragmentManager()
                    .beginTransaction()
                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getFragmentManager().executePendingTransactions();
        }
    }

    public class SupportRetrieverHarness implements RetrieverHarness {
        private final ActivityController<FragmentActivity> controller = Robolectric.buildActivity(
                FragmentActivity.class);
        private final Fragment parent;

        public SupportRetrieverHarness() {
            this.parent = new Fragment();

            controller.create();
            controller.get().getSupportFragmentManager()
                    .beginTransaction()
                    .add(parent, PARENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getSupportFragmentManager().executePendingTransactions();
            controller.start().resume();
        }

        @Override
        public ActivityController getController() {
            return controller;
        }

        @Override
        public RequestManager doGet() {
            return retriever.get(controller.get());
        }

        @Override
        public boolean hasFragmentWithTag(String tag) {
            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
                    != null;
        }
=======
    activity.getFragmentManager().executePendingTransactions();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
        @Override
        public void addFragmentWithTag(String tag, RequestManager manager) {
            SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
            fragment.setRequestManager(manager);
            controller.get().getSupportFragmentManager()
                    .beginTransaction()
                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getSupportFragmentManager().executePendingTransactions();
        }
=======
    assertTrue(fragment.isDetached());
    retriever.get(fragment);
  }

  @Test
  public void testSupportCanGetRequestManagerFromDetachedFragment() {
    helpTestSupportCanGetRequestManagerFromDetachedFragment();
  }

  @Test
  public void testSupportCanGetRequestManagerFromDetachedFragment_PreJellyBeanMr1() {
    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
    helpTestSupportCanGetRequestManagerFromDetachedFragment();
  }

  private void helpTestSupportCanGetRequestManagerFromDetachedFragment() {
    FragmentActivity activity =
        Robolectric.buildActivity(FragmentActivity.class).create().start().resume().get();
    Fragment fragment = new Fragment();
    activity.getSupportFragmentManager().beginTransaction().add(fragment, PARENT_TAG)
        .detach(fragment).commit();
    activity.getSupportFragmentManager().executePendingTransactions();

    assertTrue(fragment.isDetached());
    retriever.get(fragment);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfFragmentNotAttached() {
    android.app.Fragment fragment = new android.app.Fragment();
    retriever.get(fragment);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfSupportFragmentNotAttached() {
    Fragment fragment = new Fragment();
    retriever.get(fragment);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfActivityDestroyed() {
    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
    harness.getController().pause().stop().destroy();
    harness.doGet();
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfFragmentActivityDestroyed() {
    SupportRetrieverHarness harness = new SupportRetrieverHarness();
    harness.getController().pause().stop().destroy();
    harness.doGet();
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfGivenNullContext() {
    retriever.get((Context) null);
  }

  @Test
  public void testChecksIfContextIsFragmentActivity() {
    SupportRetrieverHarness harness = new SupportRetrieverHarness();
    RequestManager requestManager = harness.doGet();

    assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
  }

  @Test
  public void testChecksIfContextIsActivity() {
    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
    RequestManager requestManager = harness.doGet();

    assertEquals(requestManager, retriever.get((Context) harness.getController().get()));
  }

  @Test
  public void testHandlesContextWrappersForActivities() {
    DefaultRetrieverHarness harness = new DefaultRetrieverHarness();
    RequestManager requestManager = harness.doGet();
    ContextWrapper contextWrapper = new ContextWrapper((Context) harness.getController().get());

    assertEquals(requestManager, retriever.get(contextWrapper));
  }

  @Test
  public void testHandlesContextWrappersForApplication() {
    ContextWrapper contextWrapper = new ContextWrapper(RuntimeEnvironment.application);
    RequestManager requestManager = retriever.get(RuntimeEnvironment.application);

    assertEquals(requestManager, retriever.get(contextWrapper));
  }

  @Test
  public void testReturnsNonNullManagerIfGivenApplicationContext() {
    assertNotNull(retriever.get(RuntimeEnvironment.application));
  }

  @Test
  public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {
    RequestManager manager = retriever.get(RuntimeEnvironment.application);
    assertFalse(manager.isPaused());
  }

  @Test
  public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {
    RequestManager manager = retriever.get(RuntimeEnvironment.application);
    manager.pauseRequests();
    manager = retriever.get(RuntimeEnvironment.application);
    assertTrue(manager.isPaused());
  }

  @Test
  public void testDoesNotThrowWhenGetWithContextCalledFromBackgroundThread()
      throws InterruptedException {
    testInBackground(new BackgroundUtil.BackgroundTester() {
      @Override
      public void runTest() throws Exception {
        retriever.get(RuntimeEnvironment.application);
      }
    });
  }

  // See Issue #117: https://github.com/bumptech/glide/issues/117.
  @Test
  public void testCanCallGetInOnAttachToWindowInFragmentInViewPager() {
    // Robolectric by default runs messages posted to the main looper synchronously, the
    // framework does not. We post
    // to the main thread here to work around an issue caused by a recursive method call so we
    // need (and reasonably
    // expect) our message to not run immediately
    Shadows.shadowOf(Looper.getMainLooper()).pause();
    Robolectric.buildActivity(Issue117Activity.class).create().start().resume().visible();
  }

  @Test
  public void testDoesNotThrowIfAskedToGetManagerForActivityPreHoneycomb() {
    Util.setSdkVersionInt(Build.VERSION_CODES.GINGERBREAD_MR1);
    Activity activity = mock(Activity.class);
    when(activity.getApplicationContext()).thenReturn(RuntimeEnvironment.application);
    when(activity.getFragmentManager()).thenThrow(new NoSuchMethodError());

    assertNotNull(retriever.get(activity));
  }

  @Test
  public void testDoesNotThrowIfAskedToGetManagerForActivityPreJellYBeanMr1() {
    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    Activity spyActivity = Mockito.spy(activity);
    when(spyActivity.isDestroyed()).thenThrow(new NoSuchMethodError());

    assertNotNull(retriever.get(spyActivity));
  }

  @Test
  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreHoneyCombMr2() {
    Util.setSdkVersionInt(Build.VERSION_CODES.HONEYCOMB_MR1);
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();

    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
    android.app.Fragment spyFragment = Mockito.spy(fragment);
    when(spyFragment.isDetached()).thenThrow(new NoSuchMethodError());

    assertNotNull(retriever.get(spyFragment));
  }

  @Test
  public void testDoesNotThrowIfAskedToGetManagerForFragmentPreJellyBeanMr1() {
    Util.setSdkVersionInt(Build.VERSION_CODES.JELLY_BEAN);
    Activity activity = Robolectric.buildActivity(Activity.class).create().start().resume().get();
    android.app.Fragment fragment = new android.app.Fragment();

    activity.getFragmentManager().beginTransaction().add(fragment, "test").commit();
    android.app.Fragment spyFragment = Mockito.spy(fragment);
    when(spyFragment.getChildFragmentManager()).thenThrow(new NoSuchMethodError());

    assertNotNull(retriever.get(spyFragment));
  }

  private interface RetrieverHarness {

    public ActivityController getController();

    public RequestManager doGet();

    public boolean hasFragmentWithTag(String tag);

    public void addFragmentWithTag(String tag, RequestManager manager);
  }

  public class DefaultRetrieverHarness implements RetrieverHarness {
    private final ActivityController<Activity> controller =
        Robolectric.buildActivity(Activity.class);
    private final android.app.Fragment parent;

    public DefaultRetrieverHarness() {
      this.parent = new android.app.Fragment();

      controller.create();
      controller.get().getFragmentManager().beginTransaction().add(parent, PARENT_TAG)
          .commitAllowingStateLoss();
      controller.get().getFragmentManager().executePendingTransactions();
      controller.start().resume();
    }

    @Override
    public ActivityController getController() {
      return controller;
    }

    @Override
    public RequestManager doGet() {
      return retriever.get(controller.get());
    }

    @Override
    public boolean hasFragmentWithTag(String tag) {
      return null != controller
          .get()
          .getFragmentManager()
          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
    }

    @Override
    public void addFragmentWithTag(String tag, RequestManager requestManager) {
      RequestManagerFragment fragment = new RequestManagerFragment();
      fragment.setRequestManager(requestManager);
      controller.get().getFragmentManager().beginTransaction()
          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
      controller.get().getFragmentManager().executePendingTransactions();
    }
  }

  public class SupportRetrieverHarness implements RetrieverHarness {
    private final ActivityController<FragmentActivity> controller =
        Robolectric.buildActivity(FragmentActivity.class);
    private final Fragment parent;

    public SupportRetrieverHarness() {
      this.parent = new Fragment();

      controller.create();
      controller.get().getSupportFragmentManager().beginTransaction().add(parent, PARENT_TAG)
          .commitAllowingStateLoss();
      controller.get().getSupportFragmentManager().executePendingTransactions();
      controller.start().resume();
    }

    @Override
    public ActivityController getController() {
      return controller;
    }

    @Override
    public RequestManager doGet() {
      return retriever.get(controller.get());
    }

    @Override
    public boolean hasFragmentWithTag(String tag) {
      return controller.get().getSupportFragmentManager()
          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG) != null;
    }

    @Override
    public void addFragmentWithTag(String tag, RequestManager manager) {
      SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
      fragment.setRequestManager(manager);
      controller.get().getSupportFragmentManager().beginTransaction()
          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
      controller.get().getSupportFragmentManager().executePendingTransactions();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
package com.bumptech.glide.request;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestTest {
    private RequestHarness harness;

    /**
     * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
     * Both are in the middle of the hierarchy having multiple descendants and ancestors.
     */
    @SuppressWarnings("unchecked")
    private static class RequestHarness {
        ModelLoader<Number, Object> modelLoader;
        Engine engine = mock(Engine.class);
        Number model = 123456;
        Target<List> target = mock(Target.class);
        Context context = Robolectric.application;
        Resource<List> resource = mock(Resource.class);
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        Priority priority = Priority.NORMAL;
        int placeholderResourceId = 0;
        Drawable placeholderDrawable = null;
        int errorResourceId = 0;
        Drawable fallbackDrawable = null;
        int fallbackResourceId = 0;
        Transformation transformation = mock(Transformation.class);
        Drawable errorDrawable = null;
        LoadProvider<Number, Object, Object, List> loadProvider = mock(LoadProvider.class);
        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
        Encoder<Object> sourceEncoder = mock(Encoder.class);
        RequestListener<Number, List> requestListener = mock(RequestListener.class);
        boolean skipMemoryCache;
        GlideAnimationFactory<List> factory = mock(GlideAnimationFactory.class);
        int overrideWidth = -1;
        int overrideHeight = -1;
        List result = new ArrayList();
        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
        Key signature = mock(Key.class);

        public RequestHarness() {
            modelLoader = mock(ModelLoader.class);
            when(modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt()))
                    .thenReturn(mock(DataFetcher.class));
            when(loadProvider.getModelLoader()).thenReturn(modelLoader);
            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
            when(loadProvider.getEncoder()).thenReturn(encoder);
            when(loadProvider.getTranscoder()).thenReturn(transcoder);
            when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
            when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);

            when(resource.get()).thenReturn(result);
        }

        public GenericRequest<Number, Object, Object, List> getRequest() {
            return GenericRequest.obtain(loadProvider,
                    model,
                    signature,
                    context,
                    priority,
                    target,
                    1f,
                    placeholderDrawable,
                    placeholderResourceId,
                    errorDrawable,
                    errorResourceId,
                    fallbackDrawable,
                    fallbackResourceId,
                    requestListener,
                    requestCoordinator,
                    engine,
                    transformation,
                    List.class,
                    skipMemoryCache,
                    factory,
                    overrideWidth,
                    overrideHeight,
                    diskCacheStrategy);
        }
    }

    @Before
    public void setUp() {
        harness = new RequestHarness();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testReturnsWhenMissingCacheDecoderAndNeeded3() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingCacheDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenMissingTranscoder() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getTranscoder()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testThrowsWhenMissingModelLoader() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getModelLoader()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenTransformationIsNull() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            harness.transformation = null;

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testIsNotCompleteBeforeReceivingResource() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isComplete());
    }

    @Test
    public void testCanHandleNullResources() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);

        assertTrue(request.isFailed());
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }

    @Test
    public void testCanHandleEmptyResources() {
        GenericRequest request = harness.getRequest();
        when(harness.resource.get()).thenReturn(null);

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleNonConformingResources() {
        GenericRequest request = harness.getRequest();
        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }

    @Test
    public void testIsNotFailedAfterClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.clear();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsPausedAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertTrue(request.isPaused());
    }

    @Test
    public void testIsNotCancelledAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertFalse(request.isCancelled());
    }

    @Test
    public void testIsNotPausedAfterBeginningWhilePaused() {
        GenericRequest request = harness.getRequest();
        request.pause();
        request.begin();

        assertFalse(request.isPaused());
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotFailedAfterBegin() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.begin();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsCompleteAfterReceivingResource() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        assertTrue(request.isComplete());
    }

    @Test
    public void testIsNotCompleteAfterClear() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);
        request.clear();

        assertFalse(request.isComplete());
    }

    @Test
    public void testIsCancelledAfterClear() {
        GenericRequest request = harness.getRequest();
        request.clear();

        assertTrue(request.isCancelled());
    }

    @Test
    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
        GenericRequest request = harness.getRequest();
        request.clear();
        request.clear();

        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
    }

    @Test
    public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Request request = (Request) invocation.getArguments()[0];
                assertFalse(request.isComplete());
                return true;
            }
        }).when(requestCoordinator).canSetImage(any(Request.class));

        harness.requestCoordinator = requestCoordinator;
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        verify(requestCoordinator).canSetImage(eq(request));
    }

    @Test
    public void testIsNotFailedWithoutException() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsFailedAfterException() {
        GenericRequest request = harness.getRequest();

        request.onException(new Exception("test"));
        assertTrue(request.isFailed());
    }

    @Test
    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onSizeReady(100, 100);
        request.onSizeReady(100, 100);

        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100),
            any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
            any(ResourceTranscoder.class), any(Priority.class), anyBoolean(),
            any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testIsFailedAfterNoResultAndNullException() {
        GenericRequest request = harness.getRequest();

        request.onException(null);
        assertTrue(request.isFailed());
    }

    @Test
    public void testEngineLoadPassedCorrectPriority() {
        Priority expected = Priority.HIGH;
        harness.priority = expected;
        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);

        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
            any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
            eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testEngineLoadCancelledOnCancel() {
        Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenReturn(loadStatus);

        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);
        request.cancel();

        verify(loadStatus).cancel();
    }

    @Test
    public void testResourceIsRecycledOnClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);
        request.clear();

        verify(harness.engine).release(eq(harness.resource));
    }

    @Test
    public void testPlaceholderResourceIsSet() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.placeholderResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableIsSet() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorResourceIsSetOnLoadFailed() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.errorResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableIsSetOnLoadFailed() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.errorDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
        Drawable placeholder = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(placeholder, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(errorPlaceholder, target.currentPlaceholder);
    }

    @Test
    public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
        Drawable fallback = new ColorDrawable(Color.BLUE);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.fallbackDrawable = fallback;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(fallback, target.currentPlaceholder);
    }

    @Test
    public void testIsNotRunningBeforeRunCalled() {
        assertFalse(harness.getRequest().isRunning());
    }

    @Test
    public void testIsRunningAfterRunCalled() {
        Request request = harness.getRequest();
        request.begin();
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterComplete() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onResourceReady(harness.resource);

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterFailing() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onException(new RuntimeException("Test"));

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterClear() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.clear();

        assertFalse(request.isRunning());
    }

    @Test
    public void testCallsTargetOnResourceReadyIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.target, never()).onResourceReady(any(List.class), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnExceptionIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        Exception exception = new IOException("test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(false);
        Exception exception = new IOException("Test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(true);

        request.onException(new IllegalArgumentException("test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testRequestListenerIsCalledWithResourceResult() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithModel() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), eq(harness.model), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithTarget() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
        final GenericRequest request = harness.getRequest();
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(),  any(DiskCacheStrategy.class),
                any(ResourceCallback.class))).thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        request.onResourceReady(harness.resource);
                        return null;
                    }
                });

        request.begin();
        request.onSizeReady(100, 100);
        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(true), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
        GenericRequest request = harness.getRequest();
        request.onSizeReady(100, 100);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(false), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
        harness.requestCoordinator = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(false));
    }

    @Test
    public void testTargetIsCalledWithAnimationFromFactory() {
        GenericRequest request = harness.getRequest();
        GlideAnimation<List> glideAnimation = mock(GlideAnimation.class);
        when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(glideAnimation);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), eq(glideAnimation));
    }

    @Test
    public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
        harness.overrideWidth = -1;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
        harness.overrideHeight = -1;
        harness.overrideWidth = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
        harness.overrideWidth = 100;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
        harness.overrideWidth = 1;
        harness.overrideHeight = 2;

        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(harness.overrideWidth), eq(harness.overrideHeight),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    @Test
    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
        harness.errorDrawable = new ColorDrawable(Color.RED);
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
        request.onException(new IOException("Test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testCanReRunCancelledRequests() {
        doAnswer(new CallSizeReady(100, 100)).when(harness.target)
                .getSize(any(SizeReadyCallback.class));
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenAnswer(new CallResourceCallback(harness.resource));
        GenericRequest request = harness.getRequest();

        request.begin();
        request.cancel();
        request.begin();

        verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testResourceOnlyReceivesOneGetOnResourceReady() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.resource, times(1)).get();
    }

    @Test
    public void testOnSizeReadyWithNullDataFetcherCallsOnException() {
        GenericRequest request = harness.getRequest();
        when(harness.modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt())).thenReturn(null);
        request.begin();
        request.onSizeReady(100, 100);

        verify(harness.requestListener).onException(any(Exception.class), any(Number.class), any(Target.class),
                anyBoolean());
    }

    @Test
    public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
        GenericRequest request = harness.getRequest();
        request.cancel();
        request.onSizeReady(100, 100);

        verify(harness.engine, never()).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testStartsLoadImmediatelyWhenGivenOverrideWithSizeOriginal() {
        harness.overrideWidth = Target.SIZE_ORIGINAL;
        harness.overrideHeight = Target.SIZE_ORIGINAL;
        GenericRequest<Number, Object, Object, List> request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(Target.SIZE_ORIGINAL), eq(Target.SIZE_ORIGINAL),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    private static class CallResourceCallback implements Answer {

        private Resource resource;

        public CallResourceCallback(Resource resource) {
            this.resource = resource;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            ResourceCallback cb = (ResourceCallback)
                    invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 1];
            cb.onResourceReady(resource);
            return null;
        }
    }

    private static class CallSizeReady implements Answer {

        private int width;
        private int height;

        public CallSizeReady(int width, int height) {
            this.width = width;
            this.height = height;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            SizeReadyCallback cb =
                    (SizeReadyCallback) invocationOnMock.getArguments()[0];
            cb.onSizeReady(width, height);
            return null;
        }
    }

    private Context mockContextToReturn(int resourceId, Drawable drawable) {
        Resources resources = mock(Resources.class);
        Context context = mock(Context.class);

        when(context.getApplicationContext()).thenReturn(context);
        when(context.getResources()).thenReturn(resources);
        when(resources.getDrawable(eq(resourceId))).thenReturn(drawable);

        return context;
    }

    private static class MockTarget implements Target {
        private Drawable currentPlaceholder;

        @Override
        public void onLoadCleared(Drawable placeholder) {
            currentPlaceholder = placeholder;
        }

        @Override
        public void onLoadStarted(Drawable placeholder) {
            currentPlaceholder = placeholder;

        }

        @Override
        public void onLoadFailed(Exception e, Drawable errorDrawable) {
            currentPlaceholder = errorDrawable;

        }

        @Override
        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
            currentPlaceholder = null;
        }


        @Override
        public void getSize(SizeReadyCallback cb) {
        }

        @Override
        public void setRequest(Request request) {
        }

        @Override
        public Request getRequest() {
            return null;
        }

        @Override
        public void onStart() {
        }

        @Override
        public void onStop() {

        }

        @Override
        public void onDestroy() {

        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java;<<<<<<< MINE
        InOrder order = inOrder(thumb, full);
        order.verify(thumb).clear();
        order.verify(full).clear();
    }

    @Test
    public void testRecyclesRequestsWhenRecycled() {
        coordinator.recycle();
        verify(thumb).recycle();
        verify(full).recycle();
    }

    @Test
    public void testIsPausedWhenFullIsPaused() {
        when(full.isPaused()).thenReturn(true);
        assertTrue(coordinator.isPaused());
    }

    @Test
    public void testPausesBothRequestsWhenPaused() {
        coordinator.pause();
        verify(full).pause();
        verify(thumb).pause();
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
        coordinator = new ThumbnailRequestCoordinator();
        coordinator.setRequests(full, thumb);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canSetImage(full));
    }

    @Test
    public void testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanSetImageReturnsFalseForThumbRequestIfParentDoesNotAllowSetImageAndFullDoesNotHaveResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canSetImage(eq(coordinator))).thenReturn(false);
        when(full.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.canSetImage(thumb));
    }

    @Test
    public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumb() {
        assertFalse(coordinator.canNotifyStatusChanged(thumb));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.isAnyResourceSet()).thenReturn(true);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotifyStatusChangedIfParentAllowsNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
        assertTrue(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
        assertFalse(coordinator.canNotifyStatusChanged(full));
    }

    @Test
    public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);
        assertFalse(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        when(thumb.isResourceSet()).thenReturn(false);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);

        when(parent.isAnyResourceSet()).thenReturn(true);
        when(full.isResourceSet()).thenReturn(false);
        when(thumb.isResourceSet()).thenReturn(false);

        assertTrue(coordinator.isAnyResourceSet());
    }

    @Test
    public void testIsNotCompleteIfNeitherRequestIsComplete() {
        assertFalse(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfFullIsComplete() {
        when(full.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsCompleteIfThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        assertTrue(coordinator.isComplete());
    }

    @Test
    public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
        assertFalse(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
        when(full.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
        when(thumb.isResourceSet()).thenReturn(true);
        assertTrue(coordinator.isResourceSet());
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(parent).onRequestSuccess(eq(coordinator));
    }

    @Test
    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(full);
        verify(thumb).clear();
    }

    @Test
    public void testDoesNotClearThumbOnThumbRequestComplete() {
        coordinator.onRequestSuccess(thumb);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        coordinator.onRequestSuccess(full);
        verify(thumb, never()).clear();
    }

    @Test
    public void testDoesNotNotifyParentOnThumbRequestComplete() {
        coordinator = new ThumbnailRequestCoordinator(parent);
        coordinator.setRequests(full, thumb);
        coordinator.onRequestSuccess(thumb);
=======
        return null;
      }
    }).when(thumb).begin();

    coordinator.begin();

    verify(full, never()).begin();
  }

  @Test
  public void testCallsClearOnRequestsWhenCleared() {
    coordinator.clear();
    InOrder order = inOrder(thumb, full);
    order.verify(thumb).clear();
    order.verify(full).clear();
  }

  @Test
  public void testRecyclesRequestsWhenRecycled() {
    coordinator.recycle();
    verify(thumb).recycle();
    verify(full).recycle();
  }

  @Test
  public void testIsPausedWhenFullIsPaused() {
    when(full.isPaused()).thenReturn(true);
    assertTrue(coordinator.isPaused());
  }

  @Test
  public void testPausesBothRequestsWhenPaused() {
    coordinator.pause();
    verify(full).pause();
    verify(thumb).pause();
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfCoordinatorIsNull() {
    coordinator = new ThumbnailRequestCoordinator();
    coordinator.setRequests(full, thumb);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsTrueForFullRequestIfParentAllowsSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canSetImage(full));
  }

  @Test
  public void testCanSetImageReturnsFalseForFullRequestIfParentDoesNotAllowSetImage() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canSetImage(full));
  }

  @Test
  public void
  testCanSetImageReturnsTrueForThumbRequestIfParentIsNullAndFullDoesNotHaveResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanSetImageReturnsFalseForThumbRequestIfParentIsNullAndFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotSetImageForThumbIfNotAllowedByParentAndFullDoesNotHaveResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canSetImage(eq(coordinator))).thenReturn(false);
    when(full.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.canSetImage(thumb));
  }

  @Test
  public void testCanNotifyStatusChangedIfFullAndNoRequestsAreComplete() {
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumb() {
    assertFalse(coordinator.canNotifyStatusChanged(thumb));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfThumbHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.isAnyResourceSet()).thenReturn(true);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotifyStatusChangedIfParentAllowsNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(true);
    assertTrue(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testCanNotNotifyStatusChangedIfParentDoesNotAllowNotify() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    when(parent.canNotifyStatusChanged(eq(coordinator))).thenReturn(false);
    assertFalse(coordinator.canNotifyStatusChanged(full));
  }

  @Test
  public void testIsAnyResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);
    assertFalse(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfFullHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    when(thumb.isResourceSet()).thenReturn(false);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfThumbHasResourceSet() {
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsAnyResourceSetIsTrueIfParentIsNonNullAndParentHasResourceSet() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);

    when(parent.isAnyResourceSet()).thenReturn(true);
    when(full.isResourceSet()).thenReturn(false);
    when(thumb.isResourceSet()).thenReturn(false);

    assertTrue(coordinator.isAnyResourceSet());
  }

  @Test
  public void testIsNotCompleteIfNeitherRequestIsComplete() {
    assertFalse(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfFullIsComplete() {
    when(full.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsCompleteIfThumbIsComplete() {
    when(thumb.isComplete()).thenReturn(true);
    assertTrue(coordinator.isComplete());
  }

  @Test
  public void testIsResourceSetIsFalseIfNeitherRequestHasResourceSet() {
    assertFalse(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfFullRequestHasResourceSet() {
    when(full.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testIsResourceSetIsTrueIfThumbRequestHasResourceSet() {
    when(thumb.isResourceSet()).thenReturn(true);
    assertTrue(coordinator.isResourceSet());
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(parent).onRequestSuccess(eq(coordinator));
  }

  @Test
  public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(full);
    verify(thumb).clear();
  }

  @Test
  public void testDoesNotClearThumbOnThumbRequestComplete() {
    coordinator.onRequestSuccess(thumb);
    verify(thumb, never()).clear();

  }

  @Test
  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
      when(thumb.isComplete()).thenReturn(true);
      coordinator.onRequestSuccess(full);
      verify(thumb, never()).clear();
  }

  @Test
  public void testDoesNotNotifyParentOnThumbRequestComplete() {
    coordinator = new ThumbnailRequestCoordinator(parent);
    coordinator.setRequests(full, thumb);
    coordinator.onRequestSuccess(thumb);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java;<<<<<<< MINE
package com.bumptech.glide.load.model.stream;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assume.assumeTrue;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.verify;

import android.net.Uri;

import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.tests.Util;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

/**
 * Tests for the {@link StreamStringLoader} class.
 */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class StringLoaderTest {
    // Not a magic number, just an arbitrary non zero value.
    private static final int IMAGE_SIDE = 100;

    private StreamStringLoader stringLoader;
    @Mock ModelLoader<Uri, InputStream> uriLoader;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        stringLoader = new StreamStringLoader(uriLoader);
    }

    @Test
    public void testHandlesPaths() throws IOException {
        // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
        assumeTrue(!Util.isWindows());
        File f = Robolectric.application.getCacheDir();
        stringLoader.getResourceFetcher(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testCanHandleComplexFilePaths() {
        assumeTrue(!Util.isWindows());
        String testPath = "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
                + "2448x3264,orientation=0,date=Tue";
        stringLoader.getResourceFetcher(testPath, IMAGE_SIDE, IMAGE_SIDE);

        Uri expected = Uri.fromFile(new File(testPath));
        verify(uriLoader).getResourceFetcher(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesFileUris() throws IOException {
        File f = Robolectric.application.getCacheDir();
        stringLoader.getResourceFetcher(Uri.fromFile(f)
                .toString(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesResourceUris() throws IOException {
        Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
        stringLoader.getResourceFetcher(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesHttp() {
        String url = "http://www.google.com";
        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesHttps() {
        String url = "https://www.google.com";
        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesContent() {
        String content = "content://com.bumptech.glide";
        stringLoader.getResourceFetcher(content, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(content)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testGetResourceFetcher_withEmptyString_returnsNull() {
        assertThat(stringLoader.getResourceFetcher("", IMAGE_SIDE, IMAGE_SIDE)).isNull();
        assertThat(stringLoader.getResourceFetcher("    ", IMAGE_SIDE, IMAGE_SIDE)).isNull();
        assertThat(stringLoader.getResourceFetcher("  \n", IMAGE_SIDE, IMAGE_SIDE)).isNull();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java;<<<<<<< MINE
package com.bumptech.glide.load.model.stream;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

import android.net.Uri;

import com.bumptech.glide.load.model.ModelLoader;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.InputStream;

/**
 * Tests for the {@link StreamResourceLoader} class.
 */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ResourceLoaderTest {

    @Mock ModelLoader<Uri, InputStream> streamUriLoader;
    private StreamResourceLoader resourceLoader;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        resourceLoader = new StreamResourceLoader(Robolectric.application, streamUriLoader);
    }

    @Test
    public void testCanHandleId() {
        int id = android.R.drawable.star_off;
        resourceLoader.getResourceFetcher(id, 0, 0);

        Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");
        verify(streamUriLoader).getResourceFetcher(eq(contentUri), anyInt(), anyInt());
    }

    @Test
    public void testDoesNotThrowOnInvalidOrMissingId() {
        assertThat(resourceLoader.getResourceFetcher(1234, 0, 0)).isNull();
        verify(streamUriLoader, never()).getResourceFetcher(any(Uri.class), anyInt(), anyInt());
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java;<<<<<<< MINE
    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenURLIsNull() {
        new GlideUrl((URL) null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenStringUrlIsNull() {
        new GlideUrl((String) null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenStringURLIsEmpty() {
        new GlideUrl("");
    }

    @Test
    public void testCanCompareGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
        String stringUrl = "http://www.google.com";
        URL url = new URL(stringUrl);

        assertEquals(new GlideUrl(stringUrl), new GlideUrl(url));
    }

    @Test
    public void testCanCompareHashcodeOfGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
        String stringUrl = "http://nytimes.com";
        URL url = new URL(stringUrl);

        assertEquals(new GlideUrl(stringUrl).hashCode(), new GlideUrl(url).hashCode());
    }

    @Test
    public void testProducesEquivalentUrlFromString() throws MalformedURLException {
        String stringUrl = "http://www.google.com";
        GlideUrl glideUrl = new GlideUrl(stringUrl);

        URL url = glideUrl.toURL();
        assertEquals(stringUrl, url.toString());
    }

    @Test
    public void testProducesEquivalentStringFromURL() throws MalformedURLException {
        String expected = "http://www.washingtonpost.com";
        URL url = new URL(expected);
        GlideUrl glideUrl = new GlideUrl(url);

        assertEquals(expected, glideUrl.toStringUrl());
    }

    @Test
    public void testIssue133() throws MalformedURLException {
        // u00e0=Ã 
        final String original =  "http://www.commitstrip.com/wp-content/uploads/2014/07/"
                + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";

        final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
                + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";

        GlideUrl glideUrlFromString = new GlideUrl(original);
        assertEquals(escaped, glideUrlFromString.toURL().toString());

        GlideUrl glideUrlFromEscapedString = new GlideUrl(escaped);
        assertEquals(escaped, glideUrlFromEscapedString.toURL().toString());

        GlideUrl glideUrlFromUrl = new GlideUrl(new URL(original));
        assertEquals(escaped, glideUrlFromUrl.toURL().toString());

        GlideUrl glideUrlFromEscapedUrl = new GlideUrl(new URL(escaped));
        assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
    }
=======
  @Test(expected = NullPointerException.class)
  public void testThrowsIfGivenURLIsNull() {
    new GlideUrl((URL) null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfGivenStringUrlIsNull() {
    new GlideUrl((String) null);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testThrowsIfGivenStringURLIsEmpty() {
    new GlideUrl("");
  }

  @Test
  public void testCanCompareGlideUrlsCreatedWithDifferentTypes() throws MalformedURLException {
    String stringUrl = "http://www.google.com";
    URL url = new URL(stringUrl);

    assertEquals(new GlideUrl(stringUrl), new GlideUrl(url));
  }

  @Test
  public void testCanCompareHashcodeOfGlideUrlsCreatedWithDifferentTypes()
      throws MalformedURLException {
    String stringUrl = "http://nytimes.com";
    URL url = new URL(stringUrl);

    assertEquals(new GlideUrl(stringUrl).hashCode(), new GlideUrl(url).hashCode());
  }

  @Test
  public void testProducesEquivalentUrlFromString() throws MalformedURLException {
    String stringUrl = "http://www.google.com";
    GlideUrl glideUrl = new GlideUrl(stringUrl);

    URL url = glideUrl.toURL();
    assertEquals(stringUrl, url.toString());
  }

  @Test
  public void testProducesEquivalentStringFromURL() throws MalformedURLException {
    String expected = "http://www.washingtonpost.com";
    URL url = new URL(expected);
    GlideUrl glideUrl = new GlideUrl(url);

    assertEquals(expected, glideUrl.toStringUrl());
  }

  @Test
  public void testIssue133() throws MalformedURLException {
    // u00e0=Ã 
    final String original = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
        + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";

    final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/"
        + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";

    GlideUrl glideUrlFromString = new GlideUrl(original);
    assertEquals(escaped, glideUrlFromString.toURL().toString());

    GlideUrl glideUrlFromEscapedString = new GlideUrl(escaped);
    assertEquals(escaped, glideUrlFromEscapedString.toURL().toString());

    GlideUrl glideUrlFromUrl = new GlideUrl(new URL(original));
    assertEquals(escaped, glideUrlFromUrl.toURL().toString());

    GlideUrl glideUrlFromEscapedUrl = new GlideUrl(new URL(escaped));
    assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());
  }

  @Test
  public void testEquals() throws MalformedURLException {
    Headers headers = mock(Headers.class);
    Headers otherHeaders = mock(Headers.class);
    String url = "http://www.google.com";
    String otherUrl = "http://mail.google.com";
    new EqualsTester()
        .addEqualityGroup(
            new GlideUrl(url),
            new GlideUrl(url),
            new GlideUrl(new URL(url)),
            new GlideUrl(new URL(url))
        )
        .addEqualityGroup(
            new GlideUrl(otherUrl),
            new GlideUrl(new URL(otherUrl))
        )
        .addEqualityGroup(
            new GlideUrl(url, headers),
            new GlideUrl(new URL(url), headers)
        )
        .addEqualityGroup(
            new GlideUrl(url, otherHeaders),
            new GlideUrl(new URL(url), otherHeaders)
        ).testEquals();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.model;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.google.common.testing.EqualsTester;

import com.bumptech.glide.load.model.LazyHeaders.Builder;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.util.Map;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class LazyHeadersTest {

    @Test
    public void testIncludesEagerHeaders() {
        Map<String, String> headers = new Builder()
            .addHeader("key", "value")
            .build()
            .getHeaders();
        assertThat(headers).containsEntry("key", "value");
        assertThat(headers).hasSize(1);
    }

    @Test
    public void testIncludesLazyHeaders() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("value");
        Map<String, String> headers = new Builder()
            .addHeader("key", factory)
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "value");
    }

    @Test
    public void testMultipleEagerValuesAreSeparatedByCommas() {
        Map<String, String> headers = new Builder()
            .addHeader("key", "first")
            .addHeader("key", "second")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");
    }

    @Test
    public void testMultipleLazyValuesAreSeparatedByCommas() {
        LazyHeaderFactory first = mock(LazyHeaderFactory.class);
        when(first.buildHeader()).thenReturn("first");
        LazyHeaderFactory second = mock(LazyHeaderFactory.class);
        when(second.buildHeader()).thenReturn("second");

        Map<String, String> headers = new Builder()
            .addHeader("key", first)
            .addHeader("key", second)
            .build()
            .getHeaders();
        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");
    }

    @Test
    public void testMixedEagerAndLazyValuesAreIncluded() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("first");
        Map<String, String> headers = new Builder()
            .addHeader("key", factory)
            .addHeader("key", "second")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");

        headers = new Builder()
            .addHeader("key", "second")
            .addHeader("key", factory)
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "second,first");
    }

    @Test
    public void testCanAddMultipleKeys() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("lazy");
        Map<String, String> headers = new Builder()
            .addHeader("first", factory)
            .addHeader("second", "eager")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(2);
        assertThat(headers).containsEntry("first", "lazy");
        assertThat(headers).containsEntry("second", "eager");
    }

    @Test
    public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
        Builder builder = new Builder();
        builder.addHeader("key", "firstValue");
        LazyHeaders first = builder.build();

        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("otherValue");
        builder.addHeader("key", "secondValue");
        builder.addHeader("otherKey", factory);
        LazyHeaders second = builder.build();

        assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());

        assertThat(first.getHeaders()).hasSize(1);
        assertThat(first.getHeaders()).containsEntry("key", "firstValue");

        assertThat(second.getHeaders()).hasSize(2);
        assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
        assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
    }

    @Test
    public void testEquals() {
        LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
        LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
        new EqualsTester()
            .addEqualityGroup(
                new Builder().build(),
                new Builder().build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "value").build(),
                new Builder().addHeader("key", "value").build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "value").addHeader("key", "value").build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", firstLazyFactory).build(),
                new Builder().addHeader("key", firstLazyFactory).build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("key", firstLazyFactory)
                    .addHeader("key", firstLazyFactory)
                    .build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", "value")
                    .addHeader("secondKey", firstLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("secondKey", firstLazyFactory)
                    .addHeader("firstKey", "value")
                    .build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "secondValue")
            )
            .addEqualityGroup(
                new Builder().addHeader("secondKey", "value")
            )
            .addEqualityGroup(
                new Builder().addHeader("key", secondLazyFactory)
            )
            .addEqualityGroup(
                new Builder().addHeader("secondKey", firstLazyFactory)
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", "firstValue")
                    .addHeader("secondKey", "secondValue")
                    .build(),
                new Builder()
                    .addHeader("firstKey", "firstValue")
                    .addHeader("secondKey", "secondValue")
                    .build(),
                new Builder()
                    .addHeader("secondKey", "secondValue")
                    .addHeader("firstKey", "firstValue")
                    .build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", firstLazyFactory)
                    .addHeader("secondKey", secondLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("firstKey", firstLazyFactory)
                    .addHeader("secondKey", secondLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("secondKey", secondLazyFactory)
                    .addHeader("firstKey", firstLazyFactory)
                    .build()
            )
            .testEquals();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
import static com.google.common.truth.Truth.assertThat;
import static com.bumptech.glide.load.resource.bitmap.ImageHeaderParser.ImageType;
=======
import static com.google.common.truth.Truth.assertThat;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
=======
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
import org.robolectric.util.Util;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
=======
import java.io.FilterInputStream;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@RunWith(JUnit4.class)
=======
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
    @Test
    public void testReturnsUnknownTypeForEmptyData() throws IOException {
        InputStream is = new ByteArrayInputStream(new byte[0]);
        ImageHeaderParser parser = new ImageHeaderParser(is);
        assertEquals(ImageType.UNKNOWN, parser.getType());
    }

    // Test for #286.
    @Test
    public void testHandlesParsingOrientationWithMinimalExifSegment() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "short_exif_sample.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(is);
        assertEquals(-1, parser.getOrientation());
=======
    protected PartialReadInputStream(InputStream in) {
        super(in);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
    // Test for #387.
    @Test
    public void testHandlesPartialReads() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }

    // Test for #387.
    @Test
    public void testHandlesPartialSkips() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }

    @Test
    public void testHandlesSometimesZeroSkips() throws IOException {
        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
        ImageHeaderParser parser = new ImageHeaderParser(new SometimesZeroSkipInputStream(is));
        assertEquals(ImageType.PNG, parser.getType());
    }

    private static byte[] generatePngHeaderWithIhdr(int bitDepth) {
        byte[] result = new byte[PNG_HEADER_WITH_IHDR_CHUNK.length];
        System.arraycopy(PNG_HEADER_WITH_IHDR_CHUNK, 0, result, 0, PNG_HEADER_WITH_IHDR_CHUNK.length);
        result[result.length - 1] = (byte) bitDepth;
        return result;
=======
    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int toActuallyRead = byteCount / 2;
        if (byteCount == 1) {
            toActuallyRead = 1;
        }
        return super.read(buffer, byteOffset, toActuallyRead);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE

    private static class SometimesZeroSkipInputStream extends FilterInputStream {
        boolean returnZeroFlag = true;

        protected SometimesZeroSkipInputStream(InputStream in) {
            super(in);
        }

        @Override
        public long skip(long byteCount) throws IOException {
            if (returnZeroFlag) {
                return 0;
            }
            returnZeroFlag = !returnZeroFlag;
            return super.skip(byteCount);
        }
    }

    private static class PartialSkipInputStream extends FilterInputStream {

        protected PartialSkipInputStream(InputStream in) {
            super(in);
        }

        @Override
        public long skip(long byteCount) throws IOException {
            long toActuallySkip = byteCount / 2;
            if (byteCount == 1) {
                toActuallySkip = 1;
            }
            return super.skip(toActuallySkip);
        }
    }

    private static class PartialReadInputStream extends FilterInputStream {

        protected PartialReadInputStream(InputStream in) {
            super(in);
        }

        @Override
        public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
            int toActuallyRead = byteCount / 2;
            if (byteCount == 1) {
                toActuallyRead = 1;
            }
            return super.read(buffer, byteOffset, toActuallyRead);
        }
    }
=======
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.database.MatrixCursor;
import android.net.Uri;
import android.provider.MediaStore;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
import org.robolectric.tester.android.database.SimpleTestCursor;
import org.robolectric.tester.android.database.TestCursor;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ThumbnailStreamOpenerTest {
    private Harness harness;

    @Before
    public void setUp() {
        harness = new Harness();
    }

    @Test
    public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(
                new MatrixCursor(new String[1]));
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
        MatrixCursor cursor = new MatrixCursor(new String[1]);
        cursor.addRow(new Object[]{ "" });
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
        when(harness.service.get(anyString())).thenReturn(harness.file);
        when(harness.service.exists(eq(harness.file))).thenReturn(false);
        assertNull(harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
        when(harness.service.get(anyString())).thenReturn(harness.file);
        when(harness.service.length(eq(harness.file))).thenReturn(0L);
        assertNull(harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testClosesCursor() throws FileNotFoundException {
        harness.get().open(Robolectric.application, harness.uri);
        assertTrue(harness.cursor.isClosed());
    }

    @Test
    public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundException {
        InputStream expected = new ByteArrayInputStream(new byte[0]);
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).registerInputStream(harness.uri, expected);
        assertEquals(expected, harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testVideoQueryReturnsVideoCursor() {
        Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.VideoThumbnailQuery query = new MediaStoreThumbFetcher.VideoThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }

    @Test
    public void testImageQueryReturnsImageCurosr() {
        Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.ImageThumbnailQuery query = new MediaStoreThumbFetcher.ImageThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }

    private static class Harness {
        MatrixCursor cursor = new MatrixCursor(new String[1]);
        File file = new File("fake/uri");
        Uri uri = Uri.fromFile(file);
        MediaStoreThumbFetcher.ThumbnailQuery query = mock(MediaStoreThumbFetcher.ThumbnailQuery.class);
        MediaStoreThumbFetcher.FileService service = mock(MediaStoreThumbFetcher.FileService.class);

        public Harness() {
            cursor.addRow(new String[] { file.getAbsolutePath() });
            when(query.queryPath(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
            when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
            when(service.exists(eq(file))).thenReturn(true);
            when(service.length(eq(file))).thenReturn(1L);
        }

        public MediaStoreThumbFetcher.ThumbnailStreamOpener get() {
            return new MediaStoreThumbFetcher.ThumbnailStreamOpener(service, query);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
import org.junit.runners.JUnit4;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
=======
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
@RunWith(JUnit4.class)
=======
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
    private HttpURLConnection urlConnection;
    private HttpUrlFetcher fetcher;
    private GlideUrl glideUrl;
    private InputStream stream;

    @Before
    public void setUp() throws IOException {
        urlConnection =  mock(HttpURLConnection.class);
        URL url = new URL("http://www.google.com");
        HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory = mock(HttpUrlFetcher.HttpUrlConnectionFactory.class);
        when(connectionFactory.build(eq(url))).thenReturn(urlConnection);

        glideUrl = mock(GlideUrl.class);
        when(glideUrl.toURL()).thenReturn(url);
        fetcher = new HttpUrlFetcher(glideUrl, connectionFactory);
        stream = mock(InputStream.class);
        when(urlConnection.getInputStream()).thenReturn(stream);
        when(urlConnection.getResponseCode()).thenReturn(200);
    }

    @Test
    public void testReturnsModelAsString() {
        final String expected = "fakeId";
        when(glideUrl.getCacheKey()).thenReturn(expected);
        assertEquals(expected, fetcher.getId());
    }

    @Test
    public void testSetsReadTimeout() throws Exception {
        fetcher.loadData(Priority.HIGH);
        verify(urlConnection).setReadTimeout(eq(2500));
    }

    @Test
    public void testSetsConnectTimeout() throws Exception {
        fetcher.loadData(Priority.IMMEDIATE);
        verify(urlConnection).setConnectTimeout(eq(2500));
    }

    @Test
    public void testReturnsNullIfCancelledBeforeConnects() throws Exception {
        InputStream notExpected = new ByteArrayInputStream(new byte[0]);
        when(urlConnection.getInputStream()).thenReturn(notExpected);

        fetcher.cancel();
        assertNull(fetcher.loadData(Priority.LOW));
    }

    @Test
    public void testDisconnectsUrlOnCleanup() throws Exception {
        fetcher.loadData(Priority.HIGH);
        fetcher.cleanup();

        verify(urlConnection).disconnect();
    }

    @Test
    public void testDoesNotThrowIfCleanupCalledBeforeStarted() {
        fetcher.cleanup();
    }

    @Test
    public void testDoesNotThrowIfCancelCalledBeforeStart() {
        fetcher.cancel();
    }

    @Test
    public void testCancelDoesNotDisconnectIfAlreadyConnected() throws Exception {
        fetcher.loadData(Priority.HIGH);
        fetcher.cancel();

        verify(urlConnection, never()).disconnect();
    }

    @Test
    public void testClosesStreamInCleanupIfNotNull() throws Exception {
        fetcher.loadData(Priority.HIGH);
        fetcher.cleanup();

        verify(stream).close();
    }

    @Test
    public void testClosesStreamBeforeDisconnectingConnection() throws Exception {
        fetcher.loadData(Priority.NORMAL);
        fetcher.cleanup();

        InOrder order = inOrder(stream, urlConnection);
        order.verify(stream).close();
        order.verify(urlConnection).disconnect();
    }
=======
  @Mock HttpURLConnection urlConnection;
  @Mock HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory;
  @Mock GlideUrl glideUrl;
  @Mock InputStream stream;
  @Mock DataFetcher.DataCallback<InputStream> callback;

  private static final int TIMEOUT_MS = 100;
  private HttpUrlFetcher fetcher;

  @Before
  public void setUp() throws IOException {
    MockitoAnnotations.initMocks(this);
    URL url = new URL("http://www.google.com");

    when(connectionFactory.build(eq(url))).thenReturn(urlConnection);
    when(urlConnection.getInputStream()).thenReturn(stream);
    when(urlConnection.getResponseCode()).thenReturn(200);
    when(glideUrl.toURL()).thenReturn(url);

    fetcher = new HttpUrlFetcher(glideUrl, TIMEOUT_MS, connectionFactory);
  }

  @Test
  public void testSetsReadTimeout() throws IOException {
    fetcher.loadData(Priority.HIGH, callback);
    verify(urlConnection).setReadTimeout(eq(TIMEOUT_MS));
  }

  @Test
  public void testSetsConnectTimeout() throws IOException {
    fetcher.loadData(Priority.IMMEDIATE, callback);
    verify(urlConnection).setConnectTimeout(eq(TIMEOUT_MS));
  }

  @Test
  public void testReturnsNullIfCancelledBeforeConnects() throws IOException {
    InputStream notExpected = new ByteArrayInputStream(new byte[0]);
    when(urlConnection.getInputStream()).thenReturn(notExpected);

    fetcher.cancel();
    fetcher.loadData(Priority.LOW, callback);
    verify(callback).onDataReady(isNull(InputStream.class));
  }

  @Test
  public void testDisconnectsUrlOnCleanup() throws IOException {
    fetcher.loadData(Priority.HIGH, callback);
    fetcher.cleanup();

    verify(urlConnection).disconnect();
  }

  @Test
  public void testDoesNotThrowIfCleanupCalledBeforeStarted() {
    fetcher.cleanup();
  }

  @Test
  public void testDoesNotThrowIfCancelCalledBeforeStart() {
    fetcher.cancel();
  }

  @Test
  public void testCancelDoesNotDisconnectIfAlreadyConnected()
      throws IOException {
    fetcher.loadData(Priority.HIGH, callback);
    fetcher.cancel();

    verify(urlConnection, never()).disconnect();
  }

  @Test
  public void testClosesStreamInCleanupIfNotNull() throws IOException {
    fetcher.loadData(Priority.HIGH, callback);
    fetcher.cleanup();

    verify(stream).close();
  }

  @Test
  public void testClosesStreamBeforeDisconnectingConnection() throws IOException {
    fetcher.loadData(Priority.NORMAL, callback);
    fetcher.cleanup();

    InOrder order = inOrder(stream, urlConnection);
    order.verify(stream).close();
    order.verify(urlConnection).disconnect();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.net.Uri;
import android.provider.MediaStore;

import com.bumptech.glide.Priority;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class MediaStoreThumbFetcherTest {
    private Harness harness;

    @Before
    public void setUp() {
        harness = new Harness();
    }

    @Test
    public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(
            expected);

        InputStream result = harness.get().loadData(Priority.LOW);
        assertNotNull(result);
    }

    @Test
    public void testReturnsInputStreamFromDefaultFetcherIfStreamFromThumbnailOpenerIsNull() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);

        assertEquals(expected, harness.get().loadData(Priority.HIGH));
    }

    @Test
    public void testReturnsInputStreamFromDefaultFetcherIfFactoryReturnsNull() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.factory.build(any(Uri.class), anyInt(), anyInt())).thenReturn(null);
        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);

        assertEquals(expected, harness.get().loadData(Priority.IMMEDIATE));
    }

    @Test
    public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
        InputStream expected = mock(InputStream.class);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(expected);

        MediaStoreThumbFetcher fetcher = harness.get();
        fetcher.loadData(Priority.HIGH);

        fetcher.cleanup();
        verify(expected).close();
    }

    @Test
    public void testCallsCleanupOnDefaultFetcherOnCleanup() {
        harness.get().cleanup();
        verify(harness.defaultFetcher).cleanup();
    }

    @Test
    public void testDoesNotThrowIfCleanupWithNullInputStream() {
        harness.get().cleanup();
    }

    @Test
    public void testContainsAllRelevantPartsInId() {
        String id = harness.get().getId();
        assertThat(id).contains(harness.uri.toString());
    }

    @SuppressWarnings("unchecked")
    private static class Harness {
        Uri uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
        DataFetcher<InputStream> defaultFetcher = mock(DataFetcher.class);
        int width = 123;
        int height = 222;

        MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory factory = mock(
                MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory.class);
        MediaStoreThumbFetcher.ThumbnailStreamOpener
                thumbnailFetcher = mock(MediaStoreThumbFetcher.ThumbnailStreamOpener.class);

        public Harness() {
            when(factory.build(eq(uri), eq(width), eq(height))).thenReturn(thumbnailFetcher);
        }

        public MediaStoreThumbFetcher get() {
            return new MediaStoreThumbFetcher(Robolectric.application, uri, defaultFetcher, width, height, factory);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}=======
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private LruByteArrayPool byteArrayPool;

  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.util;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ContentLengthInputStreamTest {
  @Mock InputStream wrapped;

  @Before
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength()
      throws IOException {
    int value = 123356;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));

    assertThat(is.available()).isEqualTo(value);
  }

  @Test
  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
      throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
    int expected = 1234;
    when(wrapped.available()).thenReturn(expected);

    assertThat(is.available()).isEqualTo(expected);
  }

  @Test
  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    int expected = 567;
    when(wrapped.available()).thenReturn(expected);

    assertThat(is.available()).isEqualTo(expected);
  }

  @Test
  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {
    int contentLength = 999;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(1);

    assertThat(is.read()).isEqualTo(1);
    assertThat(is.available()).isEqualTo(contentLength - 1);
  }

  @Test
  public void testAvailable_handlesReadValueOfZero() throws IOException {
    int contentLength = 999;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(0);

    assertThat(is.read()).isEqualTo(0);
    assertThat(is.available()).isEqualTo(contentLength);
  }

  @Test
  public void testAvailable_withReadBytes_returnsContentLengthOffsetByNumberOfBytes()
      throws IOException {
    int contentLength = 678;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    int read = 100;
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(read);

    assertThat(is.read(new byte[500], 0, 0)).isEqualTo(read);
    assertThat(is.available()).isEqualTo(contentLength - read);
  }

  @Test
  public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
      throws IOException {
    int contentLength = 1;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(-1);

    try {
      is.read();
      fail("Failed to throw expected exception");
    } catch (IOException e) {
      // Expected.
    }
  }

  @Test
  public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
      throws IOException {
    int contentLength = 2;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);

    try {
      is.read(new byte[10], 0, 0);
      fail("Failed to throw expected exception");
    } catch (IOException e) {
      // Expected.
    }
  }

  @Test
  public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    when(wrapped.read()).thenReturn(-1);
    is.read();
  }

  @Test
  public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow()
      throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
    is.read(new byte[10], 0, 0);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java;<<<<<<< MINE
=======
import static com.google.common.truth.Truth.assertThat;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java;<<<<<<< MINE
    @Test
    public void testIssue387() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        assertThat(new ImageHeaderParser(is).getOrientation()).isEqualTo(6);
    }

    @Test
    public void testLandscape() throws IOException {
        for (int i = 1; i <= 8; i++) {
            assertOrientation("Landscape", i);
        }
=======
  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIssue387() throws IOException {
      InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
      assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
  }

  @Test
  public void testLandscape() throws IOException {
    for (int i = 1; i <= 8; i++) {
      assertOrientation("Landscape", i);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java;<<<<<<< MINE
=======
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Collections;
import java.util.Set;

/**
 * A {@link RequestManagerTreeNode} that returns no relatives.
 */
final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
    @Override
    public Set<RequestManager> getDescendants() {
        return Collections.emptySet();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java;<<<<<<< MINE
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context hierarchy
 * is provided by nesting in Activity and Fragments; the application context does not provide access to
 * any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();
}=======
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context
 * hierarchy is provided by nesting in Activity and Fragments; the application context does not
 * provide access to any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current
     * {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
=======
import com.bumptech.glide.util.Util;

>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    private final Set<LifecycleListener> lifecycleListeners =
            Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
    private boolean isStarted;
    private boolean isDestroyed;

    /**
     * Adds the given listener to the list of listeners to be notified on each lifecycle event.
     *
     * <p>
     *     The latest lifecycle event will be called on the given listener synchronously in this method. If the
     *     activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be called, and same for onStart and
     *     onDestroy.
     * </p>
     *
     * <p>
     *     Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once will have their
     *     lifecycle methods called more than once. It is the caller's responsibility to avoid adding listeners
     *     multiple times.
     * </p>
     */
    @Override
    public void addListener(LifecycleListener listener) {
        lifecycleListeners.add(listener);

        if (isDestroyed) {
            listener.onDestroy();
        } else if (isStarted) {
            listener.onStart();
        } else {
            listener.onStop();
        }
=======
  private final Set<LifecycleListener> lifecycleListeners =
      Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());
  private boolean isStarted;
  private boolean isDestroyed;

  /**
   * Adds the given listener to the list of listeners to be notified on each lifecycle event.
   *
   * <p> The latest lifecycle event will be called on the given listener synchronously in this
   * method. If the activity or fragment is stopped, {@link LifecycleListener#onStop()}} will be
   * called, and same for onStart and onDestroy. </p>
   *
   * <p> Note - {@link com.bumptech.glide.manager.LifecycleListener}s that are added more than once
   * will have their lifecycle methods called more than once. It is the caller's responsibility to
   * avoid adding listeners multiple times. </p>
   */
  @Override
  public void addListener(LifecycleListener listener) {
    lifecycleListeners.add(listener);

    if (isDestroyed) {
      listener.onDestroy();
    } else if (isStarted) {
      listener.onStart();
    } else {
      listener.onStop();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onStart() {
        isStarted = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStart();
        }
=======
  @Override
  public void removeListener(LifecycleListener listener) {
    lifecycleListeners.remove(listener);
  }

  void onStart() {
    isStarted = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStart();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onStop() {
        isStarted = false;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStop();
        }
=======
  void onStop() {
    isStarted = false;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStop();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
    void onDestroy() {
        isDestroyed = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onDestroy();
        }
=======
  void onDestroy() {
    isDestroyed = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onDestroy();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/signature/StringSignature.java;<<<<<<< MINE
    @Override
    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
        messageDigest.update(signature.getBytes(STRING_CHARSET_NAME));
    }

    @Override
    public String toString() {
        return "StringSignature{"
            + "signature='" + signature + '\''
            + '}';
    }
=======
  @Override
  public int hashCode() {
    return signature.hashCode();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(signature.getBytes(CHARSET));
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.gif.GifDrawable;
import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;

import java.io.File;
import java.io.InputStream;

/**
 * A class for creating a request to load an animated gif.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 */
public class GifRequestBuilder<ModelType>
        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>
        implements BitmapOptions, DrawableOptions {

    GifRequestBuilder(LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider,
            Class<GifDrawable> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        super(loadProvider, transcodeClass, other);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> thumbnail(GenericRequestBuilder<?, ?, ?, GifDrawable> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * Loads and displays the GIF retrieved by the given thumbnail request if it finishes before this
     * request. Best used for loading thumbnail GIFs that are smaller and will be loaded more quickly
     * than the fullsize GIF. There are no guarantees about the order in which the requests will actually
     * finish. However, if the thumb request completes after the full request, the thumb GIF will never
     * replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full GIF loads or the thumbnail loads,
     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This builder object.
     */
    public GifRequestBuilder<ModelType> thumbnail(GifRequestBuilder<?> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> decoder(
            ResourceDecoder<InputStream, GifDrawable> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> cacheDecoder(
            ResourceDecoder<File, GifDrawable> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> encoder(
            ResourceEncoder<GifDrawable> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> centerCrop() {
        return transformFrame(glide.getBitmapCenterCrop());
    }

    /**
     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder..
     */
    public GifRequestBuilder<ModelType> fitCenter() {
        return transformFrame(glide.getBitmapFitCenter());
    }

    /**
     * Transforms each frame of the GIF using the given transformations.
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param bitmapTransformations The transformations to apply in order to each frame.
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> transformFrame(BitmapTransformation... bitmapTransformations) {
        return transform(toGifTransformations(bitmapTransformations));
    }

    /**
     * Transforms each frame of the GIF using the given transformations.
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param bitmapTransformations The transformations to apply in order to each frame.
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> transformFrame(Transformation<Bitmap>... bitmapTransformations) {
        return transform(toGifTransformations(bitmapTransformations));
    }

    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {
        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];
        for (int i = 0; i < bitmapTransformations.length; i++) {
            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());
        }
        return transformations;
    }

    /**
     * {@inheritDoc}
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     *
     */
    @Override
    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade() {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>());
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade(int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @Override
    public GifRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(animation, duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade(int animationId, int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(context, animationId,
                duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public GifRequestBuilder<ModelType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> listener(
            RequestListener<? super ModelType, GifDrawable> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> sourceEncoder(Encoder<InputStream> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> clone() {
        return (GifRequestBuilder<ModelType>) super.clone();
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.MultiTransformation;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.UnitTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.ChildLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.FutureTarget;
import com.bumptech.glide.request.GenericRequest;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.RequestCoordinator;
import com.bumptech.glide.request.RequestFutureTarget;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.ThumbnailRequestCoordinator;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.animation.NoAnimation;
import com.bumptech.glide.request.animation.ViewAnimationFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
import com.bumptech.glide.request.target.PreloadTarget;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.signature.EmptySignature;
import com.bumptech.glide.util.Util;

import java.io.File;

/**
 * A generic class that can handle setting options and staring loads for generic resource types.
 *
 * @param <ModelType> The type of model representing the resource.
 * @param <DataType> The data type that the resource {@link com.bumptech.glide.load.model.ModelLoader} will provide that
 *                  can be decoded by the {@link com.bumptech.glide.load.ResourceDecoder}.
 * @param <ResourceType> The type of the resource that will be loaded.
 * @param <TranscodeType> The type of resource the decoded resource will be transcoded to.
 */
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable {
    protected final Class<ModelType> modelClass;
    protected final Context context;
    protected final Glide glide;
    protected final Class<TranscodeType> transcodeClass;
    protected final RequestTracker requestTracker;
    protected final Lifecycle lifecycle;
    private ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider;

    private ModelType model;
    private Key signature = EmptySignature.obtain();
    // model may occasionally be null, so to enforce that load() was called, set a boolean rather than relying on model
    // not to be null.
    private boolean isModelSet;
    private int placeholderId;
    private int errorId;
    private RequestListener<? super ModelType, TranscodeType> requestListener;
    private Float thumbSizeMultiplier;
    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
    private Float sizeMultiplier = 1f;
    private Drawable placeholderDrawable;
    private Drawable errorPlaceholder;
    private Priority priority = null;
    private boolean isCacheable = true;
    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
    private int overrideHeight = -1;
    private int overrideWidth = -1;
    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
    private Transformation<ResourceType> transformation = UnitTransformation.get();
    private boolean isTransformationSet;
    private boolean isThumbnailBuilt;
    private Drawable fallbackDrawable;
    private int fallbackResource;

    GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        this(other.context, other.modelClass, loadProvider, transcodeClass, other.glide, other.requestTracker,
                other.lifecycle);
        this.model = other.model;
        this.isModelSet = other.isModelSet;
        this.signature = other.signature;
        this.diskCacheStrategy = other.diskCacheStrategy;
        this.isCacheable = other.isCacheable;
    }

    GenericRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {
        this.context = context;
        this.modelClass = modelClass;
        this.transcodeClass = transcodeClass;
        this.glide = glide;
        this.requestTracker = requestTracker;
        this.lifecycle = lifecycle;
        this.loadProvider = loadProvider != null
                ? new ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType>(loadProvider) : null;

        if (context == null) {
            throw new NullPointerException("Context can't be null");
        }
        if (modelClass != null && loadProvider == null) {
            throw new NullPointerException("LoadProvider must not be null");
        }
    }

    /**
     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before this request.
     * Best used for loading thumbnail resources that are smaller and will be loaded more quickly than the full size
     * resource. There are no guarantees about the order in which the requests will actually finish. However, if the
     * thumb request completes after the full request, the thumb resource will never replace the full resource.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        if (this.equals(thumbnailRequest)) {
            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
                    + "clone() on the request you are passing to thumbnail()");
        }
        this.thumbnailRequestBuilder = thumbnailRequest;

        return this;
    }

    /**
     * Loads a resource in an identical manner to this request except with the dimensions of the target multiplied
     * by the given size multiplier. If the thumbnail load completes before the fullsize load, the thumbnail will
     * be shown. If the thumbnail load completes afer the fullsize load, the thumbnail will not be shown.
     *
     * <p>
     *     Note - The thumbnail resource will be smaller than the size requested so the target (or {@link ImageView})
     *     must be able to scale the thumbnail appropriately. See {@link android.widget.ImageView.ScaleType}.
     * </p>
     *
     * <p>
     *     Almost all options will be copied from the original load, including the
     *     {@link com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder}, and
     *     {@link Transformation}s. However, {@link #placeholder(int)} and {@link #error(int)},
     *     and {@link #listener(RequestListener)} will only be used on the fullsize load and will not be copied for
     *     the thumbnail load.
     * </p>
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.thumbSizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Applies a multiplier to the {@link Target}'s size before loading the resource. Useful for loading thumbnails
     * or trying to avoid loading huge resources (particularly {@link android.graphics.Bitmap}s on devices with overly
     * dense screens.
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sizeMultiplier(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.sizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the original data.
     * By default, this decoder will only be used if the final transformed resource is not in the disk cache.
     *
     * @see #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param decoder The {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> decoder(
            ResourceDecoder<DataType, ResourceType> decoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setSourceDecoder(decoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the disk cache. By
     * default, this decoder will only be used if the final transformed resource is already in the disk cache.
     *
     * @see #decoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param cacheDecoder The decoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> cacheDecoder(
            ResourceDecoder<File, ResourceType> cacheDecoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setCacheDecoder(cacheDecoder);
        }

        return this;
    }

    /**
     * Sets the source encoder to use to encode the data retrieved by this request directly into cache. The returned
     * resource will then be decoded from the cached data.
     *
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param sourceEncoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sourceEncoder(
            Encoder<DataType> sourceEncoder) {
        if (loadProvider != null) {
            loadProvider.setSourceEncoder(sourceEncoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.
     *
     * <p>
     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal.
     *     Applications that use the same resource multiple times in multiple sizes and are willing to trade off some
     *     speed and disk space in return for lower bandwidth usage may want to consider using
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should
     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}.
     * </p>
     *
     * @param strategy The strategy to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(
            DiskCacheStrategy strategy) {
        this.diskCacheStrategy = strategy;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.Encoder} to use to encode the original data directly to cache. Will only
     * be used if the original data is not already in cache and if the
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} is set to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}.
     *
     * @see #sourceEncoder(com.bumptech.glide.load.Encoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param encoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> encoder(
            ResourceEncoder<ResourceType> encoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the encoder.
        if (loadProvider != null) {
            loadProvider.setEncoder(encoder);
        }

        return this;
    }

    /**
     * Sets the priority for this load.
     *
     * @param priority A priority.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> priority(
            Priority priority) {
        this.priority = priority;

        return this;
    }

    /**
     * Transform resources with the given {@link Transformation}s. Replaces any existing transformation or
     * transformations.
     *
     * @param transformations the transformations to apply in order.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transform(
            Transformation<ResourceType>... transformations) {
        isTransformationSet = true;
        if (transformations.length == 1) {
            transformation = transformations[0];
        } else {
            transformation = new MultiTransformation<ResourceType>(transformations);
        }

        return this;
    }

    /**
     * Removes the current {@link com.bumptech.glide.load.Transformation}.
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontTransform() {
        Transformation<ResourceType> transformation = UnitTransformation.get();
        return transform(transformation);
    }

    /**
     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use for this load.
     *
     * @see com.bumptech.glide.load.resource.transcode.UnitTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder
     *
     * @param transcoder The transcoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcoder(
            ResourceTranscoder<ResourceType, TranscodeType> transcoder) {
        if (loadProvider != null) {
            loadProvider.setTranscoder(transcoder);
        }

        return this;
    }

    /**
     * Removes any existing animation set on the builder. Will be overridden by subsequent calls that set an animation.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontAnimate() {
        GlideAnimationFactory<TranscodeType> animation = NoAnimation.getFactory();
        return animate(animation);
    }

    /**
     * Sets an animation to run on the wrapped target when an resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @param animationId The resource id of the animation to run
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
    }

    /**
     * Sets an animation to run on the wrapped target when a resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @see #animate(int)
     * @see #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)
     *
     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
     * views animating repeatedly. Use {@link #animate(int)} or
     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
     * Glide 4.0.
     * @param animation The animation to run
     * @return This request builder.
     */
    @Deprecated
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
        return animate(new ViewAnimationFactory<TranscodeType>(animation));
    }

    /**
     * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target may be wrapping
     * when a resource load finishes. Will only be run if the load was loaded asynchronously (ie was not in the
     * memory cache).
     *
     * @param animator The {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} to run.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            ViewPropertyAnimation.Animator animator) {
        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
    }

    GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            GlideAnimationFactory<TranscodeType> animationFactory) {
        if (animationFactory == null) {
            throw new NullPointerException("Animation factory must not be null!");
        }
        this.animationFactory = animationFactory;

        return this;
    }

    /**
     * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resourceto display while a resource
     * is loading.
     *
     * @param resourceId The id of the resource to use as a placeholder
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            int resourceId) {
        this.placeholderId = resourceId;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            Drawable drawable) {
        this.placeholderDrawable = drawable;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
     * {@link #load(Object)} is {@code null}.
     *
     * <p>
     *   If a fallback is not set, null models will cause the error drawable to be displayed. If
     *   the error drawable is not set, the placeholder will be displayed.
     * </p>
     *
     * @see #placeholder(Drawable)
     * @see #placeholder(int)
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> fallback(
            Drawable drawable) {
        this.fallbackDrawable = drawable;

        return this;
    }

    /**
     * Sets a resource to display if the model provided to {@link #load(Object)} is {@code null}.
     *
     * <p>
     *   If a fallback is not set, null models will cause the error drawable to be displayed. If
     *   the error drawable is not set, the placeholder will be displayed.
     * </p>
     *
     * @see #placeholder(Drawable)
     * @see #placeholder(int)
     *
     * @param resourceId The id of the resource to use as a fallback.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> fallback(
            int resourceId) {
        this.fallbackResource = resourceId;

        return this;
    }

    /**
     * Sets a resource to display if a load fails.
     *
     * @param resourceId The id of the resource to use as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            int resourceId) {
        this.errorId = resourceId;

        return this;
    }

    /**
     * Sets a {@link Drawable} to display if a load fails.
     *
     * @param drawable The drawable to display.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            Drawable drawable) {
        this.errorPlaceholder = drawable;

        return this;
    }

    /**
     * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single instance of an
     * exception handler per type of request (usually activity/fragment) rather than pass one in per request to
     * avoid some redundant object allocation.
     *
     * @param requestListener The request listener to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        this.requestListener = requestListener;

        return this;
    }

    /**
     * Allows the loaded resource to skip the memory cache.
     *
     * <p>
     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not
     *     also skipping the memory cache, the resource will be cached in memory.
     * </p>
     *
     * @param skip True to allow the resource to skip the memory cache.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {
        this.isCacheable = !skip;

        return this;
    }

    /**
     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for
     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
     *
     * @param width The width in pixels to use to load the resource.
     * @param height The height in pixels to use to load the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
        if (!Util.isValidDimensions(width, height)) {
            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");
        }
        this.overrideWidth = width;
        this.overrideHeight = height;

        return this;
    }

    /**
     * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over
     * when cached data is invalidated.
     *
     * <p>
     *     Note - The signature does not replace the cache key, it is purely additive.
     * </p>
     *
     * @see com.bumptech.glide.signature.StringSignature
     *
     * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current state of the
     *                  model that will be mixed in to the cache key.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> signature(Key signature) {
        if (signature == null) {
            throw new NullPointerException("Signature must not be null");
        }
        this.signature = signature;
        return this;
    }

    /**
     * Sets the specific model to load data for.
     *
     * <p>
     *      This method must be called at least once before {@link #into(com.bumptech.glide.request.target.Target)} is
     *      called.
     * </p>
     *
     * @param model The model to load data for, or null.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {
        this.model = model;
        isModelSet = true;
        return this;
    }

    /**
     * Returns a copy of this request builder with all of the options set so far on this builder.
     *
     * <p>
     *     This method returns a "deep" copy in that all non-immutable arguments are copied such that changes to one
     *     builder will not affect the other builder. However, in addition to immutable arguments, the current model
     *     is not copied copied so changes to the model will affect both builders.
     * </p>
     */
    @SuppressWarnings("unchecked")
    @Override
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone() {
        try {
            GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone =
                    (GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>) super.clone();
            clone.loadProvider = loadProvider != null ? loadProvider.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Set the target the resource will be loaded into.
     *
     * @see Glide#clear(com.bumptech.glide.request.target.Target)
     *
     * @param target The target to load the resource into.
     * @return The given target.
     */
    public <Y extends Target<TranscodeType>> Y into(Y target) {
        Util.assertMainThread();
        if (target == null) {
            throw new IllegalArgumentException("You must pass in a non null Target");
        }
        if (!isModelSet) {
            throw new IllegalArgumentException("You must first set a model (try #load())");
        }

        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        Request request = buildRequest(target);
        target.setRequest(request);
        lifecycle.addListener(target);
        requestTracker.runRequest(request);

        return target;
    }

    /**
     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into the view, and frees
     * any resources Glide may have previously loaded into the view so they may be reused.
     *
     * @see Glide#clear(android.view.View)
     *
     * @param view The view to cancel previous loads for and load the new resource into.
     * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
     */
    public Target<TranscodeType> into(ImageView view) {
        Util.assertMainThread();
        if (view == null) {
            throw new IllegalArgumentException("You must pass in a non null View");
        }

        if (!isTransformationSet && view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                //$CASES-OMITTED$
                default:
                    // Do nothing.
            }
        }

        return into(glide.buildImageViewTarget(view, transcodeClass));
    }

    /**
     * Returns a future that can be used to do a blocking get on a background thread.
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     *
     * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
     *
     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
     *         resource in a blocking manner.
     */
    public FutureTarget<TranscodeType> into(int width, int height) {
        final RequestFutureTarget<ModelType, TranscodeType> target =
                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);

        // TODO: Currently all loads must be started on the main thread...
        glide.getMainHandler().post(new Runnable() {
            @Override
            public void run() {
                if (!target.isCancelled()) {
                    into(target);
                }
            }
        });

        return target;
    }

    /**
     * Preloads the resource into the cache using the given width and height.
     *
     * <p>
     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are
     *     available quickly.
     * </p>
     *
     *
     * @see com.bumptech.glide.ListPreloader
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload(int width, int height) {
        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
        return into(target);
    }

    /**
     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and height.
     * Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as the width and height.
     *
     * @see #preload(int, int)
     *
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload() {
        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
    }

    void applyCenterCrop() {
        // To be implemented by subclasses when possible.
    }

    void applyFitCenter() {
        // To be implemented by subclasses when possible.
    }

    private Priority getThumbnailPriority() {
        final Priority result;
        if (priority == Priority.LOW) {
            result = Priority.NORMAL;
        } else if (priority == Priority.NORMAL) {
            result = Priority.HIGH;
        } else {
            result = Priority.IMMEDIATE;
        }
        return result;
    }

    private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        return buildRequestRecursive(target, null);
    }

    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            // Guard against infinite recursion.
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            isThumbnailBuilt = false;
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }

    private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
            RequestCoordinator requestCoordinator) {
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                fallbackDrawable,
                fallbackResource,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.ParcelFileDescriptor;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.load.model.ImageVideoWrapper;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.bitmap.Downsampler;
import com.bumptech.glide.load.resource.bitmap.FileDescriptorBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.ImageVideoBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.target.Target;

import java.io.File;
import java.io.InputStream;

/**
 * A class for creating a request to load a bitmap for an image or from a video. Sets a variety of type independent
 * options including resizing, animations, and placeholders.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 * @param <TranscodeType> The type of the transcoded resource that the target will receive
 */
public class BitmapRequestBuilder<ModelType, TranscodeType>
        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> implements BitmapOptions {
    private final BitmapPool bitmapPool;

    private Downsampler downsampler = Downsampler.AT_LEAST;
    private DecodeFormat decodeFormat;
    private ResourceDecoder<InputStream, Bitmap> imageDecoder;
    private ResourceDecoder<ParcelFileDescriptor, Bitmap> videoDecoder;

    BitmapRequestBuilder(LoadProvider<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        super(loadProvider, transcodeClass, other);
        this.bitmapPool = other.glide.getBitmapPool();
        this.decodeFormat =  other.glide.getDecodeFormat();

        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);
        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);
    }

    /**
     * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}.
     *
     * @see #downsample(Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> approximate() {
        return downsample(Downsampler.AT_LEAST);
    }

    /**
     * Load images at their original size using {@link Downsampler#NONE}.
     *
     * @see #downsample(Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> asIs() {
        return downsample(Downsampler.NONE);
    }

    /**
     * Load images at a size that is at most exactly as big as the target using
     * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#AT_MOST}.
     *
     * @see #downsample(com.bumptech.glide.load.resource.bitmap.Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> atMost() {
        return downsample(Downsampler.AT_MOST);
    }

    /**
     * Load images using the given {@link Downsampler}. Replaces any existing image decoder. Defaults to
     * {@link Downsampler#AT_LEAST}. Will be ignored if the data represented by the model is a video. This replaces any
     * previous calls to {@link #imageDecoder(ResourceDecoder)}  and {@link #decoder(ResourceDecoder)} with default
     * decoders with the appropriate options set.
     *
     * @see #imageDecoder
     *
     * @param downsampler The downsampler.
     * @return This request builder.
     */
    private BitmapRequestBuilder<ModelType, TranscodeType> downsample(Downsampler downsampler) {
        this.downsampler = downsampler;
        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * Loads and displays the {@link android.graphics.Bitmap} retrieved by the given thumbnail request if it finishes
     * before this request. Best used for loading thumbnail {@link Bitmap}s that are smaller and will be loaded more
     * quickly than the fullsize {@link Bitmap}. There are no guarantees about the order in which the requests will
     * actually finish. However, if the thumb request completes after the full request, the thumb
     * {@link android.graphics.Bitmap} will never replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full {@link android.graphics.Bitmap} loads or the thumbnail
     *     loads, you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(BitmapRequestBuilder<?, TranscodeType>
            thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> decoder(ResourceDecoder<ImageVideoWrapper, Bitmap> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> encoder(ResourceEncoder<Bitmap> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
     * from an {@link java.io.InputStream}.
     *
     * @see #videoDecoder
     *
     * @param decoder The decoder to use to decode {@link Bitmap}s.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> imageDecoder(ResourceDecoder<InputStream, Bitmap> decoder) {
        imageDecoder = decoder;
        super.decoder(new ImageVideoBitmapDecoder(decoder, videoDecoder));
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
     * from an {@link android.os.ParcelFileDescriptor}.
     *
     * @param decoder The decoder to use to decode {@link Bitmap}s.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> videoDecoder(
            ResourceDecoder<ParcelFileDescriptor, Bitmap> decoder) {
        videoDecoder = decoder;
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, decoder));
        return this;
    }

    /**
     * Sets the preferred format for {@link Bitmap}s decoded in this request. Defaults to
     * {@link DecodeFormat#PREFER_RGB_565}. This replaces any previous calls to {@link #imageDecoder(ResourceDecoder)},
     * {@link #videoDecoder(ResourceDecoder)}, {@link #decoder(ResourceDecoder)} and
     * {@link #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)}} with default decoders with the appropriate
     * options set.
     *
     * <p>
     *     Note - If using a {@link Transformation} that expect bitmaps to support transparency, this should always be
     *     set to ALWAYS_ARGB_8888. RGB_565 requires fewer bytes per pixel and is generally preferable, but it does not
     *     support transparency.
     * </p>
     *
     * @see DecodeFormat
     *
     * @param format The format to use.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> format(DecodeFormat format) {
        this.decodeFormat = format;
        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, format);
        videoDecoder = new FileDescriptorBitmapDecoder(new VideoBitmapDecoder(), bitmapPool, format);
        super.cacheDecoder(new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(downsampler, bitmapPool, format)));
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param transformations The transformations to apply in order.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> centerCrop() {
        return transform(glide.getBitmapCenterCrop());
    }

    /**
     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> fitCenter() {
        return transform(glide.getBitmapFitCenter());
    }

    /**
     * {@inheritDoc}
     *
     * @see #fitCenter()
     * @see #centerCrop()
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> transform(Transformation<Bitmap>... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> transcoder(
            ResourceTranscoder<Bitmap, TranscodeType> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> clone() {
        return (BitmapRequestBuilder<ModelType, TranscodeType>) super.clone();
    }

    /**
     * {@inheritDoc}
     *
     * <p>
     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
     *     use {@link #dontTransform()}.
     * </p>
     *
     * @param view {@inheritDoc}
     * @return {@inheritDoc}
     */
    @Override
    public Target<TranscodeType> into(ImageView view) {
        return super.into(view);
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java;<<<<<<< MINE
public class ThumbnailRequestCoordinator implements RequestCoordinator, Request {
    private Request full;
    private Request thumb;
    private RequestCoordinator coordinator;

    public ThumbnailRequestCoordinator() {
        this(null);
    }

    public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
        this.coordinator = coordinator;
    }

    public void setRequests(Request full, Request thumb) {
        this.full = full;
        this.thumb = thumb;
    }

    /**
     *
     * Returns true if the request is either the request loading the fullsize image or if the request loading the
     * full size image has not yet completed.
     *
     * @param request {@inheritDoc}
     */
    @Override
    public boolean canSetImage(Request request) {
        return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
    }

    private boolean parentCanSetImage() {
        return coordinator == null || coordinator.canSetImage(this);
    }

    /**
     * Returns true if the request is the request loading the fullsize image and if neither the full nor the thumbnail
     * image have completed sucessfully.
     *
     * @param request {@inheritDoc}.
     */
    @Override
    public boolean canNotifyStatusChanged(Request request) {
        return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
    }

    private boolean parentCanNotifyStatusChanged() {
        return coordinator == null || coordinator.canNotifyStatusChanged(this);
    }

    @Override
    public boolean isAnyResourceSet() {
        return parentIsAnyResourceSet() || isResourceSet();
    }

    @Override
    public void onRequestSuccess(Request request) {
        if (request.equals(thumb)) {
            return;
        }
        if (coordinator != null) {
            coordinator.onRequestSuccess(this);
        }
        // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
        // as a layer in a cross fade for example. The only way we know the thumb is not being
        // displayed and is therefore safe to clear is if the thumb request has not yet completed.
        if (!thumb.isComplete()) {
          thumb.clear();
        }
    }

    private boolean parentIsAnyResourceSet() {
        return coordinator != null && coordinator.isAnyResourceSet();
    }

    /**
     * Starts first the thumb request and then the full request.
     */
    @Override
    public void begin() {
        if (!thumb.isRunning()) {
            thumb.begin();
        }
        if (!full.isRunning()) {
            full.begin();
        }
    }

    @Override
    public void pause() {
        full.pause();
        thumb.pause();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clear() {
        thumb.clear();
        full.clear();
    }

    @Override
    public boolean isPaused() {
        return full.isPaused();
    }

    /**
     * Returns true if the full request is still running.
     */
    @Override
    public boolean isRunning() {
        return full.isRunning();
    }

    /**
     * Returns true if the full request is complete.
     */
    @Override
    public boolean isComplete() {
        return full.isComplete() || thumb.isComplete();
    }

    @Override
    public boolean isResourceSet() {
        return full.isResourceSet() || thumb.isResourceSet();
    }

    @Override
    public boolean isCancelled() {
        return full.isCancelled();
    }

    /**
     * Returns true if the full request has failed.
     */
    @Override
    public boolean isFailed() {
        return full.isFailed();
    }

    /**
     * {@inheritDoc}.
     */
    @Override
    public void recycle() {
        full.recycle();
        thumb.recycle();
    }
=======
public class ThumbnailRequestCoordinator implements RequestCoordinator,
    Request {
  private Request full;
  private Request thumb;
  private RequestCoordinator coordinator;
  private boolean isRunning;

  public ThumbnailRequestCoordinator() {
    this(null);
  }

  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
    this.coordinator = coordinator;
  }

  public void setRequests(Request full, Request thumb) {
    this.full = full;
    this.thumb = thumb;
  }

  /**
   * Returns true if the request is either the request loading the fullsize image or if the request
   * loading the full size image has not yet completed.
   *
   * @param request {@inheritDoc}
   */
  @Override
  public boolean canSetImage(Request request) {
    return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
  }

  private boolean parentCanSetImage() {
    return coordinator == null || coordinator.canSetImage(this);
  }

  /**
   * Returns true if the request is the request loading the fullsize image and if neither the full
   * nor the thumbnail image have completed sucessfully.
   *
   * @param request {@inheritDoc}.
   */
  @Override
  public boolean canNotifyStatusChanged(Request request) {
    return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
  }

  private boolean parentCanNotifyStatusChanged() {
    return coordinator == null || coordinator.canNotifyStatusChanged(this);
  }

  @Override
  public boolean isAnyResourceSet() {
    return parentIsAnyResourceSet() || isResourceSet();
  }

  @Override
  public void onRequestSuccess(Request request) {
    if (request.equals(thumb)) {
      return;
    }
    if (coordinator != null) {
      coordinator.onRequestSuccess(this);
    }
    // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
    // as a layer in a cross fade for example. The only way we know the thumb is not being
    // displayed and is therefore safe to clear is if the thumb request has not yet completed.
    if (!thumb.isComplete()) {
      thumb.clear();
    }
  }

  private boolean parentIsAnyResourceSet() {
    return coordinator != null && coordinator.isAnyResourceSet();
  }

  /**
   * Starts first the thumb request and then the full request.
   */
  @Override
  public void begin() {
    isRunning = true;
    if (!thumb.isRunning()) {
      thumb.begin();
    }
    if (isRunning && !full.isRunning()) {
      full.begin();
    }
  }

  @Override
  public void pause() {
    isRunning = false;
    full.pause();
    thumb.pause();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void clear() {
    isRunning = false;
    thumb.clear();
    full.clear();
  }

  @Override
  public boolean isPaused() {
    return full.isPaused();
  }

  /**
   * Returns true if the full request is still running.
   */
  @Override
  public boolean isRunning() {
    return full.isRunning();
  }

  /**
   * Returns true if the full request is complete.
   */
  @Override
  public boolean isComplete() {
    return full.isComplete() || thumb.isComplete();
  }

  @Override
  public boolean isResourceSet() {
    return full.isResourceSet() || thumb.isResourceSet();
  }

  @Override
  public boolean isCancelled() {
    return full.isCancelled();
  }

  /**
   * Returns true if the full request has failed.
   */
  @Override
  public boolean isFailed() {
    return full.isFailed();
  }

  /**
   * {@inheritDoc}.
   */
  @Override
  public void recycle() {
    full.recycle();
    thumb.recycle();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java;<<<<<<< MINE
    RequestFutureTarget(Handler mainHandler, int width, int height, boolean assertBackgroundThread, Waiter waiter) {
        this.mainHandler = mainHandler;
        this.width = width;
        this.height = height;
        this.assertBackgroundThread = assertBackgroundThread;
        this.waiter = waiter;
    }

    @Override
    public synchronized boolean cancel(boolean mayInterruptIfRunning) {
        if (isCancelled) {
            return true;
        }

        final boolean result = !isDone();
        if (result) {
            isCancelled = true;
            if (mayInterruptIfRunning) {
                clear();
            }
            waiter.notifyAll(this);
        }
        return result;
    }

    @Override
    public synchronized boolean isCancelled() {
        return isCancelled;
    }

    @Override
    public synchronized boolean isDone() {
        return isCancelled || resultReceived;
    }

    @Override
    public R get() throws InterruptedException, ExecutionException {
        try {
            return doGet(null);
        } catch (TimeoutException e) {
            throw new AssertionError(e);
        }
    }

    @Override
    public R get(long time, TimeUnit timeUnit) throws InterruptedException, ExecutionException, TimeoutException {
        return doGet(timeUnit.toMillis(time));
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public void getSize(SizeReadyCallback cb) {
        cb.onSizeReady(width, height);
    }

    @Override
    public void setRequest(Request request) {
        this.request = request;
    }

    @Override
    public Request getRequest() {
        return request;
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public void onLoadCleared(Drawable placeholder) {
        // Do nothing.
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public void onLoadStarted(Drawable placeholder) {
        // Do nothing.
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public synchronized void onLoadFailed(Exception e, Drawable errorDrawable) {
         // We might get a null exception.
        exceptionReceived = true;
        this.exception = e;
        waiter.notifyAll(this);
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public synchronized void onResourceReady(R resource, GlideAnimation<? super R> glideAnimation) {
        // We might get a null result.
        resultReceived = true;
        this.resource = resource;
        waiter.notifyAll(this);
    }

    private synchronized R doGet(Long timeoutMillis) throws ExecutionException, InterruptedException, TimeoutException {
        if (assertBackgroundThread) {
            Util.assertBackgroundThread();
        }

        if (isCancelled) {
            throw new CancellationException();
        } else if (exceptionReceived) {
            throw new ExecutionException(exception);
        } else if (resultReceived) {
            return resource;
        }

        if (timeoutMillis == null) {
            waiter.waitForTimeout(this, 0);
        } else if (timeoutMillis > 0) {
            waiter.waitForTimeout(this, timeoutMillis);
        }

        if (Thread.interrupted()) {
            throw new InterruptedException();
        } else if (exceptionReceived) {
            throw new ExecutionException(exception);
        } else if (isCancelled) {
            throw new CancellationException();
        } else if (!resultReceived) {
            throw new TimeoutException();
        }

        return resource;
    }

    /**
     * A callback that should never be invoked directly.
     */
    @Override
    public void run() {
        if (request != null) {
            request.clear();
            cancel(false /*mayInterruptIfRunning*/);
        }
    }

    /**
     * Can be safely called from either the main thread or a background thread to cleanup the resources used by this
     * target.
     */
    @Override
    public void clear() {
        mainHandler.post(this);
    }

    @Override
    public void onStart() {
        // Do nothing.
    }

    @Override
    public void onStop() {
        // Do nothing.
    }

    @Override
    public void onDestroy() {
        // Do nothing.
    }

    // Visible for testing.
    static class Waiter {

        public void waitForTimeout(Object toWaitOn, long timeoutMillis) throws InterruptedException {
            toWaitOn.wait(timeoutMillis);
        }

        public void notifyAll(Object toNotify) {
            toNotify.notifyAll();
        }
=======
    public void notifyAll(Object toNotify) {
      toNotify.notifyAll();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java;<<<<<<< MINE
package com.bumptech.glide.request.target;

import android.annotation.TargetApi;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;

import com.bumptech.glide.load.resource.drawable.GlideDrawable;

/**
 * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with exactly the given side
 * length. The goal of this drawable is to ensure that square thumbnail drawables always match the size of the view
 * they will be displayed in to avoid a costly requestLayout call. This class should not be used with views or drawables
 * that are not square.
 */
public class SquaringDrawable extends GlideDrawable {
    private GlideDrawable wrapped;
    private State state;
    private boolean mutated;

    public SquaringDrawable(GlideDrawable wrapped, int side) {
        this(new State(wrapped.getConstantState(), side), wrapped, null /*res*/);
    }

    SquaringDrawable(State state, GlideDrawable wrapped, Resources res) {
        this.state = state;
        if (wrapped == null) {
          if (res != null) {
            this.wrapped = (GlideDrawable) state.wrapped.newDrawable(res);
          } else {
            this.wrapped = (GlideDrawable) state.wrapped.newDrawable();
          }
        } else {
          this.wrapped = wrapped;
        }
    }

    @Override
    public void setBounds(int left, int top, int right, int bottom) {
        super.setBounds(left, top, right, bottom);
        wrapped.setBounds(left, top, right, bottom);
    }

    @Override
    public void setBounds(Rect bounds) {
        super.setBounds(bounds);
        wrapped.setBounds(bounds);
    }

    @Override
    public void setChangingConfigurations(int configs) {
        wrapped.setChangingConfigurations(configs);
    }

    @Override
    public int getChangingConfigurations() {
        return wrapped.getChangingConfigurations();
    }

    @Override
    public void setDither(boolean dither) {
        wrapped.setDither(dither);
    }

    @Override
    public void setFilterBitmap(boolean filter) {
        wrapped.setFilterBitmap(filter);
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public Callback getCallback() {
        return wrapped.getCallback();
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    @Override
    public int getAlpha() {
        return wrapped.getAlpha();
    }

    @Override
    public void setColorFilter(int color, PorterDuff.Mode mode) {
        wrapped.setColorFilter(color, mode);
    }

    @Override
    public void clearColorFilter() {
        wrapped.clearColorFilter();
    }

    @Override
    public Drawable getCurrent() {
        return wrapped.getCurrent();
    }

    @Override
    public boolean setVisible(boolean visible, boolean restart) {
        return wrapped.setVisible(visible, restart);
    }

    @Override
    public int getIntrinsicWidth() {
        return state.side;
    }

    @Override
    public int getIntrinsicHeight() {
        return state.side;
    }

    @Override
    public int getMinimumWidth() {
        return wrapped.getMinimumWidth();
    }

    @Override
    public int getMinimumHeight() {
        return wrapped.getMinimumHeight();
    }

    @Override
    public boolean getPadding(Rect padding) {
        return wrapped.getPadding(padding);
    }

    @Override
    public void invalidateSelf() {
        super.invalidateSelf();
        wrapped.invalidateSelf();
    }

    @Override
    public void unscheduleSelf(Runnable what) {
        super.unscheduleSelf(what);
        wrapped.unscheduleSelf(what);
    }

    @Override
    public void scheduleSelf(Runnable what, long when) {
        super.scheduleSelf(what, when);
        wrapped.scheduleSelf(what, when);
    }

    @Override
    public void draw(Canvas canvas) {
        wrapped.draw(canvas);
    }

    @Override
    public void setAlpha(int i) {
        wrapped.setAlpha(i);
    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {
        wrapped.setColorFilter(colorFilter);
    }

    @Override
    public int getOpacity() {
        return wrapped.getOpacity();
    }

    @Override
    public boolean isAnimated() {
        return wrapped.isAnimated();
    }

    @Override
    public void setLoopCount(int loopCount) {
        wrapped.setLoopCount(loopCount);
    }

    @Override
    public void start() {
        wrapped.start();
    }

    @Override
    public void stop() {
        wrapped.stop();
    }

    @Override
    public boolean isRunning() {
        return wrapped.isRunning();
    }

    @Override
    public Drawable mutate() {
        if (!mutated && super.mutate() == this) {
            wrapped = (GlideDrawable) wrapped.mutate();
            state = new State(state);
            mutated = true;
        }
        return this;
    }

    @Override
    public ConstantState getConstantState() {
        return state;
    }

    static class State extends ConstantState {
        private final ConstantState wrapped;
        private final int side;

        State(State other) {
          this(other.wrapped, other.side);
        }

        State(ConstantState wrapped, int side) {
          this.wrapped = wrapped;
          this.side = side;
        }

        @Override
        public Drawable newDrawable() {
          return newDrawable(null /*res*/);
        }

        @Override
        public Drawable newDrawable(Resources res) {
          return new SquaringDrawable(this, null /*wrapped*/, res);
        }

        @Override
        public int getChangingConfigurations() {
          return 0;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java;<<<<<<< MINE
package com.bumptech.glide.request.animation;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;

/**
 * A factory class that produces a new {@link com.bumptech.glide.request.animation.GlideAnimation} that varies depending
 * on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first
 * image to be set on the target.
 *
 * <p>
 *     Resources are usually loaded from the memory cache just before the user can see the view,
 *     for example when the user changes screens or scrolls back and forth in a list. In those cases the user
 *     typically does not expect to see an animation. As a result, when the resource is loaded from the memory
 *     cache this factory produces an {@link com.bumptech.glide.request.animation.NoAnimation}.
 * </p>
 *
 * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
 */
public class DrawableCrossFadeFactory<T extends Drawable> implements GlideAnimationFactory<T> {
    private static final int DEFAULT_DURATION_MS = 300;
    private final ViewAnimationFactory<T> animationFactory;
    private final int duration;
    private DrawableCrossFadeViewAnimation<T> firstResourceAnimation;
    private DrawableCrossFadeViewAnimation<T> secondResourceAnimation;

    public DrawableCrossFadeFactory() {
        this(DEFAULT_DURATION_MS);
    }

    public DrawableCrossFadeFactory(int duration) {
        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory(duration)), duration);
    }

    public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
        this(new ViewAnimationFactory<T>(context, defaultAnimationId), duration);
    }

    public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
        this(new ViewAnimationFactory<T>(defaultAnimation), duration);
    }

    DrawableCrossFadeFactory(ViewAnimationFactory<T> animationFactory, int duration) {
        this.animationFactory = animationFactory;
        this.duration = duration;
    }

    @Override
    public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
        if (isFromMemoryCache) {
            return NoAnimation.get();
        } else if (isFirstResource) {
            return getFirstResourceAnimation();
        } else {
            return getSecondResourceAnimation();
        }
    }

    private GlideAnimation<T> getFirstResourceAnimation() {
        if (firstResourceAnimation == null) {
            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
                true /*isFirstResource*/);
            firstResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
        }
        return firstResourceAnimation;
    }

    private GlideAnimation<T> getSecondResourceAnimation() {
        if (secondResourceAnimation == null) {
            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
                false /*isFirstResource*/);
            secondResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
        }
        return secondResourceAnimation;
    }

    private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {

        private final int duration;

        DefaultAnimationFactory(int duration) {
            this.duration = duration;
        }

        @Override
        public Animation build() {
            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
            animation.setDuration(duration);
            return animation;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
package com.bumptech.glide.request;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.util.LogTime;
import com.bumptech.glide.util.Util;

import java.util.Queue;

/**
 * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given {@link Target}.
 *
 * @param <A> The type of the model that the resource will be loaded from.
 * @param <T> The type of the data that the resource will be loaded from.
 * @param <Z> The type of the resource that will be loaded.
 * @param <R> The type of the resource that will be transcoded from the loaded resource.
 */
public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,
        ResourceCallback {
    private static final String TAG = "GenericRequest";
    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);
    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);

    private enum Status {
        /** Created but not yet running. */
        PENDING,
        /** In the process of fetching media. */
        RUNNING,
        /** Waiting for a callback given to the Target to be called to determine target dimensions. */
        WAITING_FOR_SIZE,
        /** Finished loading media successfully. */
        COMPLETE,
        /** Failed to load media, may be restarted. */
        FAILED,
        /** Cancelled by the user, may not be restarted. */
        CANCELLED,
        /** Cleared by the user with a placeholder set, may not be restarted. */
        CLEARED,
        /** Temporarily paused by the system, may be restarted. */
        PAUSED,
    }

    private final String tag = String.valueOf(hashCode());

    private Key signature;
    private Drawable fallbackDrawable;
    private int fallbackResourceId;
    private int placeholderResourceId;
    private int errorResourceId;
    private Context context;
    private Transformation<Z> transformation;
    private LoadProvider<A, T, Z, R> loadProvider;
    private RequestCoordinator requestCoordinator;
    private A model;
    private Class<R> transcodeClass;
    private boolean isMemoryCacheable;
    private Priority priority;
    private Target<R> target;
    private RequestListener<? super A, R> requestListener;
    private float sizeMultiplier;
    private Engine engine;
    private GlideAnimationFactory<R> animationFactory;
    private int overrideWidth;
    private int overrideHeight;
    private DiskCacheStrategy diskCacheStrategy;

    private Drawable placeholderDrawable;
    private Drawable errorDrawable;
    private boolean loadedFromMemoryCache;
    // doing our own type check
    private Resource<?> resource;
    private Engine.LoadStatus loadStatus;
    private long startTime;
    private Status status;

    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        @SuppressWarnings("unchecked")
        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
        if (request == null) {
            request = new GenericRequest<A, T, Z, R>();
        }
        request.init(loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderResourceId,
                errorDrawable,
                errorResourceId,
                fallbackDrawable,
                fallbackResourceId,
                requestListener,
                requestCoordinator,
                engine,
                transformation,
                transcodeClass,
                isMemoryCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
        return request;
    }

    private GenericRequest() {
        // just create, instances are reused with recycle/init
    }

    @Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        fallbackDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }

    private void init(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        this.loadProvider = loadProvider;
        this.model = model;
        this.signature = signature;
        this.fallbackDrawable = fallbackDrawable;
        this.fallbackResourceId = fallbackResourceId;
        this.context = context.getApplicationContext();
        this.priority = priority;
        this.target = target;
        this.sizeMultiplier = sizeMultiplier;
        this.placeholderDrawable = placeholderDrawable;
        this.placeholderResourceId = placeholderResourceId;
        this.errorDrawable = errorDrawable;
        this.errorResourceId = errorResourceId;
        this.requestListener = requestListener;
        this.requestCoordinator = requestCoordinator;
        this.engine = engine;
        this.transformation = transformation;
        this.transcodeClass = transcodeClass;
        this.isMemoryCacheable = isMemoryCacheable;
        this.animationFactory = animationFactory;
        this.overrideWidth = overrideWidth;
        this.overrideHeight = overrideHeight;
        this.diskCacheStrategy = diskCacheStrategy;
        status = Status.PENDING;

        // We allow null models by just setting an error drawable. Null models will always have empty providers, we
        // simply skip our sanity checks in that unusual case.
        if (model != null) {
            check("ModelLoader", loadProvider.getModelLoader(), "try .using(ModelLoader)");
            check("Transcoder", loadProvider.getTranscoder(), "try .as*(Class).transcode(ResourceTranscoder)");
            check("Transformation", transformation, "try .transform(UnitTransformation.get())");
            if (diskCacheStrategy.cacheSource()) {
                check("SourceEncoder", loadProvider.getSourceEncoder(),
                        "try .sourceEncoder(Encoder) or .diskCacheStrategy(NONE/RESULT)");
            } else {
                check("SourceDecoder", loadProvider.getSourceDecoder(),
                        "try .decoder/.imageDecoder/.videoDecoder(ResourceDecoder) or .diskCacheStrategy(ALL/SOURCE)");
            }
            if (diskCacheStrategy.cacheSource() || diskCacheStrategy.cacheResult()) {
                // TODO if(resourceClass.isAssignableFrom(InputStream.class) it is possible to wrap sourceDecoder
                // and use it instead of cacheDecoder: new FileToStreamDecoder<Z>(sourceDecoder)
                // in that case this shouldn't throw
                check("CacheDecoder", loadProvider.getCacheDecoder(),
                        "try .cacheDecoder(ResouceDecoder) or .diskCacheStrategy(NONE)");
            }
            if (diskCacheStrategy.cacheResult()) {
                check("Encoder", loadProvider.getEncoder(),
                        "try .encode(ResourceEncoder) or .diskCacheStrategy(NONE/SOURCE)");
            }
        }
    }

    private static void check(String name, Object object, String suggestion) {
        if (object == null) {
            StringBuilder message = new StringBuilder(name);
            message.append(" must not be null");
            if (suggestion != null) {
                message.append(", ");
                message.append(suggestion);
            }
            throw new NullPointerException(message.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }

    /**
     * Cancels the current load but does not release any resources held by the request and continues to display
     * the loaded resource if the load completed before the call to cancel.
     *
     * <p>
     *     Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
     * </p>
     *
     * @see #clear()
     */
    void cancel() {
        status = Status.CANCELLED;
        if (loadStatus != null) {
            loadStatus.cancel();
            loadStatus = null;
        }
    }

    /**
     * Cancels the current load if it is in progress, clears any resources held onto by the request and replaces
     * the loaded resource if the load completed with the placeholder.
     *
     * <p>
     *     Cleared requests can be restarted with a subsequent call to {@link #begin()}
     * </p>
     *
     * @see #cancel()
     */
    @Override
    public void clear() {
        Util.assertMainThread();
        if (status == Status.CLEARED) {
            return;
        }
        cancel();
        // Resource must be released before canNotifyStatusChanged is called.
        if (resource != null) {
            releaseResource(resource);
        }
        if (canNotifyStatusChanged()) {
            target.onLoadCleared(getPlaceholderDrawable());
        }
        // Must be after cancel().
        status = Status.CLEARED;
    }

    @Override
    public boolean isPaused() {
        return status == Status.PAUSED;
    }

    @Override
    public void pause() {
        clear();
        status = Status.PAUSED;
    }

    private void releaseResource(Resource resource) {
        engine.release(resource);
        this.resource = null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isRunning() {
        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isComplete() {
        return status == Status.COMPLETE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isResourceSet() {
        return isComplete();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isCancelled() {
        return status == Status.CANCELLED || status == Status.CLEARED;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    private Drawable getFallbackDrawable() {
      if (fallbackDrawable == null && fallbackResourceId > 0) {
        fallbackDrawable = context.getResources().getDrawable(fallbackResourceId);
      }
      return fallbackDrawable;
    }

    private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = model == null ? getFallbackDrawable() : null;
        if (error == null) {
          error = getErrorDrawable();
        }
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }

    private Drawable getErrorDrawable() {
        if (errorDrawable == null && errorResourceId > 0) {
            errorDrawable = context.getResources().getDrawable(errorResourceId);
        }
        return errorDrawable;
    }

    private Drawable getPlaceholderDrawable() {
        if (placeholderDrawable == null && placeholderResourceId > 0) {
            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
        }
        return placeholderDrawable;
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Failed to load model: \'" + model + "\'"));
            return;
        }
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }

    private boolean canSetResource() {
        return requestCoordinator == null || requestCoordinator.canSetImage(this);
    }

    private boolean canNotifyStatusChanged() {
        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
    }

    private boolean isFirstReadyResource() {
        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
    }

    private void notifyLoadSuccess() {
      if (requestCoordinator != null) {
        requestCoordinator.onRequestSuccess(this);
      }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void onResourceReady(Resource<?> resource) {
        if (resource == null) {
            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
                    + " inside, but instead got null."));
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            onException(new Exception("Expected to receive an object of " + transcodeClass
                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
                    + " inside Resource{" + resource + "}."
                    + (received != null ? "" : " "
                        + "To indicate failure return a null Resource object, "
                        + "rather than a Resource object containing null data.")
            ));
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't set the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady(resource, (R) received);
    }

    /**
     * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
     *
     * @param resource original {@link Resource}, never <code>null</code>
     * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
     */
    private void onResourceReady(Resource<?> resource, R result) {
        // We must call isFirstReadyResource before setting status.
        boolean isFirstResource = isFirstReadyResource();
        status = Status.COMPLETE;
        this.resource = resource;

        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstResource)) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);
            target.onResourceReady(result, animation);
        }

        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onException(Exception e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, "load failed", e);
        }

        status = Status.FAILED;
        //TODO: what if this is a thumbnail request?
        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {
            setErrorPlaceholder(e);
        }
    }

    private void logV(String message) {
        Log.v(TAG, message + " this: " + tag);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/Headers.java;<<<<<<< MINE
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 * Implementations must implement equals() and hashcode().
 */
public interface Headers {

    /** An empty Headers object that can be used if users don't want to provide headers. */
    Headers NONE = new Headers() {
        @Override
        public Map<String, String> getHeaders() {
            return Collections.emptyMap();
        }
    };

    Map<String, String> getHeaders();

}=======
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 *
 * <p> Implementations must implement equals() and hashcode(). </p>
 */
public interface Headers {

  /** An empty Headers object that can be used if users don't want to provide headers. */
  Headers NONE = new Headers() {
      @Override
      public Map<String, String> getHeaders() {
          return Collections.emptyMap();
      }
  };

  /**
   * Returns a non-null map containing a set of headers to apply to an http request.
   */
  Map<String, String> getHeaders();
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.model;

/**
 * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
 * example) to be generated in the background during the first fetch.
 *
 * <p> Implementations should implement equals() and hashcode() </p> .
 */
public interface LazyHeaderFactory {

    String buildHeader();

}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
import java.util.Map;
=======
import java.security.MessageDigest;
import java.util.Map;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
 * <p>  Users wishing to replace the class for handling URLs must register a factory using GlideUrl. </p>
=======
 * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string
 * URL, call {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache
 * key, call {@link #getCacheKey()}. </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
 * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call
 * {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache key, call
 * {@link #getCacheKey()}. </p>
 *
 * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for convenience. </p>
=======
 * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
 * convenience. </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
    public enum ImageType {
        /** GIF type. */
        GIF(true),
        /** JPG type. */
        JPEG(false),
        /** PNG type with alpha. */
        PNG_A(true),
        /** PNG type without alpha. */
        PNG(false),
        /** Unrecognized type. */
        UNKNOWN(false);
        private final boolean hasAlpha;

        ImageType(boolean hasAlpha) {
            this.hasAlpha = hasAlpha;
        }

        public boolean hasAlpha() {
            return hasAlpha;
        }
    }

    private static final int GIF_HEADER = 0x474946;
    private static final int PNG_HEADER = 0x89504E47;
    private static final int EXIF_MAGIC_NUMBER = 0xFFD8;
    // "MM".
    private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;
    // "II".
    private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;
    private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";
    private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES;
    private static final int SEGMENT_SOS = 0xDA;
    private static final int MARKER_EOI = 0xD9;
    private static final int SEGMENT_START_ID = 0xFF;
    private static final int EXIF_SEGMENT_TYPE = 0xE1;
    private static final int ORIENTATION_TAG_TYPE = 0x0112;
    private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };

    private final StreamReader streamReader;
=======
    UNKNOWN(false);
    private final boolean hasAlpha;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
    public ImageType getType() throws IOException {
        int firstTwoBytes = streamReader.getUInt16();
=======
  private byte[] getExifSegment() throws IOException {
    short segmentId, segmentType;
    int segmentLength;
    while (true) {
      segmentId = reader.getUInt8();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        // JPEG.
        if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
            return JPEG;
=======
      if (segmentId != SEGMENT_START_ID) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Unknown segmentId=" + segmentId);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;
        // PNG.
        if (firstFourBytes == PNG_HEADER) {
            // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type
            streamReader.skip(25 - 4);
            int alpha = streamReader.getByte();
            // A RGB indexed PNG can also have transparency. Better safe than sorry!
            return alpha >= 3 ? PNG_A : PNG;
        }
=======
      segmentType = reader.getUInt8();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            if (segmentType != EXIF_SEGMENT_TYPE) {
                long skipped = streamReader.skip(segmentLength);
                if (skipped != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to skip enough data"
                            + ", type: " + segmentType
                            + ", wanted to skip: " + segmentLength
                            + ", but actually skipped: " + skipped);
                    }
                    return null;
                }
            } else {
                byte[] segmentData = new byte[segmentLength];
                int read = streamReader.read(segmentData);
                if (read != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to read segment data"
                            + ", type: " + segmentType
                            + ", length: " + segmentLength
                            + ", actually read: " + read);
                    }
                    return null;
                } else {
                    return segmentData;
                }
            }
        }
    }
=======
      // We only want orientation.
      if (tagType != ORIENTATION_TAG_TYPE) {
        continue;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            // 12 is max format code.
            if (formatCode < 1 || formatCode > 12) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Got invalid format code=" + formatCode);
                }
                continue;
            }
=======
      if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
        }
        continue;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
                        + " componentCount=" + componentCount);
            }
=======
    return -1;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        public long skip(long total) throws IOException {
            if (total < 0) {
                return 0;
            }

            long toSkip = total;
            while (toSkip > 0) {
                long skipped = is.skip(toSkip);
                if (skipped > 0) {
                    toSkip -= skipped;
                } else {
                    // Skip has no specific contract as to what happens when you reach the end of
                    // the stream. To differentiate between temporarily not having more data and
                    // having finished the stream, we read a single byte when we fail to skip any
                    // amount of data.
                    int testEofByte = is.read();
                    if (testEofByte == -1) {
                        break;
                    } else {
                        toSkip--;
                    }
                }
            }
            return total - toSkip;
        }
=======
    @Override
    public short getUInt8() throws IOException {
      return (short) (is.read() & 0xFF);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        public int read(byte[] buffer) throws IOException {
            int toRead = buffer.length;
            int read;
            while (toRead > 0 && ((read = is.read(buffer, buffer.length - toRead, toRead)) != -1)) {
                toRead -= read;
            }
            return buffer.length - toRead;
        }
=======
    @Override
    public long skip(long total) throws IOException {
      if (total < 0) {
        return 0;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java;<<<<<<< MINE
    /**
     * Transforms the given {@link android.graphics.Bitmap} based on the given dimensions and returns the transformed
     * result.
     *
     * <p>
     *   The provided Bitmap, toTransform, should not be recycled or returned to the pool. Glide will automatically
     *   recycle and/or reuse toTransform if the transformation returns a different Bitmap. Similarly implementations
     *   should never recycle or return Bitmaps that are returned as the result of this method. Recycling or returning
     *   the provided and/or the returned Bitmap to the pool will lead to a variety of runtime exceptions and drawing
     *   errors. See #408 for an example. If the implementation obtains and discards intermediate Bitmaps, they may
     *   safely be returned to the BitmapPool and/or recycled.
     * </p>
     *
     * <p>
     *     outWidth and outHeight will never be {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL}, this
     *     class converts them to be the size of the Bitmap we're going to transform before calling this method.
     * </p>
     *
     * @param pool A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can be used to obtain and
     *             return intermediate {@link Bitmap}s used in this transformation. For every
     *             {@link android.graphics.Bitmap} obtained from the pool during this transformation, a
     *             {@link android.graphics.Bitmap} must also be returned.
     * @param toTransform The {@link android.graphics.Bitmap} to transform.
     * @param outWidth The ideal width of the transformed bitmap (the transformed width does not need to match exactly).
     * @param outHeight The ideal height of the transformed bitmap (the transformed heightdoes not need to match
     *                  exactly).
     */
    protected abstract Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight);
=======
  /**
   * Transforms the given {@link android.graphics.Bitmap} based on the given dimensions and returns
   * the transformed result.
   *
   * <p> outWidth and outHeight will never be
   * {@link com.bumptech.glide.request.target.Target#SIZE_ORIGINAL},
   * this class converts them to be the size of the Bitmap we're going to transform before calling
   * this method. </p>
   *
   * @param pool        A {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool} that can
   *                    be used to obtain and return intermediate {@link Bitmap}s used in this
   *                    transformation. For every {@link android.graphics.Bitmap} obtained from the
   *                    pool during this transformation, a {@link android.graphics.Bitmap} must also
   *                    be returned.
   * @param toTransform The {@link android.graphics.Bitmap} to transform.
   * @param outWidth    The ideal width of the transformed bitmap (the transformed width does not
   *                    need to match exactly).
   * @param outHeight   The ideal height of the transformed bitmap (the transformed heightdoes not
   *                    need to match exactly).
   */
  protected abstract Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth,
      int outHeight);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java;<<<<<<< MINE
    private static final String TAG = "TransformationUtils";
    public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
=======
  private static final String TAG = "TransformationUtils";
  public static final int PAINT_FLAGS = Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    /**
     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that the smallest edge of the
     * image will be between 1x and 2x the requested size. The larger edge has no maximum size.
     */
    public static final Downsampler AT_LEAST = new Downsampler() {
        @Override
        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
            return Math.min(inHeight / outHeight, inWidth / outWidth);
        }

        @Override
        public String getId() {
            return "AT_LEAST.com.bumptech.glide.load.data.bitmap";
        }
    };

    /**
     * Load and scale the image uniformly (maintaining the image's aspect ratio) so that largest edge of the image
     * will be between 1/2x and 1x of the requested size. The smaller edge has no minimum size.
     */
    public static final Downsampler AT_MOST = new Downsampler() {
        @Override
        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
            int maxIntegerFactor = (int) Math.ceil(Math.max(inHeight / (float) outHeight,
                inWidth / (float) outWidth));
            int lesserOrEqualSampleSize = Math.max(1, Integer.highestOneBit(maxIntegerFactor));
            return lesserOrEqualSampleSize << (lesserOrEqualSampleSize < maxIntegerFactor ? 1 : 0);
        }

        @Override
        public String getId() {
            return "AT_MOST.com.bumptech.glide.load.data.bitmap";
        }
    };

    /**
     * Load the image at its original size.
     */
    public static final Downsampler NONE = new Downsampler() {
        @Override
        protected int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight) {
            return 0;
        }

        @Override
        public String getId() {
            return "NONE.com.bumptech.glide.load.data.bitmap";
        }
    };

    // 5MB. This is the max image header size we can handle, we preallocate a much smaller buffer but will resize up to
    // this amount if necessary.
    private static final int MARK_POSITION = 5 * 1024 * 1024;


    /**
     * Load the image for the given InputStream. If a recycled Bitmap whose dimensions exactly match those of the image
     * for the given InputStream is available, the operation is much less expensive in terms of memory.
     *
     * <p>
     *     Note - this method will throw an exception of a Bitmap with dimensions not matching
     *     those of the image for the given InputStream is provided.
     * </p>
     *
     * @param is An {@link InputStream} to the data for the image.
     * @param pool A pool of recycled bitmaps.
     * @param outWidth The width the final image should be close to.
     * @param outHeight The height the final image should be close to.
     * @return A new bitmap containing the image from the given InputStream, or recycle if recycle is not null.
     */
    @SuppressWarnings("resource")
    // see BitmapDecoder.decode
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    public Bitmap decode(InputStream is, BitmapPool pool, int outWidth, int outHeight, DecodeFormat decodeFormat) {
        final ByteArrayPool byteArrayPool = ByteArrayPool.get();
        final byte[] bytesForOptions = byteArrayPool.getBytes();
        final byte[] bytesForStream = byteArrayPool.getBytes();
        final BitmapFactory.Options options = getDefaultOptions();

        // Use to fix the mark limit to avoid allocating buffers that fit entire images.
        RecyclableBufferedInputStream bufferedStream = new RecyclableBufferedInputStream(
                is, bytesForStream);
        // Use to retrieve exceptions thrown while reading.
        // TODO(#126): when the framework no longer returns partially decoded Bitmaps or provides a way to determine
        // if a Bitmap is partially decoded, consider removing.
        ExceptionCatchingInputStream exceptionStream =
                ExceptionCatchingInputStream.obtain(bufferedStream);
        // Use to read data.
        // Ensures that we can always reset after reading an image header so that we can still attempt to decode the
        // full image even when the header decode fails and/or overflows our read buffer. See #283.
        MarkEnforcingInputStream invalidatingStream = new MarkEnforcingInputStream(exceptionStream);
        try {
            exceptionStream.mark(MARK_POSITION);
            int orientation = 0;
            try {
                orientation = new ImageHeaderParser(exceptionStream).getOrientation();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot determine the image orientation from header", e);
                }
            } finally {
                try {
                    exceptionStream.reset();
                } catch (IOException e) {
                    if (Log.isLoggable(TAG, Log.WARN)) {
                        Log.w(TAG, "Cannot reset the input stream", e);
                    }
                }
            }

            options.inTempStorage = bytesForOptions;

            final int[] inDimens = getDimensions(invalidatingStream, bufferedStream, options);
            final int inWidth = inDimens[0];
            final int inHeight = inDimens[1];

            final int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
            final int sampleSize = getRoundedSampleSize(degreesToRotate, inWidth, inHeight, outWidth, outHeight);

            final Bitmap downsampled =
                    downsampleWithSize(invalidatingStream, bufferedStream, options, pool, inWidth, inHeight, sampleSize,
                            decodeFormat);

            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch
            // and log a stack trace but still return a non null bitmap. To avoid displaying partially decoded bitmaps,
            // we catch exceptions reading from the stream in our ExceptionCatchingInputStream and throw them here.
            final Exception streamException = exceptionStream.getException();
            if (streamException != null) {
                throw new RuntimeException(streamException);
            }

            Bitmap rotated = null;
            if (downsampled != null) {
                rotated = TransformationUtils.rotateImageExif(downsampled, pool, orientation);

                if (!downsampled.equals(rotated) && !pool.put(downsampled)) {
                    downsampled.recycle();
                }
            }

            return rotated;
        } finally {
            byteArrayPool.releaseBytes(bytesForOptions);
            byteArrayPool.releaseBytes(bytesForStream);
            exceptionStream.release();
            releaseOptions(options);
        }
    }

    private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? inHeight : outHeight;
        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? inWidth : outWidth;

        final int exactSampleSize;
        if (degreesToRotate == 90 || degreesToRotate == 270) {
            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
            // decreased to near our target's height and the image height is decreased to near our target width.
            //noinspection SuspiciousNameCombination
            exactSampleSize = getSampleSize(inHeight, inWidth, targetWidth, targetHeight);
        } else {
            exactSampleSize = getSampleSize(inWidth, inHeight, targetWidth, targetHeight);
        }

        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
        // http://stackoverflow.com/a/17379704/800716.
        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);

        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
        return Math.max(1, powerOfTwoSampleSize);
    }

    private Bitmap downsampleWithSize(MarkEnforcingInputStream is, RecyclableBufferedInputStream  bufferedStream,
            BitmapFactory.Options options, BitmapPool pool, int inWidth, int inHeight, int sampleSize,
            DecodeFormat decodeFormat) {
        // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
        Bitmap.Config config = getConfig(is, decodeFormat);
        options.inSampleSize = sampleSize;
        options.inPreferredConfig = config;
        if ((options.inSampleSize == 1 || Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) && shouldUsePool(is)) {
            int targetWidth = (int) Math.ceil(inWidth / (double) sampleSize);
            int targetHeight = (int) Math.ceil(inHeight / (double) sampleSize);
            // BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.
            setInBitmap(options, pool.getDirty(targetWidth, targetHeight, config));
        }
        return decodeStream(is, bufferedStream, options);
    }

    private static boolean shouldUsePool(InputStream is) {
        // On KitKat+, any bitmap can be used to decode any other bitmap.
        if (Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT) {
            return true;
        }

        is.mark(1024);
        try {
            final ImageHeaderParser.ImageType type = new ImageHeaderParser(is).getType();
            // cannot reuse bitmaps when decoding images that are not PNG or JPG.
            // look at : https://groups.google.com/forum/#!msg/android-developers/Mp0MFVFi1Fo/e8ZQ9FGdWdEJ
            return TYPES_THAT_USE_POOL.contains(type);
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine the image type from header", e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }
        return false;
    }

    @SuppressWarnings("deprecation")
    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }

        boolean hasAlpha = false;
        // We probably only need 25, but this is safer (particularly since the buffer size is > 1024).
        is.mark(1024);
        try {
            hasAlpha = new ImageHeaderParser(is).hasAlpha();
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);
            }
        } finally {
            try {
                is.reset();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Cannot reset the input stream", e);
                }
            }
        }

        return hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
    }

    /**
     * Determine the amount of downsampling to use for a load given the dimensions of the image to be downsampled and
     * the dimensions of the view/target the image will be displayed in.
     *
     * @see android.graphics.BitmapFactory.Options#inSampleSize
     *
     * @param inWidth The width in pixels of the image to be downsampled.
     * @param inHeight The height in piexels of the image to be downsampled.
     * @param outWidth The width in pixels of the view/target the image will be displayed in.
     * @param outHeight The height in pixels of the view/target the imag will be displayed in.
     * @return An integer to pass in to {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
     *          android.graphics.BitmapFactory.Options)}.
     */
    protected abstract int getSampleSize(int inWidth, int inHeight, int outWidth, int outHeight);

    /**
     * A method for getting the dimensions of an image from the given InputStream.
     *
     * @param is The InputStream representing the image.
     * @param options The options to pass to
     *          {@link BitmapFactory#decodeStream(java.io.InputStream, android.graphics.Rect,
     *              android.graphics.BitmapFactory.Options)}.
     * @return an array containing the dimensions of the image in the form {width, height}.
     */
    public int[] getDimensions(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
            BitmapFactory.Options options) {
        options.inJustDecodeBounds = true;
        decodeStream(is, bufferedStream, options);
        options.inJustDecodeBounds = false;
        return new int[] { options.outWidth, options.outHeight };
    }

    private static Bitmap decodeStream(MarkEnforcingInputStream is, RecyclableBufferedInputStream bufferedStream,
            BitmapFactory.Options options) {
         if (options.inJustDecodeBounds) {
             // This is large, but jpeg headers are not size bounded so we need something large enough to minimize
             // the possibility of not being able to fit enough of the header in the buffer to get the image size so
             // that we don't fail to load images. The BufferedInputStream will create a new buffer of 2x the
             // original size each time we use up the buffer space without passing the mark so this is a maximum
             // bound on the buffer size, not a default. Most of the time we won't go past our pre-allocated 16kb.
             is.mark(MARK_POSITION);
         } else {
             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid
             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our
             // current buffer size here. See issue #225.
             bufferedStream.fixMarkLimit();
         }

        final Bitmap result = BitmapFactory.decodeStream(is, null, options);

        try {
            if (options.inJustDecodeBounds) {
                is.reset();
            }
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception loading inDecodeBounds=" + options.inJustDecodeBounds
                        + " sample=" + options.inSampleSize, e);
            }
        }

        return result;
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static void setInBitmap(BitmapFactory.Options options, Bitmap recycled) {
        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
            options.inBitmap = recycled;
        }
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static synchronized BitmapFactory.Options getDefaultOptions() {
        BitmapFactory.Options decodeBitmapOptions;
        synchronized (OPTIONS_QUEUE) {
            decodeBitmapOptions = OPTIONS_QUEUE.poll();
        }
        if (decodeBitmapOptions == null) {
            decodeBitmapOptions = new BitmapFactory.Options();
            resetOptions(decodeBitmapOptions);
        }

        return decodeBitmapOptions;
    }

    private static void releaseOptions(BitmapFactory.Options decodeBitmapOptions) {
        resetOptions(decodeBitmapOptions);
        synchronized (OPTIONS_QUEUE) {
            OPTIONS_QUEUE.offer(decodeBitmapOptions);
        }
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    private static void resetOptions(BitmapFactory.Options decodeBitmapOptions) {
        decodeBitmapOptions.inTempStorage = null;
        decodeBitmapOptions.inDither = false;
        decodeBitmapOptions.inScaled = false;
        decodeBitmapOptions.inSampleSize = 1;
        decodeBitmapOptions.inPreferredConfig = null;
        decodeBitmapOptions.inJustDecodeBounds = false;
        decodeBitmapOptions.outWidth = 0;
        decodeBitmapOptions.outHeight = 0;
        decodeBitmapOptions.outMimeType = null;

        if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT)  {
            decodeBitmapOptions.inBitmap = null;
            decodeBitmapOptions.inMutable = true;
        }
=======
    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) throws IOException {
      // Do nothing.
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {

    public InternalCacheDiskCacheFactory(Context context) {
        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
=======
public final class InternalCacheDiskCacheFactory implements DiskCache.Factory {
  private final Context context;
  private final String diskCacheName;
  private final int diskCacheSize;

  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
    this(context, null /*diskCacheName*/, diskCacheSize);
  }

  public InternalCacheDiskCacheFactory(Context context, String diskCacheName, int diskCacheSize) {
    this.context = context;
    this.diskCacheName = diskCacheName;
    this.diskCacheSize = diskCacheSize;
  }

  @Override
  public DiskCache build() {
    DiskCache diskCache = null;
    final File cacheDir;

    if (diskCacheName != null) {
      cacheDir = Glide.getPhotoCacheDir(context, diskCacheName);
    } else {
      cacheDir = Glide.getPhotoCacheDir(context);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
    public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
=======
    if (cacheDir != null) {
      diskCache = DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
    public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName, int diskCacheSize) {
        super(new CacheDirectoryGetter() {
            @Override
            public File getCacheDirectory() {
                File cacheDirectory = context.getCacheDir();
                if (cacheDirectory == null) {
                    return null;
                }
                if (diskCacheName != null) {
                    return new File(cacheDirectory, diskCacheName);
                }
                return cacheDirectory;
            }
        }, diskCacheSize);
=======
    if (diskCache == null) {
      diskCache = new DiskCacheAdapter();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java;<<<<<<< MINE
    @Override
    public File get(Key key) {
        // no op, default for overriders
        return null;
    }

    @Override
    public void put(Key key, Writer writer) {
        // no op, default for overriders
    }

    @Override
    public void delete(Key key) {
        // no op, default for overriders
    }

    @Override
    public void clear() {
        // no op, default for overriders
    }
=======
  @Override
  public File get(Key key) {
    // no op, default for overriders
    return null;
  }

  @Override
  public void put(Key key, Writer writer) {
    // no op, default for overriders
  }

  @Override
  public void delete(Key key) {
    // no op, default for overriders
  }

  @Override
  public void clear() {
      // no op, default for overriders
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    private static final int APP_VERSION = 1;
    private static final int VALUE_COUNT = 1;
    private static DiskLruCacheWrapper wrapper = null;

    private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
    private final SafeKeyGenerator safeKeyGenerator;
    private final File directory;
    private final int maxSize;
    private DiskLruCache diskLruCache;

    /**
     * Get a DiskCache in the given directory and size. If a disk cache has alread been created with
     * a different directory and/or size, it will be returned instead and the new arguments
     * will be ignored.
     *
     * @param directory The directory for the disk cache
     * @param maxSize The max size for the disk cache
     * @return The new disk cache with the given arguments, or the current cache if one already exists
     */
    public static synchronized DiskCache get(File directory, int maxSize) {
        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!
        if (wrapper == null) {
            wrapper = new DiskLruCacheWrapper(directory, maxSize);
=======
  private static final int APP_VERSION = 1;
  private static final int VALUE_COUNT = 1;
  private static DiskLruCacheWrapper wrapper = null;

  private final SafeKeyGenerator safeKeyGenerator;
  private final File directory;
  private final int maxSize;
  private final DiskCacheWriteLocker writeLocker = new DiskCacheWriteLocker();
  private DiskLruCache diskLruCache;

  /**
   * Get a DiskCache in the given directory and size. If a disk cache has already been created with
   * a different directory and/or size, it will be returned instead and the new arguments will be
   * ignored.
   *
   * @param directory The directory for the disk cache
   * @param maxSize   The max size for the disk cache
   * @return The new disk cache with the given arguments, or the current cache if one already exists
   */
  public static synchronized DiskCache get(File directory, int maxSize) {
    // TODO calling twice with different arguments makes it return the cache for the same
    // directory, it's public!
    if (wrapper == null) {
      wrapper = new DiskLruCacheWrapper(directory, maxSize);
    }
    return wrapper;
  }

  protected DiskLruCacheWrapper(File directory, int maxSize) {
    this.directory = directory;
    this.maxSize = maxSize;
    this.safeKeyGenerator = new SafeKeyGenerator();
  }

  private synchronized DiskLruCache getDiskCache() throws IOException {
    if (diskLruCache == null) {
      diskLruCache = DiskLruCache.open(directory, APP_VERSION, VALUE_COUNT, maxSize);
    }
    return diskLruCache;
  }

  @Override
  public File get(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, "Get: Obtained: " + safeKey + " for for Key: " + key);
    }
    File result = null;
    try {
      // It is possible that the there will be a put in between these two gets. If so that shouldn't
      // be a problem because we will always put the same value at the same key so our input streams
      // will still represent the same data.
      final DiskLruCache.Value value = getDiskCache().get(safeKey);
      if (value != null) {
        result = value.getFile(0);
      }
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to get from disk cache", e);
      }
    }
    return result;
  }

  @Override
  public void put(Key key, Writer writer) {
    // We want to make sure that puts block so that data is available when put completes. We may
    // actually not write any data if we find that data is written by the time we acquire the lock.
    writeLocker.acquire(key);
    try {
      String safeKey = safeKeyGenerator.getSafeKey(key);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
      }
      try {
        // We assume we only need to put once, so if data was written while we were trying to get
        // the lock, we can simply abort.
        DiskLruCache diskCache = getDiskCache();
        Value current = diskCache.get(safeKey);
        if (current != null) {
          return;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
        return diskLruCache;
    }

    private synchronized void resetDiskCache() {
        diskLruCache = null;
    }

    @Override
    public File get(Key key) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        File result = null;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
        return result;
    }

    @Override
    public void put(Key key, Writer writer) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        writeLocker.acquire(key);
        try {
            DiskLruCache.Editor editor = getDiskCache().edit(safeKey);
            // Editor will be null if there are two concurrent puts. In the worst case we will just silently fail.
            if (editor != null) {
                try {
                    File file = editor.getFile(0);
                    if (writer.write(file)) {
                        editor.commit();
                    }
                } finally {
                    editor.abortUnlessCommitted();
                }
            }
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to put to disk cache", e);
            }
        } finally {
            writeLocker.release(key);
        }
    }

    @Override
    public void delete(Key key) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        try {
            getDiskCache().remove(safeKey);
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to delete from disk cache", e);
            }
=======
      } catch (IOException e) {
        if (Log.isLoggable(TAG, Log.WARN)) {
          Log.w(TAG, "Unable to put to disk cache", e);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    }

    @Override
    public synchronized void clear() {
        try {
            getDiskCache().delete();
            resetDiskCache();
        }  catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to clear disk cache", e);
            }
        }
    }
=======
      }
    } finally {
      writeLocker.release(key);
    }
  }

  @Override
  public void delete(Key key) {
    String safeKey = safeKeyGenerator.getSafeKey(key);
    try {
      getDiskCache().remove(safeKey);
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to delete from disk cache", e);
      }
    }
  }

  @Override
  public synchronized void clear() {
    try {
      getDiskCache().delete();
      resetDiskCache();
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to clear disk cache", e);
      }
    }
  }

  private synchronized void resetDiskCache() {
    diskLruCache = null;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java;<<<<<<< MINE
    interface Factory {

        /** 250 MB of cache. */
        int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
        String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";

        /**
         * Returns a new disk cache, or {@code null} if no disk cache could be created.
         */
        DiskCache build();
    }
=======
    DiskCache build();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java;<<<<<<< MINE
    /**
     * Write to a key in the cache. {@link Writer} is used so that the cache implementation can perform actions after
     * the write finishes, like commit (via atomic file rename).
     *
     * @param key The key to write to.
     * @param writer An interface that will write data given an OutputStream for the key.
     */
    void put(Key key, Writer writer);

    /**
     * Remove the key and value from the cache.
     *
     * @param key The key to remove.
     */
    void delete(Key key);

    /**
     * Clear the cache.
     */
    void clear();
=======
  /**
   * Get the cache for the value at the given key.
   *
   * <p> Note - This is potentially dangerous, someone may write a new value to the file at any
   * point in time and we won't know about it. </p>
   *
   * @param key The key in the cache.
   * @return An InputStream representing the data at key at the time get is called.
   */
  File get(Key key);

  /**
   * Write to a key in the cache. {@link Writer} is used so that the cache implementation can
   * perform actions after the write finishes, like commit (via atomic file rename).
   *
   * @param key    The key to write to.
   * @param writer An interface that will write data given an OutputStream for the key.
   */
  void put(Key key, Writer writer);

  /**
   * Remove the key and value from the cache.
   *
   * @param key The key to remove.
   */
  void delete(Key key);

  /**
   * Clear the cache.
   */
  void clear();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java;<<<<<<< MINE
    private static final String EMPTY_LOG_STRING = "";
    private final String id;
    private final int width;
    private final int height;
    private final ResourceDecoder cacheDecoder;
    private final ResourceDecoder decoder;
    private final Transformation transformation;
    private final ResourceEncoder encoder;
    private final ResourceTranscoder transcoder;
    private final Encoder sourceEncoder;
    private final Key signature;
    private String stringKey;
    private int hashCode;
    private Key originalKey;

    public EngineKey(String id, Key signature, int width, int height, ResourceDecoder cacheDecoder,
            ResourceDecoder decoder, Transformation transformation, ResourceEncoder encoder,
            ResourceTranscoder transcoder, Encoder sourceEncoder) {
        this.id = id;
        this.signature = signature;
        this.width = width;
        this.height = height;
        this.cacheDecoder = cacheDecoder;
        this.decoder = decoder;
        this.transformation = transformation;
        this.encoder = encoder;
        this.transcoder = transcoder;
        this.sourceEncoder = sourceEncoder;
    }

    public Key getOriginalKey() {
        if (originalKey == null) {
            originalKey = new OriginalKey(id, signature);
        }
        return originalKey;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }

        EngineKey engineKey = (EngineKey) o;

        if (!id.equals(engineKey.id)) {
            return false;
        } else if (!signature.equals(engineKey.signature)) {
            return false;
        } else if (height != engineKey.height) {
            return false;
        } else if (width != engineKey.width) {
            return false;
        } else if (transformation == null ^ engineKey.transformation == null) {
            return false;
        } else if (transformation != null && !transformation.getId().equals(engineKey.transformation.getId())) {
            return false;
        } else if (decoder == null ^ engineKey.decoder == null) {
            return false;
        } else if (decoder != null && !decoder.getId().equals(engineKey.decoder.getId())) {
            return false;
        } else if (cacheDecoder == null ^ engineKey.cacheDecoder == null) {
            return false;
        } else if (cacheDecoder != null && !cacheDecoder.getId().equals(engineKey.cacheDecoder.getId())) {
            return false;
        } else if (encoder == null ^ engineKey.encoder == null) {
            return false;
        } else if (encoder != null && !encoder.getId().equals(engineKey.encoder.getId())) {
            return false;
        } else if (transcoder == null ^ engineKey.transcoder == null) {
            return false;
        } else if (transcoder != null && !transcoder.getId().equals(engineKey.transcoder.getId())) {
            return false;
        } else if (sourceEncoder == null ^ engineKey.sourceEncoder == null) {
            return false;
        } else if (sourceEncoder != null && !sourceEncoder.getId().equals(engineKey.sourceEncoder.getId())) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        if (hashCode == 0) {
            hashCode = id.hashCode();
            hashCode = 31 * hashCode + signature.hashCode();
            hashCode = 31 * hashCode + width;
            hashCode = 31 * hashCode + height;
            hashCode = 31 * hashCode + (cacheDecoder   != null ? cacheDecoder  .getId().hashCode() : 0);
            hashCode = 31 * hashCode + (decoder        != null ? decoder       .getId().hashCode() : 0);
            hashCode = 31 * hashCode + (transformation != null ? transformation.getId().hashCode() : 0);
            hashCode = 31 * hashCode + (encoder        != null ? encoder       .getId().hashCode() : 0);
            hashCode = 31 * hashCode + (transcoder     != null ? transcoder    .getId().hashCode() : 0);
            hashCode = 31 * hashCode + (sourceEncoder  != null ? sourceEncoder .getId().hashCode() : 0);
        }
        return hashCode;
    }

    @Override
    public String toString() {
        if (stringKey == null) {
            stringKey = new StringBuilder()
                .append("EngineKey{")
                .append(id)
                .append('+')
                .append(signature)
                .append("+[")
                .append(width)
                .append('x')
                .append(height)
                .append("]+")
                .append('\'')
                .append(cacheDecoder   != null ? cacheDecoder  .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(decoder        != null ? decoder       .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(transformation != null ? transformation.getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(encoder        != null ? encoder       .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(transcoder     != null ? transcoder    .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(sourceEncoder  != null ? sourceEncoder .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('}')
                .toString();
        }
        return stringKey;
    }

    @Override
    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {
        byte[] dimensions = ByteBuffer.allocate(8)
                .putInt(width)
                .putInt(height)
                .array();
        signature.updateDiskCacheKey(messageDigest);
        messageDigest.update(id.getBytes(STRING_CHARSET_NAME));
        messageDigest.update(dimensions);
        messageDigest.update((cacheDecoder   != null ? cacheDecoder  .getId() : "").getBytes(STRING_CHARSET_NAME));
        messageDigest.update((decoder        != null ? decoder       .getId() : "").getBytes(STRING_CHARSET_NAME));
        messageDigest.update((transformation != null ? transformation.getId() : "").getBytes(STRING_CHARSET_NAME));
        messageDigest.update((encoder        != null ? encoder       .getId() : "").getBytes(STRING_CHARSET_NAME));
        // The Transcoder is not included in the disk cache key because its result is not cached.
        messageDigest.update((sourceEncoder  != null ? sourceEncoder .getId() : "").getBytes(STRING_CHARSET_NAME));
    }
=======
  private final Object model;
  private final int width;
  private final int height;
  private final Class<?> resourceClass;
  private final Class<?> transcodeClass;
  private final Key signature;
  private final Map<Class<?>, Transformation<?>> transformations;
  private final Options options;
  private int hashCode;

  public EngineKey(Object model, Key signature, int width, int height,
      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,
      Class<?> transcodeClass, Options options) {
    this.model = Preconditions.checkNotNull(model);
    this.signature = Preconditions.checkNotNull(signature, "Signature must not be null");
    this.width = width;
    this.height = height;
    this.transformations = Preconditions.checkNotNull(transformations);
    this.resourceClass =
        Preconditions.checkNotNull(resourceClass, "Resource class must not be null");
    this.transcodeClass =
        Preconditions.checkNotNull(transcodeClass, "Transcode class must not be null");
    this.options = Preconditions.checkNotNull(options);
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof EngineKey) {
      EngineKey other = (EngineKey) o;
      return model.equals(other.model)
          && signature.equals(other.signature)
          && height == other.height
          && width == other.width
          && transformations.equals(other.transformations)
          && resourceClass.equals(other.resourceClass)
          && transcodeClass.equals(other.transcodeClass)
          && options.equals(other.options);
    }
    return false;
  }

  @Override
  public int hashCode() {
    if (hashCode == 0) {
      hashCode = model.hashCode();
      hashCode = 31 * hashCode + signature.hashCode();
      hashCode = 31 * hashCode + width;
      hashCode = 31 * hashCode + height;
      hashCode = 31 * hashCode + transformations.hashCode();
      hashCode = 31 * hashCode + resourceClass.hashCode();
      hashCode = 31 * hashCode + transcodeClass.hashCode();
      hashCode = 31 * hashCode + options.hashCode();
    }
    return hashCode;
  }

  @Override
  public String toString() {
    return "EngineKey{"
        + "model=" + model
        + ", width=" + width
        + ", height=" + height
        + ", resourceClass=" + resourceClass
        + ", transcodeClass=" + transcodeClass
        + ", signature=" + signature
        + ", hashCode=" + hashCode
        + ", transformations=" + transformations
        + ", options=" + options
        + '}';
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    throw new UnsupportedOperationException();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
=======
import android.util.Log;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
import com.bumptech.glide.util.ContentLengthInputStream;
=======
import com.bumptech.glide.util.ContentLengthInputStream;
import com.bumptech.glide.util.LogTime;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
=======
import java.util.Map;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
    private static final String TAG = "HttpUrlFetcher";
    private static final String ENCODING_HEADER = "Accept-Encoding";
    private static final String DEFAULT_ENCODING = "identity";
    private static final int MAXIMUM_REDIRECTS = 5;
    private static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultHttpUrlConnectionFactory();

    private final GlideUrl glideUrl;
    private final HttpUrlConnectionFactory connectionFactory;

    private HttpURLConnection urlConnection;
    private InputStream stream;
    private volatile boolean isCancelled;

    public HttpUrlFetcher(GlideUrl glideUrl) {
        this(glideUrl, DEFAULT_CONNECTION_FACTORY);
    }

    // Visible for testing.
    HttpUrlFetcher(GlideUrl glideUrl, HttpUrlConnectionFactory connectionFactory) {
        this.glideUrl = glideUrl;
        this.connectionFactory = connectionFactory;
    }

    @Override
    public InputStream loadData(Priority priority) throws Exception {
        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
    }

    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)
            throws IOException {
        if (redirects >= MAXIMUM_REDIRECTS) {
            throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
        } else {
            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
            try {
                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
                    throw new IOException("In re-direct loop");
                }
            } catch (URISyntaxException e) {
                // Do nothing, this is best effort.
            }
        }
        urlConnection = connectionFactory.build(url);
        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
        }
        // Do our best to avoid gzip since it's both inefficient for images and also makes it more
        // difficult for us to detect and prevent partial content rendering. See #440.
        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {
            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);
        }
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);
        urlConnection.setDoInput(true);

        // Connect explicitly to avoid errors in decoders if connection fails.
        urlConnection.connect();
        if (isCancelled) {
            return null;
        }
        final int statusCode = urlConnection.getResponseCode();
        if (statusCode / 100 == 2) {
            return getStreamForSuccessfulRequest(urlConnection);
        } else if (statusCode / 100 == 3) {
            String redirectUrlString = urlConnection.getHeaderField("Location");
            if (TextUtils.isEmpty(redirectUrlString)) {
                throw new IOException("Received empty or null redirect url");
            }
            URL redirectUrl = new URL(url, redirectUrlString);
            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
        } else {
            if (statusCode == -1) {
                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
            }
            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
        }
    }
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private static final int MAXIMUM_REDIRECTS = 5;
  private static final int DEFAULT_TIMEOUT_MS = 2500;
  // Visible for testing.
  static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
      new DefaultHttpUrlConnectionFactory();

  private final GlideUrl glideUrl;
  private final int timeout;
  private final HttpUrlConnectionFactory connectionFactory;

  private HttpURLConnection urlConnection;
  private InputStream stream;
  private volatile boolean isCancelled;

  public HttpUrlFetcher(GlideUrl glideUrl) {
    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
  }

  // Visible for testing.
  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
    this.glideUrl = glideUrl;
    this.timeout = timeout;
    this.connectionFactory = connectionFactory;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    long startTime = LogTime.getLogTime();
    InputStream result = null;
    try {
      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
          glideUrl.getHeaders());
    } catch (IOException e) {
      if (Logs.isEnabled(Log.DEBUG)) {
        Logs.log(Log.DEBUG, "Failed to load data for url", e);
      }
    }
    if (Logs.isEnabled(Log.VERBOSE)) {
      Logs.log(Log.VERBOSE, "Finished http url fetcher fetch in "
          + LogTime.getElapsedMillis(startTime) + " ms and loaded "  + result);
    }
    callback.onDataReady(result);
  }

  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
            throw new IOException("In re-direct loop");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      String contentLength = urlConnection.getHeaderField(CONTENT_LENGTH_HEADER);
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
      return stream;
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField("Location");
      if (TextUtils.isEmpty(redirectUrlString)) {
          throw new IOException("Received empty or null redirect url");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else {
      if (statusCode == -1) {
          throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
      }
      throw new IOException("Request failed " + statusCode + ": "
          + urlConnection.getResponseMessage());
    }
  }

  @Override
  public void cleanup() {
    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }
    if (urlConnection != null) {
      urlConnection.disconnect();
    }
  }

  @Override
  public void cancel() {
    // TODO: we should consider disconnecting the url connection here, but we can't do so
    // directly because cancel is often called on the main thread.
    isCancelled = true;
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  interface HttpUrlConnectionFactory {
    HttpURLConnection build(URL url) throws IOException;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
            throws IOException {
        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
            int contentLength = urlConnection.getContentLength();
            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
        } else {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());
            }
            stream = urlConnection.getInputStream();
        }
        return stream;
    }

=======
  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
    public void cleanup() {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignore
            }
        }
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
    }

    @Override
    public String getId() {
        return glideUrl.getCacheKey();
    }

    @Override
    public void cancel() {
        // TODO: we should consider disconnecting the url connection here, but we can't do so directly because cancel is
        // often called on the main thread.
        isCancelled = true;
    }

    interface HttpUrlConnectionFactory {
        HttpURLConnection build(URL url) throws IOException;
    }

    private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
        @Override
        public HttpURLConnection build(URL url) throws IOException {
            return (HttpURLConnection) url.openConnection();
        }
=======
    public HttpURLConnection build(URL url) throws IOException {
      return (HttpURLConnection) url.openConnection();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.MediaStore;
import android.text.TextUtils;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

/**
 * A DataFetcher that retrieves an {@link java.io.InputStream} for a local Uri that may or may not be for a resource
 * in the media store. If the local Uri is for a resource in the media store and the size requested is less than or
 * equal to the media store thumbnail size, preferentially attempts to fetch data for the pre-generated media store
 * thumbs using {@link android.provider.MediaStore.Images.Thumbnails} and
 * {@link android.provider.MediaStore.Video.Thumbnails}.
 */
public class MediaStoreThumbFetcher implements DataFetcher<InputStream> {
    private static final String TAG = "MediaStoreThumbFetcher";
    private static final int MINI_WIDTH = 512;
    private static final int MINI_HEIGHT = 384;
    private static final ThumbnailStreamOpenerFactory DEFAULT_FACTORY = new ThumbnailStreamOpenerFactory();

    private final Context context;
    private final Uri mediaStoreUri;
    private final DataFetcher<InputStream> defaultFetcher;
    private final int width;
    private final int height;
    private final ThumbnailStreamOpenerFactory factory;
    private InputStream inputStream;

    public MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher,
            int width, int height) {
        this(context, mediaStoreUri, defaultFetcher, width, height, DEFAULT_FACTORY);
    }

    MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher, int width,
            int height, ThumbnailStreamOpenerFactory factory) {
        this.context = context;
        this.mediaStoreUri = mediaStoreUri;
        this.defaultFetcher = defaultFetcher;
        this.width = width;
        this.height = height;
        this.factory = factory;
    }

    @Override
    public InputStream loadData(Priority priority) throws Exception {
        ThumbnailStreamOpener fetcher = factory.build(mediaStoreUri, width, height);

        if (fetcher != null) {
            inputStream = openThumbInputStream(fetcher);
        }

        if (inputStream == null) {
            inputStream = defaultFetcher.loadData(priority);
        }

        return inputStream;
    }

    private InputStream openThumbInputStream(ThumbnailStreamOpener fetcher) {
        InputStream result = null;
        try {
            result = fetcher.open(context, mediaStoreUri);
        } catch (FileNotFoundException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Failed to find thumbnail file", e);
            }
        }

        int orientation = -1;
        if (result != null) {
            orientation = fetcher.getOrientation(context, mediaStoreUri);
        }

        if (orientation != -1) {
            result = new ExifOrientationStream(result, orientation);
        }
        return result;
    }

    @Override
    public void cleanup() {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                // Do nothing.
            }
        }
        defaultFetcher.cleanup();
    }

    @Override
    public String getId() {
        return mediaStoreUri.toString();
    }

    @Override
    public void cancel() {
        // Do nothing.
    }

    private static boolean isMediaStoreUri(Uri uri) {
        return uri != null
                && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
                && MediaStore.AUTHORITY.equals(uri.getAuthority());
    }

    private static boolean isMediaStoreVideo(Uri uri) {
        return isMediaStoreUri(uri) && uri.getPathSegments().contains("video");
    }

    static class FileService {
        public boolean exists(File file) {
            return file.exists();
        }

        public long length(File file) {
            return file.length();
        }

        public File get(String path) {
            return new File(path);
        }
    }

    interface ThumbnailQuery {
        Cursor queryPath(Context context, Uri uri);
    }

    static class ThumbnailStreamOpener {
        private static final FileService DEFAULT_SERVICE = new FileService();
        private final FileService service;
        private ThumbnailQuery query;

        public ThumbnailStreamOpener(ThumbnailQuery query) {
            this(DEFAULT_SERVICE, query);
        }

        public ThumbnailStreamOpener(FileService service, ThumbnailQuery query) {
            this.service = service;
            this.query = query;
        }

        public int getOrientation(Context context, Uri uri) {
            int orientation = -1;
            InputStream is = null;
            try {
                is = context.getContentResolver().openInputStream(uri);
                orientation = new ImageHeaderParser(is).getOrientation();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Failed to open uri: " + uri, e);
                }
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        // Ignored.
                    }
                }
            }
            return orientation;
        }

        public InputStream open(Context context, Uri uri) throws FileNotFoundException {
            Uri thumbnailUri = null;
            InputStream inputStream = null;

            final Cursor cursor = query.queryPath(context, uri);
            try {
                if (cursor != null && cursor.moveToFirst()) {
                    thumbnailUri = parseThumbUri(cursor);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            if (thumbnailUri != null) {
                inputStream = context.getContentResolver().openInputStream(thumbnailUri);
            }
            return inputStream;
        }

        private Uri parseThumbUri(Cursor cursor) {
            Uri result = null;
            String path = cursor.getString(0);
            if (!TextUtils.isEmpty(path)) {
                File file = service.get(path);
                if (service.exists(file) && service.length(file) > 0) {
                    result = Uri.fromFile(file);
                }
            }
            return result;
        }
    }

    static class ImageThumbnailQuery implements ThumbnailQuery {
        private static final String[] PATH_PROJECTION = {
            MediaStore.Images.Thumbnails.DATA,
        };
        private static final String PATH_SELECTION =
            MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";

        @Override
        public Cursor queryPath(Context context, Uri uri) {
            String imageId = uri.getLastPathSegment();
            return context.getContentResolver().query(
                MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
                PATH_PROJECTION,
                PATH_SELECTION,
                new String[] { imageId },
                null /*sortOrder*/);
        }
    }

    static class VideoThumbnailQuery implements ThumbnailQuery {
        private static final String[] PATH_PROJECTION = {
            MediaStore.Video.Thumbnails.DATA
        };
        private static final String PATH_SELECTION =
            MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";

        @Override
        public Cursor queryPath(Context context, Uri uri) {
            String videoId = uri.getLastPathSegment();
            return context.getContentResolver().query(
                MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
                PATH_PROJECTION,
                PATH_SELECTION,
                new String[] { videoId },
                null /*sortOrder*/);
        }
    }

    static class ThumbnailStreamOpenerFactory {

        public ThumbnailStreamOpener build(Uri uri, int width, int height) {
            if (!isMediaStoreUri(uri) || width > MINI_WIDTH || height > MINI_HEIGHT) {
                return null;
            } else if (isMediaStoreVideo(uri)) {
                return new ThumbnailStreamOpener(new VideoThumbnailQuery());
            } else {
                return new ThumbnailStreamOpener(new ImageThumbnailQuery());
            }
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;<<<<<<< MINE
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.model.ImageVideoWrapper;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.drawable.GlideDrawable;
import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.target.Target;

import java.io.File;

/**
 * A class for creating a request to load a {@link GlideDrawable}.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 */
public class DrawableRequestBuilder<ModelType>
        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>
        implements BitmapOptions, DrawableOptions {

    DrawableRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,
            RequestTracker requestTracker, Lifecycle lifecycle) {
        super(context, modelClass, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);
        // Default to animating.
        crossFade();
    }

    /**
     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this
     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly
     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will
     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}
     * will never replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,
     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This builder object.
     */
    public DrawableRequestBuilder<ModelType> thumbnail(
            DrawableRequestBuilder<?> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> thumbnail(
            GenericRequestBuilder<?, ?, ?, GlideDrawable> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> decoder(ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> cacheDecoder(ResourceDecoder<File, GifBitmapWrapper> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> encoder(ResourceEncoder<GifBitmapWrapper> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transform {@link GlideDrawable}s using the given
     * {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
     *
     * <p>
     *     Note - Bitmap transformations will apply individually to each frame of animated GIF images and also to
     *     individual {@link Bitmap}s.
     * </p>
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param transformations The transformations to apply in order.
     * @return This request builder.
     */
    public DrawableRequestBuilder<ModelType> transform(BitmapTransformation... transformations) {
        return bitmapTransform(transformations);
    }

    /**
     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public DrawableRequestBuilder<ModelType> centerCrop() {
        return transform(glide.getDrawableCenterCrop());
    }

    /**
     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public DrawableRequestBuilder<ModelType> fitCenter() {
        return transform(glide.getDrawableFitCenter());
    }

    /**
     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any
     * previous transformations.
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public DrawableRequestBuilder<ModelType> bitmapTransform(Transformation<Bitmap>... bitmapTransformations) {
        GifBitmapWrapperTransformation[] transformations =
                new GifBitmapWrapperTransformation[bitmapTransformations.length];
        for (int i = 0; i < bitmapTransformations.length; i++) {
            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);
        }
        return transform(transformations);
    }



    /**
     * {@inheritDoc}
     *
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #centerCrop()
     * @see #fitCenter()
     */
    @Override
    public DrawableRequestBuilder<ModelType> transform(Transformation<GifBitmapWrapper>... transformation) {
        super.transform(transformation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> transcoder(
            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public final DrawableRequestBuilder<ModelType> crossFade() {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>());
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public DrawableRequestBuilder<ModelType> crossFade(int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(animation, duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(context, animationId,
                duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public DrawableRequestBuilder<ModelType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> listener(
            RequestListener<? super ModelType, GlideDrawable> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> clone() {
        return (DrawableRequestBuilder<ModelType>) super.clone();
    }

    /**
     * {@inheritDoc}
     *
     * <p>
     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
     *     use {@link #dontTransform()}.
     * </p>
     *
     * @param view {@inheritDoc}
     * @return {@inheritDoc}
     */
    @Override
    public Target<GlideDrawable> into(ImageView view) {
        return super.into(view);
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/okio/revisions/rev_89e1341_c8a36a6/rev_89e1341-c8a36a6/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java;<<<<<<< MINE
      consumeTrailer(deadline);
=======
      consumeTrailer();
>>>>>>> YOURS
/home/arthur/analysis/projects/okio/revisions/rev_89e1341_c8a36a6/rev_89e1341-c8a36a6/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java;<<<<<<< MINE
    // +---+---+=======
  private void consumeTrailer() throws IOException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_3b20004_63678dd/rev_3b20004-63678dd/java/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
    /**
     * Send a message to a channel.
     *
     * @param args
     *            Hashtable containing channel name, message.
     * @param callback
     *            object of sub class of Callback class
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Methods
     *             accepting Hashtable as arguments have been deprecated.
     */
    @Deprecated
    @Override
    public void publish(Hashtable args, Callback callback) {
        super.publish(args, callback);
    }

    /**
     * Send a message to a channel.
     *
     * @param args
     *            Hashtable containing channel name, message, callback
     * @deprecated As of version 3.5.2 . Will be removed in 3.6.0 . Methods
     *             accepting Hashtable as arguments have been deprecated.
     *
     */
    @Deprecated
    @Override
    public void publish(Hashtable args) {
        super.publish(args);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param count
     *            Upper limit on number of messages to be returned
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, long start, long end, int count, boolean reverse, Callback callback)}
     */
    @Deprecated
    @Override
    public void detailedHistory(final String channel, long start, long end,
                                int count, boolean reverse, final Callback callback) {
        super.detailedHistory(channel, start, end, count, reverse, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param count
     *            Upper limit on number of messages to be returned
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     */
    public void history(final String channel, long start, long end, int count,
                        boolean reverse, final Callback callback) {
        super.detailedHistory(channel, start, end, count, reverse, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, long start, boolean reverse, Callback callback)}
     */
    @Deprecated
    @Override
    public void detailedHistory(String channel, long start, boolean reverse,
                                Callback callback) {
        super.detailedHistory(channel, start, reverse, callback);
    }

    /**
     *
     * Read history for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     */
    public void history(String channel, long start, boolean reverse,
                        Callback callback) {
        super.detailedHistory(channel, start, reverse, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, long start, long end, Callback callback)}
     */
    @Deprecated
    @Override
    public void detailedHistory(String channel, long start, long end,
                                Callback callback) {
        super.detailedHistory(channel, start, end, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param callback
     *            Callback
     */

    public void history(String channel, long start, long end, Callback callback) {
        super.detailedHistory(channel, start, end, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, long start, long end, boolean reverse, Callback callback)}
     */
    @Deprecated
    @Override
    public void detailedHistory(String channel, long start, long end,
                                boolean reverse, Callback callback) {
        super.detailedHistory(channel, start, end, reverse, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param start
     *            Start time
     * @param end
     *            End time
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     */
    public void history(String channel, long start, long end, boolean reverse,
                        Callback callback) {
        super.detailedHistory(channel, start, end, reverse, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param count
     *            Upper limit on number of messages to be returned
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, int count, boolean reverse, Callback callback)}
     */
    @Deprecated
    @Override
    public void detailedHistory(String channel, int count, boolean reverse,
                                Callback callback) {
        super.detailedHistory(channel, count, reverse, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param count
     *            Upper limit on number of messages to be returned
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     */
    public void history(String channel, int count, boolean reverse,
                        Callback callback) {
        super.detailedHistory(channel, count, reverse, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, boolean reverse, Callback callback)}
     */
    @Deprecated
    public void detailedHistory(String channel, boolean reverse,
                                Callback callback) {
        super.detailedHistory(channel, reverse, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param reverse
     *            True if messages need to be in reverse order
     * @param callback
     *            Callback
     */

    public void history(String channel, boolean reverse, Callback callback) {
        super.detailedHistory(channel, reverse, callback);
    }

    /**
     *
     * Read DetailedHistory for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param count
     *            Maximum number of messages
     * @param callback
     *            Callback object
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Replaced
     *             by
     *             {@link #history(String channel, int count, Callback callback)}
     */
    @Deprecated
    public void detailedHistory(String channel, int count, Callback callback) {
        super.detailedHistory(channel, count, callback);
    }

    /**
     *
     * Read History for a channel.
     *
     * @param channel
     *            Channel name for which detailed history is required
     * @param count
     *            Maximum number of messages
     * @param callback
     *            Callback object
     */
    @Override
    public void history(String channel, int count, Callback callback) {
        super.detailedHistory(channel, count, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Methods
     *             accepting Hashtable as arguments have been deprecated.
     */
    @Deprecated
    public void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     *
     * Listen for a message on a channel.
     *
     * @param args
     *            Hashtable containing channel name
     * @param callback
     *            Callback
     * @exception PubnubException
     *                Throws PubnubException if Callback is null
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 .
     */
    @Deprecated
    public void subscribe(Hashtable args, Callback callback)
    throws PubnubException {
        args.put("callback", callback);
        super.subscribe(args);
    }

    /**
     *
     * Listen for a message on a channel.
     *
     * @param args
     *            Hashtable containing channel name, callback
     * @exception PubnubException
     *                Throws PubnubException if Callback is null
     * @deprecated as of version 3.5.2 and will be removed with 3.6.0 . Methods
     *             accepting Hashtable as arguments have been deprecated.
     */
    @Deprecated
    public void subscribe(Hashtable args) throws PubnubException {
        super.subscribe(args);
    }

    private String pamSign(String key, String data) throws PubnubException {
        Mac sha256_HMAC;

        try {
            sha256_HMAC = Mac.getInstance("HmacSHA256");
            SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(),
                    "HmacSHA256");
            sha256_HMAC.init(secret_key);
            byte[] hmacData = sha256_HMAC.doFinal(data.getBytes("UTF-8"));
            return new String(Base64Encoder.encode(hmacData)).replace('+', '-')
                   .replace('/', '_');
        } catch (InvalidKeyException e1) {
            throw new PubnubException(getErrorObject(PubnubError.PNERROBJ_ULSSIGN_ERROR, 1, "Invalid Key : " + e1.toString()));
        } catch (NoSuchAlgorithmException e1) {
            throw new PubnubException(getErrorObject(PubnubError.PNERROBJ_ULSSIGN_ERROR, 2, "Invalid Algorithm : " + e1.toString()));
        } catch (IllegalStateException e1) {
            throw new PubnubException(getErrorObject(PubnubError.PNERROBJ_ULSSIGN_ERROR, 3, "Invalid State : " + e1.toString()));
        } catch (UnsupportedEncodingException e1) {
            throw new PubnubException(getErrorObject(PubnubError.PNERROBJ_ULSSIGN_ERROR, 4, "Unsupported encoding : " + e1.toString()));
        }
    }

    /** Grant r/w access based on channel and auth key
     * @param channel
     * @param auth_key
     * @param read
     * @param write
     * @param callback
     */
    public void pamGrant(final String channel, String auth_key, boolean read,
                         boolean write, final Callback callback) {
        pamGrant(channel, auth_key, read, write, -1, callback);
    }

    /** Grant r/w access based on channel and auth key
     * @param channel
     * @param auth_key
     * @param read
     * @param write
     * @param callback
     */
    public void pamGrant(final String channel, String auth_key, boolean read,
                         boolean write, int ttl, final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING, 1));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "grant" + "\n" + "auth=" + urlEncode(auth_key) + "&" + "channel="
                            + urlEncode(channel) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                            + ((ttl > -1)?"&" + "ttl=" + ttl:"")
                            + "&" + "w=" + w;


        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }


        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", urlEncode(channel));
        parameters.put("auth", urlEncode(auth_key));
        if (ttl > 0) parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, getErrorObject(
                                    PNERROBJ_INVALID_JSON, 4,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }

    /** ULS Audit
     * @param callback
     */
    public void pamAudit(final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback("",
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING, 2));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "audit" + "\n"
                            + "timestamp=" + timestamp;


        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback("",
                                   e1.getPubnubError());
            return;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, getErrorObject(
                                    PNERROBJ_INVALID_JSON, 5,
                                    response));
                    return;
                }
                callback.successCallback("", jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback("", error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }

    /** ULS audit by channel
     * @param channel
     * @param callback
     */
    public void pamAudit(final String channel,
                         final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING , 3));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "audit" + "\n" + "channel="
                            + urlEncode(channel) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", urlEncode(channel));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, getErrorObject(
                                    PNERROBJ_INVALID_JSON, 6,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }

    /** ULS audit by channel and auth key
     * @param channel
     * @param auth_key
     * @param callback
     */
    public void pamAudit(final String channel, String auth_key,
                         final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING, 4));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "audit" + "\n" + "auth=" + urlEncode(auth_key) + "&" + "channel="
                            + urlEncode(channel) + "&" + "timestamp=" + timestamp;


        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", urlEncode(channel));
        parameters.put("auth", urlEncode(auth_key));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(
                                    PubnubError.PNERROBJ_INVALID_JSON, 2,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }

    /** ULS revoke by channel and auth key
     * @param channel
     * @param auth_key
     * @param callback
     */
    public void pamRevoke(String channel, String auth_key, Callback callback) {
        pamGrant(channel, auth_key, false, false, callback);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_157aa0a_bed3057/rev_157aa0a-bed3057/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloRequest>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloRequest>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_157aa0a_bed3057/rev_157aa0a-bed3057/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloReply>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloReply>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_41f1155_a287a11/rev_41f1155-a287a11/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloRequest>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloRequest>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloRequest>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_41f1155_a287a11/rev_41f1155-a287a11/android/app/src/main/java/io/grpc/helloworldexample/GreeterGrpc.java;<<<<<<< MINE
                    io.grpc.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.nano.Parser<Helloworld.HelloReply>() {
=======
                    io.grpc.protobuf.nano.NanoUtils.<Helloworld.HelloReply>marshaller(
                            new io.grpc.protobuf.nano.Parser<Helloworld.HelloReply>() {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6bf11c0_8024de0/rev_6bf11c0-8024de0/java/src1/com/pubnub/api/SubscribeWorker.java;<<<<<<< MINE
                sleep = true;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6bf11c0_8024de0/rev_6bf11c0-8024de0/java/src1/com/pubnub/api/SubscribeWorker.java;<<<<<<< MINE
=======
            sleep = true;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6bf11c0_8024de0/rev_6bf11c0-8024de0/java/srcPubnubApi/com/pubnub/api/AbstractLogger.java;<<<<<<< MINE
    private static boolean LOGGING = true;
=======
    private static boolean LOGGING = false;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53490c3_d5a696c/rev_53490c3-d5a696c/java/srcPubnubApi/com/pubnub/api/PubnubError.java;<<<<<<< MINE
    public static final int                PNERR_HTTP_RC_ERROR                        =       128;
    /**
     * Pubnub server or intermediate server returned HTTP 404 unauthorized status code
     * 
     */
    public static final int         PNERR_NOT_FOUND                         =       129;
=======
    static final int                PNERR_HTTP_RC_ERROR                        =       128;

    /**
     * Subscribe Timeout .
     */
    static final int                PNERR_HTTP_SUBSCRIBE_TIMEOUT               =       129;

>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/test/java/io/grpc/transport/AbstractStreamTest.java;<<<<<<< MINE
=======
/*
 * Copyright 2015, Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 *    * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package io.grpc.transport;

import static org.junit.Assert.fail;
import static org.mockito.Mockito.verify;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

import io.grpc.transport.AbstractStream.Phase;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.InputStream;

import javax.annotation.Nullable;

@RunWith(JUnit4.class)
public class AbstractStreamTest {
  @Mock private StreamListener streamListener;

  @Before
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void onStreamAllocated_shouldNotifyReady() {
    AbstractStream<Object> stream = new AbstractStreamBase<Object>(null);

    stream.onStreamAllocated();

    verify(streamListener).onReady();
  }

  @Test
  public void validPhaseTransitions() {
    AbstractStream<Object> stream = new AbstractStreamBase<Object>(null);
    Multimap<Phase, Phase> validTransitions = ImmutableMultimap.<Phase, Phase>builder()
        .put(Phase.HEADERS, Phase.HEADERS)
        .put(Phase.HEADERS, Phase.MESSAGE)
        .put(Phase.HEADERS, Phase.STATUS)
        .put(Phase.MESSAGE, Phase.MESSAGE)
        .put(Phase.MESSAGE, Phase.STATUS)
        .put(Phase.STATUS, Phase.STATUS)
        .build();

    for (Phase startPhase : Phase.values()) {
      for (Phase endPhase : Phase.values()) {
        if (validTransitions.containsEntry(startPhase, endPhase)) {
          stream.verifyNextPhase(startPhase, endPhase);
        } else {
          try {
            stream.verifyNextPhase(startPhase, endPhase);
            fail();
          } catch (IllegalStateException expected) {
            // continue
          }
        }
      }
    }
  }

  /**
   * Base class for testing.
   */
  private class AbstractStreamBase<IdT> extends AbstractStream<IdT> {
    private AbstractStreamBase(WritableBufferAllocator bufferAllocator) {
      super(bufferAllocator);
    }

    @Override
    public void request(int numMessages) {
      throw new UnsupportedOperationException();
    }

    @Override
    @Nullable
    public IdT id() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected StreamListener listener() {
      return streamListener;
    }

    @Override
    protected void internalSendFrame(WritableBuffer frame, boolean endOfStream, boolean flush) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void receiveMessage(InputStream is) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void inboundDeliveryPaused() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void remoteEndClosed() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void returnProcessedBytes(int processedBytes) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void deframeFailed(Throwable cause) {
      throw new UnsupportedOperationException();
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractServerStream.java;<<<<<<< MINE
=======
import static com.google.common.base.Preconditions.checkNotNull;

>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractServerStream.java;<<<<<<< MINE
    this.listener = Preconditions.checkNotNull(listener, "listener");
=======
    this.listener = checkNotNull(listener);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractServerStream.java;<<<<<<< MINE
    return this.listener;
=======
    return listener;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
import static com.google.common.base.Preconditions.checkArgument;
=======
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
import com.google.common.base.Preconditions;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
=======
 *
 * @param <IdT> type of the unique identifier of this stream.
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
   * Indicates whether the listener is currently eligible for notification of
   * {@link StreamListener#onReady()}.
   */
  @GuardedBy("onReadyLock")
  private boolean shouldNotifyOnReady = true;
  /**
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
=======
   * Override this method to provide a stream listener.
   */
  protected abstract StreamListener listener();

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
    return onReadyThreshold;
  }

  /**
   * Sets the number of queued bytes for a given stream, below which
   * {@link StreamListener#onReady()} will be called. If not called, defaults to
   * {@link #DEFAULT_ONREADY_THRESHOLD}.
   *
   * <p>This must be called from the transport thread, since a listener may be called back directly.
   */
  public void setOnReadyThreshold(int onReadyThreshold) {
    checkArgument(onReadyThreshold > 0, "onReadyThreshold must be > 0");
    boolean doNotify;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      if (this.onReadyThreshold <= numSentBytesQueued && onReadyThreshold > numSentBytesQueued) {
        shouldNotifyOnReady = true;
      }
      this.onReadyThreshold = onReadyThreshold;
      doNotify = needToNotifyOnReady();
    }
    if (doNotify) {
      listener().onReady();
=======
      return onReadyThreshold;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
    Preconditions.checkNotNull(message, "message");
=======
    checkNotNull(message);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
        if (allocated && numSentBytesQueued < onReadyThreshold) {
          return true;
        }
=======
        return allocated && numSentBytesQueued < onReadyThreshold;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
   * Gets the listener to this stream.
   */
  protected abstract StreamListener listener();

  /**
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  protected void onStreamAllocated() {
    boolean doNotify;
=======
  protected final void onStreamAllocated() {
    checkState(listener() != null);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      if (allocated) {
        throw new IllegalStateException("Already allocated");
      }
=======
      checkState(!allocated, "Already allocated");
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      doNotify = needToNotifyOnReady();
    }
    if (doNotify) {
      listener().onReady();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
=======
    notifyIfReady();
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      if (!isReady()) {
        shouldNotifyOnReady = true;
      }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
=======
      boolean belowThresholdBefore = numSentBytesQueued < onReadyThreshold;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      doNotify = needToNotifyOnReady();
=======
      boolean belowThresholdAfter = numSentBytesQueued < onReadyThreshold;
      doNotify = !belowThresholdBefore && belowThresholdAfter;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
      listener().onReady();
=======
      notifyIfReady();
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  /**
   * Determines whether or not we need to call the {@link StreamListener#onReady()} handler now.
   * Calling this method has the side-effect of unsetting {@link #shouldNotifyOnReady} so the
   * handler should always be invoked immediately after calling this method.
   */
  @GuardedBy("onReadyLock")
  private boolean needToNotifyOnReady() {
    if (shouldNotifyOnReady && isReady()) {
      // Returning true here counts as a call to the onReady callback, so
      // unset the flag.
      shouldNotifyOnReady = false;
      return true;
=======
  @VisibleForTesting
  final void notifyIfReady() {
    boolean doNotify = false;
    synchronized (onReadyLock) {
      doNotify = isReady();
    }
    if (doNotify) {
      listener().onReady();
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
    return false;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE
  private Phase verifyNextPhase(Phase currentPhase, Phase nextPhase) {
=======
  @VisibleForTesting
  Phase verifyNextPhase(Phase currentPhase, Phase nextPhase) {
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/main/java/io/grpc/transport/AbstractStream.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java;<<<<<<< MINE
=======
import io.grpc.transport.AbstractStream;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java;<<<<<<< MINE
    final int messageLength = 15;
=======
    // exactly one byte below the threshold
    int messageLength = AbstractStream.DEFAULT_ONREADY_THRESHOLD - HEADER_LENGTH - 1;
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java;<<<<<<< MINE
        method,new Metadata.Headers(), listener);
    stream.setOnReadyThreshold(HEADER_LENGTH + 20);
=======
        method, new Metadata.Headers(), listener);
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/okhttp/src/test/java/io/grpc/transport/okhttp/OkHttpClientTransportTest.java;<<<<<<< MINE
    // Now the first message is still in the queue, and it's size is smaller than the threshold.
    // Increase the threshold should have no affection.
    stream.setOnReadyThreshold(messageLength * 10);
    assertFalse(listener.isOnReadyCalled());
    // Decrease the threshold should have no affection too.
    stream.setOnReadyThreshold(HEADER_LENGTH);
    assertFalse(listener.isOnReadyCalled());
    // But now increase the threshold to larger than the queued message size, onReady should be
    // triggered.
    stream.setOnReadyThreshold(HEADER_LENGTH + messageLength + 1);
    assertTrue(listener.isOnReadyCalled());

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;<<<<<<< MINE
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/java/examples/src/com/pubnub/examples/PubnubPushSampleCode.java;<<<<<<< MINE
    private static void usage(Options options) {

        HelpFormatter formatter = new HelpFormatter();
        formatter.printHelp("Publisher", options);
    }

    public void start() {


    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        Options options = new Options();
        String publish_key = "demo-36";
        String subscribe_key = "demo-36";
        boolean nativ = false;
        boolean gcm = false;
        boolean apns = false;

        String channel = "demo";

        String origin = "gcm-beta";

        String auth_key = "";

        CommandLine cmd = null;

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
                withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
                withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
                withType(String.class).withDescription("Origin ( Ex. pubsub )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
                withType(String.class).withDescription("Auth Key").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
                withType(String.class).withDescription("Secret Key ( default: 'my_channel' )").create());

        options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());

        options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());

        options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());

        CommandLineParser parser = new BasicParser();
        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e1) {
            usage(options);
            return;
        }

        if (cmd.hasOption("publish_key")) {
            try {
                publish_key = cmd.getOptionValue("publish_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("subscribe_key")) {
            try {
                subscribe_key = cmd.getOptionValue("subscribe_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("origin")) {
            try {
                origin = cmd.getOptionValue("origin");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("channel")) {
            try {
                channel = cmd.getOptionValue("channel");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("auth_key")) {
            try {
                auth_key = cmd.getOptionValue("auth_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("apns")) {
            try {
                apns = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("gcm")) {
            try {
                gcm = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        if (cmd.hasOption("native")) {
            try {
                nativ = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
        pubnub.setAuthKey(auth_key);
        pubnub.setCacheBusting(false);
        pubnub.setOrigin(origin);

        // Create APNS message

        PnApnsMessage apnsMessage = new PnApnsMessage();
        apnsMessage.setApsAlert("Game update 49ers touchdown");
        apnsMessage.setApsBadge(2);

        try {
            apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
            apnsMessage.put("score", new JSONArray().put(7).put(0));
        } catch (JSONException e1) {

        }

        // Create GCM Message

        PnGcmMessage gcmMessage = new PnGcmMessage();

        JSONObject jso = new JSONObject();
        try {
            jso.put("summary", "Game update 49ers touchdown");
            jso.put("lastplay", "5yd run up the middle");
        } catch (JSONException e) {

        }

        gcmMessage.setData(jso);


        Callback callback = new Callback() {
            @Override
            public void successCallback(String channel, Object response) {
                System.out.println(response);
                pubnub.shutdown();
            }

            @Override
            public void errorCallback(String channel, PubnubError error) {
                System.out.println(error);
                pubnub.shutdown();
            }
        };

        PubnubSender sender = new PubnubSender(channel, pubnub, callback);

        PnMessage message = null;

        if (apns && gcm) {
            message = new PnMessage(sender, apnsMessage, gcmMessage);
        } else if (apns) {
            message = new PnMessage(sender, apnsMessage);
        } else if (gcm) {
            message = new PnMessage(sender, gcmMessage);
        }
        if (message == null) message = new PnMessage(sender);
        if (nativ) {
            try {
                message.put("test", "hi");
            } catch (JSONException e1) {

            }
        }

        try {
            message.publish();
        } catch (PubnubSenderMissingException e) {
            System.out.println("Set Sender");
        }

=======
		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp( "Publisher", options );
	}
	
	public void start() {
		
	
	}
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Options options = new Options();
		String publish_key = "demo-36";
		String subscribe_key = "demo-36";
		boolean nativ = false;
		boolean gcm = false;
		boolean apns = false;
		
		String channel = "my_channel";
		
		String origin = "pubsub";
		
		String auth_key = "";
		
		CommandLine cmd = null;
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
				withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
				withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
				withType(String.class).withDescription("Origin ( Ex. pubsub )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
				withType(String.class).withDescription("Auth Key").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
				withType(String.class).withDescription("Channel ( default: 'my_channel' )").create());
		
		options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());
		
		options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());
		
		options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());
		
		CommandLineParser parser = new BasicParser();
		try {
			cmd = parser.parse( options, args);
		} catch (ParseException e1) {
			usage(options);return;
		}
		
		if (cmd.hasOption("publish_key")) {
			try {
				publish_key = cmd.getOptionValue("publish_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("subscribe_key")) {
			try {
				subscribe_key = cmd.getOptionValue("subscribe_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("origin")) {
			try {
				origin = cmd.getOptionValue("origin");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("channel")) {
			try {
				channel = cmd.getOptionValue("channel");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("auth_key")) {
			try {
				auth_key = cmd.getOptionValue("auth_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("apns")) {
			try {
				apns = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		if (cmd.hasOption("gcm")) {
			try {
				gcm = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		
		if (cmd.hasOption("native")) {
			try {
				nativ = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		
		final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
		pubnub.setAuthKey(auth_key);
		pubnub.setCacheBusting(false);
		pubnub.setOrigin(origin);
		
		// Create APNS message
		
		PnApnsMessage apnsMessage = new PnApnsMessage();
		apnsMessage.setApsAlert("Game update 49ers touchdown");
		apnsMessage.setApsBadge(2);
		
		try {
			apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
			apnsMessage.put("score", new JSONArray().put(7).put(0));
		} catch (JSONException e1) {

		}
		
		// Create GCM Message	
		
		PnGcmMessage gcmMessage = new PnGcmMessage();
		
		JSONObject jso = new JSONObject();
		try {
			jso.put("summary", "Game update 49ers touchdown");
			jso.put("lastplay", "5yd run up the middle");
		} catch (JSONException e) {

		}

		gcmMessage.setData(jso);
		
		
		Callback callback = new Callback() {
			@Override
			public void successCallback(String channel, Object response) {
				System.out.println(response);
				pubnub.shutdown();
			}
			@Override
			public void errorCallback(String channel, PubnubError error) {
				System.out.println(error);
				pubnub.shutdown();
			}			
		};
		
		PubnubSender sender = new PubnubSender(channel, pubnub, callback);
		
		PnMessage message = null;
		
		if (apns && gcm) {
			message = new PnMessage(sender, apnsMessage, gcmMessage);
		} else if (apns) {
			message = new PnMessage(sender, apnsMessage);
		} else if (gcm) {
			message = new PnMessage(sender, gcmMessage);
		}
		if (message == null) message = new PnMessage(sender);
		if (nativ) {
			try {
				message.put("test","hi");
			} catch (JSONException e1) {

			}
		}
		
		try {
			message.publish();
		} catch (PubnubSenderMissingException e) {
			System.out.println("Set Sender");
		}
		
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/android/examples/PubnubExample/src/com/pubnub/examples/pubnubExample10/MainActivity.java;<<<<<<< MINE
            protected String doInBackground(Void... params) {
                String msg = "";
                try {
                    if (gcm == null) {
                        gcm = GoogleCloudMessaging.getInstance(context);
                    }
                    REG_ID = gcm.register(SENDER_ID);
                    Log.d("RegisterActivity", "registerInBackground - regId: "
                            + REG_ID);
                    msg = "Device registered, registration ID=" + REG_ID;

                    storeRegistrationId(context, REG_ID);
                } catch (IOException ex) {
                    msg = "Error :" + ex.getMessage();
                    Log.d("RegisterActivity", "Error: " + msg);
                }
                Log.d("RegisterActivity", "AsyncTask completed: " + msg);
                return msg;
=======
            public void onClick(DialogInterface dialog, int which) {
            	   		
        		if (TextUtils.isEmpty(REG_ID)) {
        		      Toast.makeText(getApplicationContext(),
        			          "GCM Registration id not set. Register to GCM and try again.",
        			          Toast.LENGTH_LONG).show();
        		      return ;
        		}
                String channel = edChannelName.getText().toString();
				pubnub.enablePushNotificationsOnChannel(channel, REG_ID, new Callback() {
				    @Override
				    public void successCallback(String channel,
				    Object message) {
				        notifyUser("GCM ADD : " + message);
				    }
				    @Override
				    public void errorCallback(String channel,
				    PubnubError error) {
				        notifyUser("GCM ADD : " + error);
				    }
				});
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_35c7f03_449a6c6/rev_35c7f03-449a6c6/java/srcPubnubApi/com/pubnub/api/PubnubUtilCore.java;<<<<<<< MINE
        Hashtable ht, String delimiter) {
=======
        Hashtable ht, String delimiter, String exclude) {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_35c7f03_449a6c6/rev_35c7f03-449a6c6/java/srcPubnubApi/com/pubnub/api/PubnubUtilCore.java;<<<<<<< MINE

=======
            
            if (exclude != null) {
            	if (s.indexOf(exclude) != -1) {
            		continue;
            	}
            }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_35c7f03_449a6c6/rev_35c7f03-449a6c6/java/srcPubnubApi/com/pubnub/api/PubnubUtilCore.java;<<<<<<< MINE
    
    /**
     * Returns string keys in a hashtable as delimited string
     *
     * @param ht
     *            , Hashtable
     * @param delimiter
     *            , String
     * @return , string array with hash keys string
     */
    public static String hashTableKeysToDelimitedString(
        Hashtable ht, String delimiter) {

        return hashTableKeysToDelimitedString(ht, delimiter, null);

    }

=======
    
    /**
     * Returns string keys in a hashtable as delimited string
     *
     * @param ht
     *            , Hashtable
     * @param delimiter
     *            , String
     * @return , string array with hash keys string
     */
    public static String hashTableKeysToDelimitedString(
        Hashtable ht, String delimiter) {

        return hashTableKeysToDelimitedString(ht, delimiter, null);

    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_8e4119c_6dbe265/rev_8e4119c-6dbe265/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        String[] urlargs = { getPubnubUrl(), "v2/presence/sub_key",
                this.SUBSCRIBE_KEY, "channel", PubnubUtil.urlEncode(channel),
                "leave"
        };
        Hashtable parameters = PubnubUtil.hashtableClone(params);
=======
    private void channelGroupLeave(String group) {
        Hashtable params = new Hashtable();
        params.put("channel-group", group);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_8e4119c_6dbe265/rev_8e4119c-6dbe265/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("uuid", UUID);
        
        HttpRequest hreq = new HttpRequest(urlargs, parameters,
                new ResponseHandler() {
=======
        _leave(",", params);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_c2d55ac_4efc0ab/rev_c2d55ac-4efc0ab/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java;<<<<<<< MINE
  public static final int TYPE_DASH_VOD = 0;
  public static final int TYPE_SS_VOD = 1;
  public static final int TYPE_OTHER = 2;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_c2d55ac_4efc0ab/rev_c2d55ac-4efc0ab/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java;<<<<<<< MINE
    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, TYPE_OTHER);
=======
    contentType = intent.getIntExtra(DemoUtil.CONTENT_TYPE_EXTRA, DemoUtil.TYPE_OTHER);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_c2d55ac_4efc0ab/rev_c2d55ac-4efc0ab/demo/src/main/java/com/google/android/exoplayer/demo/simple/SimplePlayerActivity.java;<<<<<<< MINE
      case TYPE_SS_VOD:
=======
      case DemoUtil.TYPE_SS:
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
        _request(hreq, nonSubscribeManager);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.successCallback("", jsarr);
=======
                cb.successCallback("", jsarr);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
                callback.errorCallback("", error);
=======
                cb.errorCallback("", error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_629a45c_d6cff1f/rev_629a45c-d6cff1f/android/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
        _request(hreq, nonSubscribeManager);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java;<<<<<<< MINE
import com.google.android.exoplayer.demo.full.player.UnsupportedDrmException;
=======
import com.google.android.exoplayer.metadata.TxxxMetadata;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/demo/src/main/java/com/google/android/exoplayer/demo/full/FullPlayerActivity.java;<<<<<<< MINE
    DemoPlayer.Listener, DemoPlayer.TextListener, AudioCapabilitiesReceiver.Listener {
=======
    DemoPlayer.Listener, DemoPlayer.TextListener, DemoPlayer.Id3MetadataListener {

  private static final String TAG = "FullPlayerActivity";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/demo/src/main/java/com/google/android/exoplayer/demo/Samples.java;<<<<<<< MINE
        DemoUtil.TYPE_SS, false),
=======
        DemoUtil.TYPE_SS, false, false),
    new Sample("Apple master playlist (HLS)", "uid:hls:applemaster",
        "https://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/"
        + "bipbop_4x3_variant.m3u8", DemoUtil.TYPE_HLS, false, false),
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/library/src/main/java/com/google/android/exoplayer/MediaFormat.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.util.MimeTypes;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_5a3340d_1554db1/rev_5a3340d-1554db1/library/src/main/java/com/google/android/exoplayer/MediaFormat.java;<<<<<<< MINE
  public static MediaFormat createTtmlFormat() {
    return createFormatForMimeType(MimeTypes.APPLICATION_TTML);
  }

  public static MediaFormat createFormatForMimeType(String mimeType) {
    return new MediaFormat(mimeType, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
        NO_VALUE, null);
  }

=======
  public static MediaFormat createId3Format() {
    return new MediaFormat(MimeTypes.APPLICATION_ID3, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
        NO_VALUE, NO_VALUE, NO_VALUE, null);
  }

  public static MediaFormat createEia608Format() {
    return new MediaFormat(MimeTypes.APPLICATION_EIA608, NO_VALUE, NO_VALUE, NO_VALUE, NO_VALUE,
        NO_VALUE, NO_VALUE, NO_VALUE, null);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_b805692_57068a6/rev_b805692-57068a6/demo/src/main/java/com/google/android/exoplayer/demo/full/player/DemoPlayer.java;<<<<<<< MINE
=======
      if (type == TYPE_TEXT && index == DISABLED_TRACK && textListener != null) {
        textListener.onText(null);
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);
=======
        return true;
    }

    
    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }
    
    private void channelGroupLeave(String group) {
    	channelGroupLeave(group, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        if (auth_key != null && auth_key.length() > 0 ) parameters.put("auth", auth_key);

        String[] urlComponents = {getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                this.SUBSCRIBE_KEY
=======
    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }
   
    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
    	_leave(channels, channelGroups, params, null);
    }
    
    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
    	_leave(PubnubUtil.joinString(channels, ","),
    			PubnubUtil.joinString(channelGroups, ","), params, callback);
    }
    
    private void _leave(String[] channels, String[] channelGroups) {
    	_leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    } 
    
    
    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
    	_leave(PubnubUtil.joinString(channels, ","),
    			PubnubUtil.joinString(channelGroups, ","), PubnubUtil.hashtableClone(this.params), callback);
    }    
    
    private void _leave(String channel, String channelGroup, Callback callback) {
    	_leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }
    
    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {
    	
    	final Callback cb = getWrappedCallback(callback);
    	
    	if (PubnubUtil.isEmptyString(channel) &&
    			PubnubUtil.isEmptyString(channelGroup))
    		return;
    	
    	if (PubnubUtil.isEmptyString(channel)) channel = ",";
    	
        String[] urlArgs = {getPubnubUrl(), "v2/presence/sub_key",
                this.SUBSCRIBE_KEY, "channel", PubnubUtil.urlEncode(channel), "leave"
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
=======
        params.put("uuid", UUID);
        

        if (!PubnubUtil.isEmptyString(channelGroup))
        	params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                        invokeCallback(group, response, "payload", cb, 6);
=======
                    	cb.successCallback(null, response);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                        cb.errorCallback(group, error);
=======
                    	cb.errorCallback(null, error);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
    protected Object _pamAudit(final String channel, String auth_key,
                         Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
=======
    /**
     * Unsubscribe from channels.
     *
     * @param channels String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }
    
    /**
     * Unsubscribe from channels.
     *
     * @param channels String array containing channel names
     */
    public void unsubscribe(String[] channels) {
    	unsubscribe(channels, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);
=======
    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    
    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[]{channel}, callback);
    }
    
    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[]{(String) args.get("channel")};
        }
        unsubscribe(channelList);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
=======
    /**
     * Unsubscribe from channel group
     *
     * @param group to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group to unsubscribe
     * @param callback Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[]{group}, callback);
    }
    
    
    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups to unsubscribe
     * @param callback Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                + "audit" + "\n" + "auth=" + PubnubUtil.urlEncode(auth_key) + "&" + "channel="
                + PubnubUtil.urlEncode(channel) + "&" + "pnsdk=" + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
=======
    /**
     * Unsubscribe from presence channel.
     *
     * @param channel channel name as String.
     * @param callback Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[]{channel + PRESENCE_SUFFIX}, callback);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                    e1.getPubnubError());
            return null;
=======
    /**
     * Unsubscribe from presence channel.
     *
     * @param channel channel name as String.
     */
    public void unsubscribePresence(String channel) {
    	unsubscribePresence(channel, null);
    }
    
    /**
     * Unsubscribe from all channels and channel groups.
     * 
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                this.SUBSCRIBE_KEY
        };
=======
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }
    
    /**
     * Unsubscribe from all channels and channel groups.
     */    
    public void unsubscribeAll() {
    	unsubscribeAll(null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
                new ResponseHandler() {
                    public void handleResponse(HttpRequest hreq, String response) {
                        invokeCallback(channel, response, "payload", cb, 2);
                    }
=======
    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
    	unsubscribeAllChannels(null);
    }
    
    /**
     * Unsubscribe from all channels.
     * 
     * @param callback Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
                    public void handleError(HttpRequest hreq, PubnubError error) {
                        cb.errorCallback(channel, error);
                        return;
                    }
                });
=======
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
        return _request(hreq, (sync)?null:nonSubscribeManager);
=======
    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
    	channelGroupUnsubscribeAllGroups(null);
    }
    
    /**
     * Unsubscribe from all channel groups.
     * 
     * @param callback Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_7d3cb58_87bd1b5/rev_7d3cb58-87bd1b5/src/main/java/com/corundumstudio/socketio/store/RedissonPubSubStore.java;<<<<<<< MINE
import java.util.concurrent.ConcurrentHashMap;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_7d3cb58_87bd1b5/rev_7d3cb58-87bd1b5/src/main/java/com/corundumstudio/socketio/handler/ClientHead.java;<<<<<<< MINE
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE
import com.pubnub.api.endpoints.presence.GetState;
import com.pubnub.api.endpoints.presence.HereNow;
import com.pubnub.api.endpoints.presence.SetState;
import com.pubnub.api.endpoints.presence.WhereNow;
=======
import com.pubnub.api.endpoints.channel_groups.*;
import com.pubnub.api.endpoints.presence.*;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
=======
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE
        byte[] encoded;
=======
        Properties prop = new Properties();
        InputStream in = ClassLoader.getSystemClassLoader().getResourceAsStream("version.properties");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE
            encoded = Files.readAllBytes(Paths.get(Pubnub.class.getClassLoader().getResource("version.properties").getPath()));
=======
            prop.load(in);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE

        return prop.getProperty("version");

    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_1bc188b_0fadf3d/rev_1bc188b-0fadf3d/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_1bc188b_0fadf3d/rev_1bc188b-0fadf3d/java/examples/eclipse_project_console/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_1bc188b_0fadf3d/rev_1bc188b-0fadf3d/j2me/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======
    

    
    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */
    public static String[] splitString(String source, String delimiter) {
        System.out.println("[" + delimiter + "] : " + source );
        int delimiterCount = 0;
        int index = 0;
        String tmpStr = source;

        String[] splittedList;

        while ((index = tmpStr.indexOf(delimiter)) != -1) {

            tmpStr = tmpStr.substring(index + delimiter.length());
            delimiterCount++;
        }

        splittedList = new String[delimiterCount + 1];

        int counter = 0;
        tmpStr = source;
        System.out.println("Delimiter Count : " + delimiterCount);
        do {
            int nextIndex = tmpStr.indexOf(delimiter, index + 1);
            
            System.out.println("Next Index : " + nextIndex);
            
            if (nextIndex != -1) {
                System.out.println(tmpStr);
                System.out.println(index);
                System.out.println(index + delimiter.length() + " : " + nextIndex);
                splittedList[counter++] = tmpStr.substring(index + delimiter.length(), nextIndex);
                tmpStr = tmpStr.substring(nextIndex);

            } else {
                splittedList[counter++] = tmpStr.substring(index + delimiter.length());
                tmpStr = tmpStr.substring(index + 1);
            }
        } while ((index = tmpStr.indexOf(delimiter)) != -1);

        return splittedList;
    }

    /**
     * Takes String[] of tokens, and String delimiter as input and returns
     * joined String
     *
     * @param sourceArray
     *            , input tokens in String array
     * @param delimiter
     *            , delimiter to join on
     * @return String , string of tokens joined by delimiter
     */
    public static String joinString(String[] sourceArray, String delimiter) {
        if (sourceArray == null || delimiter == null || sourceArray.length <= 0) {
            return "";
        }
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < sourceArray.length - 1; i++) {
            sb.append(sourceArray[i]).append(delimiter);
        }
        sb.append(sourceArray[sourceArray.length - 1]);

        return sb.toString();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_1bc188b_0fadf3d/rev_1bc188b-0fadf3d/scala/scala-pubnub-tests/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com/pubnub/api/Base64Test.java;<<<<<<< MINE
import com.pubnub.api.core.utils.Base64;
=======
import com.pubnub.api.utils.Base64;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.pubsub;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.server.SubscribeEnvelope;
import com.pubnub.api.models.server.SubscribeMessage;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class SubscribeEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    PubNub pubnub;
    Subscribe instance;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        instance = new Subscribe(pubnub);
    }

    @Test
    public void subscribeChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        SubscribeEnvelope subscribeEnvelope = instance.channels(Arrays.asList("coolChannel")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());

        assertEquals("1", subscribeEnvelope.getMetadata().getRegion());
        assertTrue(subscribeEnvelope.getMetadata().getTimetoken().equals(14607577960932487L));

        assertEquals(1, subscribeEnvelope.getMessages().size());
        SubscribeMessage subscribeMessage = subscribeEnvelope.getMessages().get(0);
        assertEquals("4", subscribeMessage.getShard());
        assertEquals("0", subscribeMessage.getFlags());
        assertEquals("coolChannel", subscribeMessage.getChannel());
        assertEquals("coolChan-bnel", subscribeMessage.getSubscriptionMatch());
        assertEquals("sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f", subscribeMessage.getSubscribeKey());
        assertEquals("Client-g5d4g", subscribeMessage.getIssuingClientId());
        assertEquals("{text=Enter Message Here}", subscribeMessage.getPayload().toString());
    }

    @Test
    public void subscribeChannelsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }

    @Test
    public void subscribeChannelsAuthSync() throws PubNubException {

        pubnub.getConfiguration().setAuthKey("authKey");

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals("authKey", requests.get(0).queryParameter("auth").firstValue());
        assertEquals(1, requests.size());
    }

    @Test
    public void subscribeChannelsWithGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1", "cg2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeWithTimeTokenSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).timetoken(1337L).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("1337", requests.get(0).queryParameter("tt").firstValue());
    }

    @Test
    public void subscribeWithFilter() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).filterExpression("this=1&that=cool").sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("this%3D1%26that%3Dcool", requests.get(0).queryParameter("filter-expr").firstValue());
    }

    @Test
    public void subscribeWithRegion() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).region("10").sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("10", requests.get(0).queryParameter("tr").firstValue());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void subscribeMissingChannelAndGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        SubscribeEnvelope subscribeEnvelope = instance.sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.access;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerAuditResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static com.github.tomakehurst.wiremock.client.WireMock.matching;
import static org.junit.Assert.assertEquals;

public class AuditEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Audit partialAudit;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {

        pubnub = this.createPubNubInstance(8080);
        partialAudit = pubnub.audit();

        pubnub.getConfiguration().setSecretKey("secretKey");

    }

    @Test
    public void testSuccessChannelGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("IjnQ0J7c0SYT3gHBxrIC_8OkDHTqsF9KnI0SlBRLNfg%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel-group\":\"cg2\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();

        Assert.assertEquals("cg2", pnAccessManagerAuditResult.getChannelGroup());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isManageEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isReadEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isWriteEnabled());
        Assert.assertEquals("channel-group+auth", pnAccessManagerAuditResult.getLevel());
        Assert.assertEquals("sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f", pnAccessManagerAuditResult.getSubscribeKey());

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v1/auth/audit/sub-key/mySubscribeKey.*")));
        assertEquals(1, requests.size());

    }

    @Test
    public void testSuccessChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("ZlPruaId7jzupmK4LUynpnjvA2CQYyrrT0475wWkbwY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channel("ch1").authKeys(Arrays.asList("key1")).sync();

        Assert.assertEquals("ch1", pnAccessManagerAuditResult.getChannel());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isManageEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isReadEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isWriteEnabled());
        Assert.assertEquals("user", pnAccessManagerAuditResult.getLevel());
        Assert.assertEquals("sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f", pnAccessManagerAuditResult.getSubscribeKey());

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSuccessChannelMissingKeySync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("ZlPruaId7jzupmK4LUynpnjvA2CQYyrrT0475wWkbwY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channel("ch1").sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.access;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerGrantResult;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerKeyData;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static com.github.tomakehurst.wiremock.client.WireMock.matching;

public class GrantEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Grant partialGrant;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {

        pubnub = this.createPubNubInstance(8080);
        partialGrant = pubnub.grant();

        pubnub.getConfiguration().setSecretKey("secretKey");

    }

    @Test
    public void NoGroupsOneChannelOneKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("KQ1g-hpCnWGD6DfR0J30xkB0KwBhbIBlLqKi8GNoD7M%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelTwoKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("hlFr8HmcEIK51rEc-jhwym89SgCeAKvzhTYphwD_Sqw%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
    }

    @Test
    public void NoGroupsTwoChannelOneKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("YSf7ataHaZQj0-kE9P5-0ACR4fjrzzGJbzRSoF3J4UQ%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(1, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
    }

    @Test
    public void NoGroupsTwoChannelTwoKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("q9gzdsS-Z_Ff21ZfiXEakG3fkOWsT49MEn4ZKFxjehY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(2, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());
    }

    @Test
    public void OneGroupNoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("BGNIzQq6T-X_ES7RjSeUh0L_THx6RP956DBRIfilQCE%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

    }

    @Test
    public void OneGroupNoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("vBxdD0-HPCuKoVlXL2c7JYeAmDVBN-TGodVJXFbOLcI%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

    }

    @Test
    public void OneGroupOneChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("eRwmB_DpD7rdR6qZDm4fh2PiXfdYbFXbwIcq-oVQOaY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":\"cg1\"},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void OneGroupOneChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("4ogB_IAapikN32FOCXJQD2FOHfrFbZqFrOCRry2C3AY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":\"cg1\"},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());

    }

    @Test
    public void OneGroupTwoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("SMoWF-RgW-2wGZ-wbzkaKwd6b3Zigq2gYFCxmw0Equs%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1", "ch2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());

    }

    @Test
    public void OneGroupTwoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("FF-8u5mhNhbrWD5_XyIrCOPitG8YQbmeGYZXaiOQYBA%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1", "ch2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());
    }

    //

    @Test
    public void TwoGroupNoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("6mss-Lh0eaN0G_TfY6WfFKBqePYe1j4blNGwJPMxTOs%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

    }

    @Test
    public void TwoGroupNoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("q2AUprf6ZUD4N96hMTCVm7hoMfDRC7xfG4XPyLLNWB4%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

    }

    @Test
    public void TwoGroupOneChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("pRlfFAiCrKIqSPUjZgaI3ZLq9wK4-VUvhf_ispH6ow8%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
    }

    @Test
    public void TwoGroupOneChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("8H6V_0LqSBinnK5Po5LA29ny8CH8eGonzB6UomoXvXo%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(2, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());

    }

    @Test
    public void TwoGroupTwoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("yBYF6-JTkM8F-U-K4ACwzrPEN0iihJQUygz4JOh4rwU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(1, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
    }

    @Test
    public void TwoGroupTwoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("JLTTsGTwaaEORmY_zoZcCzYl4qEZVkid-YRSvKYMwUU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(2, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(2, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneKeyTTLTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("pzSNXZSiBMkzg15vOQrKoDkue8OWoxEB1afup9Godac%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .withQueryParam("ttl", matching("1334"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).ttl(1334).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneReadKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("uVcT9Q_XiLPpR1kmIzD9OJ6mTa1V1GyvyBcKBWSDrJU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("1"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).read(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneWriteKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("-MirRhU4989XbPZEza82xvhZ0CdQIngM8b7qSUL1kDI%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("1"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).write(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneKeyManageTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("_znR67zw5cdCq3Cmn1QHUHtFolkquYARh_JYCeMb8ig%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("1"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).manage(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }


    @org.junit.Test(expected=PubNubException.class)
    public void NoGroupsOneChannelMissingKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("_znR67zw5cdCq3Cmn1QHUHtFolkquYARh_JYCeMb8ig%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("1"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.channels(Arrays.asList("ch1")).manage(true).sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/HistoryEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.history.PNHistoryResult;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.*;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class HistoryEndpointTest extends TestHarness {

    private History partialHistory;
    private PubNub pubnub;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        partialHistory = pubnub.history();
    }


    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(true).sync();

        Assert.assertTrue(response.getStartTimeToken().equals(1234L));
        Assert.assertTrue(response.getEndTimeToken().equals(4321L));

        Assert.assertEquals(response.getMessages().size(), 2);

        Assert.assertTrue(response.getMessages().get(0).getTimetoken().equals(1111L));
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("a").asInt(), 11);
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("b").asInt(), 22);

        Assert.assertTrue(response.getMessages().get(1).getTimetoken().equals(2222L));
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("a").asInt(), 33);
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("b").asInt(), 44);
    }

    @Test
    public void testSyncAuthSuccess() throws PubNubException, JsonProcessingException {

        pubnub.getConfiguration().setAuthKey("authKey");

        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));


        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(true).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals("authKey", requests.get(0).queryParameter("auth").firstValue());
        assertEquals(1, requests.size());
    }


    @org.junit.Test
    public void testSyncEncryptedSuccess() throws IOException, PubNubException {
        pubnub.getConfiguration().setCipherKey("testCipher");

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody("[[\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\",\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\",\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\"],14606134331557853,14606134485013970]")));

        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(false).sync();

        Assert.assertTrue(response.getStartTimeToken().equals(14606134331557853L));
        Assert.assertTrue(response.getEndTimeToken().equals(14606134485013970L));

        Assert.assertEquals(response.getMessages().size(), 3);

        Assert.assertEquals(response.getMessages().get(0).getTimetoken(), null);
        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(0).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(0).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(0).getEntry()).get(2).asText());

        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(1).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(1).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(1).getEntry()).get(2).asText());

        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(2).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(2).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(2).getEntry()).get(2).asText());

    }

    @org.junit.Test
    public void testSyncSuccessWithoutTimeToken() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);

        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);

        historyItems.add(historyItem1);
        historyItems.add(historyItem2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("niceChannel").sync();

        Assert.assertTrue(response.getStartTimeToken().equals(1234L));
        Assert.assertTrue(response.getEndTimeToken().equals(4321L));

        Assert.assertEquals(response.getMessages().size(), 2);

        Assert.assertNull(response.getMessages().get(0).getTimetoken());
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("a").asInt(), 11);
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("b").asInt(), 22);

        Assert.assertNull(response.getMessages().get(1).getTimetoken());
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("a").asInt(), 33);
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("b").asInt(), 44);
    }


    @org.junit.Test(expected=PubNubException.class)
    public void testMissinChannel() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.includeTimetoken(true).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testChannelIsEmpty() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("").includeTimetoken(true).sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/EndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints;

import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.enums.PNOperationType;
import okhttp3.Request;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

import java.io.IOException;
import java.util.Map;

public class EndpointTest extends TestHarness {

    PubNub pubnub;


    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
    }

    @Test
    public void testUUID() throws PubNubException {
        Endpoint<Object, Object> endpoint =  new Endpoint<Object, Object>(pubnub) {

            @Override
            protected void validateParams() throws PubNubException {
            }

            @Override
            protected Object createResponse(Response input) throws PubNubException {
                return null;
            }

            @Override
            protected int getConnectTimeout() {
                return 0;
            }

            @Override
            protected int getRequestTimeout() {
                return 0;
            }

            @Override
            protected PNOperationType getOperationType() {
                return null;
            }

            @Override
            protected Call doWork(Map baseParams) throws PubNubException {

                Call<Object> fakeCall = new Call<Object>() {

                    @Override
                    public Response<Object> execute() throws IOException {
                        Response<Object> newResponse = Response.success(null);
                        return newResponse;
                    }

                    @Override
                    public void enqueue(Callback<Object> callback) {

                    }

                    @Override
                    public boolean isExecuted() {
                        return false;
                    }

                    @Override
                    public void cancel() {

                    }

                    @Override
                    public boolean isCanceled() {
                        return false;
                    }

                    @Override
                    public Call<Object> clone() {
                        return null;
                    }

                    @Override
                    public Request request() {
                        return null;
                    }
                };

                Assert.assertEquals("myUUID",baseParams.get("uuid"));
                return fakeCall;
            }
        };

        endpoint.sync();
    }



}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class AddChannelChannelGroupEndpointTest extends TestHarness {
    private AddChannelChannelGroup partialAddChannelChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialAddChannelChannelGroup = this.createPubNubInstance(8080).addChannelsToChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncGroupMissing() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncGroupIsEmpty() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("").channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncChannelMissing() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("groupA").sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class DeleteChannelGroupEndpointTest extends TestHarness {
    private DeleteChannelGroup partialDeleteChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialDeleteChannelGroup = this.createPubNubInstance(8080).deleteChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA/remove"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialDeleteChannelGroup.channelGroup("groupA").sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissingGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA/remove"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialDeleteChannelGroup.sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.channel_group.PNChannelGroupsAllChannelsResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class AllChannelsChannelGroupEndpointTest extends TestHarness {
    private AllChannelsChannelGroup partialAllChannelsChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialAllChannelsChannelGroup = this.createPubNubInstance(8080).listChannelsForChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {\"channels\": [\"a\",\"b\"]}, \"service\": \"ChannelGroups\"}")));

        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.channelGroup("groupA").sync();
        assertThat(response.getChannels(), org.hamcrest.Matchers.contains("a", "b"));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissingGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {\"channels\": [\"a\",\"b\"]}, \"service\": \"ChannelGroups\"}")));

        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class RemoveChannelChannelGroupEndpointTest extends TestHarness {
    private RemoveChannelChannelGroup partialRemoveChannelChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialRemoveChannelChannelGroup = this.createPubNubInstance(8080).removeChannelsFromChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissinGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissinChannel() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channelGroup("groupA").sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.presence.PNGetStateResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class GetStateEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private GetState partialGetState;

    @Before
    public void beforeEach() throws IOException {
        partialGetState = this.createPubNubInstance(8080).getPresenceState();
    }

    @Test
    public void testOneChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));


        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("testChannel");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
    }

    @Test
    public void testOneChannelWithoutUUIDSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));


        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("testChannel");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
    }


    @org.junit.Test(expected=PubNubException.class)
    public void testFailedPayloadSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));

        partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
    }

    @Test
    public void testMultipleChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1,ch2/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"ch1\": { \"age\" : 20, \"status\" : \"online\"}, \"ch2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channels(Arrays.asList("ch1", "ch2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("ch1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("ch2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");
    }

    @Test
    public void testOneChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channelGroups(Arrays.asList("cg1")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void testManyChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channelGroups(Arrays.asList("cg1", "cg2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void testCombinationSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @org.junit.Test(expected=PubNubException.class)
    public void testMissingChannelAndGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));
        PNGetStateResult result = partialGetState.uuid("sampleUUID").sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/LeaveTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.jayway.awaitility.Awaitility;
import com.pubnub.api.callbacks.PNCallback;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.PNStatus;
import com.pubnub.api.endpoints.TestHarness;
import com.pubnub.api.models.consumer.presence.PNGetStateResult;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class LeaveTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Leave instance;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        instance = new Leave(pubnub);
    }

    @Test
    public void subscribeChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());

    }

    @Test
    public void subscribeChannelsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }


    @Test
    public void subscribeChannelsWithGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeChannelsWithGroupASync() throws PubNubException {

        final AtomicBoolean statusArrived = new AtomicBoolean();

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .async(new PNCallback<Boolean>() {
            @Override
            public void onResponse(Boolean result, PNStatus status) {
                assertEquals(status.getAffectedChannels().get(0), "coolChannel");
                assertEquals(status.getAffectedChannels().get(1), "coolChannel2");
                assertEquals(status.getAffectedChannelGroups().get(0), "cg1");
                statusArrived.set(true);
            }
        });


        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(statusArrived, org.hamcrest.core.IsEqual.equalTo(true));
    }

    @Test
    public void subscribeGroupsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channelGroups(Arrays.asList("cg1", "cg2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channelGroups(Arrays.asList("cg1")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testMissingChannelAndGroupSync() throws PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/SetStateEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.presence.PNSetStateResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class SetStateEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private SetState partialSetState;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);

        partialSetState = pubnub.setPresenceState();
    }

    @Test
    public void applyStateForChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel")).state(Arrays.asList("s1", "s2", "s3")).sync();
        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());

    }

    @Test
    public void applyStateForChannelsSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel,testChannel2/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel", "testChannel2")).state(Arrays.asList("s1", "s2", "s3")).sync();
        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
    }

    @Test
    public void applyStateForChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channelGroups(Arrays.asList("cg1")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void applyStateForChannelGroupsSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @Test
    public void applyStateForMixSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @org.junit.Test(expected=PubNubException.class)
    public void applyNon200Sync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}").withStatus(400)));


        PNSetStateResult result = partialSetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void MissimStateSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel")).sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE
    protected final boolean validateParams() {
=======
    protected final void validateParams() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE
            return false;
=======
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_MESSAGE_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE

        if (channel == null || channel.length() == 0) {
            return false;
=======
        if (channel == null || channel.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CHANNEL_MISSING).build();
        }
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
        if (pubnub.getConfiguration().getPublishKey()==null || pubnub.getConfiguration().getPublishKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUBLISH_KEY_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE

        return true;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE
=======
import com.pubnub.api.PubNubError;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE
    protected boolean validateParams() {
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE
            return false;
=======
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUSH_TYPE_MISSING).build();
        }
        if (deviceId == null || deviceId.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_DEVICE_ID_MISSING).build();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/RemoveAllPushChannelsForDevice.java;<<<<<<< MINE

        return true;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/ListPushProvisions.java;<<<<<<< MINE
=======
import com.pubnub.api.PubNubError;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/push/ListPushProvisions.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
        if (pushType == null) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_PUSH_TYPE_MISSING).build();
        }
        if (deviceId == null || deviceId.isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_DEVICE_ID_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/Time.java;<<<<<<< MINE
    protected final boolean validateParams() {
        return true;
=======
    protected final void validateParams() throws PubNubException {

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroup.java;<<<<<<< MINE
=======
import com.pubnub.api.PubNubError;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (channelGroup==null || channelGroup.isEmpty())
        {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_GROUP_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroup.java;<<<<<<< MINE
        return true;
=======
        return !input.body().isError();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException
    {
        if (channelGroup==null || channelGroup.isEmpty())
        {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_GROUP_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroup.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException
    {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroup.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/endpoints/presence/WhereNow.java;<<<<<<< MINE
    protected boolean validateParams() {
        return true;
=======
    protected void validateParams() throws PubNubException {
        if (pubnub.getConfiguration().getSubscribeKey()==null || pubnub.getConfiguration().getSubscribeKey().isEmpty()) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_SUBSCRIBE_KEY_MISSING).build();
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_ULSSIGN_ERROR = 105;
=======
        public static final int PNERR_ULSSIGN_ERROR = 105;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_GETINPUTSTREAM = 118;
=======
        public static final int PNERR_GETINPUTSTREAM = 118;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_MALFORMED_URL = 119;
=======
        public static final int PNERR_MALFORMED_URL = 119;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_JSON_ERROR = 121;
=======
        public static final int PNERR_JSON_ERROR = 121;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_PROTOCOL_EXCEPTION = 122;
=======
        public static final int PNERR_PROTOCOL_EXCEPTION = 122;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_READINPUT = 123;
=======
        public static final int PNERR_READINPUT = 123;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_BAD_GATEWAY = 124;
=======
        public static final int PNERR_BAD_GATEWAY = 124;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_INTERNAL_ERROR = 125;
=======
        public static final int PNERR_INTERNAL_ERROR = 125;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_PARSING_ERROR = 126;
=======
        public static final int PNERR_PARSING_ERROR = 126;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_BAD_REQUEST = 127;
=======
        public static final int PNERR_BAD_REQUEST = 127;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final int PNERR_HTTP_SUBSCRIBE_TIMEOUT = 130;
=======
        public static final int PNERR_HTTP_SUBSCRIBE_TIMEOUT = 130;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        // Error Objects
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_TIMEOUT = new PubNubError(PNERR_TIMEOUT, "Timeout Occurred");
=======
        /**
         * Group missing
         *
         */
        public static final int PNERR_GROUP_MISSING = 136;

        /**
         * Auth Keys missing
         *
         */
        public static final int PNERR_AUTH_KEYS_MISSING = 137;

        /**
         * Subscribe Key missing
         *
         */
        public static final int PNERR_SUBSCRIBE_KEY_MISSING = 138;

        /**
         * Publish Key missing
         *
         */
        public static final int PNERR_PUBLISH_KEY_MISSING = 139;

        /**
         * State missing
         *
         */
        public static final int PNERR_STATE_MISSING = 140;

        /**
         * Channel and Group missing
         *
         */
        public static final int PNERR_CHANNEL_AND_GROUP_MISSING = 141;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR, "Internal Error");
=======
        /**
         * Message missing
         *
         */
        public static final int PNERR_MESSAGE_MISSING = 142;

        /**
         * Push TYpe missing
         *
         */
        public static final int PNERR_PUSH_TYPE_MISSING = 143;

        /**
         * Device ID missing
         *
         */
        public static final int PNERR_DEVICE_ID_MISSING = 144;

    // Error Objects
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_ENCRYPTION_ERROR = new PubNubError(PNERR_ENCRYPTION_ERROR,
=======
        public static final PubNubError PNERROBJ_TIMEOUT = new PubNubError(PNERR_TIMEOUT, "Timeout Occurred");

        public static final PubNubError PNERROBJ_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR, "Internal Error");

        public static final PubNubError PNERROBJ_ENCRYPTION_ERROR = new PubNubError(PNERR_ENCRYPTION_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_DECRYPTION_ERROR = new PubNubError(PNERR_DECRYPTION_ERROR, "Decryption Error. "
=======
        public static final PubNubError PNERROBJ_DECRYPTION_ERROR = new PubNubError(PNERR_DECRYPTION_ERROR, "Decryption Error. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_INVALID_JSON = new PubNubError(PNERR_INVALID_JSON, "Invalid Json. "
=======
        public static final PubNubError PNERROBJ_INVALID_JSON = new PubNubError(PNERR_INVALID_JSON, "Invalid Json. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_JSON_ERROR = new PubNubError(PNERR_JSON_ERROR,
=======
        public static final PubNubError PNERROBJ_JSON_ERROR = new PubNubError(PNERR_JSON_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_MALFORMED_URL = new PubNubError(PNERR_MALFORMED_URL, "Malformed URL ."
=======
        public static final PubNubError PNERROBJ_MALFORMED_URL = new PubNubError(PNERR_MALFORMED_URL, "Malformed URL ."
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_PUBNUB_ERROR = new PubNubError(PNERR_PUBNUB_ERROR, "PubNub Error");
=======
        public static final PubNubError PNERROBJ_PUBNUB_ERROR = new PubNubError(PNERR_PUBNUB_ERROR, "PubNub Error");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_URL_OPEN = new PubNubError(PNERR_URL_OPEN, "Error opening url. "
=======
        public static final PubNubError PNERROBJ_URL_OPEN = new PubNubError(PNERR_URL_OPEN, "Error opening url. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_PROTOCOL_EXCEPTION = new PubNubError(PNERR_PROTOCOL_EXCEPTION,
=======
        public static final PubNubError PNERROBJ_PROTOCOL_EXCEPTION = new PubNubError(PNERR_PROTOCOL_EXCEPTION,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_CONNECT_EXCEPTION = new PubNubError(PNERR_CONNECT_EXCEPTION,
=======
        public static final PubNubError PNERROBJ_CONNECT_EXCEPTION = new PubNubError(PNERR_CONNECT_EXCEPTION,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_HTTP_RC_ERROR = new PubNubError(PNERR_HTTP_RC_ERROR,
=======
        public static final PubNubError PNERROBJ_HTTP_RC_ERROR = new PubNubError(PNERR_HTTP_RC_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_GETINPUTSTREAM = new PubNubError(PNERR_GETINPUTSTREAM,
=======
        public static final PubNubError PNERROBJ_GETINPUTSTREAM = new PubNubError(PNERR_GETINPUTSTREAM,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_READINPUT = new PubNubError(PNERR_READINPUT, "Unable to read Input Stream. "
=======
        public static final PubNubError PNERROBJ_READINPUT = new PubNubError(PNERR_READINPUT, "Unable to read Input Stream. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_BAD_REQUEST = new PubNubError(PNERR_BAD_REQUEST, "Bad request. "
=======
        public static final PubNubError PNERROBJ_BAD_REQUEST = new PubNubError(PNERR_BAD_REQUEST, "Bad request. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_BAD_GATEWAY = new PubNubError(PNERR_BAD_GATEWAY, "Bad Gateway. "
=======
        public static final PubNubError PNERROBJ_BAD_GATEWAY = new PubNubError(PNERR_BAD_GATEWAY, "Bad Gateway. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_CLIENT_TIMEOUT = new PubNubError(PNERR_CLIENT_TIMEOUT, "Client Timeout");
=======
        public static final PubNubError PNERROBJ_CLIENT_TIMEOUT = new PubNubError(PNERR_CLIENT_TIMEOUT, "Client Timeout");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_GATEWAY_TIMEOUT = new PubNubError(PNERR_GATEWAY_TIMEOUT, "Gateway Timeout");
=======
        public static final PubNubError PNERROBJ_GATEWAY_TIMEOUT = new PubNubError(PNERR_GATEWAY_TIMEOUT, "Gateway Timeout");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_5023_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR,
=======
        public static final PubNubError PNERROBJ_5023_INTERNAL_ERROR = new PubNubError(PNERR_INTERNAL_ERROR,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_PUBNUB_EXCEPTION = new PubNubError(PNERR_PUBNUB_EXCEPTION, "PubNub Exception");
=======
        public static final PubNubError PNERROBJ_PUBNUB_EXCEPTION = new PubNubError(PNERR_PUBNUB_EXCEPTION, "PubNub Exception");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_DISCONNECT = new PubNubError(PNERR_DISCONNECT, "Disconnect");
=======
        public static final PubNubError PNERROBJ_DISCONNECT = new PubNubError(PNERR_DISCONNECT, "Disconnect");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_DISCONN_AND_RESUB = new PubNubError(PNERR_DISCONN_AND_RESUB,
=======
        public static final PubNubError PNERROBJ_DISCONN_AND_RESUB = new PubNubError(PNERR_DISCONN_AND_RESUB,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_FORBIDDEN = new PubNubError(PNERR_FORBIDDEN, "Authentication Failure. "
=======
        public static final PubNubError PNERROBJ_FORBIDDEN = new PubNubError(PNERR_FORBIDDEN, "Authentication Failure. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_UNAUTHORIZED = new PubNubError(PNERR_UNAUTHORIZED, "Authentication Failure. "
=======
        public static final PubNubError PNERROBJ_UNAUTHORIZED = new PubNubError(PNERR_UNAUTHORIZED, "Authentication Failure. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_SECRET_KEY_MISSING = new PubNubError(PNERR_SECRET_KEY_MISSING,
=======
        public static final PubNubError PNERROBJ_SECRET_KEY_MISSING = new PubNubError(PNERR_SECRET_KEY_MISSING,
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_ULSSIGN_ERROR = new PubNubError(PNERR_ULSSIGN_ERROR, "Invalid Signature . "
=======
        public static final PubNubError PNERROBJ_SUBSCRIBE_KEY_MISSING = new PubNubError(PNERR_SUBSCRIBE_KEY_MISSING,
                "ULS configuration failed. Subscribe Key not configured. ");

        public static final PubNubError PNERROBJ_PUBLISH_KEY_MISSING = new PubNubError(PNERR_PUBLISH_KEY_MISSING,
                "ULS configuration failed. Publish Key not configured. ");

        public static final PubNubError PNERROBJ_ULSSIGN_ERROR = new PubNubError(PNERR_ULSSIGN_ERROR, "Invalid Signature . "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_5075_NETWORK_ERROR = new PubNubError(PNERR_NETWORK_ERROR, "Network Error. "
=======
        public static final PubNubError PNERROBJ_5075_NETWORK_ERROR = new PubNubError(PNERR_NETWORK_ERROR, "Network Error. "
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
        static final PubNubError PNERROBJ_NOT_FOUND_ERROR = new PubNubError(PNERR_NOT_FOUND, "Page Not Found"
=======
        public static final PubNubError PNERROBJ_NOT_FOUND_ERROR = new PubNubError(PNERR_NOT_FOUND, "Page Not Found"
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
=======
        public static final PubNubError PNERROBJ_STATE_MISSING = new PubNubError(PNERR_STATE_MISSING, "State Missing.");

        public static final PubNubError PNERROBJ_MESSAGE_MISSING = new PubNubError(PNERR_MESSAGE_MISSING, "Message Missing.");

        public static final PubNubError PNERROBJ_PUSH_TYPE_MISSING = new PubNubError(PNERR_PUSH_TYPE_MISSING, "Push Type Missing.");

        public static final PubNubError PNERROBJ_DEVICE_ID_MISSING = new PubNubError(PNERR_DEVICE_ID_MISSING, "Device Id Missing.");

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubNubError.java;<<<<<<< MINE
=======
        public static final PubNubError PNERROBJ_GROUP_MISSING = new PubNubError(PNERR_GROUP_MISSING, "Group Missing.");

        public static final PubNubError PNERROBJ_CHANNEL_AND_GROUP_MISSING = new PubNubError(PNERR_CHANNEL_AND_GROUP_MISSING, "Channel and Group Missing.");

        public static final PubNubError PNERROBJ_AUTH_KEYS_MISSING = new PubNubError(PNERR_AUTH_KEYS_MISSING, "Auth Keys Missing.");

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/utils/Base64.java;<<<<<<< MINE
package com.pubnub.api.core.utils;
=======
package com.pubnub.api.utils;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/Crypto.java;<<<<<<< MINE
import com.pubnub.api.core.utils.Base64;
=======
import com.pubnub.api.utils.Base64;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======
package com.pubnub.api;

import com.pubnub.api.utils.Base64;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

/**
 * Created by Frederick on 3/30/16.
 */
public class PubnubUtil {


    public static String joinString(List<String> val, String delim){
        StringBuilder builder = new StringBuilder();
        for(String l: val){
            builder.append(l);
            builder.append(",");
        }

        return builder.toString().substring(0,builder.toString().length() - 1);

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.
                    replace("*", "%2A")
                    .replace("!", "%21")
                    .replace("'", "%27")
                    .replace("(", "%28")
                    .replace(")", "%29")
                    .replace("[", "%5B")
                    .replace("]", "%5D")
                    .replace("~", "%7E");
        }
        return encoded;
    }


    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String preparePamArguments(Map<String, String> pamArgs){
        Set<String> pamKeys = new TreeSet(pamArgs.keySet());
        String stringifiedArguments = "";
        int i = 0;

        for (String pamKey : pamKeys) {
            if (i != 0) {
                stringifiedArguments += "&";
            }


            stringifiedArguments += pamEncode(pamKey);
            stringifiedArguments += "=";
            stringifiedArguments += pamEncode(pamArgs.get(pamKey));

            i += 1;
        }

        return stringifiedArguments;
    }

    public static String signSHA256(final String key, final String data) throws PubNubException {
        Mac sha256HMAC;
        byte[] hmacData;
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "HmacSHA256");

        try {
            sha256HMAC = Mac.getInstance("HmacSHA256");
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        try {
            sha256HMAC.init(secretKey);
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        try {
            hmacData = sha256HMAC.doFinal(data.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        return new String(Base64.encode(hmacData, 0)).replace('+', '-').replace('/', '_');
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals(null, segments.get(0).encryptionMethod);
=======
      assertEquals(false, segments.get(0).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(1).encryptionMethod);
=======
      assertEquals(true, segments.get(1).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals(HlsMediaPlaylist.ENCRYPTION_METHOD_NONE, segments.get(2).encryptionMethod);
=======
      assertEquals(false, segments.get(2).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(3).encryptionMethod);
=======
      assertEquals(true, segments.get(3).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("AES-128", segments.get(4).encryptionMethod);
=======
      assertEquals(true, segments.get(4).isEncrypted);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      // 0xA7A == 2682.
=======
      // 0xA7B == 2683.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/test/java/com/google/android/exoplayer/hls/HlsMediaPlaylistParserTest.java;<<<<<<< MINE
      assertEquals("A7A", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
=======
      assertEquals("A7B", segments.get(4).encryptionIV.toUpperCase(Locale.getDefault()));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java;<<<<<<< MINE
=======
  private static final String METHOD_NONE = "NONE";
  private static final String METHOD_AES128 = "AES-128";

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsPlaylistParser.java;<<<<<<< MINE
      Pattern.compile(METHOD_ATTR + "=([^,.*]+)");
=======
      Pattern.compile(METHOD_ATTR + "=(" + METHOD_NONE + "|" + METHOD_AES128 + ")");
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsChunkSource.java;<<<<<<< MINE
    if (HlsMediaPlaylist.ENCRYPTION_METHOD_AES_128.equals(segment.encryptionMethod)) {
=======
    if (segment.isEncrypted) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
    public final String encryptionMethod;
=======
    public final boolean isEncrypted;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
        String encryptionMethod, String encryptionKeyUri, String encryptionIV,
        int byterangeOffset, int byterangeLength) {
=======
        boolean isEncrypted, String encryptionKeyUri, String encryptionIV, int byterangeOffset,
        int byterangeLength) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_12807a7_fb36f85/rev_12807a7-fb36f85/library/src/main/java/com/google/android/exoplayer/hls/HlsMediaPlaylist.java;<<<<<<< MINE
      this.encryptionMethod = encryptionMethod;
=======
      this.isEncrypted = isEncrypted;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/j2me/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import org.json.me.*;

public class PubnubUtil extends PubnubUtilCore {

    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }

    public static String escapeJava(String s) {
        s = s.replaceAll("\"", "\\\\\"");
        return s;
    }
		

    private static String replace(String str, String pattern, String replace) {
        int s = 0;
        int e = 0;
        StringBuffer result = new StringBuffer();

        while ((e = str.indexOf(pattern, s)) >= 0) {
            result.append(str.substring(s, e));
            result.append(replace);
            s = e + pattern.length();
        }
        result.append(str.substring(s));
        return result.toString();
    }

    /**
     * Returns encoded String
     * 
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = replace(encoded, "*", "%2A");
            encoded = replace(encoded, "!", "%21");
            encoded = replace(encoded, "'", "%27");
            encoded = replace(encoded, "(", "%28");
            encoded = replace(encoded, ")", "%29");
            encoded = replace(encoded, "[", "%5B");
            encoded = replace(encoded, "]", "%5D");
            encoded = replace(encoded, "~", "%7E");
        }
        return encoded;
    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return replace(encode(sUrl, "UTF-8"), "+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String encode(String s, String enc) throws UnsupportedEncodingException {

        boolean needToChange = false;
        boolean wroteUnencodedChar = false;
        int maxBytesPerChar = 10;
        StringBuffer out = new StringBuffer(s.length());
        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);

        OutputStreamWriter writer = new OutputStreamWriter(buf, enc);

        for (int i = 0; i < s.length(); i++) {
            int c = (int) s.charAt(i);
            if (dontNeedEncoding(c)) {
                if (c == ' ') {
                    c = '+';
                    needToChange = true;
                }
                out.append((char) c);
                wroteUnencodedChar = true;
            } else {
                try {
                    if (wroteUnencodedChar) {
                        writer = new OutputStreamWriter(buf, enc);
                        wroteUnencodedChar = false;
                    }
                    writer.write(c);
                    if (c >= 0xD800 && c <= 0xDBFF) {

                        if ((i + 1) < s.length()) {
                            int d = (int) s.charAt(i + 1);
                            if (d >= 0xDC00 && d <= 0xDFFF) {
                                writer.write(d);
                                i++;
                            }
                        }
                    }
                    writer.flush();
                } catch (IOException e) {
                    buf.reset();
                    continue;
                }
                byte[] ba = buf.toByteArray();
                for (int j = 0; j < ba.length; j++) {
                    out.append('%');
                    char ch = CCharacter.forDigit((ba[j] >> 4) & 0xF, 16);
                    out.append(ch);
                    ch = CCharacter.forDigit(ba[j] & 0xF, 16);
                    out.append(ch);
                }
                buf.reset();
                needToChange = true;
            }
        }

        return (needToChange ? out.toString() : s);
    }

    static class CCharacter {
        public static char forDigit(int digit, int radix) {
            if ((digit >= radix) || (digit < 0)) {
                return '\0';
            }
            if ((radix < Character.MIN_RADIX) || (radix > Character.MAX_RADIX)) {
                return '\0';
            }
            if (digit < 10) {
                return (char) ('0' + digit);
            }
            return (char) ('a' - 10 + digit);
        }
    }

    public static boolean dontNeedEncoding(int ch) {
        int len = _dontNeedEncoding.length();
        boolean en = false;
        for (int i = 0; i < len; i++) {
            if (_dontNeedEncoding.charAt(i) == ch) {
                en = true;
                break;
            }
        }

        return en;
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        return str;
    }

    private static String _dontNeedEncoding = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ -_.*";
    

    
    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */
    public static String[] splitString(String source, String delimiter) {
        System.out.println("[" + delimiter + "] : " + source );
        int delimiterCount = 0;
        int index = 0;
        String tmpStr = source;

        String[] splittedList;

        while ((index = tmpStr.indexOf(delimiter)) != -1) {

            tmpStr = tmpStr.substring(index + delimiter.length());
            delimiterCount++;
        }

        splittedList = new String[delimiterCount + 1];

        int counter = 0;
        tmpStr = source;
        System.out.println("Delimiter Count : " + delimiterCount);
        do {
            int nextIndex = tmpStr.indexOf(delimiter, index + 1);
            
            System.out.println("Next Index : " + nextIndex);
            
            if (nextIndex != -1) {
                System.out.println(tmpStr);
                System.out.println(index);
                System.out.println(index + delimiter.length() + " : " + nextIndex);
                splittedList[counter++] = tmpStr.substring(index + delimiter.length(), nextIndex);
                tmpStr = tmpStr.substring(nextIndex);

            } else {
                splittedList[counter++] = tmpStr.substring(index + delimiter.length());
                tmpStr = tmpStr.substring(index + 1);
            }
        } while ((index = tmpStr.indexOf(delimiter)) != -1);

        return splittedList;
    }

    /**
     * Takes String[] of tokens, and String delimiter as input and returns
     * joined String
     *
     * @param sourceArray
     *            , input tokens in String array
     * @param delimiter
     *            , delimiter to join on
     * @return String , string of tokens joined by delimiter
     */
    public static String joinString(String[] sourceArray, String delimiter) {
        if (sourceArray == null || delimiter == null || sourceArray.length <= 0) {
            return "";
        }
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < sourceArray.length - 1; i++) {
            sb.append(sourceArray[i]).append(delimiter);
        }
        sb.append(sourceArray[sourceArray.length - 1]);

        return sb.toString();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/endpoints/pubsub/Publish.java;<<<<<<< MINE
import com.pubnub.api.*;
import com.pubnub.api.builder.PubNubErrorBuilder;
=======
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubError;
import com.pubnub.api.PubNubException;
import com.pubnub.api.PubNubUtil;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/PubNubUtil.java;<<<<<<< MINE
import com.pubnub.api.builder.PubNubErrorBuilder;
import com.pubnub.api.utils.Base64;
=======
import com.pubnub.api.vendor.Base64;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/PubNubUtil.java;<<<<<<< MINE
    /**
     * Returns decoded String
     *
     * @param sUrl
     *            , input string
     * @return , decoded string
     */
    public static String urlDecode(String sUrl) {
        try {
            return URLDecoder.decode(sUrl, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String preparePamArguments(Map<String, String> pamArgs){
=======
    public static String preparePamArguments(Map<String, String> pamArgs) {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/consumer/PNErrorData.java;<<<<<<< MINE
    String information;
    Exception throwable;
=======
    private String information;
    private Exception throwable;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/server/access_manager/AccessManagerAuditPayload.java;<<<<<<< MINE
    String level;
=======
    private String level;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/server/access_manager/AccessManagerAuditPayload.java;<<<<<<< MINE
    String subscribeKey;
=======
    private String subscribeKey;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/server/access_manager/AccessManagerAuditPayload.java;<<<<<<< MINE
    String channel;
=======
    private String channel;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/server/access_manager/AccessManagerAuditPayload.java;<<<<<<< MINE
    String channelGroup;
=======
    private String channelGroup;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/models/server/access_manager/AccessManagerAuditPayload.java;<<<<<<< MINE
    Map<String, PNAccessManagerKeyData> authKeys;
=======
    private Map<String, PNAccessManagerKeyData> authKeys;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/Crypto.java;<<<<<<< MINE
package com.pubnub.api;

import com.pubnub.api.builder.PubNubErrorBuilder;
import com.pubnub.api.utils.Base64;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;



@Slf4j
public class Crypto {

    byte[] keyBytes = null;
    byte[] ivBytes = null;
    String initializationVector = "0123456789012345";
    String cipherKey;
    boolean INIT = false;

    public Crypto(String cipherKey) {
        this.cipherKey = cipherKey;
    }

    public Crypto(String cipherKey, String customInitializationVector) {
        if (customInitializationVector != null) {
            this.initializationVector = customInitializationVector;
        }

        this.cipherKey = cipherKey;
    }

    public void initCiphers() throws PubNubException {
        if (INIT)
            return;
        try {

            keyBytes = new String(hexEncode(sha256(this.cipherKey.getBytes("UTF-8"))), "UTF-8")
                    .substring(0, 32)
                    .toLowerCase().getBytes("UTF-8");
            ivBytes = initializationVector.getBytes("UTF-8");
            INIT = true;
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(11, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    public static byte[] hexEncode(byte[] input) throws PubNubException {
        StringBuffer result = new StringBuffer();
        for (byte byt : input)
            result.append(Integer.toString((byt & 0xff) + 0x100, 16).substring(1));
        try {
            return result.toString().getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(12, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    private static PubNubError newCryptoError(int code, String message) {

        return PubNubErrorBuilder.createCryptoError(code, message);
    }

    public String encrypt(String input) throws PubNubException {
        try {
            initCiphers();
            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES");
            Cipher cipher = null;
            cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
            return new String(Base64.encode(cipher.doFinal(input.getBytes("UTF-8")), 0));
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidAlgorithmParameterException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (IllegalBlockSizeException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (BadPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        }

    }

    /**
     * Decrypt
     *
     * @param cipher_text
     * @return String
     * @throws PubNubException
     */
    public String decrypt(String cipher_text) throws PubNubException {
        try {
            initCiphers();
            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
            return new String(cipher.doFinal(Base64.decode(cipher_text, 0)), "UTF-8");
        } catch (IllegalArgumentException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (IllegalBlockSizeException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (BadPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidAlgorithmParameterException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        }
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    /**
     * Get MD5
     *
     * @param input
     * @return byte[]
     * @throws PubNubException
     */
    public static byte[] md5(String input) throws PubNubException {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("MD5");
            byte[] hashedBytes = digest.digest(input.getBytes("UTF-8"));
            return hashedBytes;
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(118, e.toString())).errormsg(e.getMessage()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(119, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    /**
     * Get SHA256
     *
     * @param input
     * @return byte[]
     * @throws PubNubException
     */
    public static byte[] sha256(byte[] input) throws PubNubException {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("SHA-256");
            byte[] hashedBytes = digest.digest(input);
            return hashedBytes;
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(111, e.toString())).errormsg(e.getMessage()).build();
        }
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_9208c65_6c5af23/rev_9208c65-6c5af23/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java;<<<<<<< MINE
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.hls.parser;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.SampleHolder;
import com.google.android.exoplayer.upstream.BufferPool;
import com.google.android.exoplayer.upstream.DataSource;
import com.google.android.exoplayer.util.Assertions;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Log;
import android.util.SparseArray;

import java.io.IOException;

/**
 * Facilitates the extraction of data from the MPEG-2 TS container format.
 */
public final class TsExtractor extends HlsExtractor {

  private static final String TAG = "TsExtractor";

  private static final int TS_PACKET_SIZE = 188;
  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
  private static final int TS_PAT_PID = 0;

  private static final int TS_STREAM_TYPE_MPA = 0x03;
  private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
  private static final int TS_STREAM_TYPE_AAC = 0x0F;
  private static final int TS_STREAM_TYPE_H264 = 0x1B;
  private static final int TS_STREAM_TYPE_ID3 = 0x15;
  private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1

  private static final long MAX_PTS = 0x1FFFFFFFFL;

  private final ParsableByteArray tsPacketBuffer;
  private final SparseArray<SampleQueue> sampleQueues; // Indexed by streamType
  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
  private final BufferPool bufferPool;
  private final long firstSampleTimestamp;
  private final ParsableBitArray tsScratch;

  // Accessed only by the loading thread.
  private int tsPacketBytesRead;
  private long timestampOffsetUs;
  private long lastPts;

  // Accessed by both the loading and consuming threads.
  private volatile boolean prepared;

  public TsExtractor(boolean shouldSpliceIn, long firstSampleTimestamp, BufferPool bufferPool) {
    super(shouldSpliceIn);
    this.firstSampleTimestamp = firstSampleTimestamp;
    this.bufferPool = bufferPool;
    tsScratch = new ParsableBitArray(new byte[3]);
    tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
    sampleQueues = new SparseArray<SampleQueue>();
    tsPayloadReaders = new SparseArray<TsPayloadReader>();
    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
    lastPts = Long.MIN_VALUE;
  }

  @Override
  public int getTrackCount() {
    Assertions.checkState(prepared);
    return sampleQueues.size();
  }

  @Override
  public MediaFormat getFormat(int track) {
    Assertions.checkState(prepared);
    return sampleQueues.valueAt(track).getMediaFormat();
  }

  @Override
  public boolean isPrepared() {
    return prepared;
  }

  @Override
  public void release() {
    for (int i = 0; i < sampleQueues.size(); i++) {
      sampleQueues.valueAt(i).release();
    }
  }

  @Override
  public long getLargestSampleTimestamp() {
    long largestParsedTimestampUs = Long.MIN_VALUE;
    for (int i = 0; i < sampleQueues.size(); i++) {
      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
    }
    return largestParsedTimestampUs;
  }

  @Override
  public boolean getSample(int track, SampleHolder holder) {
    Assertions.checkState(prepared);
    return sampleQueues.valueAt(track).getSample(holder);
  }

  @Override
  public void discardUntil(int track, long timeUs) {
    Assertions.checkState(prepared);
    sampleQueues.valueAt(track).discardUntil(timeUs);
  }

  @Override
  public boolean hasSamples(int track) {
    Assertions.checkState(prepared);
    return !sampleQueues.valueAt(track).isEmpty();
  }

  private boolean checkPrepared() {
    int pesPayloadReaderCount = sampleQueues.size();
    if (pesPayloadReaderCount == 0) {
      return false;
    }
    for (int i = 0; i < pesPayloadReaderCount; i++) {
      if (!sampleQueues.valueAt(i).hasMediaFormat()) {
        return false;
      }
    }
    return true;
  }

  @Override
  public int read(DataSource dataSource) throws IOException {
    int bytesRead = dataSource.read(tsPacketBuffer.data, tsPacketBytesRead,
        TS_PACKET_SIZE - tsPacketBytesRead);
    if (bytesRead == -1) {
      return -1;
    }

    tsPacketBytesRead += bytesRead;
    if (tsPacketBytesRead < TS_PACKET_SIZE) {
      // We haven't read the whole packet yet.
      return bytesRead;
    }

    // Reset before reading the packet.
    tsPacketBytesRead = 0;
    tsPacketBuffer.setPosition(0);
    tsPacketBuffer.setLimit(TS_PACKET_SIZE);

    int syncByte = tsPacketBuffer.readUnsignedByte();
    if (syncByte != TS_SYNC_BYTE) {
      return bytesRead;
    }

    tsPacketBuffer.readBytes(tsScratch, 3);
    tsScratch.skipBits(1); // transport_error_indicator
    boolean payloadUnitStartIndicator = tsScratch.readBit();
    tsScratch.skipBits(1); // transport_priority
    int pid = tsScratch.readBits(13);
    tsScratch.skipBits(2); // transport_scrambling_control
    boolean adaptationFieldExists = tsScratch.readBit();
    boolean payloadExists = tsScratch.readBit();
    // Last 4 bits of scratch are skipped: continuity_counter

    // Skip the adaptation field.
    if (adaptationFieldExists) {
      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
      tsPacketBuffer.skip(adaptationFieldLength);
    }

    // Read the payload.
    if (payloadExists) {
      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
      if (payloadReader != null) {
        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
      }
    }

    if (!prepared) {
      prepared = checkPrepared();
    }

    return bytesRead;
  }

  @Override
  protected SampleQueue getSampleQueue(int track) {
    return sampleQueues.valueAt(track);
  }

  /**
   * Adjusts a PTS value to the corresponding time in microseconds, accounting for PTS wraparound.
   *
   * @param pts The raw PTS value.
   * @return The corresponding time in microseconds.
   */
  /* package */ long ptsToTimeUs(long pts) {
    if (lastPts != Long.MIN_VALUE) {
      // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
      // and we need to snap to the one closest to lastPts.
      long closestWrapCount = (lastPts + (MAX_PTS / 2)) / MAX_PTS;
      long ptsWrapBelow = pts + (MAX_PTS * (closestWrapCount - 1));
      long ptsWrapAbove = pts + (MAX_PTS * closestWrapCount);
      pts = Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)
          ? ptsWrapBelow : ptsWrapAbove;
    }
    // Calculate the corresponding timestamp.
    long timeUs = (pts * C.MICROS_PER_SECOND) / 90000;
    // If we haven't done the initial timestamp adjustment, do it now.
    if (lastPts == Long.MIN_VALUE) {
      timestampOffsetUs = firstSampleTimestamp - timeUs;
    }
    // Record the adjusted PTS to adjust for wraparound next time.
    lastPts = pts;
    return timeUs + timestampOffsetUs;
  }

  /**
   * Parses TS packet payload data.
   */
  private abstract static class TsPayloadReader {

    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);

  }

  /**
   * Parses Program Association Table data.
   */
  private class PatReader extends TsPayloadReader {

    private final ParsableBitArray patScratch;

    public PatReader() {
      patScratch = new ParsableBitArray(new byte[4]);
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      // Skip pointer.
      if (payloadUnitStartIndicator) {
        int pointerField = data.readUnsignedByte();
        data.skip(pointerField);
      }

      data.readBytes(patScratch, 3);
      patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
      int sectionLength = patScratch.readBits(12);
      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
      // section_number (8), last_section_number (8)
      data.skip(5);

      int programCount = (sectionLength - 9) / 4;
      for (int i = 0; i < programCount; i++) {
        data.readBytes(patScratch, 4);
        patScratch.skipBits(19); // program_number (16), reserved (3)
        int pid = patScratch.readBits(13);
        tsPayloadReaders.put(pid, new PmtReader());
      }

      // Skip CRC_32.
    }

  }

  /**
   * Parses Program Map Table.
   */
  private class PmtReader extends TsPayloadReader {

    private final ParsableBitArray pmtScratch;

    public PmtReader() {
      pmtScratch = new ParsableBitArray(new byte[5]);
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      // Skip pointer.
      if (payloadUnitStartIndicator) {
        int pointerField = data.readUnsignedByte();
        data.skip(pointerField);
      }

      data.readBytes(pmtScratch, 3);
      pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
      int sectionLength = pmtScratch.readBits(12);

      // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
      // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
      // Skip the rest of the PMT header.
      data.skip(7);

      data.readBytes(pmtScratch, 2);
      pmtScratch.skipBits(4);
      int programInfoLength = pmtScratch.readBits(12);

      // Skip the descriptors.
      data.skip(programInfoLength);

      int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
          - programInfoLength - 4 /* CRC size */;
      while (entriesSize > 0) {
        data.readBytes(pmtScratch, 5);
        int streamType = pmtScratch.readBits(8);
        pmtScratch.skipBits(3); // reserved
        int elementaryPid = pmtScratch.readBits(13);
        pmtScratch.skipBits(4); // reserved
        int esInfoLength = pmtScratch.readBits(12);

        // Skip the descriptors.
        data.skip(esInfoLength);
        entriesSize -= esInfoLength + 5;

        if (sampleQueues.get(streamType) != null) {
          continue;
        }

        ElementaryStreamReader pesPayloadReader = null;
        switch (streamType) {
          case TS_STREAM_TYPE_MPA:
          case TS_STREAM_TYPE_MPA_LSF:
            pesPayloadReader = new MpaReader(bufferPool);
            break;
          case TS_STREAM_TYPE_AAC:
            pesPayloadReader = new AdtsReader(bufferPool);
            break;
          case TS_STREAM_TYPE_H264:
            SeiReader seiReader = new SeiReader(bufferPool);
            sampleQueues.put(TS_STREAM_TYPE_EIA608, seiReader);
            pesPayloadReader = new H264Reader(bufferPool, seiReader);
            break;
          case TS_STREAM_TYPE_ID3:
            pesPayloadReader = new Id3Reader(bufferPool);
            break;
        }

        if (pesPayloadReader != null) {
          sampleQueues.put(streamType, pesPayloadReader);
          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
        }
      }

      // Skip CRC_32.
    }

  }

  /**
   * Parses PES packet data and extracts samples.
   */
  private class PesReader extends TsPayloadReader {

    private static final int STATE_FINDING_HEADER = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_HEADER_EXTENSION = 2;
    private static final int STATE_READING_BODY = 3;

    private static final int HEADER_SIZE = 9;
    private static final int MAX_HEADER_EXTENSION_SIZE = 5;

    private final ParsableBitArray pesScratch;
    private final ElementaryStreamReader pesPayloadReader;

    private int state;
    private int bytesRead;
    private boolean bodyStarted;

    private boolean ptsFlag;
    private int extendedHeaderLength;

    private int payloadSize;

    private long timeUs;

    public PesReader(ElementaryStreamReader pesPayloadReader) {
      this.pesPayloadReader = pesPayloadReader;
      pesScratch = new ParsableBitArray(new byte[HEADER_SIZE]);
      state = STATE_FINDING_HEADER;
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      if (payloadUnitStartIndicator) {
        switch (state) {
          case STATE_FINDING_HEADER:
          case STATE_READING_HEADER:
            // Expected.
            break;
          case STATE_READING_HEADER_EXTENSION:
            Log.w(TAG, "Unexpected start indicator reading extended header");
            break;
          case STATE_READING_BODY:
            // If payloadSize == -1 then the length of the previous packet was unspecified, and so
            // we only know that it's finished now that we've seen the start of the next one. This
            // is expected. If payloadSize != -1, then the length of the previous packet was known,
            // but we didn't receive that amount of data. This is not expected.
            if (payloadSize != -1) {
              Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
            }
            // Either way, if the body was started, notify the reader that it has now finished.
            if (bodyStarted) {
              pesPayloadReader.packetFinished();
            }
            break;
        }
        setState(STATE_READING_HEADER);
      }

      while (data.bytesLeft() > 0) {
        switch (state) {
          case STATE_FINDING_HEADER:
            data.skip(data.bytesLeft());
            break;
          case STATE_READING_HEADER:
            if (continueRead(data, pesScratch.getData(), HEADER_SIZE)) {
              setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
            }
            break;
          case STATE_READING_HEADER_EXTENSION:
            int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
            // Read as much of the extended header as we're interested in, and skip the rest.
            if (continueRead(data, pesScratch.getData(), readLength)
                && continueRead(data, null, extendedHeaderLength)) {
              parseHeaderExtension();
              bodyStarted = false;
              setState(STATE_READING_BODY);
            }
            break;
          case STATE_READING_BODY:
            readLength = data.bytesLeft();
            int padding = payloadSize == -1 ? 0 : readLength - payloadSize;
            if (padding > 0) {
              readLength -= padding;
              data.setLimit(data.getPosition() + readLength);
            }
            pesPayloadReader.consume(data, timeUs, !bodyStarted);
            bodyStarted = true;
            if (payloadSize != -1) {
              payloadSize -= readLength;
              if (payloadSize == 0) {
                pesPayloadReader.packetFinished();
                setState(STATE_READING_HEADER);
              }
            }
            break;
        }
      }
    }

    private void setState(int state) {
      this.state = state;
      bytesRead = 0;
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read, or {@code null} to skip.
     * @param targetLength The target length of the read.
     * @return Whether the target length has been reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
      int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
      if (bytesToRead <= 0) {
        return true;
      } else if (target == null) {
        source.skip(bytesToRead);
      } else {
        source.readBytes(target, bytesRead, bytesToRead);
      }
      bytesRead += bytesToRead;
      return bytesRead == targetLength;
    }

    private boolean parseHeader() {
      pesScratch.setPosition(0);
      int startCodePrefix = pesScratch.readBits(24);
      if (startCodePrefix != 0x000001) {
        Log.w(TAG, "Unexpected start code prefix: " + startCodePrefix);
        payloadSize = -1;
        return false;
      }

      pesScratch.skipBits(8); // stream_id.
      int packetLength = pesScratch.readBits(16);
      // First 8 bits are skipped: '10' (2), PES_scrambling_control (2), PES_priority (1),
      // data_alignment_indicator (1), copyright (1), original_or_copy (1)
      pesScratch.skipBits(8);
      ptsFlag = pesScratch.readBit();
      // DTS_flag (1), ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
      // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
      pesScratch.skipBits(7);
      extendedHeaderLength = pesScratch.readBits(8);

      if (packetLength == 0) {
        payloadSize = -1;
      } else {
        payloadSize = packetLength + 6 /* packetLength does not include the first 6 bytes */
            - HEADER_SIZE - extendedHeaderLength;
      }
      return true;
    }

    private void parseHeaderExtension() {
      pesScratch.setPosition(0);
      timeUs = 0;
      if (ptsFlag) {
        pesScratch.skipBits(4); // '0010'
        long pts = pesScratch.readBitsLong(3) << 30;
        pesScratch.skipBits(1); // marker_bit
        pts |= pesScratch.readBitsLong(15) << 15;
        pesScratch.skipBits(1); // marker_bit
        pts |= pesScratch.readBitsLong(15);
        pesScratch.skipBits(1); // marker_bit
        timeUs = ptsToTimeUs(pts);
      }
    }

  }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.util;

import com.google.android.exoplayer.MediaFormat;

import java.util.Collections;

/**
 * Utility methods for parsing AC-3 headers.
 */
public final class Ac3Util {

  /** Sample rates, indexed by fscod. */
  private static final int[] SAMPLE_RATES = new int[] {48000, 44100, 32000};
  /** Channel counts, indexed by acmod. */
  private static final int[] CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
  /** Nominal bitrates in kbps, indexed by bit_rate_code. */
  private static final int[] BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,
      224, 256, 320, 384, 448, 512, 576, 640};
  /** 16-bit words per sync frame, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.) */
  private static final int[] FRMSIZECOD_TO_FRAME_SIZE_44_1 = new int[] {69, 87, 104, 121, 139, 174,
    208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};

  /**
   * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to
   * ETSI TS 102 366 Annex F.
   */
  public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data) {
    // fscod (sample rate code)
    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
    int sampleRate = SAMPLE_RATES[fscod];
    int nextByte = data.readUnsignedByte();
    // Map acmod (audio coding mode) onto a channel count.
    int channelCount = CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
    // lfeon (low frequency effects on)
    if ((nextByte & 0x04) != 0) {
      channelCount++;
    }
    // Map bit_rate_code onto a bitrate in bit/s.
    int bitrate = BITRATES[((nextByte & 0x03) << 3) + (data.readUnsignedByte() >> 5)] * 1000;
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
        MediaFormat.NO_VALUE, channelCount, sampleRate, bitrate, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 format given {@code data} containing the EC3SpecificBox according to
   * ETSI TS 102 366 Annex F.
   */
  public static MediaFormat parseAnnexFEAc3Format(ParsableByteArray data) {
    data.skipBytes(2); // Skip data_rate and num_ind_sub.

    // Read only the first substream.
    // TODO: Read later substreams?
    // fscod (sample rate code)
    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
    int sampleRate = SAMPLE_RATES[fscod];
    int nextByte = data.readUnsignedByte();
    // Map acmod (audio coding mode) onto a channel count.
    int channelCount = CHANNEL_COUNTS[(nextByte & 0x0E) >> 1];
    // lfeon (low frequency effects on)
    if ((nextByte & 0x01) != 0) {
      channelCount++;
    }
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_EC3, MediaFormat.NO_VALUE,
        channelCount, sampleRate, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 format given {@code data} containing the frame header starting from the sync
   * word.
   *
   * @param data Data to parse, positioned at the start of the syncword.
   * @return AC-3 format parsed from data in the header.
   */
  public static MediaFormat parseFrameAc3Format(ParsableBitArray data) {
    // Skip syncword and crc1.
    data.skipBits(4 * 8);

    int fscod = data.readBits(2);
    int frmsizecod = data.readBits(6);
    data.skipBits(8); // bsid (5 bits) + bsmod (3 bits)
    int acmod = data.readBits(3);
    if ((acmod & 0x01) != 0 && acmod != 1) {
      data.skipBits(2); // cmixlev
    }
    if ((acmod & 0x04) != 0) {
      data.skipBits(2); // surmixlev
    }
    if (acmod == 0x02) {
      data.skipBits(2); // dsurmod
    }
    boolean lfeon = data.readBit();
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
        MediaFormat.NO_VALUE, CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0), SAMPLE_RATES[fscod],
        BITRATES[frmsizecod / 2] * 1000, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 frame size in bytes given {@code data} containing the frame header starting
   * from the sync word.
   *
   * @param data Data to parse, positioned at the start of the syncword.
   * @return The frame size parsed from data in the header.
   */
  public static int parseFrameSize(ParsableBitArray data) {
    // Skip syncword and crc1.
    data.skipBits(4 * 8);

    int fscod = data.readBits(2);
    int frmsizecod = data.readBits(6);
    int sampleRate = SAMPLE_RATES[fscod];
    int bitrate = BITRATES[frmsizecod / 2];
    if (sampleRate == 32000) {
      return 6 * bitrate;
    } else if (sampleRate == 44100) {
      return 2 * (FRMSIZECOD_TO_FRAME_SIZE_44_1[frmsizecod / 2] + (frmsizecod % 2));
    } else { // sampleRate == 48000
      return 4 * bitrate;
    }
  }

  private Ac3Util() {
    // Prevent instantiation.
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java;<<<<<<< MINE
=======
  private static final int TS_STREAM_TYPE_ATSC_AC3 = 0x81;
  private static final int TS_STREAM_TYPE_DVB_AC3 = 0x06;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java;<<<<<<< MINE
=======
          case TS_STREAM_TYPE_ATSC_AC3:
          case TS_STREAM_TYPE_DVB_AC3:
            pesPayloadReader = new Ac3Reader(output.track(streamType));
            break;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/TsExtractor.java;<<<<<<< MINE
            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264),
                seiReader);
=======
            pesPayloadReader = new H264Reader(output.track(TS_STREAM_TYPE_H264), seiReader);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.Ac3Util;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

/**
 * Parses a continuous AC-3 byte stream and extracts individual samples.
 */
/* package */ final class Ac3Reader extends ElementaryStreamReader {

  private static final int STATE_FINDING_SYNC = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_SAMPLE = 2;

  private static final int HEADER_SIZE = 8;

  private final ParsableBitArray headerScratchBits;
  private final ParsableByteArray headerScratchBytes;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWas0B;

  // Used when parsing the header.
  private long frameDurationUs;
  private MediaFormat mediaFormat;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public Ac3Reader(TrackOutput output) {
    super(output);
    headerScratchBits = new ParsableBitArray(new byte[HEADER_SIZE]);
    headerScratchBytes = new ParsableByteArray(headerScratchBits.getData());
    state = STATE_FINDING_SYNC;
  }

  public void seek() {
    state = STATE_FINDING_SYNC;
    bytesRead = 0;
    lastByteWas0B = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_SYNC:
          if (skipToNextSync(data)) {
            state = STATE_READING_HEADER;
            headerScratchBytes.data[0] = 0x0B;
            headerScratchBytes.data[1] = 0x77;
            bytesRead = 2;
          }
          break;
        case STATE_READING_HEADER:
          if (continueRead(data, headerScratchBytes.data, HEADER_SIZE)) {
            parseHeader();
            headerScratchBytes.setPosition(0);
            output.sampleData(headerScratchBytes, HEADER_SIZE);
            state = STATE_READING_SAMPLE;
          }
          break;
        case STATE_READING_SAMPLE:
          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
          output.sampleData(data, bytesToRead);
          bytesRead += bytesToRead;
          if (bytesRead == sampleSize) {
            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
            timeUs += frameDurationUs;
            state = STATE_FINDING_SYNC;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
   * that the data should be written into {@code target} starting from an offset of zero.
   *
   * @param source The source from which to read.
   * @param target The target into which data is to be read.
   * @param targetLength The target length of the read.
   * @return Whether the target length was reached.
   */
  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
    source.readBytes(target, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    return bytesRead == targetLength;
  }

  /**
   * Locates the next sync word, advancing the position to the byte that immediately follows it.
   * If a sync word was not located, the position is advanced to the limit.
   *
   * @param pesBuffer The buffer whose position should be advanced.
   * @return True if a sync word position was found. False otherwise.
   */
  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
    while (pesBuffer.bytesLeft() > 0) {
      if (!lastByteWas0B) {
        lastByteWas0B = pesBuffer.readUnsignedByte() == 0x0B;
        continue;
      }
      int secondByte = pesBuffer.readUnsignedByte();
      if (secondByte == 0x77) {
        lastByteWas0B = false;
        return true;
      } else {
        lastByteWas0B = secondByte == 0x0B;
      }
    }
    return false;
  }

  /**
   * Parses the sample header.
   */
  private void parseHeader() {
    if (mediaFormat == null) {
      headerScratchBits.setPosition(0);
      mediaFormat = Ac3Util.parseFrameAc3Format(headerScratchBits);
      output.format(mediaFormat);
    }
    headerScratchBits.setPosition(0);
    sampleSize = Ac3Util.parseFrameSize(headerScratchBits);
    frameDurationUs = (int) (1000000L * 8 * sampleSize / mediaFormat.bitrate);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
    public void testSubscribeWithEncryption() {
        final AtomicInteger atomic = new AtomicInteger(0);
        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/ch2,ch1/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14718972508742569\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":512,\"i\":\"ff374d0b-b866-40db-9ced-42d205bb808b\",\"p\":{\"t\":\"14718972508739738\",\"r\":1},\"k\":\"demo-36\",\"c\":\"max_ch1\",\"d\":\"6QoqmS9CnB3W9+I4mhmL7w==\"}]}")));

        pubnub.getConfiguration().setCipherKey("hello");

        pubnub.addListener(new SubscribeCallback() {
            @Override
            public void status(PubNub pubnub, PNStatus status) {
            }

            @Override
            public void message(PubNub pubnub, PNMessageResult message) {
                List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v2/subscribe.*")));
                assertTrue(requests.size() > 0);
                assertEquals("hey", message.getMessage().get("text").asText());
                atomic.addAndGet(1);
            }

            @Override
            public void presence(PubNub pubnub, PNPresenceEventResult presence) {
            }
        });


        pubnub.subscribe().channels(Arrays.asList("ch1", "ch2")).execute();

        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.Matchers.greaterThan(0));

    }

    @Test
    public void testSubscribeWithEncryptionPNOther() {
        final AtomicInteger atomic = new AtomicInteger(0);
        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/ch2,ch1/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14718972508742569\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":512,\"i\":\"ff374d0b-b866-40db-9ced-42d205bb808b\",\"p\":{\"t\":\"14718972508739738\",\"r\":1},\"k\":\"demo-36\",\"c\":\"max_ch1\",\"d\":{\"pn_other\":\"6QoqmS9CnB3W9+I4mhmL7w==\"}}]}")));

        pubnub.getConfiguration().setCipherKey("hello");

        pubnub.addListener(new SubscribeCallback() {
            @Override
            public void status(PubNub pubnub, PNStatus status) {
            }

            @Override
            public void message(PubNub pubnub, PNMessageResult message) {
                List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v2/subscribe.*")));
                assertTrue(requests.size() > 0);
                assertEquals("hey", message.getMessage().get("pn_other").get("text").asText());
                atomic.addAndGet(1);
            }

            @Override
            public void presence(PubNub pubnub, PNPresenceEventResult presence) {
            }
        });


        pubnub.subscribe().channels(Arrays.asList("ch1", "ch2")).execute();

        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.Matchers.greaterThan(0));

    }

    @Test
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
        Assert.assertEquals("4.0.8", version);
=======
        Assert.assertEquals("4.0.9", version);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/PubNub.java;<<<<<<< MINE
    private static final String SDK_VERSION = "4.0.8";
=======
    private static final String SDK_VERSION = "4.0.9";
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
=======
import com.fasterxml.jackson.databind.node.ObjectNode;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
=======
        // if we do not have a crypto key, there is no way to process the node; let's return.
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
=======
        String inputText;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
=======
        if (input.isObject() && input.has("pn_other")) {
            inputText = input.get("pn_other").asText();
        } else {
            inputText = input.asText();
        }

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            outputText = crypto.decrypt(input.toString());
=======
            outputText = crypto.decrypt(inputText);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_53e6287_5f2334a/rev_53e6287-5f2334a/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
=======
        // inject the decoded response into the payload
        if (input.isObject() && input.has("pn_other")) {
            ObjectNode objectNode = (ObjectNode) input;
            objectNode.set("pn_other", outputObject);
            outputObject = objectNode;
        }

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Message\"},\"b\":\"coolChan-bnel\"}]}")));
=======
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Message\"},\"b\":\"coolChannel\"}]}")));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
                assertTrue(requests.size() >= 1);
                assertEquals("Message", message.getMessage().get("text").asText());
                assertEquals("coolChannel", message.getChannel());
                assertEquals(null, message.getSubscription());
                gotMessage.set(true);
            }

            @Override
            public void presence(PubNub pubnub, PNPresenceEventResult presence) {
            }
        });


        pubnub.subscribe().channels(Arrays.asList("ch1", "ch2")).execute();

        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotMessage, org.hamcrest.core.IsEqual.equalTo(true));
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotStatus, org.hamcrest.core.IsEqual.equalTo(1));

    }

    @Test
    public void testNamingSubscribeChannelGroupBuilder() {
        final AtomicInteger gotStatus = new AtomicInteger();
        final AtomicBoolean gotMessage = new AtomicBoolean();
        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/ch2,ch1/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Message\"},\"b\":\"coolChannelGroup\"}]}")));

        pubnub.addListener(new SubscribeCallback() {
            @Override
            public void status(PubNub pubnub, PNStatus status) {

                if (status.getCategory() == PNStatusCategory.PNConnectedCategory) {
                    gotStatus.addAndGet(1);
                }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
            }

            @Override
            public void message(PubNub pubnub, PNMessageResult message) {
                List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v2/subscribe.*")));
                assertTrue(requests.size() >= 1);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
                assertEquals("coolChannel", message.getChannel());
                assertEquals("coolChannelGroup", message.getSubscription());
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
    public void testPresenceSubscribeBuilder() {
        final AtomicInteger gotStatus = new AtomicInteger();
        final AtomicBoolean gotMessage = new AtomicBoolean();
        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/ch2,ch1/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14614512228786519\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"p\":{\"t\":\"14614512228418349\",\"r\":2},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel-pnpres\",\"d\":{\"action\": \"join\", \"timestamp\": 1461451222, \"uuid\": \"4a6d5df7-e301-4e73-a7b7-6af9ab484eb0\", \"occupancy\": 1},\"b\":\"coolChannel-pnpres\"}]}")));

        pubnub.addListener(new SubscribeCallback() {
            @Override
            public void status(PubNub pubnub, PNStatus status) {

                if (status.getCategory() == PNStatusCategory.PNConnectedCategory) {
                    gotStatus.addAndGet(1);
                }

            }

            @Override
            public void message(PubNub pubnub, PNMessageResult message) {
            }

            @Override
            public void presence(PubNub pubnub, PNPresenceEventResult presence) {
                List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v2/subscribe.*")));
                assertTrue(requests.size() >= 1);
                assertEquals("coolChannel", presence.getChannel());
                assertEquals(null, presence.getSubscription());
                gotMessage.set(true);
            }
        });


        pubnub.subscribe().channels(Arrays.asList("ch1", "ch2")).execute();

        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotMessage, org.hamcrest.core.IsEqual.equalTo(true));
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotStatus, org.hamcrest.core.IsEqual.equalTo(1));

    }

    @Test
    public void testPresenceChannelGroupSubscribeBuilder() {
        final AtomicInteger gotStatus = new AtomicInteger();
        final AtomicBoolean gotMessage = new AtomicBoolean();
        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/ch2,ch1/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14614512228786519\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"p\":{\"t\":\"14614512228418349\",\"r\":2},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel-pnpres\",\"d\":{\"action\": \"join\", \"timestamp\": 1461451222, \"uuid\": \"4a6d5df7-e301-4e73-a7b7-6af9ab484eb0\", \"occupancy\": 1},\"b\":\"coolChannelGroup-pnpres\"}]}")));

        pubnub.addListener(new SubscribeCallback() {
            @Override
            public void status(PubNub pubnub, PNStatus status) {

                if (status.getCategory() == PNStatusCategory.PNConnectedCategory) {
                    gotStatus.addAndGet(1);
                }

            }

            @Override
            public void message(PubNub pubnub, PNMessageResult message) {
            }

            @Override
            public void presence(PubNub pubnub, PNPresenceEventResult presence) {
                List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v2/subscribe.*")));
                assertTrue(requests.size() >= 1);
                assertEquals("coolChannel", presence.getChannel());
                assertEquals("coolChannelGroup", presence.getSubscription());
                gotMessage.set(true);
            }
        });


        pubnub.subscribe().channels(Arrays.asList("ch1", "ch2")).execute();

        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotMessage, org.hamcrest.core.IsEqual.equalTo(true));
        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(gotStatus, org.hamcrest.core.IsEqual.equalTo(1));

    }


    @Test
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
=======
                assertTrue(requests.size() >= 1);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE

=======
                assertTrue(requests.size() >= 1);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE

=======
                assertTrue(requests.size() >= 1);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/managers/SubscriptionManagerTest.java;<<<<<<< MINE
        final AtomicBoolean messageRecieved = new AtomicBoolean();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
    public void GetVersionAndTimeStamp() throws PubNubException {
=======
    public void getVersionAndTimeStamp() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/PubNubTest.java;<<<<<<< MINE
        Assert.assertEquals("4.0.10", version);
=======
        Assert.assertEquals("4.0.11", version);
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
        SubscribeEnvelope subscribeEnvelope = instance.sync();
=======
        instance.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
    public void StopAndReconnect() throws PubNubException {
=======
    public void stopAndReconnect() throws PubNubException {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/TestPojo.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.pubsub;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Created by Max on 9/8/16.
 */
@AllArgsConstructor
@Getter
class TestPojo {
    String field1;
    String field2;
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/push/ListPushProvisionsTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/push/ModifyPushChannelsForDeviceTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
=======
import com.pubnub.api.PubNubException;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
import com.pubnub.api.PubNubException;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
import org.junit.Assert;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/TimeEndpointTest.java;<<<<<<< MINE
        assertEquals(response.getTimetoken(), "14593046077243110");
=======
        assertTrue(response.getTimetoken().equals(14593046077243110L));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channel("ch1").sync();
=======
        partialAudit.channel("ch1").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
=======
        partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.authKeys(Arrays.asList("key1")).channel(null).channelGroup(null).sync();
=======
        partialAudit.authKeys(Arrays.asList("key1")).channel(null).channelGroup(null).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
=======
import com.pubnub.api.endpoints.TestHarness;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
import java.util.ArrayList;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
import static com.github.tomakehurst.wiremock.client.WireMock.matching;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE

=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.channels(Arrays.asList("ch1")).manage(true).sync();
=======
        partialGrant.channels(Arrays.asList("ch1")).manage(true).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
=======
        partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
import com.pubnub.api.endpoints.channel_groups.RemoveChannelChannelGroup;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
import com.pubnub.api.models.consumer.channel_group.PNChannelGroupsRemoveChannelResult;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
import java.util.Arrays;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertNotNull;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/EndpointTest.java;<<<<<<< MINE
                        return null;
=======
                        return this;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
import static org.hamcrest.MatcherAssert.assertThat;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAddChannelResult response = partialAddChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
=======
        partialAddChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAddChannelResult response = partialAddChannelChannelGroup.channelGroup("").channels(Arrays.asList("ch1", "ch2")).sync();
=======
        partialAddChannelChannelGroup.channelGroup("").channels(Arrays.asList("ch1", "ch2")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAddChannelResult response = partialAddChannelChannelGroup.channelGroup("groupA").sync();
=======
        partialAddChannelChannelGroup.channelGroup("groupA").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAddChannelResult response = partialAddChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
=======
        partialAddChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(15, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(15, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
import com.pubnub.api.models.consumer.channel_group.PNChannelGroupsListAllResult;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
import static org.junit.Assert.assertTrue;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsDeleteGroupResult response = partialDeleteChannelGroup.sync();
=======
        partialDeleteChannelGroup.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsDeleteGroupResult response = partialDeleteChannelGroup.channelGroup("").sync();
=======
        partialDeleteChannelGroup.channelGroup("").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsDeleteGroupResult response = partialDeleteChannelGroup.channelGroup("groupA").sync();
=======
        partialDeleteChannelGroup.channelGroup("groupA").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroupEndpointTest.java;<<<<<<< MINE
=======
import com.pubnub.api.endpoints.TestHarness;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroupEndpointTest.java;<<<<<<< MINE
import com.pubnub.api.endpoints.TestHarness;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroupEndpointTest.java;<<<<<<< MINE
import static org.junit.Assert.assertTrue;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroupEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/ListAllChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsListAllResult response = partialChannelGroup.sync();
=======
        partialChannelGroup.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
=======
import com.pubnub.api.endpoints.TestHarness;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
import com.pubnub.api.endpoints.TestHarness;
import com.pubnub.api.models.consumer.channel_group.PNChannelGroupsListAllResult;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
import static org.junit.Assert.assertTrue;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.sync();
=======
        partialAllChannelsChannelGroup.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.channelGroup("").sync();
=======
        partialAllChannelsChannelGroup.channelGroup("").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.channelGroup("groupA").sync();
=======
        partialAllChannelsChannelGroup.channelGroup("groupA").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsRemoveChannelResult response = partialRemoveChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
=======
        partialRemoveChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsRemoveChannelResult response = partialRemoveChannelChannelGroup.channelGroup("groupA").sync();
=======
        partialRemoveChannelChannelGroup.channelGroup("groupA").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        PNChannelGroupsRemoveChannelResult response = partialRemoveChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
=======
        partialRemoveChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));

=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        PNWhereNowResult response = partialWhereNow.sync();
=======
        partialWhereNow.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        PNWhereNowResult response = partialWhereNow.sync();
=======
        partialWhereNow.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        PNWhereNowResult response = partialWhereNow.sync();
=======
        partialWhereNow.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/WhereNowEndpointTest.java;<<<<<<< MINE
        PNWhereNowResult response = partialWhereNow.sync();
=======
        partialWhereNow.sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
        PNHereNowResult response =  partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
=======
        partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
        PNHereNowResult response =  partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
=======
        partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/HereNowEndpointTest.java;<<<<<<< MINE
        PNHereNowResult response =  partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
=======
        partialHereNow.channels(Arrays.asList("ch1", "ch2")).includeState(true).sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        PNGetStateResult result = partialGetState.uuid("sampleUUID").sync();
=======
        partialGetState.uuid("sampleUUID").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
=======
        partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        Awaitility.await().atMost(5, TimeUnit.SECONDS)
                .untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
=======
        Awaitility.await().atMost(5, TimeUnit.SECONDS).untilAtomic(atomic, org.hamcrest.core.IsEqual.equalTo(1));
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
=======
        partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
=======
        partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/presence/LeaveTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/Base64Test.java;<<<<<<< MINE
=======
import java.nio.charset.Charset;

>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/Base64Test.java;<<<<<<< MINE
       Assert.assertEquals("YWJj", Base64.encodeToString("abc".getBytes(), 0).trim());
=======
       Assert.assertEquals("YWJj", Base64.encodeToString("abc".getBytes(Charset.forName("UTF-8")), 0).trim());
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/PubNubExceptionTest.java;<<<<<<< MINE
import com.fasterxml.jackson.databind.JsonNode;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/PubNubExceptionTest.java;<<<<<<< MINE
import com.pubnub.api.PubNubError;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/PubNubExceptionTest.java;<<<<<<< MINE
=======
        wireMockRule.start();
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/PubNubExceptionTest.java;<<<<<<< MINE
        PubNubError pubnubError = null;
        int pnErrorCode= - 1;
        int pnErroCodeExtended = -1;
        JsonNode pnErrorJNode = null;
        String pnErrorMessage = null;
        String pnErrorString = null;
        String response = null;
        String erroMsg = null;
        JsonNode jNode = null;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/PubNubExceptionTest.java;<<<<<<< MINE
            pubnubError = error.getPubnubError();
            pnErrorCode = pubnubError.getErrorCode();
            pnErroCodeExtended = pubnubError.getErrorCodeExtended();
            pnErrorJNode = pubnubError.getErrorObject();
            pnErrorMessage = pubnubError.getMessage();
            pnErrorString = pubnubError.getErrorString();
            response = error.getResponse();
            erroMsg = error.getErrormsg();
            jNode = error.getJso();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/PubNub.java;<<<<<<< MINE
    private static final String SDK_VERSION = "4.0.10";
=======
    private static final String SDK_VERSION = "4.0.11";
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
        if (channel.equals(subscriptionMatch)) {
=======
        if (channel != null && channel.equals(subscriptionMatch)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            String associatedChannel = message.getChannel();
            String associatedSubscription = message.getSubscriptionMatch();
=======
            String strippedPresenceChannel = null;
            String strippedPresenceSubscription = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            if (associatedChannel != null) {
                associatedChannel = PubNubUtil.replaceLast(associatedChannel, "-pnpres", "");
=======
            if (channel != null) {
                strippedPresenceChannel = PubNubUtil.replaceLast(channel, "-pnpres", "");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
            if (associatedSubscription != null) {
                associatedSubscription = PubNubUtil.replaceLast(associatedSubscription, "-pnpres", "");
=======
            if (subscriptionMatch != null) {
                strippedPresenceSubscription = PubNubUtil.replaceLast(subscriptionMatch, "-pnpres", "");
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
                    .channel(associatedChannel)
                    .subscription(associatedSubscription)
=======
                    .channel(strippedPresenceChannel)
                    .subscription(strippedPresenceSubscription)
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/main/java/com/pubnub/api/workers/SubscribeMessageWorker.java;<<<<<<< MINE
                    .channel(message.getChannel())
                    .subscription(message.getSubscriptionMatch())
=======
                    .channel(channel)
                    .subscription(subscriptionMatch)
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_fcc7d33_05ec7d3/rev_fcc7d33-05ec7d3/src/main/java/com/corundumstudio/socketio/SocketIOServer.java;<<<<<<< MINE
=======
        bootstrap.childOption(ChannelOption.SO_LINGER, config.getSoLinger());
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_fcc7d33_05ec7d3/rev_fcc7d33-05ec7d3/src/main/java/com/corundumstudio/socketio/SocketIOServer.java;<<<<<<< MINE
        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;<<<<<<< MINE
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java;<<<<<<< MINE
      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
=======
      player.sendMessage(videoRenderer, LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/demo_misc/vp9_opus_sw/src/main/java/com/google/android/exoplayer/demo/vp9opus/VideoPlayer.java;<<<<<<< MINE
    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_VPX_SURFACE_VIEW,
=======
    player.sendMessage(renderers[0], LibvpxVideoTrackRenderer.MSG_SET_OUTPUT_BUFFER_RENDERER,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBufferRenderer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.ext.vp9;

/**
 * Renders the {@link VpxOutputBuffer}.
 */
public interface VpxOutputBufferRenderer {

  /**
   * Sets the output buffer to be rendered.
   */
  void setOutputBuffer(VpxOutputBuffer outputBuffer);

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.InputBuffer;
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;
=======
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.VpxInputBuffer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  public static final int MSG_SET_VPX_SURFACE_VIEW = 2;
=======
  /**
   * The type of a message that can be passed to an instance of this class via
   * {@link ExoPlayer#sendMessage} or {@link ExoPlayer#blockingSendMessage}. The message object
   * should be the target {@link VpxOutputBufferRenderer}, or null.
   */
  public static final int MSG_SET_OUTPUT_BUFFER_RENDERER = 2;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private InputBuffer inputBuffer;
  private OutputBuffer outputBuffer;
=======
  private VpxInputBuffer inputBuffer;
  private VpxOutputBuffer outputBuffer;
  private VpxOutputBuffer renderedOutputBuffer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private VpxVideoSurfaceView vpxVideoSurfaceView;
=======
  private VpxOutputBufferRenderer outputBufferRenderer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    checkForDiscontinuity(positionUs);
=======
    try {
      checkForDiscontinuity(positionUs);
    } catch (VpxDecoderException e) {
      notifyDecoderError(e);
      throw new ExoPlaybackException(e);
    }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
      releaseOutputBuffer();
=======
      releaseOutputBuffer(outputBuffer);
      outputBuffer = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
      releaseOutputBuffer();
=======
      releaseOutputBuffer(outputBuffer);
      outputBuffer = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && vpxVideoSurfaceView != null) {
      vpxVideoSurfaceView.renderFrame(outputBuffer);
=======
    } else if (outputBuffer.mode == VpxDecoder.OUTPUT_MODE_YUV && outputBufferRenderer != null) {
      outputBufferRenderer.setOutputBuffer(outputBuffer);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    releaseOutputBuffer();
=======
    // Release the output buffer we rendered during the previous cycle, now that we delivered a new
    // buffer.
    releaseOutputBuffer(renderedOutputBuffer);
    renderedOutputBuffer = outputBuffer;
    outputBuffer = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void releaseOutputBuffer() throws VpxDecoderException {
    decoder.releaseOutputBuffer(outputBuffer);
    outputBuffer = null;
=======
  private void releaseOutputBuffer(VpxOutputBuffer buffer) throws VpxDecoderException {
    if (buffer != null) {
      decoder.releaseOutputBuffer(buffer);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void renderRgbFrame(OutputBuffer outputBuffer, boolean scale) {
=======
  private void renderRgbFrame(VpxOutputBuffer outputBuffer, boolean scale) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void checkForDiscontinuity(long positionUs) {
=======
  private void checkForDiscontinuity(long positionUs) throws VpxDecoderException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void flushDecoder() {
=======
  private void flushDecoder() throws VpxDecoderException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
=======
    VpxOutputBuffer bufferToRelease = outputBuffer;
    // Set this to null now because releaseOutputBuffer could throw an exception.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
=======
    releaseOutputBuffer(bufferToRelease);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    } else if (messageType == MSG_SET_VPX_SURFACE_VIEW) {
      setVpxVideoSurfaceView((VpxVideoSurfaceView) message);
=======
    } else if (messageType == MSG_SET_OUTPUT_BUFFER_RENDERER) {
      setOutputBufferRenderer((VpxOutputBufferRenderer) message);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    vpxVideoSurfaceView = null;
=======
    outputBufferRenderer = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void setVpxVideoSurfaceView(VpxVideoSurfaceView vpxVideoSurfaceView) {
    if (this.vpxVideoSurfaceView == vpxVideoSurfaceView) {
=======
  private void setOutputBufferRenderer(VpxOutputBufferRenderer outputBufferRenderer) {
    if (this.outputBufferRenderer == outputBufferRenderer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    this.vpxVideoSurfaceView = vpxVideoSurfaceView;
=======
    this.outputBufferRenderer = outputBufferRenderer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
    outputMode =
        (vpxVideoSurfaceView != null) ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
=======
    outputMode = (outputBufferRenderer != null)
        ? VpxDecoder.OUTPUT_MODE_YUV : VpxDecoder.OUTPUT_MODE_UNKNOWN;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/LibvpxVideoTrackRenderer.java;<<<<<<< MINE
  private void notifyIfVideoSizeChanged(final OutputBuffer outputBuffer) {
=======
  private void notifyIfVideoSizeChanged(final VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java;<<<<<<< MINE
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java;<<<<<<< MINE
public class VpxVideoSurfaceView extends GLSurfaceView {
=======
public class VpxVideoSurfaceView extends GLSurfaceView implements VpxOutputBufferRenderer {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java;<<<<<<< MINE
  public void renderFrame(OutputBuffer outputBuffer) {
=======
  @Override
  public void setOutputBuffer(VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java;<<<<<<< MINE
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java;<<<<<<< MINE
  public int decode(ByteBuffer encoded, int size, OutputBuffer outputBuffer)
=======
  public int decode(ByteBuffer encoded, int size, VpxOutputBuffer outputBuffer)
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxDecoder.java;<<<<<<< MINE
  private native int vpxGetFrame(long context, OutputBuffer outputBuffer);
=======
  private native int vpxGetFrame(long context, VpxOutputBuffer outputBuffer);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
import com.google.android.exoplayer.ext.vp9.VpxDecoderWrapper.OutputBuffer;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
=======
  private static final float[] kColorConversion601 = {
    1.164f, 1.164f, 1.164f,
    0.0f, -0.392f, 2.017f,
    1.596f, -0.813f, 0.0f,
  };

  private static final float[] kColorConversion709 = {
    1.164f, 1.164f, 1.164f,
    0.0f, -0.213f, 2.112f,
    1.793f, -0.533f, 0.0f,
  };

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
=======
      + "uniform mat3 mColorConversion;\n"
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
      + "  float y = 1.164 * (texture2D(y_tex, interp_tc).r - 0.0625);\n"
      + "  float u = texture2D(u_tex, interp_tc).r - 0.5;\n"
      + "  float v = texture2D(v_tex, interp_tc).r - 0.5;\n"
      + "  gl_FragColor = vec4(y + 1.596 * v, "
      + "                      y - 0.391 * u - 0.813 * v, "
      + "                      y + 2.018 * u, "
      + "                      1.0);\n"
=======
      + "  vec3 yuv;"
      + "  yuv.x = texture2D(y_tex, interp_tc).r - 0.0625;\n"
      + "  yuv.y = texture2D(u_tex, interp_tc).r - 0.5;\n"
      + "  yuv.z = texture2D(v_tex, interp_tc).r - 0.5;\n"
      + "  gl_FragColor = vec4(mColorConversion * yuv, 1.0);"
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
=======
  private int colorMatrixLocation;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
  private volatile OutputBuffer outputBuffer;
=======
  private VpxOutputBuffer outputBuffer;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
  public void setFrame(OutputBuffer outputBuffer) {
=======
  public synchronized void setFrame(VpxOutputBuffer outputBuffer) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
=======
    checkNoGLES2Error();
    colorMatrixLocation = GLES20.glGetUniformLocation(program, "mColorConversion");
    checkNoGLES2Error();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
    OutputBuffer outputBuffer = this.outputBuffer;
=======
    synchronized (this) {
      VpxOutputBuffer outputBuffer = this.outputBuffer;
      if (outputBuffer == null) {
        // Nothing to render yet.
        return;
      }

      // Set color matrix. Assume BT709 if the color space is unknown.
      float[] colorConversion = outputBuffer.colorspace == VpxOutputBuffer.COLORSPACE_BT601
          ? kColorConversion601 : kColorConversion709;
      GLES20.glUniformMatrix3fv(colorMatrixLocation, 1, false, colorConversion, 0);

      for (int i = 0; i < 3; i++) {
        int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
        GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE,
            outputBuffer.yuvStrides[i], h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE,
            outputBuffer.yuvPlanes[i]);
      }
      // Set cropping of stride if either width or stride has changed.
      if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
        float crop = (float) outputBuffer.width / outputBuffer.yuvStrides[0];
        textureCoords = nativeFloatBuffer(
            0.0f, 0.0f,
            0.0f, 1.0f,
            crop, 0.0f,
            crop, 1.0f);
        GLES20.glVertexAttribPointer(
            texLocation, 2, GLES20.GL_FLOAT, false, 0, textureCoords);
        previousWidth = outputBuffer.width;
        previousStride = outputBuffer.yuvStrides[0];
      }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxRenderer.java;<<<<<<< MINE
    if (outputBuffer == null) {
      // Nothing to render yet.
      return;
    }
    for (int i = 0; i < 3; i++) {
      int h = (i == 0) ? outputBuffer.height : (outputBuffer.height + 1) / 2;
      GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + i);
      GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, yuvTextures[i]);
      GLES20.glPixelStorei(GLES20.GL_UNPACK_ALIGNMENT, 1);
      GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, outputBuffer.yuvStrides[i],
          h, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, outputBuffer.yuvPlanes[i]);
    }
    // Set cropping of stride if either width or stride has changed.
    if (previousWidth != outputBuffer.width || previousStride != outputBuffer.yuvStrides[0]) {
      float crop = (float) outputBuffer.width / outputBuffer.yuvStrides[0];
      textureCoords = nativeFloatBuffer(
          0.0f, 0.0f,
          0.0f, 1.0f,
          crop, 0.0f,
          crop, 1.0f);
      GLES20.glVertexAttribPointer(
          texLocation, 2, GLES20.GL_FLOAT, false, 0, textureCoords);
      previousWidth = outputBuffer.width;
      previousStride = outputBuffer.yuvStrides[0];
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.ext.vp9;

import java.nio.ByteBuffer;

/**
 * OutputBuffer for storing the video frame.
 */
public final class VpxOutputBuffer {

  public static final int COLORSPACE_UNKNOWN = 0;
  public static final int COLORSPACE_BT601 = 1;
  public static final int COLORSPACE_BT709 = 2;

  /**
   * RGB buffer for RGB mode.
   */
  public ByteBuffer data;
  public long timestampUs;
  public int width;
  public int height;
  public int flags;
  /**
   * YUV planes for YUV mode.
   */
  public ByteBuffer[] yuvPlanes;
  public int[] yuvStrides;
  public int mode;
  public int colorspace;

  /**
   * This method is called from C++ through JNI after decoding is done. It will resize the
   * buffer based on the given dimensions.
   */
  public void initForRgbFrame(int width, int height) {
    this.width = width;
    this.height = height;
    int minimumRgbSize = width * height * 2;
    if (data == null || data.capacity() < minimumRgbSize) {
      data = ByteBuffer.allocateDirect(minimumRgbSize);
      yuvPlanes = null;
    }
    data.position(0);
    data.limit(minimumRgbSize);
  }

  /**
   * This method is called from C++ through JNI after decoding is done. It will resize the
   * buffer based on the given stride.
   */
  public void initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {
    this.width = width;
    this.height = height;
    this.colorspace = colorspace;
    int yLength = yStride * height;
    int uvLength = uvStride * ((height + 1) / 2);
    int minimumYuvSize = yLength + (uvLength * 2);
    if (data == null || data.capacity() < minimumYuvSize) {
      data = ByteBuffer.allocateDirect(minimumYuvSize);
    }
    data.limit(minimumYuvSize);
    if (yuvPlanes == null) {
      yuvPlanes = new ByteBuffer[3];
    }
    // Rewrapping has to be done on every frame since the stride might have changed.
    data.position(0);
    yuvPlanes[0] = data.slice();
    yuvPlanes[0].limit(yLength);
    data.position(yLength);
    yuvPlanes[1] = data.slice();
    yuvPlanes[1].limit(uvLength);
    data.position(yLength + uvLength);
    yuvPlanes[2] = data.slice();
    yuvPlanes[2].limit(uvLength);
    if (yuvStrides == null) {
      yuvStrides = new int[3];
    }
    yuvStrides[0] = yStride;
    yuvStrides[1] = uvStride;
    yuvStrides[2] = uvStride;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
  /* spans which are always the same can be reused to avoid object creation */
  private static final StrikethroughSpan STRIKETHROUGH_SPAN = new StrikethroughSpan();
  private static final UnderlineSpan UNDERLINE_SPAN = new UnderlineSpan();
  private static final StyleSpan[] STYLE_SPANS = new StyleSpan[] {
    new StyleSpan(TtmlStyle.STYLE_NORMAL),
    new StyleSpan(TtmlStyle.STYLE_BOLD),
    new StyleSpan(TtmlStyle.STYLE_ITALIC),
    new StyleSpan(TtmlStyle.STYLE_BOLD_ITALIC),
  };

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(STYLE_SPANS[style.getStyle()], start, end,
=======
      builder.setSpan(new StyleSpan(style.getStyle()), start, end,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(STRIKETHROUGH_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
=======
      builder.setSpan(new StrikethroughSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/text/ttml/TtmlRenderUtil.java;<<<<<<< MINE
      builder.setSpan(UNDERLINE_SPAN, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
=======
      builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/extractor/mp3/ConstantBitrateSeeker.java;<<<<<<< MINE
    return ((position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE) / bitrate;
=======
    return (Math.max(0, position - firstFramePosition) * C.MICROS_PER_SECOND * BITS_PER_BYTE)
        / bitrate;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/library/src/main/java/com/google/android/exoplayer/extractor/mp3/XingSeeker.java;<<<<<<< MINE
    if (!isSeekable()) {
=======
    if (!isSeekable() || position < firstFramePosition) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.ParserException;
import com.google.android.exoplayer.testutil.TestUtil;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
import java.io.InputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
        .open(EMPTY_FILE);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
      parser.parse(inputStream);
      fail("Expected IOException");
    } catch (IOException expected) {
=======
      parser.parse(bytes, 0, bytes.length);
      fail("Expected ParserException");
    } catch (ParserException expected) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream =
        getInstrumentation().getContext().getResources().getAssets().open(TYPICAL_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
        .open(TYPICAL_WITH_IDS_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_IDS_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
        .open(TYPICAL_WITH_COMMENTS_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_WITH_COMMENTS_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
        .open(WITH_TAGS_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_TAGS_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext().getResources().getAssets()
        .open(WITH_POSITIONING_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_POSITIONING_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/webvtt/WebvttParserTest.java;<<<<<<< MINE
    InputStream inputStream =
        getInstrumentation().getContext().getResources().getAssets().open(WITH_BAD_CUE_HEADER_FILE);
    WebvttSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), WITH_BAD_CUE_HEADER_FILE);
    WebvttSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.testutil.TestUtil;

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
import java.io.InputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(EMPTY_FILE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), EMPTY_FILE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(TYPICAL_FILE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_FILE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(TYPICAL_EXTRA_BLANK_LINE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_EXTRA_BLANK_LINE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(TYPICAL_MISSING_TIMECODE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_TIMECODE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(TYPICAL_MISSING_SEQUENCE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), TYPICAL_MISSING_SEQUENCE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInputStream(NO_END_TIMECODES_FILE);
    SubripSubtitle subtitle = parser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), NO_END_TIMECODES_FILE);
    SubripSubtitle subtitle = parser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/subrip/SubripParserTest.java;<<<<<<< MINE
  private InputStream getInputStream(String fileName) throws IOException {
    return getInstrumentation().getContext().getResources().getAssets().open(fileName);
  }

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.testutil.TestUtil;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java;<<<<<<< MINE
import java.io.InputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/text/ttml/TtmlParserTest.java;<<<<<<< MINE
    InputStream inputStream = getInstrumentation().getContext()
        .getResources().getAssets().open(file);
    return (TtmlSubtitle) ttmlParser.parse(inputStream);
=======
    byte[] bytes = TestUtil.getByteArray(getInstrumentation(), file);
    return ttmlParser.parse(bytes, 0, bytes.length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.util.Util;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java;<<<<<<< MINE
=======
import android.app.Instrumentation;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java;<<<<<<< MINE
=======
import java.io.InputStream;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/testutil/TestUtil.java;<<<<<<< MINE
=======
  public static byte[] getByteArray(Instrumentation instrumentation, String fileName)
      throws IOException {
    InputStream is = instrumentation.getContext().getResources().getAssets().open(fileName);
    return Util.toByteArray(is);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/androidTest/java/com/google/android/exoplayer/util/ParsableByteArrayTest.java;<<<<<<< MINE
=======
  public void testReadEmptyString() {
    byte[] bytes = new byte[0];
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertNull(parser.readLine());
  }

  public void testReadSingleLineWithoutEndingTrail() {
    byte[] bytes = new byte[] {
      'f', 'o', 'o'
    };
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertEquals("foo", parser.readLine());
    assertNull(parser.readLine());
  }

  public void testReadSingleLineWithEndingLf() {
    byte[] bytes = new byte[] {
      'f', 'o', 'o', '\n'
    };
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertEquals("foo", parser.readLine());
    assertNull(parser.readLine());
  }

  public void testReadTwoLinesWithLfFollowedByCr() {
    byte[] bytes = new byte[] {
      'f', 'o', 'o', '\n', '\r', 'b', 'a', 'r'
    };
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertEquals("foo", parser.readLine());
    assertEquals("bar", parser.readLine());
    assertNull(parser.readLine());
  }

  public void testReadThreeLinesWithEmptyLine() {
    byte[] bytes = new byte[] {
      'f', 'o', 'o', '\n', '\r', '\n', 'b', 'a', 'r'
    };
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertEquals("foo", parser.readLine());
    assertEquals("", parser.readLine());
    assertEquals("bar", parser.readLine());
    assertNull(parser.readLine());
  }

  public void testReadFourLinesWithCrFollowedByLf() {
    byte[] bytes = new byte[] {
      'f', 'o', 'o', '\r', '\n', '\n', 'b', 'a', 'r', '\n', '\r'
    };
    ParsableByteArray parser = new ParsableByteArray(bytes);
    assertEquals("foo", parser.readLine());
    assertEquals("", parser.readLine());
    assertEquals("", parser.readLine());
    assertEquals("bar", parser.readLine());
    assertNull(parser.readLine());
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java;<<<<<<< MINE
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/tx3g/Tx3gParser.java;<<<<<<< MINE
  public Subtitle parse(InputStream inputStream) throws IOException {
    DataInputStream dataInputStream  = new DataInputStream(inputStream);
    String cueText = dataInputStream.readUTF();
=======
  public Subtitle parse(byte[] bytes, int offset, int length) {
    String cueText = new String(bytes, offset, length);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.util.ParsableByteArray;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
import java.io.BufferedReader;
import java.io.IOException;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
   * @throws IOException If an error occurs reading from the input.
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
  public static void validateWebvttHeaderLine(BufferedReader input) throws IOException {
=======
  public static void validateWebvttHeaderLine(ParsableByteArray input) throws ParserException {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
   * @throws IOException If an error occurs reading from the input.
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/webvtt/WebvttParserUtil.java;<<<<<<< MINE
  public static Matcher findNextCueHeader(BufferedReader input) throws IOException {
=======
  public static Matcher findNextCueHeader(ParsableByteArray input) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
=======
import com.google.android.exoplayer.ParserException;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
import java.io.ByteArrayInputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
import java.io.InputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
    IOException error = null;
=======
    ParserException error = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParserHelper.java;<<<<<<< MINE
      InputStream inputStream = new ByteArrayInputStream(holder.data.array(), 0, holder.size);
      parsedSubtitle = parser.parse(inputStream);
    } catch (IOException e) {
=======
      parsedSubtitle = parser.parse(holder.data.array(), 0, holder.size);
    } catch (ParserException e) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
import java.io.IOException;
import java.io.InputStream;
=======
import com.google.android.exoplayer.ParserException;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
 * Parses {@link Subtitle}s from {@link InputStream}s.
=======
 * Parses {@link Subtitle}s from a byte array.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * Parses a {@link Subtitle} from the provided {@link InputStream}.
=======
   * Parses a {@link Subtitle} from the provided {@code byte[]}.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * @param inputStream The stream from which to parse the subtitle.
=======
   * @param bytes The array holding the subtitle data.
   * @param offset The offset of the subtitle data in bytes.
   * @param length The length of the subtitle data in bytes.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
   * @throws IOException If a problem occurred reading from the stream.
=======
   * @throws ParserException If a problem occurred parsing the subtitle data.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/text/SubtitleParser.java;<<<<<<< MINE
  public Subtitle parse(InputStream inputStream) throws IOException;
=======
  public Subtitle parse(byte[] bytes, int offset, int length) throws ParserException;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
import java.io.InputStreamReader;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
  private void processSample() throws IOException {
    BufferedReader reader = new BufferedReader(
        new InputStreamReader(new ByteArrayInputStream(sampleData), C.UTF8_NAME));
=======
  private void processSample() throws ParserException {
    ParsableByteArray webvttData = new ParsableByteArray(sampleData);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
    WebvttParserUtil.validateWebvttHeaderLine(reader);
=======
    WebvttParserUtil.validateWebvttHeaderLine(webvttData);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
    while (!TextUtils.isEmpty(line = reader.readLine())) {
=======
    while (!TextUtils.isEmpty(line = webvttData.readLine())) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/hls/WebvttExtractor.java;<<<<<<< MINE
    Matcher cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(reader);
=======
    Matcher cueHeaderMatcher = WebvttParserUtil.findNextCueHeader(webvttData);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_69a42b6_6b59975/rev_69a42b6-6b59975/library/src/main/java/com/google/android/exoplayer/util/ParsableByteArray.java;<<<<<<< MINE
=======
  /**
   * Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), a
   * carriage return ('\r'), or a carriage return followed immediately by a line feed. Platform
   * default's charset used.
   *
   * @return A String containing the contents of the line, not including any line-termination
   *    characters, or null if the end of the stream has been reached.
   */
  public String readLine() {
    if (bytesLeft() == 0) {
      return null;
    }
    int lineLimit = position;
    while (lineLimit < limit && data[lineLimit] != '\n' && data[lineLimit] != '\r') {
      lineLimit++;
    }
    String line = new String(data, position, lineLimit - position);
    position = lineLimit;
    if (position == limit) {
      return line;
    }
    if (data[position] == '\n') {
      position++;
      if (position == limit) {
        return line;
      }
    }
    if (data[position] == '\r') {
      position++;
    }
    return line;
  }


>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_93c2133_776da10/rev_93c2133-776da10/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java;<<<<<<< MINE
    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output<List<Id3Frame>> {
=======
    MappingTrackSelector.EventListener, MetadataRenderer.Output<Metadata> {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2c54363_8caaf0b/rev_2c54363-8caaf0b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java;<<<<<<< MINE
    MetadataRenderer.Output<List<Id3Frame>> {
=======
    TrackSelector.EventListener<MappedTrackInfo>, MetadataRenderer.Output {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e803bff_8fcc8c6/rev_e803bff-8fcc8c6/library/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java;<<<<<<< MINE
=======
  @Override
  public boolean dispatchKeyEvent(KeyEvent event) {
    return useController ? controller.dispatchKeyEvent(event) : super.dispatchKeyEvent(event);
  }

  public SubtitleView getSubtitleView() {
    return subtitleView;
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
  String VERSION = "2.1.0";
=======
  String VERSION = "2.0.4";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
  int VERSION_INT = 2001000;
=======
  int VERSION_INT = 2000004;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
=======
import android.annotation.TargetApi;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
=======
  private boolean isAttachedToWindow;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
      if (isAttachedToWindow()) {
=======
      if (isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    if (!isVisible() || !isAttachedToWindow()) {
=======
    if (!isVisible() || !isAttachedToWindow) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
      view.setAlpha(enabled ? 1f : 0.3f);
=======
      setViewAlphaV11(view, enabled ? 1f : 0.3f);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
=======
  @TargetApi(11)
  private void setViewAlphaV11(View view, float alpha) {
    view.setAlpha(alpha);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
=======
    isAttachedToWindow = true;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
=======
    isAttachedToWindow = false;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
=======
  private SampleReader sampleReader;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
  private final SampleReader sampleReader;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
    sampleReader = new SampleReader(output);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
=======
    sampleReader = new SampleReader(output);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_94a3640_55ca323/rev_94a3640-55ca323/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
import com.google.android.exoplayer2.text.cea.Cea708Decoder;
import com.google.android.exoplayer2.text.ssa.SSADecoder;
=======
import com.google.android.exoplayer2.text.cea.Cea708Decoder;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_94a3640_55ca323/rev_94a3640-55ca323/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
        if(clazz == SSADecoder.class) {
          byte[] header = format.initializationData.get(1);
          String dlgfmt = new String(format.initializationData.get(0), "UTF-8");
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(byte[].class, String.class)
                  .newInstance(header, dlgfmt);
        }
        if (clazz == Cea608Decoder.class) {
=======
        if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_94a3640_55ca323/rev_94a3640-55ca323/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
        }
        else {
=======
        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
              .newInstance(format.accessibilityChannel);
        } else {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.source;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.FormatHolder;
import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
import com.google.android.exoplayer2.trackselection.TrackSelection;
import com.google.android.exoplayer2.util.Assertions;
import java.io.IOException;

/**
 * Wraps a {@link MediaPeriod} and clips its {@link SampleStream}s to provide a subsequence of their
 * samples.
 */
public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callback {

  /**
   * The {@link MediaPeriod} wrapped by this clipping media period.
   */
  public final MediaPeriod mediaPeriod;

  private MediaPeriod.Callback callback;
  private long startUs;
  private long endUs;
  private ClippingSampleStream[] sampleStreams;
  private boolean pendingInitialDiscontinuity;

  /**
   * Creates a new clipping media period that provides a clipped view of the specified
   * {@link MediaPeriod}'s sample streams.
   * <p>
   * The clipping start/end positions must be specified by calling {@link #setClipping(long, long)}
   * on the playback thread before preparation completes.
   *
   * @param mediaPeriod The media period to clip.
   */
  public ClippingMediaPeriod(MediaPeriod mediaPeriod) {
    this.mediaPeriod = mediaPeriod;
    startUs = C.TIME_UNSET;
    endUs = C.TIME_UNSET;
    sampleStreams = new ClippingSampleStream[0];
  }

  /**
   * Sets the clipping start/end times for this period, in microseconds.
   *
   * @param startUs The clipping start time, in microseconds.
   * @param endUs The clipping end time, in microseconds, or {@link C#TIME_END_OF_SOURCE} to
   *     indicate the end of the period.
   */
  public void setClipping(long startUs, long endUs) {
    this.startUs = startUs;
    this.endUs = endUs;
  }

  @Override
  public void prepare(MediaPeriod.Callback callback) {
    this.callback = callback;
    mediaPeriod.prepare(this);
  }

  @Override
  public void maybeThrowPrepareError() throws IOException {
    mediaPeriod.maybeThrowPrepareError();
  }

  @Override
  public TrackGroupArray getTrackGroups() {
    return mediaPeriod.getTrackGroups();
  }

  @Override
  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
    sampleStreams = new ClippingSampleStream[streams.length];
    SampleStream[] internalStreams = new SampleStream[streams.length];
    for (int i = 0; i < streams.length; i++) {
      sampleStreams[i] = (ClippingSampleStream) streams[i];
      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
    }
    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
        internalStreams, streamResetFlags, positionUs + startUs);
    Assertions.checkState(enablePositionUs == positionUs + startUs
        || (enablePositionUs >= startUs
        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
    for (int i = 0; i < streams.length; i++) {
      if (internalStreams[i] == null) {
        sampleStreams[i] = null;
      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
            pendingInitialDiscontinuity);
      }
      streams[i] = sampleStreams[i];
    }
    return enablePositionUs - startUs;
  }

  @Override
  public long readDiscontinuity() {
    if (pendingInitialDiscontinuity) {
      for (ClippingSampleStream sampleStream : sampleStreams) {
        if (sampleStream != null) {
          sampleStream.clearPendingDiscontinuity();
        }
      }
      pendingInitialDiscontinuity = false;
      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
      long discontinuityUs = readDiscontinuity();
      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
    }
    long discontinuityUs = mediaPeriod.readDiscontinuity();
    if (discontinuityUs == C.TIME_UNSET) {
      return C.TIME_UNSET;
    }
    Assertions.checkState(discontinuityUs >= startUs);
    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
    return discontinuityUs - startUs;
  }

  @Override
  public long getBufferedPositionUs() {
    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return Math.max(0, bufferedPositionUs - startUs);
  }

  @Override
  public long seekToUs(long positionUs) {
    for (ClippingSampleStream sampleStream : sampleStreams) {
      if (sampleStream != null) {
        sampleStream.clearSentEos();
      }
    }
    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
    Assertions.checkState(seekUs == positionUs + startUs
        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
    return seekUs - startUs;
  }

  @Override
  public long getNextLoadPositionUs() {
    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return nextLoadPositionUs - startUs;
  }

  @Override
  public boolean continueLoading(long positionUs) {
    return mediaPeriod.continueLoading(positionUs + startUs);
  }

  // MediaPeriod.Callback implementation.

  @Override
  public void onPrepared(MediaPeriod mediaPeriod) {
    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
    // If the clipping start position is non-zero, the clipping sample streams will adjust
    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
    // which may be before the clipping start point. When the renderer reads a buffer with a
    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
    // read in the previous period. Renderer implementations may not allow this, so we signal a
    // discontinuity which resets the renderers before they read the clipping sample stream.
    pendingInitialDiscontinuity = startUs != 0;
    callback.onPrepared(this);
  }

  @Override
  public void onContinueLoadingRequested(MediaPeriod source) {
    callback.onContinueLoadingRequested(this);
  }

  /**
   * Wraps a {@link SampleStream} and clips its samples.
   */
  private static final class ClippingSampleStream implements SampleStream {

    private final MediaPeriod mediaPeriod;
    private final SampleStream stream;
    private final long startUs;
    private final long endUs;

    private boolean pendingDiscontinuity;
    private boolean sentEos;

    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
        long endUs, boolean pendingDiscontinuity) {
      this.mediaPeriod = mediaPeriod;
      this.stream = stream;
      this.startUs = startUs;
      this.endUs = endUs;
      this.pendingDiscontinuity = pendingDiscontinuity;
    }

    public void clearPendingDiscontinuity() {
      pendingDiscontinuity = false;
    }

    public void clearSentEos() {
      sentEos = false;
    }

    @Override
    public boolean isReady() {
      return stream.isReady();
    }

    @Override
    public void maybeThrowError() throws IOException {
      stream.maybeThrowError();
    }

    @Override
    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
      if (pendingDiscontinuity) {
        return C.RESULT_NOTHING_READ;
      }
      if (buffer == null) {
        return stream.readData(formatHolder, null);
      }
      if (sentEos) {
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        return C.RESULT_BUFFER_READ;
      }
      int result = stream.readData(formatHolder, buffer);
      // TODO: Clear gapless playback metadata if a format was read (if applicable).
      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
        buffer.clear();
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        sentEos = true;
        return C.RESULT_BUFFER_READ;
      }
      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
        buffer.timeUs -= startUs;
      }
      return result;
    }

    @Override
    public void skipToKeyframeBefore(long timeUs) {
      stream.skipToKeyframeBefore(startUs + timeUs);
    }

  }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java;<<<<<<< MINE
=======
  // SequenceableLoader interface. Overridden to provide more specific documentation.

  /**
   * Returns the next load time, or {@link C#TIME_END_OF_SOURCE} if loading has finished.
   * <p>
   * This method should only be called after the period has been prepared. It may be called when no
   * tracks are selected.
   */
  @Override
  long getNextLoadPositionUs();

  /**
   * Attempts to continue loading.
   * <p>
   * This method may be called both during and after the period has been prepared.
   * <p>
   * A period may call {@link Callback#onContinueLoadingRequested(SequenceableLoader)} on the
   * {@link Callback} passed to {@link #prepare(Callback)} to request that this method be called
   * when the period is permitted to continue loading data. A period may do this both during and
   * after preparation.
   *
   * @param positionUs The current playback position.
   * @return True if progress was made, meaning that {@link #getNextLoadPositionUs()} will return
   *     a different value than prior to the call. False otherwise.
   */
  @Override
  boolean continueLoading(long positionUs);

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
  String VERSION = "2.2.0";
=======
  String VERSION = "2.1.1";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
  int VERSION_INT = 2002000;
=======
  int VERSION_INT = 2001001;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
=======
    } else if (result == C.RESULT_FORMAT_READ) {
      Format format = formatHolder.format;
      if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
        format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + streamOffsetUs);
        formatHolder.format = format;
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.source.dash;

import android.net.Uri;
import android.os.SystemClock;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.extractor.ChunkIndex;
import com.google.android.exoplayer2.extractor.Extractor;
import com.google.android.exoplayer2.extractor.SeekMap;
import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
import com.google.android.exoplayer2.extractor.rawcc.RawCcExtractor;
import com.google.android.exoplayer2.source.BehindLiveWindowException;
import com.google.android.exoplayer2.source.chunk.Chunk;
import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
import com.google.android.exoplayer2.source.chunk.ChunkHolder;
import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
import com.google.android.exoplayer2.source.chunk.ContainerMediaChunk;
import com.google.android.exoplayer2.source.chunk.InitializationChunk;
import com.google.android.exoplayer2.source.chunk.MediaChunk;
import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
import com.google.android.exoplayer2.source.dash.manifest.Representation;
import com.google.android.exoplayer2.trackselection.TrackSelection;
import com.google.android.exoplayer2.upstream.DataSource;
import com.google.android.exoplayer2.upstream.DataSpec;
import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
import com.google.android.exoplayer2.util.MimeTypes;
import com.google.android.exoplayer2.util.Util;
import java.io.IOException;
import java.util.List;

/**
 * A default {@link DashChunkSource} implementation.
 */
public class DefaultDashChunkSource implements DashChunkSource {

  public static final class Factory implements DashChunkSource.Factory {

    private final DataSource.Factory dataSourceFactory;
    private final int maxSegmentsPerLoad;

    public Factory(DataSource.Factory dataSourceFactory) {
      this(dataSourceFactory, 1);
    }

    public Factory(DataSource.Factory dataSourceFactory, int maxSegmentsPerLoad) {
      this.dataSourceFactory = dataSourceFactory;
      this.maxSegmentsPerLoad = maxSegmentsPerLoad;
    }

    @Override
    public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
        DashManifest manifest, int periodIndex, int adaptationSetIndex,
        TrackSelection trackSelection, long elapsedRealtimeOffsetMs,
        boolean enableEventMessageTrack, boolean enableCea608Track) {
      DataSource dataSource = dataSourceFactory.createDataSource();
      return new DefaultDashChunkSource(manifestLoaderErrorThrower, manifest, periodIndex,
          adaptationSetIndex, trackSelection, dataSource, elapsedRealtimeOffsetMs,
          maxSegmentsPerLoad, enableEventMessageTrack, enableCea608Track);
    }

  }

  private final LoaderErrorThrower manifestLoaderErrorThrower;
  private final int adaptationSetIndex;
  private final TrackSelection trackSelection;
  private final RepresentationHolder[] representationHolders;
  private final DataSource dataSource;
  private final long elapsedRealtimeOffsetMs;
  private final int maxSegmentsPerLoad;

  private DashManifest manifest;
  private int periodIndex;

  private IOException fatalError;
  private boolean missingLastSegment;

  /**
   * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
   * @param manifest The initial manifest.
   * @param periodIndex The index of the period in the manifest.
   * @param adaptationSetIndex The index of the adaptation set in the period.
   * @param trackSelection The track selection.
   * @param dataSource A {@link DataSource} suitable for loading the media data.
   * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
   *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
   *     as the server's unix time minus the local elapsed time. If unknown, set to 0.
   * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request.
   *     Note that segments will only be combined if their {@link Uri}s are the same and if their
   *     data ranges are adjacent.
   * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
   *     message track.
   * @param enableEventMessageTrack Whether the chunks generated by the source may output a CEA-608
   *     track.
   */
  public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
      DashManifest manifest, int periodIndex, int adaptationSetIndex, TrackSelection trackSelection,
      DataSource dataSource, long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad,
      boolean enableEventMessageTrack, boolean enableCea608Track) {
    this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
    this.manifest = manifest;
    this.adaptationSetIndex = adaptationSetIndex;
    this.trackSelection = trackSelection;
    this.dataSource = dataSource;
    this.periodIndex = periodIndex;
    this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
    this.maxSegmentsPerLoad = maxSegmentsPerLoad;

    long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
    AdaptationSet adaptationSet = getAdaptationSet();
    List<Representation> representations = adaptationSet.representations;
    representationHolders = new RepresentationHolder[trackSelection.length()];
    for (int i = 0; i < representationHolders.length; i++) {
      Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
      representationHolders[i] = new RepresentationHolder(periodDurationUs, representation,
          enableEventMessageTrack, enableCea608Track, adaptationSet.type);
    }
  }

  @Override
  public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
    try {
      manifest = newManifest;
      periodIndex = newPeriodIndex;
      long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
      List<Representation> representations = getAdaptationSet().representations;
      for (int i = 0; i < representationHolders.length; i++) {
        Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
        representationHolders[i].updateRepresentation(periodDurationUs, representation);
      }
    } catch (BehindLiveWindowException e) {
      fatalError = e;
    }
  }

  @Override
  public void maybeThrowError() throws IOException {
    if (fatalError != null) {
      throw fatalError;
    } else {
      manifestLoaderErrorThrower.maybeThrowError();
    }
  }

  @Override
  public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
    if (fatalError != null || trackSelection.length() < 2) {
      return queue.size();
    }
    return trackSelection.evaluateQueueSize(playbackPositionUs, queue);
  }

  @Override
  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
    if (fatalError != null) {
      return;
    }

    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
    trackSelection.updateSelectedTrack(bufferedDurationUs);

    RepresentationHolder representationHolder =
        representationHolders[trackSelection.getSelectedIndex()];

    if (representationHolder.extractorWrapper != null) {
      Representation selectedRepresentation = representationHolder.representation;
      RangedUri pendingInitializationUri = null;
      RangedUri pendingIndexUri = null;
      if (representationHolder.extractorWrapper.getSampleFormats() == null) {
        pendingInitializationUri = selectedRepresentation.getInitializationUri();
      }
      if (representationHolder.segmentIndex == null) {
        pendingIndexUri = selectedRepresentation.getIndexUri();
      }
      if (pendingInitializationUri != null || pendingIndexUri != null) {
        // We have initialization and/or index requests to make.
        out.chunk = newInitializationChunk(representationHolder, dataSource,
            trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
            trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
        return;
      }
    }

    long nowUs = getNowUnixTimeUs();
    int availableSegmentCount = representationHolder.getSegmentCount();
    if (availableSegmentCount == 0) {
      // The index doesn't define any segments.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
    int lastAvailableSegmentNum;
    if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
      // The index is itself unbounded. We need to use the current time to calculate the range of
      // available segments.
      long liveEdgeTimeUs = nowUs - manifest.availabilityStartTime * 1000;
      long periodStartUs = manifest.getPeriod(periodIndex).startMs * 1000;
      long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
      if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
        long bufferDepthUs = manifest.timeShiftBufferDepth * 1000;
        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
            representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
      }
      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
      // index of the last completed segment.
      lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
    } else {
      lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
    }

    int segmentNum;
    if (previous == null) {
      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(playbackPositionUs),
          firstAvailableSegmentNum, lastAvailableSegmentNum);
    } else {
      segmentNum = previous.getNextChunkIndex();
      if (segmentNum < firstAvailableSegmentNum) {
        // This is before the first chunk in the current manifest.
        fatalError = new BehindLiveWindowException();
        return;
      }
    }

    if (segmentNum > lastAvailableSegmentNum
        || (missingLastSegment && segmentNum >= lastAvailableSegmentNum)) {
      // This is beyond the last chunk in the current manifest.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), segmentNum,
        maxSegmentCount);
  }

  @Override
  public void onChunkLoadCompleted(Chunk chunk) {
    if (chunk instanceof InitializationChunk) {
      InitializationChunk initializationChunk = (InitializationChunk) chunk;
      RepresentationHolder representationHolder =
          representationHolders[trackSelection.indexOf(initializationChunk.trackFormat)];
      // The null check avoids overwriting an index obtained from the manifest with one obtained
      // from the stream. If the manifest defines an index then the stream shouldn't, but in cases
      // where it does we should ignore it.
      if (representationHolder.segmentIndex == null) {
        SeekMap seekMap = representationHolder.extractorWrapper.getSeekMap();
        if (seekMap != null) {
          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap);
        }
      }
    }
  }

  @Override
  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
    if (!cancelable) {
      return false;
    }
    // Workaround for missing segment at the end of the period
    if (!manifest.dynamic && chunk instanceof MediaChunk
        && e instanceof InvalidResponseCodeException
        && ((InvalidResponseCodeException) e).responseCode == 404) {
      RepresentationHolder representationHolder =
          representationHolders[trackSelection.indexOf(chunk.trackFormat)];
      int segmentCount = representationHolder.getSegmentCount();
      if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED && segmentCount != 0) {
        int lastAvailableSegmentNum = representationHolder.getFirstSegmentNum() + segmentCount - 1;
        if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
          missingLastSegment = true;
          return true;
        }
      }
    }
    // Blacklist if appropriate.
    return ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
        trackSelection.indexOf(chunk.trackFormat), e);
  }

  // Private methods.

  private AdaptationSet getAdaptationSet() {
    return manifest.getPeriod(periodIndex).adaptationSets.get(adaptationSetIndex);
  }

  private long getNowUnixTimeUs() {
    if (elapsedRealtimeOffsetMs != 0) {
      return (SystemClock.elapsedRealtime() + elapsedRealtimeOffsetMs) * 1000;
    } else {
      return System.currentTimeMillis() * 1000;
    }
  }

  private static Chunk newInitializationChunk(RepresentationHolder representationHolder,
      DataSource dataSource, Format trackFormat, int trackSelectionReason,
      Object trackSelectionData, RangedUri initializationUri, RangedUri indexUri) {
    RangedUri requestUri;
    String baseUrl = representationHolder.representation.baseUrl;
    if (initializationUri != null) {
      // It's common for initialization and index data to be stored adjacently. Attempt to merge
      // the two requests together to request both at once.
      requestUri = initializationUri.attemptMerge(indexUri, baseUrl);
      if (requestUri == null) {
        requestUri = initializationUri;
      }
    } else {
      requestUri = indexUri;
    }
    DataSpec dataSpec = new DataSpec(requestUri.resolveUri(baseUrl), requestUri.start,
        requestUri.length, representationHolder.representation.getCacheKey());
    return new InitializationChunk(dataSource, dataSpec, trackFormat,
        trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
  }

  private static Chunk newMediaChunk(RepresentationHolder representationHolder,
      DataSource dataSource, Format trackFormat, int trackSelectionReason,
      Object trackSelectionData, int firstSegmentNum, int maxSegmentCount) {
    Representation representation = representationHolder.representation;
    long startTimeUs = representationHolder.getSegmentStartTimeUs(firstSegmentNum);
    RangedUri segmentUri = representationHolder.getSegmentUrl(firstSegmentNum);
    String baseUrl = representation.baseUrl;
    if (representationHolder.extractorWrapper == null) {
      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum);
      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
          segmentUri.start, segmentUri.length, representation.getCacheKey());
      return new SingleSampleMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum,
          representationHolder.trackType, trackFormat);
    } else {
      int segmentCount = 1;
      for (int i = 1; i < maxSegmentCount; i++) {
        RangedUri nextSegmentUri = representationHolder.getSegmentUrl(firstSegmentNum + i);
        RangedUri mergedSegmentUri = segmentUri.attemptMerge(nextSegmentUri, baseUrl);
        if (mergedSegmentUri == null) {
          // Unable to merge segment fetches because the URIs do not merge.
          break;
        }
        segmentUri = mergedSegmentUri;
        segmentCount++;
      }
      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum + segmentCount - 1);
      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
          segmentUri.start, segmentUri.length, representation.getCacheKey());
      long sampleOffsetUs = -representation.presentationTimeOffsetUs;
      return new ContainerMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, segmentCount,
          sampleOffsetUs, representationHolder.extractorWrapper);
    }
  }

  // Protected classes.

  protected static final class RepresentationHolder {

    public final int trackType;
    public final ChunkExtractorWrapper extractorWrapper;

    public Representation representation;
    public DashSegmentIndex segmentIndex;

    private long periodDurationUs;
    private int segmentNumShift;

    public RepresentationHolder(long periodDurationUs, Representation representation,
        boolean enableEventMessageTrack, boolean enableCea608Track, int trackType) {
      this.periodDurationUs = periodDurationUs;
      this.representation = representation;
      this.trackType = trackType;
      String containerMimeType = representation.format.containerMimeType;
      if (mimeTypeIsRawText(containerMimeType)) {
        extractorWrapper = null;
      } else {
        Extractor extractor;
        if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
          extractor = new RawCcExtractor(representation.format);
        } else if (mimeTypeIsWebm(containerMimeType)) {
          extractor = new MatroskaExtractor();
        } else {
          int flags = 0;
          if (enableEventMessageTrack) {
            flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
          }
          if (enableCea608Track) {
            flags |= FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK;
          }
          extractor = new FragmentedMp4Extractor(flags);
        }
        // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
        // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
        extractorWrapper = new ChunkExtractorWrapper(extractor, representation.format);
      }
      segmentIndex = representation.getIndex();
    }

    public void updateRepresentation(long newPeriodDurationUs, Representation newRepresentation)
        throws BehindLiveWindowException{
      DashSegmentIndex oldIndex = representation.getIndex();
      DashSegmentIndex newIndex = newRepresentation.getIndex();

      periodDurationUs = newPeriodDurationUs;
      representation = newRepresentation;
      if (oldIndex == null) {
        // Segment numbers cannot shift if the index isn't defined by the manifest.
        return;
      }

      segmentIndex = newIndex;
      if (!oldIndex.isExplicit()) {
        // Segment numbers cannot shift if the index isn't explicit.
        return;
      }

      int oldIndexSegmentCount = oldIndex.getSegmentCount(periodDurationUs);
      if (oldIndexSegmentCount == 0) {
        // Segment numbers cannot shift if the old index was empty.
        return;
      }

      int oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
      long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
          + oldIndex.getDurationUs(oldIndexLastSegmentNum, periodDurationUs);
      int newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
      long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
      if (oldIndexEndTimeUs == newIndexStartTimeUs) {
        // The new index continues where the old one ended, with no overlap.
        segmentNumShift += oldIndexLastSegmentNum + 1 - newIndexFirstSegmentNum;
      } else if (oldIndexEndTimeUs < newIndexStartTimeUs) {
        // There's a gap between the old index and the new one which means we've slipped behind the
        // live window and can't proceed.
        throw new BehindLiveWindowException();
      } else {
        // The new index overlaps with the old one.
        segmentNumShift += oldIndex.getSegmentNum(newIndexStartTimeUs, periodDurationUs)
            - newIndexFirstSegmentNum;
      }
    }

    public int getFirstSegmentNum() {
      return segmentIndex.getFirstSegmentNum() + segmentNumShift;
    }

    public int getSegmentCount() {
      return segmentIndex.getSegmentCount(periodDurationUs);
    }

    public long getSegmentStartTimeUs(int segmentNum) {
      return segmentIndex.getTimeUs(segmentNum - segmentNumShift);
    }

    public long getSegmentEndTimeUs(int segmentNum) {
      return getSegmentStartTimeUs(segmentNum)
          + segmentIndex.getDurationUs(segmentNum - segmentNumShift, periodDurationUs);
    }

    public int getSegmentNum(long positionUs) {
      return segmentIndex.getSegmentNum(positionUs, periodDurationUs) + segmentNumShift;
    }

    public RangedUri getSegmentUrl(int segmentNum) {
      return segmentIndex.getSegmentUrl(segmentNum - segmentNumShift);
    }

    private static boolean mimeTypeIsWebm(String mimeType) {
      return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM)
          || mimeType.startsWith(MimeTypes.APPLICATION_WEBM);
    }

    private static boolean mimeTypeIsRawText(String mimeType) {
      return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2;

/**
 * Information about the ExoPlayer library.
 */
public interface ExoPlayerLibraryInfo {

  /**
   * The version of the library, expressed as a string.
   */
  String VERSION = "2.3.1";

  /**
   * The version of the library, expressed as an integer.
   * <p>
   * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
   * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
   * integer version 123045006 (123-045-006).
   */
  int VERSION_INT = 2003001;

  /**
   * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
   * checks enabled.
   */
  boolean ASSERTIONS_ENABLED = true;

  /**
   * Whether the library was compiled with {@link com.google.android.exoplayer2.util.TraceUtil}
   * trace enabled.
   */
  boolean TRACE_ENABLED = true;

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2;

import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
import com.google.android.exoplayer2.source.SampleStream;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.MediaClock;
import java.io.IOException;

/**
 * An abstract base class suitable for most {@link Renderer} implementations.
 */
public abstract class BaseRenderer implements Renderer, RendererCapabilities {

  private final int trackType;

  private RendererConfiguration configuration;
  private int index;
  private int state;
  private SampleStream stream;
  private long streamOffsetUs;
  private boolean readEndOfStream;
  private boolean streamIsFinal;

  /**
   * @param trackType The track type that the renderer handles. One of the {@link C}
   * {@code TRACK_TYPE_*} constants.
   */
  public BaseRenderer(int trackType) {
    this.trackType = trackType;
    readEndOfStream = true;
  }

  @Override
  public final int getTrackType() {
    return trackType;
  }

  @Override
  public final RendererCapabilities getCapabilities() {
    return this;
  }

  @Override
  public final void setIndex(int index) {
    this.index = index;
  }

  @Override
  public MediaClock getMediaClock() {
    return null;
  }

  @Override
  public final int getState() {
    return state;
  }

  @Override
  public final void enable(RendererConfiguration configuration, Format[] formats,
      SampleStream stream, long positionUs, boolean joining, long offsetUs)
      throws ExoPlaybackException {
    Assertions.checkState(state == STATE_DISABLED);
    this.configuration = configuration;
    state = STATE_ENABLED;
    onEnabled(joining);
    replaceStream(formats, stream, offsetUs);
    onPositionReset(positionUs, joining);
  }

  @Override
  public final void start() throws ExoPlaybackException {
    Assertions.checkState(state == STATE_ENABLED);
    state = STATE_STARTED;
    onStarted();
  }

  @Override
  public final void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
      throws ExoPlaybackException {
    Assertions.checkState(!streamIsFinal);
    this.stream = stream;
    readEndOfStream = false;
    streamOffsetUs = offsetUs;
    onStreamChanged(formats);
  }

  @Override
  public final SampleStream getStream() {
    return stream;
  }

  @Override
  public final boolean hasReadStreamToEnd() {
    return readEndOfStream;
  }

  @Override
  public final void setCurrentStreamFinal() {
    streamIsFinal = true;
  }

  @Override
  public final boolean isCurrentStreamFinal() {
    return streamIsFinal;
  }

  @Override
  public final void maybeThrowStreamError() throws IOException {
    stream.maybeThrowError();
  }

  @Override
  public final void resetPosition(long positionUs) throws ExoPlaybackException {
    streamIsFinal = false;
    readEndOfStream = false;
    onPositionReset(positionUs, false);
  }

  @Override
  public final void stop() throws ExoPlaybackException {
    Assertions.checkState(state == STATE_STARTED);
    state = STATE_ENABLED;
    onStopped();
  }

  @Override
  public final void disable() {
    Assertions.checkState(state == STATE_ENABLED);
    state = STATE_DISABLED;
    onDisabled();
    stream = null;
    streamIsFinal = false;
  }

  // RendererCapabilities implementation.

  @Override
  public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
    return ADAPTIVE_NOT_SUPPORTED;
  }

  // ExoPlayerComponent implementation.

  @Override
  public void handleMessage(int what, Object object) throws ExoPlaybackException {
    // Do nothing.
  }

  // Methods to be overridden by subclasses.

  /**
   * Called when the renderer is enabled.
   * <p>
   * The default implementation is a no-op.
   *
   * @param joining Whether this renderer is being enabled to join an ongoing playback.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onEnabled(boolean joining) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer's stream has changed. This occurs when the renderer is enabled after
   * {@link #onEnabled(boolean)} has been called, and also when the stream has been replaced whilst
   * the renderer is enabled or started.
   * <p>
   * The default implementation is a no-op.
   *
   * @param formats The enabled formats.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the position is reset. This occurs when the renderer is enabled after
   * {@link #onStreamChanged(Format[])} has been called, and also when a position discontinuity
   * is encountered.
   * <p>
   * After a position reset, the renderer's {@link SampleStream} is guaranteed to provide samples
   * starting from a key frame.
   * <p>
   * The default implementation is a no-op.
   *
   * @param positionUs The new playback position in microseconds.
   * @param joining Whether this renderer is being enabled to join an ongoing playback.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is started.
   * <p>
   * The default implementation is a no-op.
   *
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStarted() throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is stopped.
   * <p>
   * The default implementation is a no-op.
   *
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStopped() throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is disabled.
   * <p>
   * The default implementation is a no-op.
   */
  protected void onDisabled() {
    // Do nothing.
  }

  // Methods to be called by subclasses.

  /**
   * Returns the configuration set when the renderer was most recently enabled.
   */
  protected final RendererConfiguration getConfiguration() {
    return configuration;
  }

  /**
   * Returns the index of the renderer within the player.
   */
  protected final int getIndex() {
    return index;
  }

  /**
   * Use {@link #readSource(FormatHolder, DecoderInputBuffer, boolean)} instead.
   */
  @Deprecated
  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer) {
    return readSource(formatHolder, buffer, false);
  }

  /**
   * Reads from the enabled upstream source. If the upstream source has been read to the end then
   * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
   * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
   *
   * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
   * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
   *     end of the stream. If the end of the stream has been reached, the
   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
   * @param formatRequired Whether the caller requires that the format of the stream be read even if
   *     it's not changing. A sample will never be read if set to true, however it is still possible
   *     for the end of stream or nothing to be read.
   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
   *     {@link C#RESULT_BUFFER_READ}.
   */
  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer,
      boolean formatRequired) {
    int result = stream.readData(formatHolder, buffer, formatRequired);
    if (result == C.RESULT_BUFFER_READ) {
      if (buffer.isEndOfStream()) {
        readEndOfStream = true;
        return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;
      }
      buffer.timeUs += streamOffsetUs;
    } else if (result == C.RESULT_FORMAT_READ) {
      Format format = formatHolder.format;
      if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
        format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + streamOffsetUs);
        formatHolder.format = format;
      }
    }
    return result;
  }

  /**
   * Returns whether the upstream source is ready.
   *
   * @return Whether the source is ready.
   */
  protected final boolean isSourceReady() {
    return readEndOfStream ? streamIsFinal : stream.isReady();
  }

  /**
   * Attempts to skip to the keyframe before the specified time.
   *
   * @param timeUs The specified time.
   */
  protected void skipToKeyframeBefore(long timeUs) {
    stream.skipToKeyframeBefore(timeUs - streamOffsetUs);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.extractor.mkv;

import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.extractor.Extractor;
import com.google.android.exoplayer2.testutil.TestUtil;

/**
 * Tests for {@link MatroskaExtractor}.
 */
public final class MatroskaExtractorTest extends InstrumentationTestCase {

  public void testMkvSample() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/sample.mkv", getInstrumentation());
  }
/*
  public void testMkvSSASample() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/ssasample.mkv", getInstrumentation());
  }
*/
  public void testWebmSubsampleEncryption() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/subsample_encrypted_noaltref.webm", getInstrumentation());
  }

  public void testWebmSubsampleEncryptionWithAltrefFrames() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/subsample_encrypted_altref.webm", getInstrumentation());
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.text;

import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.text.cea.Cea608Decoder;
import com.google.android.exoplayer2.text.cea.Cea708Decoder;
import com.google.android.exoplayer2.text.ssa.SSADecoder;
import com.google.android.exoplayer2.text.subrip.SubripDecoder;
import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
import com.google.android.exoplayer2.text.webvtt.Mp4WebvttDecoder;
import com.google.android.exoplayer2.text.webvtt.WebvttDecoder;
import com.google.android.exoplayer2.util.MimeTypes;

/**
 * A factory for {@link SubtitleDecoder} instances.
 */
public interface SubtitleDecoderFactory {

  /**
   * Returns whether the factory is able to instantiate a {@link SubtitleDecoder} for the given
   * {@link Format}.
   *
   * @param format The {@link Format}.
   * @return Whether the factory can instantiate a suitable {@link SubtitleDecoder}.
   */
  boolean supportsFormat(Format format);

  /**
   * Creates a {@link SubtitleDecoder} for the given {@link Format}.
   *
   * @param format The {@link Format}.
   * @return A new {@link SubtitleDecoder}.
   * @throws IllegalArgumentException If the {@link Format} is not supported.
   */
  SubtitleDecoder createDecoder(Format format);

  /**
   * Default {@link SubtitleDecoderFactory} implementation.
   * <p>
   * The formats supported by this factory are:
   * <ul>
   * <li>WebVTT ({@link WebvttDecoder})</li>
   * <li>WebVTT (MP4) ({@link Mp4WebvttDecoder})</li>
   * <li>TTML ({@link TtmlDecoder})</li>
   * <li>SubRip ({@link SubripDecoder})</li>
   * <li>AAS/SSA ({@link SSADecoder})</li>
   * <li>TX3G ({@link Tx3gDecoder})</li>
   * <li>Cea608 ({@link Cea608Decoder})</li>
   * <li>Cea708 ({@link Cea708Decoder})</li>
   * </ul>
   */
  SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {

    @Override
    public boolean supportsFormat(Format format) {
      return getDecoderClass(format.sampleMimeType) != null;
    }

    @Override
    public SubtitleDecoder createDecoder(Format format) {
      try {
        Class<?> clazz = getDecoderClass(format.sampleMimeType);
        if (clazz == null) {
          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
        }
        if (format.sampleMimeType.equals(MimeTypes.TEXT_SSA)) {
          byte[] header = format.initializationData.get(1);
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(byte[].class, String.class)
                  .newInstance(header, new String(format.initializationData.get(0), "UTF-8"));
        }
        else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(String.class, Integer.TYPE)
              .newInstance(format.sampleMimeType, format.accessibilityChannel);
        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
              .newInstance(format.accessibilityChannel);
        } else {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
        }
      } catch (Exception e) {
        throw new IllegalStateException("Unexpected error instantiating decoder", e);
      }
    }

    private Class<?> getDecoderClass(String mimeType) {
      if (mimeType == null) {
        return null;
      }
      try {
        switch (mimeType) {
          case MimeTypes.TEXT_VTT:
            return Class.forName("com.google.android.exoplayer2.text.webvtt.WebvttDecoder");
          case MimeTypes.APPLICATION_TTML:
            return Class.forName("com.google.android.exoplayer2.text.ttml.TtmlDecoder");
          case MimeTypes.APPLICATION_MP4VTT:
            return Class.forName("com.google.android.exoplayer2.text.webvtt.Mp4WebvttDecoder");
          case MimeTypes.APPLICATION_SUBRIP:
            return Class.forName("com.google.android.exoplayer2.text.subrip.SubripDecoder");
          case MimeTypes.TEXT_SSA:
            return Class.forName("com.google.android.exoplayer2.text.ssa.SSADecoder");
          case MimeTypes.APPLICATION_TX3G:
            return Class.forName("com.google.android.exoplayer2.text.tx3g.Tx3gDecoder");
          case MimeTypes.APPLICATION_CEA608:
          case MimeTypes.APPLICATION_MP4CEA608:
            return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
          case MimeTypes.APPLICATION_CEA708:
            return Class.forName("com.google.android.exoplayer2.text.cea.Cea708Decoder");
          default:
            return null;
        }
      } catch (ClassNotFoundException e) {
        return null;
      }
    }

  };

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.util;

import android.text.TextUtils;
import com.google.android.exoplayer2.C;

/**
 * Defines common MIME types and helper methods.
 */
public final class MimeTypes {

  public static final String BASE_TYPE_VIDEO = "video";
  public static final String BASE_TYPE_AUDIO = "audio";
  public static final String BASE_TYPE_TEXT = "text";
  public static final String BASE_TYPE_APPLICATION = "application";

  public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
  public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
  public static final String VIDEO_H263 = BASE_TYPE_VIDEO + "/3gpp";
  public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
  public static final String VIDEO_H265 = BASE_TYPE_VIDEO + "/hevc";
  public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
  public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
  public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
  public static final String VIDEO_MPEG2 = BASE_TYPE_VIDEO + "/mpeg2";
  public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
  public static final String VIDEO_UNKNOWN = BASE_TYPE_VIDEO + "/x-unknown";

  public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
  public static final String AUDIO_AAC = BASE_TYPE_AUDIO + "/mp4a-latm";
  public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
  public static final String AUDIO_MPEG = BASE_TYPE_AUDIO + "/mpeg";
  public static final String AUDIO_MPEG_L1 = BASE_TYPE_AUDIO + "/mpeg-L1";
  public static final String AUDIO_MPEG_L2 = BASE_TYPE_AUDIO + "/mpeg-L2";
  public static final String AUDIO_RAW = BASE_TYPE_AUDIO + "/raw";
  public static final String AUDIO_ALAW = BASE_TYPE_AUDIO + "/g711-alaw";
  public static final String AUDIO_ULAW = BASE_TYPE_AUDIO + "/g711-mlaw";
  public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
  public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
  public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
  public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
  public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
  public static final String AUDIO_DTS_EXPRESS = BASE_TYPE_AUDIO + "/vnd.dts.hd;profile=lbr";
  public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
  public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
  public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
  public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
  public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
  public static final String AUDIO_ALAC = BASE_TYPE_AUDIO + "/alac";

  public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
  public static final String TEXT_SSA = BASE_TYPE_TEXT + "/x-ssa";

  public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
  public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
  public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
  public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
  public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
  public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
  public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
  public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
  public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4-vtt";
  public static final String APPLICATION_MP4CEA608 = BASE_TYPE_APPLICATION + "/x-mp4-cea-608";
  public static final String APPLICATION_RAWCC = BASE_TYPE_APPLICATION + "/x-rawcc";
  public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
  public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
  public static final String APPLICATION_SCTE35 = BASE_TYPE_APPLICATION + "/x-scte35";
  public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
  public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";

  private MimeTypes() {}

  /**
   * Whether the top-level type of {@code mimeType} is audio.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is audio.
   */
  public static boolean isAudio(String mimeType) {
    return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is video.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is video.
   */
  public static boolean isVideo(String mimeType) {
    return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is text.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is text.
   */
  public static boolean isText(String mimeType) {
    return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is application.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is application.
   */
  public static boolean isApplication(String mimeType) {
    return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
  }


  /**
   * Derives a video sample mimeType from a codecs attribute.
   *
   * @param codecs The codecs attribute.
   * @return The derived video mimeType, or null if it could not be derived.
   */
  public static String getVideoMediaMimeType(String codecs) {
    if (codecs == null) {
      return null;
    }
    String[] codecList = codecs.split(",");
    for (String codec : codecList) {
      String mimeType = getMediaMimeType(codec);
      if (mimeType != null && isVideo(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }

  /**
   * Derives a audio sample mimeType from a codecs attribute.
   *
   * @param codecs The codecs attribute.
   * @return The derived audio mimeType, or null if it could not be derived.
   */
  public static String getAudioMediaMimeType(String codecs) {
    if (codecs == null) {
      return null;
    }
    String[] codecList = codecs.split(",");
    for (String codec : codecList) {
      String mimeType = getMediaMimeType(codec);
      if (mimeType != null && isAudio(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }

  /**
   * Derives a mimeType from a codec identifier, as defined in RFC 6381.
   *
   * @param codec The codec identifier to derive.
   * @return The mimeType, or null if it could not be derived.
   */
  public static String getMediaMimeType(String codec) {
    if (codec == null) {
      return null;
    }
    codec = codec.trim();
    if (codec.startsWith("avc1") || codec.startsWith("avc3")) {
      return MimeTypes.VIDEO_H264;
    } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
      return MimeTypes.VIDEO_H265;
    } else if (codec.startsWith("vp9")) {
      return MimeTypes.VIDEO_VP9;
    } else if (codec.startsWith("vp8")) {
      return MimeTypes.VIDEO_VP8;
    } else if (codec.startsWith("mp4a")) {
      return MimeTypes.AUDIO_AAC;
    } else if (codec.startsWith("ac-3") || codec.startsWith("dac3")) {
      return MimeTypes.AUDIO_AC3;
    } else if (codec.startsWith("ec-3") || codec.startsWith("dec3")) {
      return MimeTypes.AUDIO_E_AC3;
    } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
      return MimeTypes.AUDIO_DTS;
    } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
      return MimeTypes.AUDIO_DTS_HD;
    } else if (codec.startsWith("opus")) {
      return MimeTypes.AUDIO_OPUS;
    } else if (codec.startsWith("vorbis")) {
      return MimeTypes.AUDIO_VORBIS;
    }
    return null;
  }

  /**
   * Returns the {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
   * {@link C#TRACK_TYPE_UNKNOWN} if the mime type is not known or the mapping cannot be
   * established.
   *
   * @param mimeType The mimeType.
   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
   */
  public static int getTrackType(String mimeType) {
    if (TextUtils.isEmpty(mimeType)) {
      return C.TRACK_TYPE_UNKNOWN;
    } else if (isAudio(mimeType)) {
      return C.TRACK_TYPE_AUDIO;
    } else if (isVideo(mimeType)) {
      return C.TRACK_TYPE_VIDEO;
    } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_MP4CEA608.equals(mimeType)
        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
        || APPLICATION_PGS.equals(mimeType)) {
      return C.TRACK_TYPE_TEXT;
    } else if (APPLICATION_ID3.equals(mimeType)
        || APPLICATION_EMSG.equals(mimeType)
        || APPLICATION_SCTE35.equals(mimeType)
        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
      return C.TRACK_TYPE_METADATA;
    } else {
      return C.TRACK_TYPE_UNKNOWN;
    }
  }

  /**
   * Equivalent to {@code getTrackType(getMediaMimeType(codec))}.
   *
   * @param codec The codec.
   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified codec.
   */
  public static int getTrackTypeOfCodec(String codec) {
    return getTrackType(getMediaMimeType(codec));
  }

  /**
   * Returns the top-level type of {@code mimeType}.
   *
   * @param mimeType The mimeType whose top-level type is required.
   * @return The top-level type, or null if the mimeType is null.
   */
  private static String getTopLevelType(String mimeType) {
    if (mimeType == null) {
      return null;
    }
    int indexOfSlash = mimeType.indexOf('/');
    if (indexOfSlash == -1) {
      throw new IllegalArgumentException("Invalid mime type: " + mimeType);
    }
    return mimeType.substring(0, indexOfSlash);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java;<<<<<<< MINE
    boolean haveSupportedTracks = false;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java;<<<<<<< MINE
          haveSupportedTracks = true;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/demo/src/main/java/com/google/android/exoplayer2/demo/TrackSelectionHelper.java;<<<<<<< MINE
    if (!haveSupportedTracks) {
      // Indicate that the default selection will be nothing.
      defaultView.setText(R.string.selection_default_none);
    } else if (haveAdaptiveTracks) {
=======
    if (haveAdaptiveTracks) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/gvr/src/main/java/com/google/android/exoplayer2/ext/gvr/GvrAudioProcessor.java;<<<<<<< MINE
=======
      case 1:
        surroundFormat = GvrAudioSurround.SurroundFormat.SURROUND_MONO;
        break;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
=======
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
  private final Call.Factory callFactory;
  private final String userAgent;
  private final TransferListener<? super DataSource> listener;
  private final CacheControl cacheControl;
=======
  @NonNull private final Call.Factory callFactory;
  @Nullable private final String userAgent;
  @Nullable private final TransferListener<? super DataSource> listener;
  @Nullable private final CacheControl cacheControl;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
   * @param userAgent The User-Agent string that should be used.
=======
   * @param userAgent An optional User-Agent string.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
      TransferListener<? super DataSource> listener) {
=======
  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
      @Nullable TransferListener<? super DataSource> listener) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
   * @param userAgent The User-Agent string that should be used.
=======
   * @param userAgent An optional User-Agent string.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/extensions/okhttp/src/main/java/com/google/android/exoplayer2/ext/okhttp/OkHttpDataSourceFactory.java;<<<<<<< MINE
  public OkHttpDataSourceFactory(Call.Factory callFactory, String userAgent,
      TransferListener<? super DataSource> listener, CacheControl cacheControl) {
=======
  public OkHttpDataSourceFactory(@NonNull Call.Factory callFactory, @Nullable String userAgent,
      @Nullable TransferListener<? super DataSource> listener,
      @Nullable CacheControl cacheControl) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
import java.util.Collections;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
  private static final String AVG_BANDWIDTH_MASTER_PLAYLIST = " #EXTM3U \n"
      + "\n"
      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128\n"
      + "http://example.com/low.m3u8\n"
      + "\n"
      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,AVERAGE-BANDWIDTH=1270000,"
      + "CODECS=\"mp4a.40.2 , avc1.66.30 \"\n"
      + "http://example.com/spaces_in_codecs.m3u8\n";

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
      + "\n"
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
  private static final String MASTER_PLAYLIST_WITHOUT_CC = " #EXTM3U \n"
      + "#EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,LANGUAGE=\"es\",NAME=\"Eng\",INSTREAM-ID=\"SERVICE4\"\n"
      + "#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"mp4a.40.2,avc1.66.30\",RESOLUTION=304x128,"
      + "CLOSED-CAPTIONS=NONE\n"
      + "http://example.com/low.m3u8\n";

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertNotNull(variants);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
    assertNull(masterPlaylist.muxedCaptionFormats);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertNotNull(variants.get(0).format.codecs);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertNotNull(variants.get(1).format.codecs);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertEquals(null, variants.get(2).format.codecs);
=======
    assertNull(variants.get(2).format.codecs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertEquals(null, variants.get(3).format.codecs);
=======
    assertNull(variants.get(3).format.codecs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
    assertNotNull(variants.get(4).format.codecs);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
  public void testMasterPlaylistWithBandwdithAverage() throws IOException {
    HlsMasterPlaylist masterPlaylist = parseMasterPlaylist(PLAYLIST_URI,
        AVG_BANDWIDTH_MASTER_PLAYLIST);

    List<HlsMasterPlaylist.HlsUrl> variants = masterPlaylist.variants;

    assertEquals(1280000, variants.get(0).format.bitrate);
    assertEquals(1270000, variants.get(1).format.bitrate);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/androidTest/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylistParserTest.java;<<<<<<< MINE
=======
  public void testPlaylistWithoutClosedCaptions() throws IOException {
    HlsMasterPlaylist playlist = parseMasterPlaylist(PLAYLIST_URI, MASTER_PLAYLIST_WITHOUT_CC);
    assertEquals(Collections.emptyList(), playlist.muxedCaptionFormats);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaSource.java;<<<<<<< MINE
    playlistTracker.maybeThrowPlaylistRefreshError();
=======
    playlistTracker.maybeThrowPrimaryPlaylistRefreshError();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
    /**
     * The http url from which the media playlist can be obtained.
     */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
    /**
     * Format information associated with the HLS url.
     */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
    public static HlsUrl createMediaPlaylistHlsUrl(String baseUri) {
=======
    /**
     * Creates an HLS url from a given http url.
     *
     * @param url The url.
     * @return An HLS url.
     */
    public static HlsUrl createMediaPlaylistHlsUrl(String url) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
      return new HlsUrl(baseUri, format);
=======
      return new HlsUrl(url, format);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
    /**
     * @param url See {@link #url}.
     * @param format See {@link #format}.
     */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
  /**
   * The list of variants declared by the playlist.
   */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
  /**
   * The list of demuxed audios declared by the playlist.
   */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
  /**
   * The list of subtitles declared by the playlist.
   */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
  /**
   * The format of the audio muxed in the variants. May be null if the playlist does not declare any
   * muxed audio.
   */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
  /**
   * The format of the closed captions declared by the playlist. May be empty if the playlist
   * explicitly declares no captions are available, or null if the playlist does not declare any
   * captions information.
   */
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
  /**
   * @param baseUri See {@link #baseUri}.
   * @param tags See {@link #tags}.
   * @param variants See {@link #variants}.
   * @param audios See {@link #audios}.
   * @param subtitles See {@link #subtitles}.
   * @param muxedAudioFormat See {@link #muxedAudioFormat}.
   * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
   */
  public HlsMasterPlaylist(String baseUri, List<String> tags, List<HlsUrl> variants,
      List<HlsUrl> audios, List<HlsUrl> subtitles, Format muxedAudioFormat,
      List<Format> muxedCaptionFormats) {
    super(baseUri, tags);
=======
  /**
   * @param baseUri The base uri. Used to resolve relative paths.
   * @param variants See {@link #variants}.
   * @param audios See {@link #audios}.
   * @param subtitles See {@link #subtitles}.
   * @param muxedAudioFormat See {@link #muxedAudioFormat}.
   * @param muxedCaptionFormats See {@link #muxedCaptionFormats}.
   */
  public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
      List<HlsUrl> subtitles, Format muxedAudioFormat, List<Format> muxedCaptionFormats) {
    super(baseUri);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
    this.muxedCaptionFormats = Collections.unmodifiableList(muxedCaptionFormats);
=======
    this.muxedCaptionFormats = muxedCaptionFormats != null
        ? Collections.unmodifiableList(muxedCaptionFormats) : null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUri) {
    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUri));
=======
  /**
   * Creates a playlist with a single variant.
   *
   * @param variantUrl The url of the single variant.
   * @return A master playlist with a single variant for the provided url.
   */
  public static HlsMasterPlaylist createSingleVariantMasterPlaylist(String variantUrl) {
    List<HlsUrl> variant = Collections.singletonList(HlsUrl.createMediaPlaylistHlsUrl(variantUrl));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
=======
  private HlsUrl expectedPlaylistUrl;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
=======
   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
   *     information is available in the master playlist.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
=======
    if (expectedPlaylistUrl != null) {
      playlistTracker.maybeThrowPlaylistRefreshError(expectedPlaylistUrl);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
=======
    expectedPlaylistUrl = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
=======
      expectedPlaylistUrl = selectedUrl;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsChunkSource.java;<<<<<<< MINE
=======
        expectedPlaylistUrl = selectedUrl;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
=======
import java.util.Collections;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
   * @param muxedCaptionFormats List of muxed caption {@link Format}s.
=======
   * @param muxedCaptionFormats List of muxed caption {@link Format}s. Null if no closed caption
   *     information is available in the master playlist.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
      if (!muxedCaptionFormats.isEmpty()) {
=======
      List<Format> closedCaptionFormats = muxedCaptionFormats;
      if (closedCaptionFormats != null) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
=======
      } else {
        closedCaptionFormats = Collections.emptyList();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/HlsMediaChunk.java;<<<<<<< MINE
          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, muxedCaptionFormats));
=======
          new DefaultTsPayloadReaderFactory(esReaderFactoryFlags, closedCaptionFormats));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.upstream;

import android.net.Uri;
import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.testutil.TestUtil;

/**
 * Unit tests for {@link AssetDataSource}.
 */
public final class AssetDataSourceTest extends InstrumentationTestCase {

  private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";

  public void testReadFileUri() throws Exception {
    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
    DataSpec dataSpec = new DataSpec(Uri.parse("file:///android_asset/" + DATA_PATH));
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

  public void testReadAssetUri() throws Exception {
    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
    DataSpec dataSpec = new DataSpec(Uri.parse("asset:///" + DATA_PATH));
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.upstream;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.net.Uri;
import android.support.annotation.NonNull;
import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.testutil.TestUtil;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * Unit tests for {@link ContentDataSource}.
 */
public final class ContentDataSourceTest extends InstrumentationTestCase {

  private static final String AUTHORITY = "com.google.android.exoplayer2.core.test";
  private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";

  public void testReadValidUri() throws Exception {
    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
    Uri contentUri = new Uri.Builder()
        .scheme(ContentResolver.SCHEME_CONTENT)
        .authority(AUTHORITY)
        .path(DATA_PATH).build();
    DataSpec dataSpec = new DataSpec(contentUri);
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

  public void testReadInvalidUri() throws Exception {
    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
    Uri contentUri = new Uri.Builder()
        .scheme(ContentResolver.SCHEME_CONTENT)
        .authority(AUTHORITY)
        .build();
    DataSpec dataSpec = new DataSpec(contentUri);
    try {
      dataSource.open(dataSpec);
      fail();
    } catch (ContentDataSource.ContentDataSourceException e) {
      // Expected.
      assertTrue(e.getCause() instanceof FileNotFoundException);
    } finally {
      dataSource.close();
    }
  }

  /**
   * A {@link ContentProvider} for the test.
   */
  public static final class TestContentProvider extends ContentProvider {

    @Override
    public boolean onCreate() {
      return true;
    }

    @Override
    public Cursor query(@NonNull Uri uri, String[] projection, String selection,
        String[] selectionArgs, String sortOrder) {
      throw new UnsupportedOperationException();
    }

    @Override
    public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode)
        throws FileNotFoundException {
      if (uri.getPath() == null) {
        return null;
      }
      try {
        return getContext().getAssets().openFd(uri.getPath().replaceFirst("/", ""));
      } catch (IOException e) {
        FileNotFoundException exception = new FileNotFoundException(e.getMessage());
        exception.initCause(e);
        throw exception;
      }
    }

    @Override
    public String getType(@NonNull Uri uri) {
      throw new UnsupportedOperationException();
    }

    @Override
    public Uri insert(@NonNull Uri uri, ContentValues values) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int delete(@NonNull Uri uri, String selection,
        String[] selectionArgs) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int update(@NonNull Uri uri, ContentValues values,
        String selection, String[] selectionArgs) {
      throw new UnsupportedOperationException();
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArrayTest.java;<<<<<<< MINE
    array.skipBits(1);
=======
    array.skipBit();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.util;

import android.test.MoreAsserts;

import junit.framework.TestCase;

/**
 * Tests for {@link ParsableBitArray}.
 */
public final class ParsableBitArrayTest extends TestCase {

  private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
      (byte) 0xFF, (byte) 0x14, (byte) 0x60, (byte) 0x99};

  public void testReadAllBytes() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    byte[] bytesRead = new byte[TEST_DATA.length];
    testArray.readBytes(bytesRead, 0, TEST_DATA.length);
    MoreAsserts.assertEquals(TEST_DATA, bytesRead);
    assertEquals(TEST_DATA.length * 8, testArray.getPosition());
    assertEquals(TEST_DATA.length, testArray.getBytePosition());
  }

  public void testReadBit() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertReadBitsToEnd(0, testArray);
  }

  public void testReadBits() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(5, 3), testArray.readBits(3));
    assertEquals(getTestDataBits(8, 16), testArray.readBits(16));
    assertEquals(getTestDataBits(24, 3), testArray.readBits(3));
    assertEquals(getTestDataBits(27, 18), testArray.readBits(18));
    assertEquals(getTestDataBits(45, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(50, 14), testArray.readBits(14));
  }

  public void testRead32BitsByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 32), testArray.readBits(32));
    assertEquals(getTestDataBits(32, 32), testArray.readBits(32));
  }

  public void testRead32BitsNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(5, 32), testArray.readBits(32));
  }

  public void testSkipBytes() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBytes(2);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSkipBitsByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBits(16);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSkipBitsNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBits(5);
    assertReadBitsToEnd(5, testArray);
  }

  public void testSetPositionByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(16);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSetPositionNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(5);
    assertReadBitsToEnd(5, testArray);
  }

  public void testByteAlignFromNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(11);
    testArray.byteAlign();
    assertEquals(2, testArray.getBytePosition());
    assertEquals(16, testArray.getPosition());
    assertReadBitsToEnd(16, testArray);
  }

  public void testByteAlignFromByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(16);
    testArray.byteAlign(); // Should be a no-op.
    assertEquals(2, testArray.getBytePosition());
    assertEquals(16, testArray.getPosition());
    assertReadBitsToEnd(16, testArray);
  }

  private static void assertReadBitsToEnd(int expectedStartPosition, ParsableBitArray testArray) {
    int position = testArray.getPosition();
    assertEquals(expectedStartPosition, position);
    for (int i = position; i < TEST_DATA.length * 8; i++) {
      assertEquals(getTestDataBit(i), testArray.readBit());
      assertEquals(i + 1, testArray.getPosition());
    }
  }

  private static int getTestDataBits(int bitPosition, int length) {
    int result = 0;
    for (int i = 0; i < length; i++) {
      result = result << 1;
      if (getTestDataBit(bitPosition++)) {
        result |= 0x1;
      }
    }
    return result;
  }

  private static boolean getTestDataBit(int bitPosition) {
    return (TEST_DATA[bitPosition / 8] & (0x80 >>> (bitPosition % 8))) != 0;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

    try {
      assertFalse(bitArray.readBit());
      fail();
    } catch (IllegalStateException e) {/* ignored */}
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE
    try {
      bitArray.readBit();
      fail();
    } catch (IllegalStateException e) {
      // ignored
    }
  }


  public void testSkipBitsThrowsErrorIfEOB() {
    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));

    try {
      bitArray.skipBits(17);
      fail();
    } catch (IllegalStateException e) {/* ignored */}
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE
    try {
      bitArray.readBit();
      fail();
    } catch (IllegalStateException e) {/* ignored */}

  }
  public void testSetPositionIllegalPositions() throws Exception {
    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xF0, 0x0F));

    try {
      bitArray.setPosition(16);
      fail();
    } catch (IllegalArgumentException e) {
      assertEquals(0, bitArray.getPosition());
    }

    try {
      bitArray.setPosition(-1);
      fail();
    } catch (IllegalArgumentException e) {
      assertEquals(0, bitArray.getPosition());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArrayTest.java;<<<<<<< MINE

    try {
      bitArray.readBits(24);
      fail();
    } catch (IllegalStateException e) {
      assertEquals(1, bitArray.getPosition());
    }
  }

  public void testLimit() {
    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xc0, 0x02), 1);

    try {
      bitArray.skipBits(9);
      fail();
    } catch (IllegalStateException e) {
      assertEquals(0, bitArray.getPosition());
    }

    try {
      bitArray.readBits(9);
      fail();
    } catch (IllegalStateException e) {
      assertEquals(0, bitArray.getPosition());
    }

    int byteValue = bitArray.readBits(8);
    assertEquals(0xc0, byteValue);
    assertEquals(8, bitArray.getPosition());
    try {
      bitArray.readBit();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(8, bitArray.getPosition());
    }
  }

  public void testBitsLeft() {
    VorbisBitArray bitArray = new VorbisBitArray(TestUtil.createByteArray(0xc0, 0x02));

    assertEquals(16, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.skipBits(1);
    assertEquals(15, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.skipBits(3);
    assertEquals(12, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.setPosition(6);
    assertEquals(10, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.skipBits(1);
    assertEquals(9, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.skipBits(1);
    assertEquals(8, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.readBits(4);
    assertEquals(4, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    bitArray.readBits(4);
    assertEquals(0, bitArray.bitsLeft());
    assertEquals(bitArray.limit(), bitArray.getPosition() + bitArray.bitsLeft());

    try {
      bitArray.readBit();
      fail();
    } catch (IllegalStateException e) {
      assertEquals(0, bitArray.bitsLeft());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.trackselection;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.ExoPlaybackException;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.RendererCapabilities;
import com.google.android.exoplayer2.source.TrackGroup;
import com.google.android.exoplayer2.source.TrackGroupArray;
import com.google.android.exoplayer2.util.MimeTypes;
import junit.framework.TestCase;

/**
 * Unit tests for {@link MappingTrackSelector}.
 */
public final class MappingTrackSelectorTest extends TestCase {

  private static final RendererCapabilities VIDEO_CAPABILITIES =
      new FakeRendererCapabilities(C.TRACK_TYPE_VIDEO);
  private static final RendererCapabilities AUDIO_CAPABILITIES =
      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
  private static final RendererCapabilities[] RENDERER_CAPABILITIES = new RendererCapabilities[] {
      VIDEO_CAPABILITIES, AUDIO_CAPABILITIES
  };

  private static final TrackGroup VIDEO_TRACK_GROUP = new TrackGroup(
      Format.createVideoSampleFormat("video", MimeTypes.VIDEO_H264, null, Format.NO_VALUE,
          Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, null));
  private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(
      Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
          Format.NO_VALUE, 2, 44100, null, null, 0, null));
  private static final TrackGroupArray TRACK_GROUPS = new TrackGroupArray(
      VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);

  private static final TrackSelection[] TRACK_SELECTIONS = new TrackSelection[] {
      new FixedTrackSelection(VIDEO_TRACK_GROUP, 0),
      new FixedTrackSelection(AUDIO_TRACK_GROUP, 0)
  };

  /**
   * Tests that the video and audio track groups are mapped onto the correct renderers.
   */
  public void testMapping() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
  }

  /**
   * Tests that the video and audio track groups are mapped onto the correct renderers when the
   * renderer ordering is reversed.
   */
  public void testMappingReverseOrder() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    RendererCapabilities[] reverseOrderRendererCapabilities = new RendererCapabilities[] {
        AUDIO_CAPABILITIES, VIDEO_CAPABILITIES};
    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS);
    trackSelector.assertMappedTrackGroups(0, AUDIO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, VIDEO_TRACK_GROUP);
  }

  /**
   * Tests video and audio track groups are mapped onto the correct renderers when there are
   * multiple track groups of the same type.
   */
  public void testMappingMulti() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    TrackGroupArray multiTrackGroups = new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP,
        VIDEO_TRACK_GROUP);
    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups);
    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP, VIDEO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
  }

  /**
   * Tests the result of {@link MappingTrackSelector#selectTracks(RendererCapabilities[],
   * TrackGroupArray[], int[][][])} is propagated correctly to the result of
   * {@link MappingTrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)}.
   */
  public void testSelectTracks() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that a null override clears a track selection.
   */
  public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertNull(result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that a null override can be cleared.
   */
  public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    trackSelector.clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP));
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that an override is not applied for a different set of available track groups.
   */
  public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES,
        new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * A {@link MappingTrackSelector} that returns a fixed result from
   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray[], int[][][])}.
   */
  private static final class FakeMappingTrackSelector extends MappingTrackSelector {

    private final TrackSelection[] result;
    private TrackGroupArray[] lastRendererTrackGroupArrays;

    public FakeMappingTrackSelector(TrackSelection... result) {
      this.result = result.length == 0 ? null : result;
    }

    @Override
    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
        throws ExoPlaybackException {
      lastRendererTrackGroupArrays = rendererTrackGroupArrays;
      return result == null ? new TrackSelection[rendererCapabilities.length] : result;
    }

    public void assertMappedTrackGroups(int rendererIndex, TrackGroup... expected) {
      assertEquals(expected.length, lastRendererTrackGroupArrays[rendererIndex].length);
      for (int i = 0; i < expected.length; i++) {
        assertEquals(expected[i], lastRendererTrackGroupArrays[rendererIndex].get(i));
      }
    }

  }

  /**
   * A {@link RendererCapabilities} that advertises adaptive support for all tracks of a given type.
   */
  private static final class FakeRendererCapabilities implements RendererCapabilities {

    private final int trackType;

    public FakeRendererCapabilities(int trackType) {
      this.trackType = trackType;
    }

    @Override
    public int getTrackType() {
      return trackType;
    }

    @Override
    public int supportsFormat(Format format) throws ExoPlaybackException {
      return MimeTypes.getTrackType(format.sampleMimeType) == trackType
          ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;
    }

    @Override
    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
      return ADAPTIVE_SEAMLESS;
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
=======
  public final String id;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
  @Cue.LineType
  public final int lineType;
=======
  @Cue.LineType public final int lineType;
  @Cue.AnchorType public final int lineAnchor;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
  public TtmlRegion() {
    this(Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
=======
  public TtmlRegion(String id) {
    this(id, Cue.DIMEN_UNSET, Cue.DIMEN_UNSET, Cue.TYPE_UNSET, Cue.TYPE_UNSET, Cue.DIMEN_UNSET);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
  public TtmlRegion(float position, float line, @Cue.LineType int lineType, float width) {
=======
  public TtmlRegion(String id, float position, float line, @Cue.LineType int lineType,
      @Cue.AnchorType int lineAnchor, float width) {
    this.id = id;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/text/ttml/TtmlRegion.java;<<<<<<< MINE
=======
    this.lineAnchor = lineAnchor;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java;<<<<<<< MINE
    short left = in[inPos * numChannels];
    short right = in[inPos * numChannels + numChannels];
=======
    short left = in[inPos];
    short right = in[inPos + numChannels];
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/audio/Sonic.java;<<<<<<< MINE
              interpolate(pitchBuffer, position + i, oldSampleRate, newSampleRate);
=======
              interpolate(pitchBuffer, position * numChannels + i, oldSampleRate, newSampleRate);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
import android.os.Looper;
=======
import android.os.Looper;
import android.support.annotation.IntDef;
import android.support.annotation.Nullable;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
 * <li>Registered listeners are called on the thread that created the ExoPlayer instance.</li>
=======
 * <li>Registered listeners are called on the thread that created the ExoPlayer instance, unless
 * the thread that created the ExoPlayer instance does not have a {@link Looper}. In that case,
 * registered listeners will be called on the application's main thread.</li>
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
  @Deprecated
  interface EventListener extends Player.EventListener {}
=======
  interface EventListener {

    /**
     * Called when the timeline and/or manifest has been refreshed.
     * <p>
     * Note that if the timeline has changed then a position discontinuity may also have occurred.
     * For example, the current period index may have changed as a result of periods being added or
     * removed from the timeline. This will <em>not</em> be reported via a separate call to
     * {@link #onPositionDiscontinuity()}.
     *
     * @param timeline The latest timeline. Never null, but may be empty.
     * @param manifest The latest manifest. May be null.
     */
    void onTimelineChanged(Timeline timeline, Object manifest);

    /**
     * Called when the available or selected tracks change.
     *
     * @param trackGroups The available tracks. Never null, but may be of length zero.
     * @param trackSelections The track selections for each {@link Renderer}. Never null and always
     *     of length {@link #getRendererCount()}, but may contain null elements.
     */
    void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections);

    /**
     * Called when the player starts or stops loading the source.
     *
     * @param isLoading Whether the source is currently being loaded.
     */
    void onLoadingChanged(boolean isLoading);

    /**
     * Called when the value returned from either {@link #getPlayWhenReady()} or
     * {@link #getPlaybackState()} changes.
     *
     * @param playWhenReady Whether playback will proceed when ready.
     * @param playbackState One of the {@code STATE} constants defined in the {@link ExoPlayer}
     *     interface.
     */
    void onPlayerStateChanged(boolean playWhenReady, int playbackState);

    /**
     * Called when an error occurs. The playback state will transition to {@link #STATE_IDLE}
     * immediately after this method is called. The player instance can still be used, and
     * {@link #release()} must still be called on the player should it no longer be required.
     *
     * @param error The error.
     */
    void onPlayerError(ExoPlaybackException error);

    /**
     * Called when a position discontinuity occurs without a change to the timeline. A position
     * discontinuity occurs when the current window or period index changes (as a result of playback
     * transitioning from one period in the timeline to the next), or when the playback position
     * jumps within the period currently being played (as a result of a seek being performed, or
     * when the source introduces a discontinuity internally).
     * <p>
     * When a position discontinuity occurs as a result of a change to the timeline this method is
     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object)} is called in this case.
     */
    void onPositionDiscontinuity();

    /**
     * Called when the current playback parameters change. The playback parameters may change due to
     * a call to {@link ExoPlayer#setPlaybackParameters(PlaybackParameters)}, or the player itself
     * may change them (for example, if audio playback switches to passthrough mode, where speed
     * adjustment is no longer possible).
     *
     * @param playbackParameters The playback parameters.
     */
    void onPlaybackParametersChanged(PlaybackParameters playbackParameters);

  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
   * @deprecated Use {@link Player#REPEAT_MODE_OFF} instead.
   */
  @Deprecated
  @RepeatMode int REPEAT_MODE_OFF = Player.REPEAT_MODE_OFF;
  /**
   * @deprecated Use {@link Player#REPEAT_MODE_ONE} instead.
=======
   * Register a listener to receive events from the player. The listener's methods will be called on
   * the thread that was used to construct the player. However, if the thread used to construct the
   * player does not have a {@link Looper}, then the listener will be called on the main thread.
   *
   * @param listener The listener to register.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
import android.os.Looper;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}. Available extension renderers are not used.
=======
   * Creates a {@link SimpleExoPlayer} instance. Available extension renderers are not used.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates a {@link SimpleExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates a {@link SimpleExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates an {@link ExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates an {@link ExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayerFactory.java;<<<<<<< MINE
   * Creates an {@link ExoPlayer} instance. Must be called from a thread that has an associated
   * {@link Looper}.
=======
   * Creates an {@link ExoPlayer} instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
   * Creates an instance.
   *
   * @param name The name of the {@link MediaCodec}.
   * @param mimeType A mime type supported by the {@link MediaCodec}.
   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
   * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
   * @param forceSecure Whether {@link #secure} should be forced to {@code true}.
   * @return The created instance.
=======
   * Creates an instance.
   *
   * @param name The name of the {@link MediaCodec}.
   * @param mimeType A mime type supported by the {@link MediaCodec}.
   * @param capabilities The capabilities of the {@link MediaCodec} for the specified mime type.
   * @param forceDisableAdaptive Whether {@link #adaptive} should be forced to {@code false}.
   * @return The created instance.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
  public static MediaCodecInfo newInstance(String name, String mimeType,
      CodecCapabilities capabilities, boolean forceDisableAdaptive, boolean forceSecure) {
    return new MediaCodecInfo(name, mimeType, capabilities, forceDisableAdaptive, forceSecure);
  }

  private MediaCodecInfo(String name, String mimeType, CodecCapabilities capabilities,
      boolean forceDisableAdaptive, boolean forceSecure) {
=======
  public static MediaCodecInfo newInstance(String name, String mimeType,
      CodecCapabilities capabilities, boolean forceDisableAdaptive) {
    return new MediaCodecInfo(name, mimeType, capabilities, forceDisableAdaptive);
  }

  private MediaCodecInfo(String name, String mimeType, CodecCapabilities capabilities,
      boolean forceDisableAdaptive) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
    adaptive = capabilities != null && isAdaptive(capabilities);
=======
    adaptive = !forceDisableAdaptive && capabilities != null && isAdaptive(capabilities);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
    if (audioCapabilities.getMaxInputChannelCount() < channelCount) {
=======
    int maxInputChannelCount = adjustMaxInputChannelCount(name, mimeType,
        audioCapabilities.getMaxInputChannelCount());
    if (maxInputChannelCount < channelCount) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/mediacodec/MediaCodecInfo.java;<<<<<<< MINE
=======
  private static int adjustMaxInputChannelCount(String name, String mimeType, int maxChannelCount) {
    if (maxChannelCount > 1 || (Util.SDK_INT >= 26 && maxChannelCount > 0)) {
      // The maximum channel count looks like it's been set correctly.
      return maxChannelCount;
    }
    if (MimeTypes.AUDIO_MPEG.equals(mimeType)
        || MimeTypes.AUDIO_AMR_NB.equals(mimeType)
        || MimeTypes.AUDIO_AMR_WB.equals(mimeType)
        || MimeTypes.AUDIO_AAC.equals(mimeType)
        || MimeTypes.AUDIO_VORBIS.equals(mimeType)
        || MimeTypes.AUDIO_OPUS.equals(mimeType)
        || MimeTypes.AUDIO_RAW.equals(mimeType)
        || MimeTypes.AUDIO_FLAC.equals(mimeType)
        || MimeTypes.AUDIO_ALAW.equals(mimeType)
        || MimeTypes.AUDIO_MLAW.equals(mimeType)
        || MimeTypes.AUDIO_MSGSM.equals(mimeType)) {
      // Platform code should have set a default.
      return maxChannelCount;
    }
    // The maximum channel count looks incorrect. Adjust it to an assumed default.
    int assumedMaxChannelCount;
    if (MimeTypes.AUDIO_AC3.equals(mimeType)) {
      assumedMaxChannelCount = 6;
    } else if (MimeTypes.AUDIO_E_AC3.equals(mimeType)) {
      assumedMaxChannelCount = 16;
    } else {
      // Default to the platform limit, which is 30.
      assumedMaxChannelCount = 30;
    }
    Log.w(TAG, "AssumedMaxChannelAdjustment: " + name + ", [" + maxChannelCount + " to "
        + assumedMaxChannelCount + "]");
    return assumedMaxChannelCount;
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java;<<<<<<< MINE
=======
import android.os.Looper;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/SimpleExoPlayer.java;<<<<<<< MINE
    renderers = renderersFactory.createRenderers(new Handler(), componentListener,
        componentListener, componentListener, componentListener);
=======
    Looper eventLooper = Looper.myLooper() != null ? Looper.myLooper() : Looper.getMainLooper();
    Handler eventHandler = new Handler(eventLooper);
    renderers = renderersFactory.createRenderers(eventHandler, componentListener, componentListener,
        componentListener, componentListener);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java;<<<<<<< MINE
=======
import java.nio.ByteOrder;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/decoder/SimpleOutputBuffer.java;<<<<<<< MINE
      data = ByteBuffer.allocateDirect(size);
=======
      data = ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
    joiningDeadlineMs = C.TIME_UNSET;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
=======
    joiningDeadlineMs = C.TIME_UNSET;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  protected void onOutputFormatChanged(MediaCodec codec, android.media.MediaFormat outputFormat) {
=======
  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
    return areAdaptationCompatible(oldFormat, newFormat)
=======
    return areAdaptationCompatible(codecIsAdaptive, oldFormat, newFormat)
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
    if (reportedWidth != currentWidth || reportedHeight != currentHeight
=======
    if ((currentWidth != Format.NO_VALUE || currentHeight != Format.NO_VALUE)
      && (reportedWidth != currentWidth || reportedHeight != currentHeight
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
        || reportedPixelWidthHeightRatio != currentPixelWidthHeightRatio) {
=======
        || reportedPixelWidthHeightRatio != currentPixelWidthHeightRatio)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
      eventDispatcher.videoSizeChanged(currentWidth, currentHeight, currentUnappliedRotationDegrees,
          currentPixelWidthHeightRatio);
=======
      eventDispatcher.videoSizeChanged(reportedWidth, reportedHeight,
          reportedUnappliedRotationDegrees, reportedPixelWidthHeightRatio);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
=======
  protected CodecMaxValues getCodecMaxValues(MediaCodecInfo codecInfo, Format format,
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
      if (areAdaptationCompatible(format, streamFormat)) {
=======
      if (areAdaptationCompatible(codecInfo.adaptive, format, streamFormat)) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
   * Returns whether an adaptive codec with suitable {@link CodecMaxValues} will support adaptation
   * between two {@link Format}s.
=======
   * Returns whether a codec with suitable {@link CodecMaxValues} will support adaptation between
   * two {@link Format}s.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
=======
   * @param codecIsAdaptive Whether the codec supports seamless resolution switches.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
   * @return Whether an adaptive codec with suitable {@link CodecMaxValues} will support adaptation
   *     between two {@link Format}s.
=======
   * @return Whether the codec will support adaptation between the two {@link Format}s.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static boolean areAdaptationCompatible(Format first, Format second) {
=======
  private static boolean areAdaptationCompatible(boolean codecIsAdaptive, Format first,
      Format second) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
        && getRotationDegrees(first) == getRotationDegrees(second);
=======
        && getRotationDegrees(first) == getRotationDegrees(second)
        && (codecIsAdaptive || (first.width == second.width && first.height == second.height));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static final class CodecMaxValues {
=======
  protected static final class CodecMaxValues {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;<<<<<<< MINE
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/metadata/MetadataRenderer.java;<<<<<<< MINE
    super.onDisabled();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/source/TrackGroup.java;<<<<<<< MINE
   * @param formats The track formats. Must not be null or contain null elements.
=======
   * @param formats The track formats. Must not be null, contain null elements or be of length 0.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java;<<<<<<< MINE
=======
   * <p>
   * This method should only be called after the period has been prepared.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/source/MediaPeriod.java;<<<<<<< MINE
=======
   * <p>
   * This method should only be called after the period has been prepared.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
=======
   * @see CacheDataSource#CacheDataSource(Cache, DataSource)
   */
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory) {
    this(cache, upstreamFactory, 0);
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory, int flags) {
=======
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
      @CacheDataSource.Flags int flags) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory, int flags,
      long maxCacheFileSize) {
=======
  public CacheDataSourceFactory(Cache cache, DataSource.Factory upstreamFactory,
      @CacheDataSource.Flags int flags, long maxCacheFileSize) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/cache/CacheDataSourceFactory.java;<<<<<<< MINE
      Factory cacheReadDataSourceFactory,
      DataSink.Factory cacheWriteDataSinkFactory, int flags, EventListener eventListener) {
=======
      Factory cacheReadDataSourceFactory, DataSink.Factory cacheWriteDataSinkFactory,
      @CacheDataSource.Flags int flags, EventListener eventListener) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
=======
import java.io.FileNotFoundException;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
=======
      if (assetFileDescriptor == null) {
        throw new FileNotFoundException("Could not open file descriptor for: " + uri);
      }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
      long skipped = inputStream.skip(dataSpec.position);
      if (skipped < dataSpec.position) {
=======
      long assertStartOffset = assetFileDescriptor.getStartOffset();
      long skipped = inputStream.skip(assertStartOffset + dataSpec.position) - assertStartOffset;
      if (skipped != dataSpec.position) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/upstream/ContentDataSource.java;<<<<<<< MINE
        bytesRemaining = inputStream.available();
        if (bytesRemaining == 0) {
          // FileInputStream.available() returns 0 if the remaining length cannot be determined, or
          // if it's greater than Integer.MAX_VALUE. We don't know the true length in either case,
          // so treat as unbounded.
          bytesRemaining = C.LENGTH_UNSET;
=======
        bytesRemaining = assetFileDescriptor.getLength();
        if (bytesRemaining == AssetFileDescriptor.UNKNOWN_LENGTH) {
          // The asset must extend to the end of the file.
          bytesRemaining = inputStream.available();
          if (bytesRemaining == 0) {
            // FileInputStream.available() returns 0 if the remaining length cannot be determined,
            // or if it's greater than Integer.MAX_VALUE. We don't know the true length in either
            // case, so treat as unbounded.
            bytesRemaining = C.LENGTH_UNSET;
          }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
      data.skipBits(1); // qpprime_y_zero_transform_bypass_flag
=======
      data.skipBit(); // qpprime_y_zero_transform_bypass_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // gaps_in_frame_num_value_allowed_flag
=======
    data.skipBit(); // gaps_in_frame_num_value_allowed_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
      data.skipBits(1); // mb_adaptive_frame_field_flag
=======
      data.skipBit(); // mb_adaptive_frame_field_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // direct_8x8_inference_flag
=======
    data.skipBit(); // direct_8x8_inference_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/NalUnitUtil.java;<<<<<<< MINE
    data.skipBits(1); // entropy_coding_mode_flag
=======
    data.skipBit(); // entropy_coding_mode_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
=======
   * Skips a single bit.
   */
  public void skipBit() {
    if (++bitOffset == 8) {
      bitOffset = 0;
      byteOffset++;
    }
    assertValidOffset();
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
   * @param n The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
  public void skipBits(int n) {
    byteOffset += (n / 8);
    bitOffset += (n % 8);
=======
  public void skipBits(int numBits) {
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;
    skipBit();
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE

    // Read any remaining bits.
    if (numBits > 0) {
      int nextBit = bitOffset + numBits;
      byte writeMask = (byte) (0xFF >> (8 - numBits));

      if (nextBit > 8) {
        // Combine bits from current byte and next byte.
        returnValue |= ((((data[byteOffset] & 0xFF) << (nextBit - 8)
            | ((data[byteOffset + 1] & 0xFF) >> (16 - nextBit))) & writeMask));
        byteOffset++;
      } else {
        // Bits to be read only within current byte.
        returnValue |= (((data[byteOffset] & 0xFF) >> (8 - nextBit)) & writeMask);
        if (nextBit == 8) {
          byteOffset++;
        }
      }

      bitOffset = nextBit % 8;
    }

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableBitArray.java;<<<<<<< MINE
        && (bitOffset >= 0 && bitOffset < 8)
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
=======
   * Skips a single bit.
   */
  public void skipBit() {
    if (++bitOffset == 8) {
      bitOffset = 0;
      byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;
    }
    assertValidOffset();
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
   * @param n The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
  public void skipBits(int n) {
=======
  public void skipBits(int numBits) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    byteOffset += (n / 8);
    bitOffset += (n % 8);
=======
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
   * @param n The number of bits.
=======
   * @param numBits The number of bits.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
  public boolean canReadBits(int n) {
=======
  public boolean canReadBits(int numBits) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    int newByteOffset = byteOffset + (n / 8);
    int newBitOffset = bitOffset + (n % 8);
=======
    int numBytes = numBits / 8;
    int newByteOffset = byteOffset + numBytes;
    int newBitOffset = bitOffset + numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (data[byteOffset] & (0x80 >> bitOffset)) != 0;
    skipBit();
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
    if (numBits == 0) {
      return 0;
=======
    int returnValue = 0;
    bitOffset += numBits;
    while (bitOffset > 8) {
      bitOffset -= 8;
      returnValue |= (data[byteOffset] & 0xFF) << bitOffset;
      byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE

    int returnValue = 0;

    // Read as many whole bytes as we can.
    int wholeBytes = (numBits / 8);
    for (int i = 0; i < wholeBytes; i++) {
      int nextByteOffset = shouldSkipByte(byteOffset + 1) ? byteOffset + 2 : byteOffset + 1;
      int byteValue;
      if (bitOffset != 0) {
        byteValue = ((data[byteOffset] & 0xFF) << bitOffset)
            | ((data[nextByteOffset] & 0xFF) >>> (8 - bitOffset));
      } else {
        byteValue = data[byteOffset];
      }
      numBits -= 8;
      returnValue |= (byteValue & 0xFF) << numBits;
      byteOffset = nextByteOffset;
    }

    // Read any remaining bits.
    if (numBits > 0) {
      int nextBit = bitOffset + numBits;
      byte writeMask = (byte) (0xFF >> (8 - numBits));
      int nextByteOffset = shouldSkipByte(byteOffset + 1) ? byteOffset + 2 : byteOffset + 1;

      if (nextBit > 8) {
        // Combine bits from current byte and next byte.
        returnValue |= ((((data[byteOffset] & 0xFF) << (nextBit - 8)
            | ((data[nextByteOffset] & 0xFF) >> (16 - nextBit))) & writeMask));
        byteOffset = nextByteOffset;
      } else {
        // Bits to be read only within current byte.
        returnValue |= (((data[byteOffset] & 0xFF) >> (8 - nextBit)) & writeMask);
        if (nextBit == 8) {
          byteOffset = nextByteOffset;
        }
      }

      bitOffset = nextBit % 8;
=======
    returnValue |= (data[byteOffset] & 0xFF) >> 8 - bitOffset;
    returnValue &= 0xFFFFFFFF >>> (32 - numBits);
    if (bitOffset == 8) {
      bitOffset = 0;
      byteOffset += shouldSkipByte(byteOffset + 1) ? 2 : 1;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/ParsableNalUnitBitArray.java;<<<<<<< MINE
        && (bitOffset >= 0 && bitOffset < 8)
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/FlacStreamInfo.java;<<<<<<< MINE
    this.totalSamples = scratch.readBits(36);
=======
    this.totalSamples = ((scratch.readBits(4) & 0xFL) << 32)
        | (scratch.readBits(32) & 0xFFFFFFFFL);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java;<<<<<<< MINE
  public static final String AUDIO_ULAW = BASE_TYPE_AUDIO + "/g711-mlaw";
=======
  public static final String AUDIO_MLAW = BASE_TYPE_AUDIO + "/g711-mlaw";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java;<<<<<<< MINE
  public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
=======
  public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/flac";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java;<<<<<<< MINE
=======
  public static final String AUDIO_MSGSM = BASE_TYPE_AUDIO + "/gsm";
  public static final String AUDIO_UNKNOWN = BASE_TYPE_AUDIO + "/x-unknown";
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/util/Util.java;<<<<<<< MINE
      + "([Zz]|((\\+|\\-)(\\d\\d):?(\\d\\d)))?");
=======
      + "([Zz]|((\\+|\\-)(\\d?\\d):?(\\d\\d)))?");
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
=======
import com.google.android.exoplayer2.extractor.ts.TsPayloadReader;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
=======
import com.google.android.exoplayer2.util.TimestampAdjuster;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
=======
  private @TsExtractor.Mode int tsMode;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
=======
  public DefaultExtractorsFactory() {
    tsMode = TsExtractor.MODE_SINGLE_PMT;
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory)
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**
=======
   * Sets the mode for {@link TsExtractor} instances created by the factory.
   *
   * @see TsExtractor#TsExtractor(int, TimestampAdjuster, TsPayloadReader.Factory).
   * @param mode The mode to use.
   * @return The factory, for convenience.
   */
  public synchronized DefaultExtractorsFactory setTsExtractorMode(@TsExtractor.Mode int mode) {
    tsMode = mode;
    return this;
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/DefaultExtractorsFactory.java;<<<<<<< MINE
    extractors[6] = new TsExtractor(tsFlags);
=======
    extractors[6] = new TsExtractor(tsMode, tsFlags);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java;<<<<<<< MINE
=======
import com.google.android.exoplayer2.util.Util;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/mp3/ConstantBitrateSeeker.java;<<<<<<< MINE
    return durationUs == C.TIME_UNSET ? 0
        : firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
=======
    if (durationUs == C.TIME_UNSET) {
      return 0;
    }
    timeUs = Util.constrainValue(timeUs, 0, durationUs);
    return firstFramePosition + (timeUs * bitrate) / (C.MICROS_PER_SECOND * BITS_PER_BYTE);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/flv/AudioTagPayloadReader.java;<<<<<<< MINE
            : MimeTypes.AUDIO_ULAW;
=======
            : MimeTypes.AUDIO_MLAW;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/SeiReader.java;<<<<<<< MINE
      output.format(Format.createTextSampleFormat(idGenerator.getFormatId(), channelMimeType, null,
          Format.NO_VALUE, channelFormat.selectionFlags, channelFormat.language,
          channelFormat.accessibilityChannel, null));
=======
      String formatId = channelFormat.id != null ? channelFormat.id : idGenerator.getFormatId();
      output.format(Format.createTextSampleFormat(formatId, channelMimeType, null, Format.NO_VALUE,
          channelFormat.selectionFlags, channelFormat.language, channelFormat.accessibilityChannel,
          null));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
    bitArray.skipBits(1); // sps_temporal_id_nesting_flag
=======
    bitArray.skipBit(); // sps_temporal_id_nesting_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
      bitArray.skipBits(1); // separate_colour_plane_flag
=======
      bitArray.skipBit(); // separate_colour_plane_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
      bitArray.skipBits(1); // pcm_loop_filter_disabled_flag
=======
      bitArray.skipBit(); // pcm_loop_filter_disabled_flag
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
        bitArray.skipBits(1); // delta_rps_sign
=======
        bitArray.skipBit(); // delta_rps_sign
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
            bitArray.skipBits(1); // use_delta_flag[j]
=======
            bitArray.skipBit(); // use_delta_flag[j]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
          bitArray.skipBits(1); // used_by_curr_pic_s0_flag[i]
=======
          bitArray.skipBit(); // used_by_curr_pic_s0_flag[i]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
          bitArray.skipBits(1); // used_by_curr_pic_s1_flag[i]
=======
          bitArray.skipBit(); // used_by_curr_pic_s1_flag[i]
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/StreamReader.java;<<<<<<< MINE
=======
    // First payload packet. Trim the payload array of the ogg packet after headers have been read.
    oggPacket.trimPayload();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java;<<<<<<< MINE
=======
import java.util.Arrays;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java;<<<<<<< MINE
  private final ParsableByteArray packetArray =
      new ParsableByteArray(new byte[OggPageHeader.MAX_PAGE_PAYLOAD], 0);
=======
  private final ParsableByteArray packetArray = new ParsableByteArray(
      new byte[OggPageHeader.MAX_PAGE_PAYLOAD], 0);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java;<<<<<<< MINE
=======
        if (packetArray.capacity() < packetArray.limit() + size) {
          packetArray.data = Arrays.copyOf(packetArray.data, packetArray.limit() + size);
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/OggPacket.java;<<<<<<< MINE
=======
   * Trims the packet data array.
   */
  public void trimPayload() {
    if (packetArray.data.length == OggPageHeader.MAX_PAGE_PAYLOAD) {
      return;
    }
    packetArray.data = Arrays.copyOf(packetArray.data, Math.max(OggPageHeader.MAX_PAGE_PAYLOAD,
        packetArray.limit()));
  }

  /**
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
  public final byte[] data;
  private final int limit;
=======
  private final byte[] data;
  private final int byteLimit;

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    this(data, data.length);
  }

  /**
   * Creates a new instance that wraps an existing array.
   *
   * @param data the array to wrap.
   * @param limit the limit in bytes.
   */
  public VorbisBitArray(byte[] data, int limit) {
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    this.limit = limit * 8;
=======
    byteLimit = data.length;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    return readBits(1) == 1;
=======
    boolean returnValue = (((data[byteOffset] & 0xFF) >> bitOffset) & 0x01) == 1;
    skipBits(1);
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    Assertions.checkState(getPosition() + numBits <= limit);
    if (numBits == 0) {
      return 0;
    }
    int result = 0;
    int bitCount = 0;
    if (bitOffset != 0) {
      bitCount = Math.min(numBits, 8 - bitOffset);
      int mask = 0xFF >>> (8 - bitCount);
      result = (data[byteOffset] >>> bitOffset) & mask;
      bitOffset += bitCount;
      if (bitOffset == 8) {
        byteOffset++;
        bitOffset = 0;
      }
    }

    if (numBits - bitCount > 7) {
      int numBytes = (numBits - bitCount) / 8;
      for (int i = 0; i < numBytes; i++) {
        result |= (data[byteOffset++] & 0xFFL) << bitCount;
        bitCount += 8;
      }
=======
    int tempByteOffset = byteOffset;
    int bitsRead = Math.min(numBits, 8 - bitOffset);
    int returnValue = ((data[tempByteOffset++] & 0xFF) >> bitOffset) & (0xFF >> (8 - bitsRead));
    while (bitsRead < numBits) {
      returnValue |= (data[tempByteOffset++] & 0xFF) << bitsRead;
      bitsRead += 8;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE

    if (numBits > bitCount) {
      int bitsOnNextByte = numBits - bitCount;
      int mask = 0xFF >>> (8 - bitsOnNextByte);
      result |= (data[byteOffset] & mask) << bitCount;
      bitOffset += bitsOnNextByte;
    }
    return result;
=======
    returnValue &= 0xFFFFFFFF >>> (32 - numBits);
    skipBits(numBits);
    return returnValue;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
   * @param numberOfBits The number of bits to skip.
=======
   * @param numBits The number of bits to skip.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
  public void skipBits(int numberOfBits) {
    Assertions.checkState(getPosition() + numberOfBits <= limit);
    byteOffset += numberOfBits / 8;
    bitOffset += numberOfBits % 8;
=======
  public void skipBits(int numBits) {
    int numBytes = numBits / 8;
    byteOffset += numBytes;
    bitOffset += numBits - (numBytes * 8);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
=======
    assertValidOffset();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    Assertions.checkArgument(position < limit && position >= 0);
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
=======
    assertValidOffset();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
    return limit - getPosition();
=======
    return (byteLimit - byteOffset) * 8 - bitOffset;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/extractor/ogg/VorbisBitArray.java;<<<<<<< MINE
  /**
   * Returns the limit in bits.
   **/
  public int limit() {
    return limit;
=======
  private void assertValidOffset() {
    // It is fine for position to be at the end of the array, but no further.
    Assertions.checkState(byteOffset >= 0
        && (byteOffset < byteLimit || (byteOffset == byteLimit && bitOffset == 0)));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
    onDisabled();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
=======
    onDisabled();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
   *
   * @return Whether the source is ready.
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
    // Get the current and ideal selections.
=======
    // Stash the current selection, then make a new one.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
    Format currentFormat = getSelectedFormat();
    int idealSelectedIndex = determineIdealSelectedIndex(nowMs);
    Format idealFormat = getFormat(idealSelectedIndex);
    // Assume we can switch to the ideal selection.
    selectedIndex = idealSelectedIndex;
    // Revert back to the current selection if conditions are not suitable for switching.
    if (currentFormat != null && !isBlacklisted(selectedIndex, nowMs)) {
      if (idealFormat.bitrate > currentFormat.bitrate
=======
    selectedIndex = determineIdealSelectedIndex(nowMs);
    if (selectedIndex == currentSelectedIndex) {
      return;
    }
    if (!isBlacklisted(currentSelectedIndex, nowMs)) {
      // Revert back to the current selection if conditions are not suitable for switching.
      Format currentFormat = getFormat(currentSelectedIndex);
      Format selectedFormat = getFormat(selectedIndex);
      if (selectedFormat.bitrate > currentFormat.bitrate
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
        // The ideal track is a higher quality, but we have insufficient buffer to safely switch
=======
        // The selected track is a higher quality, but we have insufficient buffer to safely switch
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
      } else if (idealFormat.bitrate < currentFormat.bitrate
=======
      } else if (selectedFormat.bitrate < currentFormat.bitrate
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/trackselection/AdaptiveTrackSelection.java;<<<<<<< MINE
        // The ideal track is a lower quality, but we have sufficient buffer to defer switching
=======
        // The selected track is a lower quality, but we have sufficient buffer to defer switching
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private static final int DEFAULT_PLAYED_COLOR = 0x33FFFFFF;
  private static final int DEFAULT_BUFFERED_COLOR = 0xCCFFFFFF;
=======
  private static final int DEFAULT_PLAYED_COLOR = 0xFFFFFFFF;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private static final int OPAQUE_COLOR = 0xFF000000;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private final Paint playedPaint;
=======
  private final Paint playedPaint;
  private final Paint scrubberPaint;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private final Paint unplayedPaint;
  private final Paint adMarkerPaint;
  private final Paint playedAdMarkerPaint;
  private final Paint scrubberPaint;
=======
  private final Paint unplayedPaint;
  private final Paint adMarkerPaint;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private int scrubberSize;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
        int scrubberColor = a.getInt(R.styleable.DefaultTimeBar_scrubber_color,
            getDefaultScrubberColor(playedColor));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
            DEFAULT_BUFFERED_COLOR);
=======
            getDefaultBufferedColor(playedColor));
        int unplayedColor = a.getInt(R.styleable.DefaultTimeBar_unplayed_color,
            getDefaultUnplayedColor(playedColor));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
        unplayedPaint.setColor(unplayedColor);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      scrubberPaint.setColor(OPAQUE_COLOR | DEFAULT_PLAYED_COLOR);
      progressPaint.setColor(DEFAULT_PLAYED_COLOR);
      bufferedPaint.setColor(DEFAULT_BUFFERED_COLOR);
=======
      playedPaint.setColor(DEFAULT_PLAYED_COLOR);
      scrubberPaint.setColor(getDefaultScrubberColor(DEFAULT_PLAYED_COLOR));
      bufferedPaint.setColor(getDefaultBufferedColor(DEFAULT_PLAYED_COLOR));
      unplayedPaint.setColor(getDefaultUnplayedColor(DEFAULT_PLAYED_COLOR));
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    scrubberSize = scrubberEnabledSize;
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
    update();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
    update();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    } else {
      updateScrubberState();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
    update();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  public void setAdGroupTimesMs(@Nullable long[] adGroupTimesMs, @Nullable boolean[] playedAdGroups,
      int adGroupCount) {
    Assertions.checkArgument(adGroupCount == 0
        || (adGroupTimesMs != null && playedAdGroups != null));
    this.adGroupCount = adGroupCount;
    this.adGroupTimesMs = adGroupTimesMs;
    this.playedAdGroups = playedAdGroups;
    update();
=======
  public void setAdBreakTimesMs(@Nullable long[] adBreakTimesMs, int adBreakCount) {
    Assertions.checkArgument(adBreakCount == 0 || adBreakTimesMs != null);
    this.adBreakCount = adBreakCount;
    this.adBreakTimesMs = adBreakTimesMs;
    update();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    updateScrubberState();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    int measureWidth = MeasureSpec.getSize(widthMeasureSpec);
    int measureHeight = MeasureSpec.getSize(heightMeasureSpec);
    setMeasuredDimension(measureWidth, measureHeight);
=======
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int height = heightMode == MeasureSpec.UNSPECIFIED ? touchTargetHeight
        : heightMode == MeasureSpec.EXACTLY ? heightSize : Math.min(touchTargetHeight, heightSize);
    setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), height);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    int barY = height - touchTargetHeight;
=======
    int barY = (height - touchTargetHeight) / 2;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    updateScrubberState();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      listener.onScrubStart(this);
=======
      listener.onScrubStart(this, getScrubberPosition());
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
    updateScrubberState();
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private void updateScrubberState() {
    scrubberSize = scrubbing ? scrubberDraggedSize
        : (isEnabled() && duration >= 0 ? scrubberEnabledSize : scrubberDisabledSize);
  }

=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      int bufferedPixelWidth =
          (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = progressBar.left + bufferedPixelWidth;
      int scrubberPixelPosition =
          (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = progressBar.left + scrubberPixelPosition;
=======
      int bufferedPixelWidth = (int) ((progressBar.width() * bufferedPosition) / duration);
      bufferedBar.right = Math.min(progressBar.left + bufferedPixelWidth, progressBar.right);
      int scrubberPixelPosition = (int) ((progressBar.width() * newScrubberTime) / duration);
      scrubberBar.right = Math.min(progressBar.left + scrubberPixelPosition, progressBar.right);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, progressPaint);
=======
      canvas.drawRect(progressBar.left, barTop, progressBar.right, barBottom, unplayedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, progressPaint);
=======
      canvas.drawRect(progressLeft, barTop, progressBar.right, barBottom, unplayedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, scrubberPaint);
=======
      canvas.drawRect(scrubberBar.left, barTop, scrubberBar.right, barBottom, playedPaint);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
    int scrubberSize = (scrubbing || isFocused()) ? scrubberDraggedSize
        : (isEnabled() ? scrubberEnabledSize : scrubberDisabledSize);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultPlayedAdMarkerColor(int adMarkerColor) {
    return 0x33000000 | (adMarkerColor & 0x00FFFFFF);
  }

=======
  private static int getDefaultScrubberColor(int playedColor) {
    return 0xFF000000 | playedColor;
  }

  private static int getDefaultUnplayedColor(int playedColor) {
    return 0x33000000 | (playedColor & 0x00FFFFFF);
  }

  private static int getDefaultBufferedColor(int playedColor) {
    return 0xCC000000 | (playedColor & 0x00FFFFFF);
  }

>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java;<<<<<<< MINE
   * @param rewindMs The rewind increment in milliseconds.
=======
   * @param rewindMs The rewind increment in milliseconds. A non-positive value will cause the
   *     rewind button to be disabled.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/SimpleExoPlayerView.java;<<<<<<< MINE
   * @param fastForwardMs The fast forward increment in milliseconds.
=======
   * @param fastForwardMs The fast forward increment in milliseconds. A non-positive value will
   *     cause the fast forward button to be disabled.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    seekTo(Math.min(player.getCurrentPosition() + fastForwardMs, player.getDuration()));
=======
    long durationMs = player.getDuration();
    long seekPositionMs = player.getCurrentPosition() + fastForwardMs;
    if (durationMs != C.TIME_UNSET) {
      seekPositionMs = Math.min(seekPositionMs, durationMs);
    }
    seekTo(seekPositionMs);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/PlaybackControlView.java;<<<<<<< MINE
    public void onScrubStart(TimeBar timeBar) {
=======
    public void onScrubStart(TimeBar timeBar, long position) {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java;<<<<<<< MINE
=======
     * @param position The position of the scrubber, in milliseconds.
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/TimeBar.java;<<<<<<< MINE
    void onScrubStart(TimeBar timeBar);
=======
    void onScrubStart(TimeBar timeBar, long position);
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java;<<<<<<< MINE
=======
import android.test.MoreAsserts;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java;<<<<<<< MINE
=======
import com.google.android.exoplayer2.upstream.DataSource;
import com.google.android.exoplayer2.upstream.DataSpec;
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/testutils/src/main/java/com/google/android/exoplayer2/testutil/TestUtil.java;<<<<<<< MINE
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
=======
  public static byte[] readToEnd(DataSource dataSource) throws IOException {
    byte[] data = new byte[1024];
    int position = 0;
    int bytesRead = 0;
    while (bytesRead != C.RESULT_END_OF_INPUT) {
      if (position == data.length) {
        data = Arrays.copyOf(data, data.length * 2);
      }
      bytesRead = dataSource.read(data, position, data.length - position);
      if (bytesRead != C.RESULT_END_OF_INPUT) {
        position += bytesRead;
      }
    }
    return Arrays.copyOf(data, position);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs) throws IOException, InterruptedException {
    return consumeTestData(extractor, input, timeUs, false);
  }

  public static FakeExtractorOutput consumeTestData(Extractor extractor, FakeExtractorInput input,
      long timeUs, boolean retryFromStartIfLive) throws IOException, InterruptedException {
    FakeExtractorOutput output = new FakeExtractorOutput();
    extractor.init(output);
    consumeTestData(extractor, input, timeUs, output, retryFromStartIfLive);
    return output;
  }

  private static void consumeTestData(Extractor extractor, FakeExtractorInput input, long timeUs,
      FakeExtractorOutput output, boolean retryFromStartIfLive)
      throws IOException, InterruptedException {
    extractor.seek(input.getPosition(), timeUs);
    PositionHolder seekPositionHolder = new PositionHolder();
    int readResult = Extractor.RESULT_CONTINUE;
    while (readResult != Extractor.RESULT_END_OF_INPUT) {
      try {
        // Extractor.read should not read seekPositionHolder.position. Set it to a value that's
        // likely to cause test failure if a read does occur.
        seekPositionHolder.position = Long.MIN_VALUE;
        readResult = extractor.read(input, seekPositionHolder);
        if (readResult == Extractor.RESULT_SEEK) {
          long seekPosition = seekPositionHolder.position;
          Assertions.checkState(0 <= seekPosition && seekPosition <= Integer.MAX_VALUE);
          input.setPosition((int) seekPosition);
        }
      } catch (SimulatedIOException e) {
        if (!retryFromStartIfLive) {
          continue;
        }
        boolean isOnDemand = input.getLength() != C.LENGTH_UNSET
            || (output.seekMap != null && output.seekMap.getDurationUs() != C.TIME_UNSET);
        if (isOnDemand) {
          continue;
        }
        input.setPosition(0);
        for (int i = 0; i < output.numberOfTracks; i++) {
          output.trackOutputs.valueAt(i).clear();
        }
        extractor.seek(0, 0);
>>>>>>> YOURS
