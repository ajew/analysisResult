file;ssmergeConf
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/AckManager.java;<<<<<<< MINE
public long registerAck(UUID sessionId, final AckCallback callback) {
        Set<Long> callbackIds = clientCallbackIds.get(sessionId);
        if (callbackIds == null) {
            callbackIds = new ConcurrentHashSet<Long>();
            Set<Long> oldCallbackIds = clientCallbackIds.putIfAbsent(sessionId, callbackIds);
            if (oldCallbackIds != null) {
                callbackIds = oldCallbackIds;
            }
        }
        long index = ackIndex.incrementAndGet();
        callbackIds.add(index);
        ackCallbacks.put(index, callback);

        scheduleTimeout(index, sessionId, callback);

        return index;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
=======
public void getSize(SizeReadyCallback cb) {
            this.cb = null;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else if (isUsingWrapContent()) {
                WindowManager windowManager =
                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
                Display display = windowManager.getDefaultDisplay();
                final int width = display.getWidth();
                final int height = display.getHeight();
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen" +
                            " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height " +
                            " for better performance.");
                }
                cb.onSizeReady(display.getWidth(), display.getHeight());
            } else {
                this.cb = cb;
                final ViewTreeObserver observer = view.getViewTreeObserver();
                layoutListener = new SizeDeterminerLayoutListener(this);
                observer.addOnGlobalLayoutListener(layoutListener);
            }
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
=======
@Deprecated
    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
        if (toFit == null) return null;

        if (height > width){
            return shrinkToWidth(toFit, width);
        } else {
            return shrinkToHeight(toFit, height);
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
=======
public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
        final Matrix matrix = new Matrix();
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                matrix.setScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
                matrix.setRotate(180);
                break;
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                matrix.setRotate(180);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_TRANSPOSE:
                matrix.setRotate(90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_90:
                matrix.setRotate(90);
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
                matrix.setRotate(-90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_270:
                matrix.setRotate(-90);
                break;
            default: //case ExifInterface.ORIENTATION_NORMAL
                return toOrient;
        }

        // From Bitmap.createBitmap.
        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
        matrix.mapRect(newRect);

        final int newWidth = Math.round(newRect.width());
        final int newHeight = Math.round(newRect.height());

        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
        if (result == null) {
            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
        }

        matrix.postTranslate(-newRect.left, -newRect.top);

        final Canvas canvas = new Canvas(result);
        final Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toOrient, matrix, paint);

        return result;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/Downsampler.java;<<<<<<< MINE
=======
public Bitmap downsample(RecyclableBufferedInputStream bis, BitmapFactory.Options options, BitmapPool pool, int outWidth, int outHeight) {
        bis.mark(MARK_POSITION);
        int orientation = 0;
        try {
            orientation = new ImageHeaderParser(bis).getOrientation();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            bis.reset();
        } catch (IOException e) {
            e.printStackTrace();
        }

        final int[] inDimens = getDimensions(bis, options);
        final int inWidth = inDimens[0];
        final int inHeight = inDimens[1];

        final int degreesToRotate = ImageResizer.getExifOrientationDegrees(orientation);
        final int sampleSize;
        if (degreesToRotate == 90 || degreesToRotate == 270) {
            //if we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
            //decreased to near our target's height and the image height is decreased to near our target width
            sampleSize = getSampleSize(inHeight, inWidth, outWidth, outHeight);
        } else {
            sampleSize = getSampleSize(inWidth, inHeight, outWidth, outHeight);
        }

        final Bitmap downsampled = downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize);
        if (downsampled == null) {
            throw new IllegalArgumentException("Unable to decode image sample size: " + sampleSize + " inWidth: "
                    + inWidth + " inHeight: " + inHeight);
        }
        final Bitmap rotated = ImageResizer.rotateImageExif(downsampled, pool, orientation);

        if (downsampled != rotated && !pool.put(downsampled)) {
            downsampled.recycle();
        }

        return rotated;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
protected DiskLruCacheWrapper(DiskLruCache diskLruCache) {
        this.diskLruCache = diskLruCache;
        this.safeKeyGenerator = new SafeKeyGenerator();
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
=======
public LoadToken getImage(String id, StreamLoader streamLoader, Transformation transformation,
                              Downsampler downsampler, int width, int height, LoadedCallback cb) {
        if (shutdown) return null;

        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);
        LoadToken result = null;
        if (!returnFromCache(key, cb)) {
            ImageManagerJob job = jobs.get(key);
            if (job == null) {
                ImageManagerRunner runner = new ImageManagerRunner(key, streamLoader, transformation, downsampler,
                        width, height);
                job = new ImageManagerJob(runner, key);
                jobs.put(key, job);
                job.addCallback(cb);
                runner.execute();
            } else {
                job.addCallback(cb);
            }
            result = new LoadToken(cb, job);
        }
        return result;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
@Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.flickr_search_activity);
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                .detectAll()
                .penaltyLog()
                .build());

        searching = findViewById(R.id.searching);
        searchLoading = findViewById(R.id.search_loading);
        searchTerm = (TextView) findViewById(R.id.search_term);

        searchText = (EditText) findViewById(R.id.search_text);
        searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
            @Override
            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
                    executeSearch();
                    return true;
                }
                return false;
            }
        });

        final Button search = (Button) findViewById(R.id.search);
        search.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                executeSearch();
            }
        });

        ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
        pager.setPageMargin(50);
        pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int i, float v, int i2) { }

            @Override
            public void onPageSelected(int position) {
                getSupportActionBar().getTabAt(position).select();
            }

            @Override
            public void onPageScrollStateChanged(int i) { }
        });


        final ActionBar actionBar = getSupportActionBar();
        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

        for (Page page : Page.values()) {
            final int textId = PAGE_TO_TITLE.get(page);
            actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
        }

        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
private void executeSearch() {
        final String searchString = searchText.getText().toString();
        searchText.getText().clear();

        if ("".equals(searchString.trim())) return;

        final int currentSearch = ++searchCount;

        searching.setVisibility(View.VISIBLE);
        searchLoading.setVisibility(View.VISIBLE);
        searchTerm.setText(getString(R.string.searching_for, searchString));

        Api.get(getApplicationContext()).search(searchString, new Api.SearchCallback() {
            @Override
            public void onSearchCompleted(List<Photo> photos) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Search completed, got " + photos.size() + " results");
                }
                searching.setVisibility(View.INVISIBLE);

                for (PhotoViewer viewer : photoViewers) {
                    viewer.onPhotosUpdated(photos);
                }

                currentPhotos = photos;
            }

            @Override
            public void onSearchFailed(Exception e) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.ERROR)) {
                    Log.e(TAG, "Search failed", e);
                }
                searching.setVisibility(View.VISIBLE);
                searchLoading.setVisibility(View.INVISIBLE);
                searchTerm.setText(getString(R.string.search_failed, searchString));
            }
        });
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
private Request(T model, ModelLoaderFactory<T> factory) {
            this.model = model;

            if (factory == null) {
                throw new IllegalArgumentException("No ModelLoaderFactory registered for class=" + model.getClass());
            }
            this.modelLoaderFactory = factory;
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
public Metadata(Request request) {
            modelClass = request.model != null ? request.model.getClass() : null;
            modelLoaderClass = request.modelLoaderFactory.loaderClass();
            downsamplerId = request.downsampler.getId();
            transformationId = request.getFinalTransformationId();
            animationId = request.animationId;
            placeholderId = request.placeholderId;
            errorId = request.errorId;
            requestListenerClass = (request.requestListener != null ?
                    request.requestListener.getClass() : null);
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
public boolean isIdenticalTo(Metadata metadata) {
            if (metadata == null) {
                return false;
            }
            if (animationId != metadata.animationId) {
                return false;
            }
            if (errorId != metadata.errorId) {
                return false;
            }
            if (placeholderId != metadata.placeholderId) {
                return false;
            }
            if (!downsamplerId.equals(metadata.downsamplerId)) {
                return false;
            }
            if (modelClass != null ? !modelClass.equals(metadata.modelClass) : metadata.modelClass != null) {
                return false;
            }
            if (!modelLoaderClass.equals(metadata.modelLoaderClass)) {
                return false;
            }
            if (!transformationId.equals(metadata.transformationId)) {
                return false;
            }
            if (requestListenerClass == null ? metadata.requestListenerClass != null :
                    !requestListenerClass.equals(metadata.requestListenerClass)) {
                return false;
            }

            return true;
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
private void checkCurrentDimens() {
            if (cb == null) return;

            boolean calledCallback = true;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else {
                calledCallback = false;
            }

            if (calledCallback) {
                cb = null;
                // Keep a reference to the layout listener and remove it here
                // rather than having the observer remove itself because the observer
                // we add the listener to will be almost immediately merged into
                // another observer and will therefore never be alive. If we instead
                // keep a reference to the listener and remove it here, we get the
                // current view tree observer and should succeed.
                ViewTreeObserver observer = view.getViewTreeObserver();
                if (observer.isAlive()) {
                    observer.removeOnPreDrawListener(layoutListener);
                }
            }
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
public void getSize(SizeReadyCallback cb) {
            this.cb = null;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else if (isUsingWrapContent()) {
                WindowManager windowManager =
                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
                Display display = windowManager.getDefaultDisplay();
                final int width = display.getWidth();
                final int height = display.getHeight();
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen" +
                            " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height " +
                            " for better performance.");
                }
                cb.onSizeReady(display.getWidth(), display.getHeight());
            } else {
                this.cb = cb;
                final ViewTreeObserver observer = view.getViewTreeObserver();
                layoutListener = new SizeDeterminerLayoutListener(this);
                observer.addOnPreDrawListener(layoutListener);
            }
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/loader/model/UriLoader.java;<<<<<<< MINE
@Override
    public StreamLoader getStreamLoader(Uri model, int width, int height) {
        final String scheme = model.getScheme();

        StreamLoader result = null;
        if (isLocalUri(scheme)) {
            result = new LocalUriLoader(context, model);
        } else if ("http".equals(scheme) || "https".equals(scheme)) {
            try {
                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        return result;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/bitmap_recycle/SizeStrategy.java;<<<<<<< MINE
private static int getBytesPerPixel(Bitmap.Config config) {
      // a bitmap by decoding a gif has null "config" in certain environments.
      if (config == null) {
          return 4;
      }

      switch (config) {
          case ARGB_8888:
              return 4;
          case RGB_565:
              return 2;
          case ARGB_4444:
              return 2;
          case ALPHA_8:
              return 1;
          default:
              // We only use this to calculate sizes to get, so choosing 4 bytes per pixel is conservative and
              // probably forces us to get a larger bitmap than we really need. Since we can't tell for sure, probably
              // better safe than sorry.
              return 4;
        }
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
public void cancel(LoadedCallback cb) {
            cbs.remove(cb);
            if (cbs.size() == 0) {
                // Note: this is potentially dangerous. The runner asynchronously asks our jobs map for a job
                // matching our key after posting a runnable to the main thread and as a result, the job it gets back
                // may not be this job. We protect against this for cancellation by not delivering failures from
                // cancelled runners, so new jobs will not receive errors from cancelled jobs. However, new jobs may
                // receive results from old runners if the old runner was cancelled, but completed successfully anyway
                // because it received the cancellation too late.
                runner.cancel();
                if (jobs.get(key) == this) {
                    jobs.remove(key);
                }
            }
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
        if (toCrop == null) {
            return null;
        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
            return toCrop;
        }
        //from ImageView/Bitmap.createScaledBitmap
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
        final float scale;
        float dx = 0, dy = 0;
        Matrix m = new Matrix();
        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
            scale = (float) height / (float) toCrop.getHeight();
            dx = (width - toCrop.getWidth() * scale) * 0.5f;
        } else {
            scale = (float) width / (float) toCrop.getWidth();
            dy = (height - toCrop.getHeight() * scale) * 0.5f;
        }

        m.setScale(scale, scale);
        m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
        final Bitmap result;
        if (recycled != null) {
            result = recycled;
        } else {
            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
        }
        Canvas canvas = new Canvas(result);
        Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toCrop, m, paint);
        return result;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_be72194_7594310/rev_be72194-7594310/library/src/main/java/com/google/android/exoplayer/MediaCodecVideoTrackRenderer.java;<<<<<<< MINE
@Override
  protected boolean processOutputBuffer(long timeUs, MediaCodec codec, ByteBuffer buffer,
      MediaCodec.BufferInfo bufferInfo, int bufferIndex, boolean shouldSkip) {
    if (shouldSkip) {
      skipOutputBuffer(codec, bufferIndex);
      return true;
    }

    long earlyUs = bufferInfo.presentationTimeUs - timeUs;
    if (earlyUs < -30000) {
      // We're more than 30ms late rendering the frame.
      dropOutputBuffer(codec, bufferIndex);
      return true;
    }

    if (!renderedFirstFrame) {
      renderOutputBufferImmediate(codec, bufferIndex);
      renderedFirstFrame = true;
      return true;
    }

    if (getState() != TrackRenderer.STATE_STARTED) {
      return false;
    }

    if (Util.SDK_INT >= 21) {
      // Let the underlying framework time the release.
      if (earlyUs < 50000) {
        renderOutputBufferTimedV21(codec, bufferIndex, System.nanoTime() + (earlyUs * 1000L));
        return true;
      }
    } else {
      // We need to time the release ourselves.
      if (earlyUs < 30000) {
        if (earlyUs > 11000) {
          // We're a little too early to render the frame. Sleep until the frame can be rendered.
          // Note: The 11ms threshold was chosen fairly arbitrarily.
          try {
            // Subtracting 10000 rather than 11000 ensures the sleep time will be at least 1ms.
            Thread.sleep((earlyUs - 10000) / 1000);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          }
        }
        renderOutputBufferImmediate(codec, bufferIndex);
        return true;
      }
    }

    // We're either not playing, or it's not time to render the frame yet.
    return false;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_be72194_7594310/rev_be72194-7594310/library/src/main/java/com/google/android/exoplayer/MediaCodecAudioTrackRenderer.java;<<<<<<< MINE
@Override
  protected boolean processOutputBuffer(long timeUs, MediaCodec codec, ByteBuffer buffer,
      MediaCodec.BufferInfo bufferInfo, int bufferIndex, boolean shouldSkip)
      throws ExoPlaybackException {
    if (shouldSkip) {
      codec.releaseOutputBuffer(bufferIndex, false);
      codecCounters.skippedOutputBufferCount++;
      if (audioTrackStartMediaTimeState == START_IN_SYNC) {
        // Skipping the sample will push track time out of sync. We'll need to sync again.
        audioTrackStartMediaTimeState = START_NEED_SYNC;
      }
      return true;
    }

    if (temporaryBufferSize == 0) {
      // This is the first time we've seen this {@code buffer}.
      // Note: presentationTimeUs corresponds to the end of the sample, not the start.
      long bufferStartTime = bufferInfo.presentationTimeUs -
          framesToDurationUs(bufferInfo.size / frameSize);
      if (audioTrackStartMediaTimeState == START_NOT_SET) {
        audioTrackStartMediaTimeUs = Math.max(0, bufferStartTime);
        audioTrackStartMediaTimeState = START_IN_SYNC;
      } else {
        // Sanity check that bufferStartTime is consistent with the expected value.
        long expectedBufferStartTime = audioTrackStartMediaTimeUs +
            framesToDurationUs(submittedBytes / frameSize);
        if (audioTrackStartMediaTimeState == START_IN_SYNC
            && Math.abs(expectedBufferStartTime - bufferStartTime) > 200000) {
          Log.e(TAG, "Discontinuity detected [expected " + expectedBufferStartTime + ", got " +
              bufferStartTime + "]");
          audioTrackStartMediaTimeState = START_NEED_SYNC;
        }
        if (audioTrackStartMediaTimeState == START_NEED_SYNC) {
          // Adjust audioTrackStartMediaTimeUs to be consistent with the current buffer's start
          // time and the number of bytes submitted. Also reset lastReportedCurrentPositionUs to
          // allow time to jump backwards if it really wants to.
          audioTrackStartMediaTimeUs += (bufferStartTime - expectedBufferStartTime);
          lastReportedCurrentPositionUs = Long.MIN_VALUE;
        }
      }

      temporaryBufferSize = bufferInfo.size;
      buffer.position(bufferInfo.offset);
      if (Util.SDK_INT < 21) {
        // Copy {@code buffer} into {@code temporaryBuffer}.
        if (temporaryBuffer == null || temporaryBuffer.length < bufferInfo.size) {
          temporaryBuffer = new byte[bufferInfo.size];
        }
        buffer.get(temporaryBuffer, 0, bufferInfo.size);
        temporaryBufferOffset = 0;
      }
    }

    if (audioTrack == null) {
      initAudioTrack();
    }

    int bytesWritten = 0;
    if (Util.SDK_INT < 21) {
      // Work out how many bytes we can write without the risk of blocking.
      int bytesPending = (int) (submittedBytes - getPlaybackHeadPosition() * frameSize);
      int bytesToWrite = bufferSize - bytesPending;
      if (bytesToWrite > 0) {
        bytesToWrite = Math.min(temporaryBufferSize, bytesToWrite);
        bytesWritten = audioTrack.write(temporaryBuffer, temporaryBufferOffset, bytesToWrite);
        temporaryBufferOffset += bytesWritten;
      }
    } else {
      bytesWritten = writeNonBlockingV21(audioTrack, buffer, temporaryBufferSize);
    }

    temporaryBufferSize -= bytesWritten;
    submittedBytes += bytesWritten;
    if (temporaryBufferSize == 0) {
      codec.releaseOutputBuffer(bufferIndex, false);
      codecCounters.renderedOutputBufferCount++;
      return true;
    }

    return false;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
      this.requestQueue = requestQueue;
    }
=======
            this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
=======
@Override
        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {
            return new VolleyUrlLoader(requestQueue, requestFactory);
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
    this.requestQueue = requestQueue;
  }
=======
        this(requestQueue, VolleyStreamFetcher.DEFAULT_REQUEST_FACTORY);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
=======
@Override
    public DataFetcher<InputStream> getResourceFetcher(GlideUrl url, int width, int height) {
        return new VolleyStreamFetcher(
            requestQueue, url, new VolleyRequestFuture<InputStream>(), requestFactory);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
      VolleyRequestFuture<InputStream> requestFuture) {
    this.requestQueue = requestQueue;
    this.url = url;
    this.requestFuture = requestFuture;
    if (requestFuture == null) {
      this.requestFuture = VolleyRequestFuture.newFuture();
=======
            VolleyRequestFuture<InputStream> requestFuture) {
        this(requestQueue, url, requestFuture, DEFAULT_REQUEST_FACTORY);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
  public InputStream loadData(Priority priority) throws Exception {
    // Make sure the string url safely encodes non ascii characters.
    String stringUrl = url.toURL().toString();
    GlideRequest request =
        new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));
=======
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toURL().toString();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority));
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
    if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {
      this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");
      }
    } else {
      this.decodeFormat = decodeFormat;
=======
        this.decodeFormat = decodeFormat;
        return this;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GlideBuilder.java;<<<<<<< MINE
    MemorySizeCalculator calculator = new MemorySizeCalculator(context);
    if (bitmapPool == null) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
        int size = calculator.getBitmapPoolSize();
        if (DecodeFormat.REQUIRE_ARGB_8888) {
          bitmapPool = new LruBitmapPool(size, Collections.singleton(Bitmap.Config.ARGB_8888));
        } else {
          bitmapPool = new LruBitmapPool(size);
        }
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
    }
=======
        MemorySizeCalculator calculator = new MemorySizeCalculator(context);
        if (bitmapPool == null) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
                int size = calculator.getBitmapPoolSize();
                bitmapPool = new LruBitmapPool(size);
            } else {
                bitmapPool = new BitmapPoolAdapter();
            }
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java;<<<<<<< MINE
  public void onLowMemory() {
    super.onLowMemory();
    requestManager.onLowMemory();
  }
=======
    public void onLowMemory() {
        super.onLowMemory();
        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onLowMemory();
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java;<<<<<<< MINE
  public void onTrimMemory(int level) {
    requestManager.onTrimMemory(level);
  }
=======
    public void onTrimMemory(int level) {
        // If an activity is re-created, onTrimMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onTrimMemory(level);
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java;<<<<<<< MINE
  public void onLowMemory() {
    requestManager.onLowMemory();
  }
=======
    public void onLowMemory() {
        // If an activity is re-created, onLowMemory may be called before a manager is ever set.
        // See #329.
        if (requestManager != null) {
            requestManager.onLowMemory();
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
=======
public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        if (this.equals(thumbnailRequest)) {
            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
                    + "clone() on the request you are passing to thumbnail()");
        }
        this.thumbnailRequestBuilder = thumbnailRequest;

        return this;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
=======
private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        isThumbnailBuilt = false;
        return buildRequestRecursive(target, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
=======
private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
=======
@Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
    // Changing configs can cause skewing on 4.1, see issue #128.
    if (format == DecodeFormat.ALWAYS_ARGB_8888
        || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
      return Bitmap.Config.ARGB_8888;
    }
=======
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java;<<<<<<< MINE
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        Bundle args = getArguments();
        photoSize = args.getInt(IMAGE_SIZE_KEY);
        thumbnail = args.getBoolean(THUMBNAIL_KEY);

        fullRequest = Glide.with(this)
                .from(Photo.class)
                .centerCrop()
                .crossFade(R.anim.fade_in, 150);

        thumbnailRequest = Glide.with(this)
                .from(Photo.class)
                .diskCacheStrategy(DiskCacheStrategy.SOURCE)
                .crossFade(R.anim.fade_in, 150)
                .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);

        preloadRequest = thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;

        final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);

        grid = (GridView) result.findViewById(R.id.images);
        grid.setColumnWidth(photoSize);
        adapter = new PhotoAdapter();
        grid.setAdapter(adapter);

        final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
                new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
        final ListPreloader<Photo> preloader =
                new ListPreloader<Photo>(adapter, preloadSizeProvider, args.getInt(PRELOAD_KEY));
        grid.setOnScrollListener(preloader);

        if (currentPhotos != null) {
            adapter.setPhotos(currentPhotos);
        }

        if (savedInstanceState != null) {
            int index = savedInstanceState.getInt(STATE_POSITION_INDEX);
            grid.setSelection(index);
        }
=======
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    Bundle args = getArguments();
    photoSize = args.getInt(IMAGE_SIZE_KEY);
    thumbnail = args.getBoolean(THUMBNAIL_KEY);

    fullRequest = Glide.with(this)
        .asDrawable()
        .transition(withCrossFade(R.anim.fade_in, 150))
        .apply(centerCropTransform(getActivity()));

    thumbnailRequest = Glide.with(this)
        .asDrawable()
        .transition(withCrossFade(R.anim.fade_in, 150))
        .apply(diskCacheStrategyOf(DiskCacheStrategy.DATA)
            .centerCrop(getActivity())
            .override(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE));

    preloadRequest =
        thumbnail ? thumbnailRequest.clone().apply(priorityOf(Priority.HIGH)) : fullRequest;

    final View result = inflater.inflate(R.layout.flickr_photo_grid, container, false);

    grid = (GridView) result.findViewById(R.id.images);
    grid.setColumnWidth(photoSize);
    adapter = new PhotoAdapter();
    grid.setAdapter(adapter);

    final FixedPreloadSizeProvider<Photo> preloadSizeProvider =
        new FixedPreloadSizeProvider<Photo>(photoSize, photoSize);
    final ListPreloader<Photo> preloader = new ListPreloader<Photo>(Glide.with(this), adapter,
        preloadSizeProvider, args.getInt(PRELOAD_KEY));
    grid.setOnScrollListener(preloader);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
@Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
    imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);

    requestBuilder = Glide.with(this)
        .as(PictureDrawable.class)
        .apply(placeholderOf(R.drawable.image_loading)
            .error(R.drawable.image_error))
        .transition(withCrossFade())
        .listener(new SvgSoftwareLayerSetter());
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
@Override
  protected void onStart() {
    super.onStart();
    reload();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
public void clearCache(View v) {
    Log.w(TAG, "clearing cache");
    Glide.with(this).clear(imageViewRes);
    Glide.with(this).clear(imageViewNet);
    Glide.get(this).clearMemory();
    File cacheDir = Glide.getPhotoCacheDir(this);
    if (cacheDir.isDirectory()) {
      for (File child : cacheDir.listFiles()) {
        if (!child.delete()) {
          Log.w(TAG, "cannot delete: " + child);
        }
      }
    }
    reload();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
public void cycleScaleType(View v) {
    ImageView.ScaleType curr = imageViewRes.getScaleType();
    Log.w(TAG, "cycle: current=" + curr);
    ImageView.ScaleType[] all = ImageView.ScaleType.values();
    int nextOrdinal = (curr.ordinal() + 1) % all.length;
    ImageView.ScaleType next = all[nextOrdinal];
    Log.w(TAG, "cycle: next=" + next);
    imageViewRes.setScaleType(next);
    imageViewNet.setScaleType(next);
    reload();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
private void reload() {
    Log.w(TAG, "reloading");
    ((TextView) findViewById(R.id.button))
        .setText(getString(R.string.scaleType, imageViewRes.getScaleType()));
    loadRes();
    loadNet();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
private void loadRes() {
    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
        + R.raw.android_toy_h);
    requestBuilder.load(uri).into(imageViewRes);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
private void loadNet() {
    Uri uri = Uri.parse("http://www.clker.com/cliparts/u/Z/2/b/a/6/android-toy-h.svg");
    requestBuilder.load(uri).into(imageViewNet);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java;<<<<<<< MINE
=======
@Override
  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
    SVG svg = toTranscode.get();
    Picture picture = svg.renderToPicture();
    PictureDrawable drawable = new PictureDrawable(picture);
    return new SimpleResource<PictureDrawable>(drawable);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
    public void cleanup() {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // Ignored
            }
        }
        if (responseBody != null) {
            try {
                responseBody.close();
            } catch (IOException e) {
                // Ignored.
            }
        }
=======
  public void cleanup() {
    try {
      if (stream != null) {
        stream.close();
      }
    } catch (IOException e) {
      // Ignored
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
@Override
    public InputStream loadData(Priority priority) throws Exception {
        Request.Builder requestBuilder = new Request.Builder()
                .url(url.toStringUrl());

        boolean isUserAgentSet = false;
        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {
            String key = headerEntry.getKey();
            requestBuilder.addHeader(key, headerEntry.getValue());
            isUserAgentSet |= USER_AGENT_HEADER.equalsIgnoreCase(key);
        }
        if (!isUserAgentSet) {
            requestBuilder.addHeader(USER_AGENT_HEADER, DEFAULT_USER_AGENT);
        }
        Request request = requestBuilder.build();

        Response response = client.newCall(request).execute();
        responseBody = response.body();
        if (!response.isSuccessful()) {
            throw new IOException("Request failed with code: " + response.code());
        }

        long contentLength = responseBody.contentLength();
        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);
        return stream;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java;<<<<<<< MINE
@Override
    public String getId() {
        return url.getCacheKey();
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
@Test
    public void testAppliesHeadersInGlideUrl() throws Exception {
      mockWebServer.enqueue(new MockResponse().setResponseCode(200));
      String headerField = "field";
      String headerValue = "value";
      Map<String, String> headersMap = new HashMap<String, String>();
      headersMap.put(headerField, headerValue);
      Headers headers = mock(Headers.class);
      when(headers.getHeaders()).thenReturn(headersMap);

      getFetcher(headers).loadData(Priority.HIGH);

      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
    }
=======
@Test
  public void testAppliesHeadersInGlideUrl() throws Exception {
    mockWebServer.enqueue(new MockResponse().setResponseCode(200));
    String headerField = "field";
    String headerValue = "value";
    Map<String, String> headersMap = new HashMap<String, String>();
    headersMap.put(headerField, headerValue);
    Headers headers = mock(Headers.class);
    when(headers.getHeaders()).thenReturn(headersMap);

    getFetcher(headers).loadData(Priority.HIGH, callback);
    waitForResponseLatch.await();

    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
      return getFetcher(Headers.NONE);
    }
=======
    return getFetcher(Headers.NONE);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java;<<<<<<< MINE
private DataFetcher<InputStream> getFetcher(Headers headers) {
        URL url = mockWebServer.getUrl(DEFAULT_PATH);
        VolleyRequestFuture<InputStream> requestFuture = new VolleyRequestFuture<InputStream>() {
            @Override
            public InputStream get() throws InterruptedException, ExecutionException {
                for (int i = 0; i < 251 && !isDone(); i++) {
                    Thread.sleep(10);
                    Robolectric.runUiThreadTasks();
                }
                if (!isDone()) {
                    fail("Failed to get response from Volley in time");
                }
                return super.get();
            }
        };
        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);
    }
=======
private DataFetcher<InputStream> getFetcher(Headers headers) {
    URL url = mockWebServer.getUrl(DEFAULT_PATH);
    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
@Override
        public Map<String, String> getHeaders() throws AuthFailureError {
          return headers;
        }
=======
@Override
    public Map<String, String> getHeaders() throws AuthFailureError {
      return headers;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
public GlideRequest(String url, VolleyRequestFuture<InputStream> future, Priority priority) {
          this(url, future, priority, Collections.<String, String>emptyMap());
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
@Override
    public InputStream loadData(Priority priority) throws Exception {
        // Make sure the string url safely encodes non ascii characters.
        String stringUrl = url.toStringUrl();
        Request<byte[]> request = requestFactory.create(
                stringUrl, requestFuture, glideToVolleyPriority(priority), url.getHeaders());

        requestFuture.setRequest(requestQueue.add(request));

        return requestFuture.get();
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java;<<<<<<< MINE
@Override
    public String getId() {
        return url.getCacheKey();
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java;<<<<<<< MINE

        // Copy pixels into previous image
        if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED
            || currentFrame.dispose == DISPOSAL_NONE)) {
            if (previousImage == null) {
                previousImage = getNextBitmap();
            }
            previousImage.setPixels(dest, 0, width, 0, 0, width, height);
=======
        // Start of line in source.
        int sx = i * currentFrame.iw;
        while (dx < dlim) {
          // Map color and insert in destination.
          int index = ((int) mainPixels[sx++]) & 0xff;
          int c = act[index];
          if (c != 0) {
            dest[dx] = c;
          }
          dx++;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java;<<<<<<< MINE
    public void setUp() {
        connectivityMonitor = mock(ConnectivityMonitor.class);
        ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
        when(factory.build(any(Context.class), any(ConnectivityMonitor.ConnectivityListener.class)))
                .thenAnswer(new Answer<ConnectivityMonitor>() {
                    @Override
                    public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
                        connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
                        return connectivityMonitor;
                    }
                });
        requestTracker = mock(RequestTracker.class);
        manager =
            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);
        options = mock(RequestManager.DefaultOptions.class);
        manager.setDefaultOptions(options);
    }
=======
  public void setUp() {
    MockitoAnnotations.initMocks(this);
    connectivityMonitor = mock(ConnectivityMonitor.class);
    ConnectivityMonitorFactory factory = mock(ConnectivityMonitorFactory.class);
    when(factory.build(any(Context.class), any(ConnectivityMonitor.ConnectivityListener.class)))
        .thenAnswer(new Answer<ConnectivityMonitor>() {
          @Override
          public ConnectivityMonitor answer(InvocationOnMock invocation) throws Throwable {
            connectivityListener = (ConnectivityListener) invocation.getArguments()[1];
            return connectivityMonitor;
          }
        });
    requestTracker = mock(RequestTracker.class);
    manager = new RequestManager(RuntimeEnvironment.application, lifecycle, treeNode,
        requestTracker, factory);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
            Robolectric.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
        }
=======
      Shadows.shadowOf(Looper.getMainLooper()).runToEndOfTasks();
      assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);
=======
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
    public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
=======
  public void testReturnsNewRequestManagerIfFragmentExistsButHasNoRequestManager() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
    public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
        for (RetrieverHarness harness : harnesses) {
            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
            RequestManager first = harness.doGet();
            RequestManager second = harness.doGet();
=======
  public void testSavesNewRequestManagerToFragmentIfCreatesRequestManagerForExistingFragment() {
    for (RetrieverHarness harness : harnesses) {
      harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);
      RequestManager first = harness.doGet();
      RequestManager second = harness.doGet();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
    public void testHasValidTag() {
        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);
    }
=======
  public void testHasValidTag() {
    assertEquals(RequestManagerRetriever.class.getPackage().getName(),
        RequestManagerRetriever.FRAGMENT_TAG);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
        public boolean hasFragmentWithTag(String tag) {
            return null != controller.get()
                .getFragmentManager()
                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
        }
=======
    public boolean hasFragmentWithTag(String tag) {
      return null != controller
          .get()
          .getFragmentManager()
          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
        public void addFragmentWithTag(String tag, RequestManager requestManager) {
            RequestManagerFragment fragment = new RequestManagerFragment();
            fragment.setRequestManager(requestManager);
            controller.get().getFragmentManager()
                    .beginTransaction()
                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getFragmentManager().executePendingTransactions();
        }
=======
    public void addFragmentWithTag(String tag, RequestManager requestManager) {
      RequestManagerFragment fragment = new RequestManagerFragment();
      fragment.setRequestManager(requestManager);
      controller.get().getFragmentManager().beginTransaction()
          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
      controller.get().getFragmentManager().executePendingTransactions();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
        public boolean hasFragmentWithTag(String tag) {
            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG)
                    != null;
        }
=======
    public boolean hasFragmentWithTag(String tag) {
      return controller.get().getSupportFragmentManager()
          .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG) != null;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java;<<<<<<< MINE
        public void addFragmentWithTag(String tag, RequestManager manager) {
            SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
            fragment.setRequestManager(manager);
            controller.get().getSupportFragmentManager()
                    .beginTransaction()
                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG)
                    .commitAllowingStateLoss();
            controller.get().getSupportFragmentManager().executePendingTransactions();
        }
=======
    public void addFragmentWithTag(String tag, RequestManager manager) {
      SupportRequestManagerFragment fragment = new SupportRequestManagerFragment();
      fragment.setRequestManager(manager);
      controller.get().getSupportFragmentManager().beginTransaction()
          .add(fragment, RequestManagerRetriever.FRAGMENT_TAG).commitAllowingStateLoss();
      controller.get().getSupportFragmentManager().executePendingTransactions();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
public GenericRequest<Number, Object, Object, List> getRequest() {
            return GenericRequest.obtain(loadProvider,
                    model,
                    signature,
                    context,
                    priority,
                    target,
                    1f,
                    placeholderDrawable,
                    placeholderResourceId,
                    errorDrawable,
                    errorResourceId,
                    fallbackDrawable,
                    fallbackResourceId,
                    requestListener,
                    requestCoordinator,
                    engine,
                    transformation,
                    List.class,
                    skipMemoryCache,
                    factory,
                    overrideWidth,
                    overrideHeight,
                    diskCacheStrategy);
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
@Test
    public void testCanHandleNullResources() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);

        assertTrue(request.isFailed());
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
@Test
    public void testCanHandleNonConformingResources() {
        GenericRequest request = harness.getRequest();
        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
@Test
    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onSizeReady(100, 100);
        request.onSizeReady(100, 100);

        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100),
            any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
            any(ResourceTranscoder.class), any(Priority.class), anyBoolean(),
            any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
@Test
    public void testEngineLoadPassedCorrectPriority() {
        Priority expected = Priority.HIGH;
        harness.priority = expected;
        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);

        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
            any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
            eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java;<<<<<<< MINE
@Test
    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
        when(thumb.isComplete()).thenReturn(true);
        coordinator.onRequestSuccess(full);
        verify(thumb, never()).clear();
    }
=======
@Test
  public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {
      when(thumb.isComplete()).thenReturn(true);
      coordinator.onRequestSuccess(full);
      verify(thumb, never()).clear();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java;<<<<<<< MINE
@Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        stringLoader = new StreamStringLoader(uriLoader);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java;<<<<<<< MINE
@Test
    public void testCanHandleId() {
        int id = android.R.drawable.star_off;
        resourceLoader.getResourceFetcher(id, 0, 0);

        Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");
        verify(streamUriLoader).getResourceFetcher(eq(contentUri), anyInt(), anyInt());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java;<<<<<<< MINE
        assertEquals(expected, glideUrl.toStringUrl());
    }
=======
    assertEquals(expected, glideUrl.toStringUrl());
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Test
    public void testHandlesPartialReads() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }
=======
@Test
  public void testHandlesPartialReads() throws IOException {
    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
    ImageHeaderParser parser = new ImageHeaderParser(new PartialReadInputStream(is), byteArrayPool);
    assertThat(parser.getOrientation()).isEqualTo(6);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Test
    public void testHandlesPartialSkips() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is));
        assertThat(parser.getOrientation()).isEqualTo(6);
    }
=======
@Test
  public void testHandlesPartialSkips() throws IOException {
    InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
    ImageHeaderParser parser = new ImageHeaderParser(new PartialSkipInputStream(is), byteArrayPool);
    assertThat(parser.getOrientation()).isEqualTo(6);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Test
    public void testHandlesSometimesZeroSkips() throws IOException {
        InputStream is = new ByteArrayInputStream(new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
        ImageHeaderParser parser = new ImageHeaderParser(new SometimesZeroSkipInputStream(is));
        assertEquals(ImageType.PNG, parser.getType());
    }
=======
@Test
  public void testHandlesSometimesZeroSkips() throws IOException {
    InputStream is = new ByteArrayInputStream(
        new byte[] { (byte) 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a });
    ImageHeaderParser parser =
        new ImageHeaderParser(new SometimesZeroSkipInputStream(is), byteArrayPool);
    assertEquals(ImageType.PNG, parser.getType());
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
protected SometimesZeroSkipInputStream(InputStream in) {
            super(in);
        }
=======
protected SometimesZeroSkipInputStream(InputStream in) {
        super(in);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Override
        public long skip(long byteCount) throws IOException {
            if (returnZeroFlag) {
                return 0;
            }
            returnZeroFlag = !returnZeroFlag;
            return super.skip(byteCount);
        }
=======
@Override
    public long skip(long byteCount) throws IOException {
      final long result;
      if (returnZeroFlag) {
        result = 0;
      } else {
        result = super.skip(byteCount);
      }
      returnZeroFlag = !returnZeroFlag;
      return result;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
protected PartialSkipInputStream(InputStream in) {
            super(in);
        }
=======
protected PartialSkipInputStream(InputStream in) {
        super(in);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Override
        public long skip(long byteCount) throws IOException {
            long toActuallySkip = byteCount / 2;
            if (byteCount == 1) {
                toActuallySkip = 1;
            }
            return super.skip(toActuallySkip);
        }
=======
@Override
    public long skip(long byteCount) throws IOException {
        long toActuallySkip = byteCount / 2;
        if (byteCount == 1) {
            toActuallySkip = 1;
        }
        return super.skip(toActuallySkip);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
protected PartialReadInputStream(InputStream in) {
            super(in);
        }
=======
protected PartialReadInputStream(InputStream in) {
        super(in);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParserTest.java;<<<<<<< MINE
@Override
        public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
            int toActuallyRead = byteCount / 2;
            if (byteCount == 1) {
                toActuallyRead = 1;
            }
            return super.read(buffer, byteOffset, toActuallyRead);
        }
=======
@Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int toActuallyRead = byteCount / 2;
        if (byteCount == 1) {
            toActuallyRead = 1;
        }
        return super.read(buffer, byteOffset, toActuallyRead);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
@Test
    public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
@Test
    public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(
                new MatrixCursor(new String[1]));
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
@Test
    public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
        MatrixCursor cursor = new MatrixCursor(new String[1]);
        cursor.addRow(new Object[]{ "" });
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
@Test
    public void testVideoQueryReturnsVideoCursor() {
        Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.VideoThumbnailQuery query = new MediaStoreThumbFetcher.VideoThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
@Test
    public void testImageQueryReturnsImageCurosr() {
        Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.ImageThumbnailQuery query = new MediaStoreThumbFetcher.ImageThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
public Harness() {
            cursor.addRow(new String[] { file.getAbsolutePath() });
            when(query.queryPath(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
            when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
            when(service.exists(eq(file))).thenReturn(true);
            when(service.length(eq(file))).thenReturn(1L);
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java;<<<<<<< MINE
@Test
    public void testReturnsModelAsString() {
        final String expected = "fakeId";
        when(glideUrl.getCacheKey()).thenReturn(expected);
        assertEquals(expected, fetcher.getId());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java;<<<<<<< MINE
@Test
    public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(
            expected);

        InputStream result = harness.get().loadData(Priority.LOW);
        assertNotNull(result);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;<<<<<<< MINE
@Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
=======
@Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java;<<<<<<< MINE
@Test
    public void testIssue387() throws IOException {
        InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
        assertThat(new ImageHeaderParser(is).getOrientation()).isEqualTo(6);
    }
=======
@Test
  public void testIssue387() throws IOException {
      InputStream is = TestResourceUtil.openResource(getClass(), "issue387_rotated_jpeg.jpg");
      assertThat(new ImageHeaderParser(is, byteArrayPool).getOrientation()).isEqualTo(6);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
        isStarted = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStart();
        }
=======
    isStarted = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStart();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
        isStarted = false;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onStop();
        }
=======
    isStarted = false;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onStop();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java;<<<<<<< MINE
        isDestroyed = true;
        for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
            lifecycleListener.onDestroy();
        }
=======
    isDestroyed = true;
    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {
      lifecycleListener.onDestroy();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        return buildRequestRecursive(target, null);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            // Guard against infinite recursion.
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            isThumbnailBuilt = false;
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
            RequestCoordinator requestCoordinator) {
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                fallbackDrawable,
                fallbackResource,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java;<<<<<<< MINE
    public void onRequestSuccess(Request request) {
        if (request.equals(thumb)) {
            return;
        }
        if (coordinator != null) {
            coordinator.onRequestSuccess(this);
        }
        // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
        // as a layer in a cross fade for example. The only way we know the thumb is not being
        // displayed and is therefore safe to clear is if the thumb request has not yet completed.
        if (!thumb.isComplete()) {
          thumb.clear();
        }
=======
  public void onRequestSuccess(Request request) {
    if (request.equals(thumb)) {
      return;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java;<<<<<<< MINE
    public synchronized boolean cancel(boolean mayInterruptIfRunning) {
        if (isCancelled) {
            return true;
        }
=======
  public synchronized boolean cancel(boolean b) {
    if (isCancelled) {
      return true;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java;<<<<<<< MINE
        final boolean result = !isDone();
        if (result) {
            isCancelled = true;
            if (mayInterruptIfRunning) {
                clear();
            }
            waiter.notifyAll(this);
        }
        return result;
=======
    final boolean result = !isDone();
    if (result) {
      isCancelled = true;
      waiter.notifyAll(this);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java;<<<<<<< MINE
    public void run() {
        if (request != null) {
            request.clear();
            cancel(false /*mayInterruptIfRunning*/);
        }
=======
  public void run() {
    if (request != null) {
      request.clear();
      request = null;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java;<<<<<<< MINE
public SquaringDrawable(GlideDrawable wrapped, int side) {
        this(new State(wrapped.getConstantState(), side), wrapped, null /*res*/);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java;<<<<<<< MINE
@Override
    public int getIntrinsicWidth() {
        return state.side;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java;<<<<<<< MINE
@Override
    public int getIntrinsicHeight() {
        return state.side;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java;<<<<<<< MINE
public DrawableCrossFadeFactory(int duration) {
        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory(duration)), duration);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java;<<<<<<< MINE
@Override
    public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
        if (isFromMemoryCache) {
            return NoAnimation.get();
        } else if (isFirstResource) {
            return getFirstResourceAnimation();
        } else {
            return getSecondResourceAnimation();
        }
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java;<<<<<<< MINE
@Override
        public Animation build() {
            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
            animation.setDuration(duration);
            return animation;
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
@Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        fallbackDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = model == null ? getFallbackDrawable() : null;
        if (error == null) {
          error = getErrorDrawable();
        }
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
@Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Failed to load model: \'" + model + "\'"));
            return;
        }
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
private void onResourceReady(Resource<?> resource, R result) {
        // We must call isFirstReadyResource before setting status.
        boolean isFirstResource = isFirstReadyResource();
        status = Status.COMPLETE;
        this.resource = resource;

        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstResource)) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);
            target.onResourceReady(result, animation);
        }

        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
        this(url, Headers.NONE);
    }
=======
    this(url, Headers.NONE);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
        this(url, Headers.NONE);
    }
=======
    this(url, Headers.NONE);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }
=======
public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }
=======
public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
=======
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public String toStringUrl() {
        return getSafeStringUrl();
    }
=======
public String toStringUrl() {
    return getSafeStringUrl();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }
=======
private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }
=======
public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }
=======
public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }
=======
  public String toString() {
    return getCacheKey();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
=======
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        int firstTwoBytes = streamReader.getUInt16();
=======
    int firstTwoBytes = reader.getUInt16();
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        // JPEG.
        if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
            return JPEG;
        }
=======
    // JPEG.
    if (firstTwoBytes == EXIF_MAGIC_NUMBER) {
      return JPEG;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;
        // PNG.
        if (firstFourBytes == PNG_HEADER) {
            // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type
            streamReader.skip(25 - 4);
            int alpha = streamReader.getByte();
            // A RGB indexed PNG can also have transparency. Better safe than sorry!
            return alpha >= 3 ? PNG_A : PNG;
        }
=======
    final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | reader.getUInt16() & 0xFFFF;
    // PNG.
    if (firstFourBytes == PNG_HEADER) {
      // See: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha
      // -color-type
      reader.skip(25 - 4);
      int alpha = reader.getByte();
      // A RGB indexed PNG can also have transparency. Better safe than sorry!
      return alpha >= 3 ? PNG_A : PNG;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE

            // Segment length includes bytes for segment length.
            segmentLength = streamReader.getUInt16() - 2;

            if (segmentType != EXIF_SEGMENT_TYPE) {
                long skipped = streamReader.skip(segmentLength);
                if (skipped != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to skip enough data"
                            + ", type: " + segmentType
                            + ", wanted to skip: " + segmentLength
                            + ", but actually skipped: " + skipped);
                    }
                    return null;
                }
            } else {
                byte[] segmentData = new byte[segmentLength];
                int read = streamReader.read(segmentData);
                if (read != segmentLength) {
                    if (Log.isLoggable(TAG, Log.DEBUG)) {
                        Log.d(TAG, "Unable to read segment data"
                            + ", type: " + segmentType
                            + ", length: " + segmentLength
                            + ", actually read: " + read);
                    }
                    return null;
                } else {
                    return segmentData;
                }
=======
            return null;
        }
      } else {
        byte[] segmentData = byteArrayPool.get(segmentLength);
        try {
          int read = reader.read(segmentData);
          if (read != segmentLength) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
              Log.d(TAG, "Unable to read segment data"
                  + ", type: " + segmentType
                  + ", length: " + segmentLength
                  + ", actually read: " + read);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
        int tagOffset, tagType, formatCode, componentCount;
        for (int i = 0; i < tagCount; i++) {
            tagOffset = calcTagOffset(firstIfdOffset, i);

            tagType = segmentData.getInt16(tagOffset);

            // We only want orientation.
            if (tagType != ORIENTATION_TAG_TYPE) {
                continue;
            }

            formatCode = segmentData.getInt16(tagOffset + 2);

            // 12 is max format code.
            if (formatCode < 1 || formatCode > 12) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Got invalid format code=" + formatCode);
                }
                continue;
            }

            componentCount = segmentData.getInt32(tagOffset + 4);

            if (componentCount < 0) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Negative tiff component count");
                }
                continue;
            }

            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got tagIndex=" + i + " tagType=" + tagType + " formatCode=" + formatCode
                        + " componentCount=" + componentCount);
            }

            final int byteCount = componentCount + BYTES_PER_FORMAT[formatCode];

            if (byteCount > 4) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Got byte count > 4, not orientation, continuing, formatCode=" + formatCode);
                }
                continue;
            }

            final int tagValueOffset = tagOffset + 8;

            if (tagValueOffset < 0 || tagValueOffset > segmentData.length()) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Illegal tagValueOffset=" + tagValueOffset + " tagType=" + tagType);
                }
                continue;
            }

            if (byteCount < 0 || tagValueOffset + byteCount > segmentData.length()) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Illegal number of bytes for TI tag data tagType=" + tagType);
                }
                continue;
            }
=======
      final int tagValueOffset = tagOffset + 8;
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
public long skip(long total) throws IOException {
            if (total < 0) {
                return 0;
            }

            long toSkip = total;
            while (toSkip > 0) {
                long skipped = is.skip(toSkip);
                if (skipped > 0) {
                    toSkip -= skipped;
                } else {
                    // Skip has no specific contract as to what happens when you reach the end of
                    // the stream. To differentiate between temporarily not having more data and
                    // having finished the stream, we read a single byte when we fail to skip any
                    // amount of data.
                    int testEofByte = is.read();
                    if (testEofByte == -1) {
                        break;
                    } else {
                        toSkip--;
                    }
                }
            }
            return total - toSkip;
=======
@Override
    public long skip(long total) throws IOException {
      if (total < 0) {
        return 0;
      }

      long toSkip = total;
      while (toSkip > 0) {
        long skipped = is.skip(toSkip);
        if (skipped > 0) {
          toSkip -= skipped;
        } else {
          // Skip has no specific contract as to what happens when you reach the end of
          // the stream. To differentiate between temporarily not having more data and
          // having finished the stream, we read a single byte when we fail to skip any
          // amount of data.
          int testEofByte = is.read();
          if (testEofByte == -1) {
            break;
          } else {
            toSkip--;
          }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java;<<<<<<< MINE
public int read(byte[] buffer) throws IOException {
            int toRead = buffer.length;
            int read;
            while (toRead > 0 && ((read = is.read(buffer, buffer.length - toRead, toRead)) != -1)) {
                toRead -= read;
            }
            return buffer.length - toRead;
        }
=======
@Override
    public int read(byte[] buffer) throws IOException {
      int toRead = buffer.length;
      int read;
      while (toRead > 0 && ((read = is.read(buffer, buffer.length - toRead, toRead)) != -1)) {
        toRead -= read;
      }
      return buffer.length - toRead;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
@SuppressWarnings("deprecation")
    private static Bitmap.Config getConfig(InputStream is, DecodeFormat format) {
        // Changing configs can cause skewing on 4.1, see issue #128.
        if (format == DecodeFormat.ALWAYS_ARGB_8888 || format == DecodeFormat.PREFER_ARGB_8888
                || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
            return Bitmap.Config.ARGB_8888;
        }
=======
private Bitmap.Config getConfig(InputStream is, DecodeFormat format) throws IOException {
    // Changing configs can cause skewing on 4.1, see issue #128.
    if (format == DecodeFormat.PREFER_ARGB_8888
        || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
      return Bitmap.Config.ARGB_8888;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java;<<<<<<< MINE
private int getRoundedSampleSize(int degreesToRotate, int inWidth, int inHeight, int outWidth, int outHeight) {
        int targetHeight = outHeight == Target.SIZE_ORIGINAL ? inHeight : outHeight;
        int targetWidth = outWidth == Target.SIZE_ORIGINAL ? inWidth : outWidth;

        final int exactSampleSize;
        if (degreesToRotate == 90 || degreesToRotate == 270) {
            // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image width is
            // decreased to near our target's height and the image height is decreased to near our target width.
            //noinspection SuspiciousNameCombination
            exactSampleSize = getSampleSize(inHeight, inWidth, targetWidth, targetHeight);
        } else {
            exactSampleSize = getSampleSize(inWidth, inHeight, targetWidth, targetHeight);
        }

        // BitmapFactory only accepts powers of 2, so it will round down to the nearest power of two that is less than
        // or equal to the sample size we provide. Because we need to estimate the final image width and height to
        // re-use Bitmaps, we mirror BitmapFactory's calculation here. For bug, see issue #224. For algorithm see
        // http://stackoverflow.com/a/17379704/800716.
        final int powerOfTwoSampleSize = exactSampleSize == 0 ? 0 : Integer.highestOneBit(exactSampleSize);

        // Although functionally equivalent to 0 for BitmapFactory, 1 is a safer default for our code than 0.
        return Math.max(1, powerOfTwoSampleSize);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);
    }
=======
    this(context, null /*diskCacheName*/, diskCacheSize);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
public InternalCacheDiskCacheFactory(final Context context, final String diskCacheName, int diskCacheSize) {
        super(new CacheDirectoryGetter() {
            @Override
            public File getCacheDirectory() {
                File cacheDirectory = context.getCacheDir();
                if (cacheDirectory == null) {
                    return null;
                }
                if (diskCacheName != null) {
                    return new File(cacheDirectory, diskCacheName);
                }
                return cacheDirectory;
            }
        }, diskCacheSize);
    }
=======
public InternalCacheDiskCacheFactory(Context context, String diskCacheName, int diskCacheSize) {
    this.context = context;
    this.diskCacheName = diskCacheName;
    this.diskCacheSize = diskCacheSize;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
=======
@Override
  public DiskCache build() {
    DiskCache diskCache = null;
    final File cacheDir;

    if (diskCacheName != null) {
      cacheDir = Glide.getPhotoCacheDir(context, diskCacheName);
    } else {
      cacheDir = Glide.getPhotoCacheDir(context);
    }

    if (cacheDir != null) {
      diskCache = DiskLruCacheWrapper.get(cacheDir, diskCacheSize);
    }

    if (diskCache == null) {
      diskCache = new DiskCacheAdapter();
    }
    return diskCache;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java;<<<<<<< MINE
@Override
    public void clear() {
        // no op, default for overriders
    }
=======
@Override
  public void clear() {
      // no op, default for overriders
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
    public void put(Key key, Writer writer) {
        String safeKey = safeKeyGenerator.getSafeKey(key);
        writeLocker.acquire(key);
=======
  public void put(Key key, Writer writer) {
    // We want to make sure that puts block so that data is available when put completes. We may
    // actually not write any data if we find that data is written by the time we acquire the lock.
    writeLocker.acquire(key);
    try {
      String safeKey = safeKeyGenerator.getSafeKey(key);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Put: Obtained: " + safeKey + " for for Key: " + key);
      }
      try {
        // We assume we only need to put once, so if data was written while we were trying to get
        // the lock, we can simply abort.
        DiskLruCache diskCache = getDiskCache();
        Value current = diskCache.get(safeKey);
        if (current != null) {
          return;
        }

        DiskLruCache.Editor editor = diskCache.edit(safeKey);
        if (editor == null) {
          throw new IllegalStateException("Had two simultaneous puts for: " + safeKey);
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
            DiskLruCache.Editor editor = getDiskCache().edit(safeKey);
            // Editor will be null if there are two concurrent puts. In the worst case we will just silently fail.
            if (editor != null) {
                try {
                    File file = editor.getFile(0);
                    if (writer.write(file)) {
                        editor.commit();
                    }
                } finally {
                    editor.abortUnlessCommitted();
                }
            }
        } catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to put to disk cache", e);
            }
        } finally {
            writeLocker.release(key);
=======
          File file = editor.getFile(0);
          if (writer.write(file)) {
            editor.commit();
          }
        } finally {
          editor.abortUnlessCommitted();
        }
      } catch (IOException e) {
        if (Log.isLoggable(TAG, Log.WARN)) {
          Log.w(TAG, "Unable to put to disk cache", e);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
@Override
    public synchronized void clear() {
        try {
            getDiskCache().delete();
            resetDiskCache();
        }  catch (IOException e) {
            if (Log.isLoggable(TAG, Log.WARN)) {
                Log.w(TAG, "Unable to clear disk cache", e);
            }
        }
    }
=======
@Override
  public synchronized void clear() {
    try {
      getDiskCache().delete();
      resetDiskCache();
    } catch (IOException e) {
      if (Log.isLoggable(TAG, Log.WARN)) {
        Log.w(TAG, "Unable to clear disk cache", e);
      }
    }
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java;<<<<<<< MINE
private synchronized void resetDiskCache() {
        diskLruCache = null;
    }
=======
private synchronized void resetDiskCache() {
    diskLruCache = null;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java;<<<<<<< MINE
    public String toString() {
        if (stringKey == null) {
            stringKey = new StringBuilder()
                .append("EngineKey{")
                .append(id)
                .append('+')
                .append(signature)
                .append("+[")
                .append(width)
                .append('x')
                .append(height)
                .append("]+")
                .append('\'')
                .append(cacheDecoder   != null ? cacheDecoder  .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(decoder        != null ? decoder       .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(transformation != null ? transformation.getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(encoder        != null ? encoder       .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(transcoder     != null ? transcoder    .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('+')
                .append('\'')
                .append(sourceEncoder  != null ? sourceEncoder .getId() : EMPTY_LOG_STRING)
                .append('\'')
                .append('}')
                .toString();
        }
        return stringKey;
    }
=======
  public String toString() {
    return "EngineKey{"
        + "model=" + model
        + ", width=" + width
        + ", height=" + height
        + ", resourceClass=" + resourceClass
        + ", transcodeClass=" + transcodeClass
        + ", signature=" + signature
        + ", hashCode=" + hashCode
        + ", transformations=" + transformations
        + ", options=" + options
        + '}';
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }
=======
public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public boolean markSupported() {
        return false;
    }
=======
@Override
  public boolean markSupported() {
    return false;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }
=======
@Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }
=======
@Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }
=======
@Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }
=======
@Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
@Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
=======
@Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)
            throws IOException {
        if (redirects >= MAXIMUM_REDIRECTS) {
            throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
        } else {
            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
            try {
                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
                    throw new IOException("In re-direct loop");
                }
            } catch (URISyntaxException e) {
                // Do nothing, this is best effort.
            }
        }
        urlConnection = connectionFactory.build(url);
        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
        }
        // Do our best to avoid gzip since it's both inefficient for images and also makes it more
        // difficult for us to detect and prevent partial content rendering. See #440.
        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {
            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);
        }
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);
        urlConnection.setDoInput(true);

        // Connect explicitly to avoid errors in decoders if connection fails.
        urlConnection.connect();
        if (isCancelled) {
            return null;
        }
        final int statusCode = urlConnection.getResponseCode();
        if (statusCode / 100 == 2) {
            return getStreamForSuccessfulRequest(urlConnection);
        } else if (statusCode / 100 == 3) {
            String redirectUrlString = urlConnection.getHeaderField("Location");
            if (TextUtils.isEmpty(redirectUrlString)) {
                throw new IOException("Received empty or null redirect url");
            }
            URL redirectUrl = new URL(url, redirectUrlString);
            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
        } else {
            if (statusCode == -1) {
                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
            }
            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
        }
    }
=======
private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
            throw new IOException("In re-direct loop");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      String contentLength = urlConnection.getHeaderField(CONTENT_LENGTH_HEADER);
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
      return stream;
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField("Location");
      if (TextUtils.isEmpty(redirectUrlString)) {
          throw new IOException("Received empty or null redirect url");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else {
      if (statusCode == -1) {
          throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
      }
      throw new IOException("Request failed " + statusCode + ": "
          + urlConnection.getResponseMessage());
    }
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
@Override
    public InputStream loadData(Priority priority) throws Exception {
        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
@Override
    public String getId() {
        return glideUrl.getCacheKey();
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java;<<<<<<< MINE
@Override
    public InputStream loadData(Priority priority) throws Exception {
        ThumbnailStreamOpener fetcher = factory.build(mediaStoreUri, width, height);

        if (fetcher != null) {
            inputStream = openThumbInputStream(fetcher);
        }

        if (inputStream == null) {
            inputStream = defaultFetcher.loadData(priority);
        }

        return inputStream;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java;<<<<<<< MINE
public InputStream open(Context context, Uri uri) throws FileNotFoundException {
            Uri thumbnailUri = null;
            InputStream inputStream = null;

            final Cursor cursor = query.queryPath(context, uri);
            try {
                if (cursor != null && cursor.moveToFirst()) {
                    thumbnailUri = parseThumbUri(cursor);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            if (thumbnailUri != null) {
                inputStream = context.getContentResolver().openInputStream(thumbnailUri);
            }
            return inputStream;
        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;<<<<<<< MINE
public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }
=======
public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;<<<<<<< MINE
@Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }
=======
@Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }
>>>>>>> YOURS
/home/arthur/analysis/projects/okio/revisions/rev_89e1341_c8a36a6/rev_89e1341-c8a36a6/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/bytes/GzipSource.java;<<<<<<< MINE
=======
@Override public long read(OkBuffer sink, long byteCount, Deadline deadline) throws IOException {
    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
    if (byteCount == 0) return 0;

    // If we haven't consumed the header, we must consume it before anything else.
    if (section == SECTION_HEADER) {
      consumeHeader(deadline);
      section = SECTION_BODY;
    }

    // Attempt to read at least a byte of the body. If we do, we're done.
    if (section == SECTION_BODY) {
      long offset = sink.byteCount;
      long result = inflaterSource.read(sink, byteCount, deadline);
      if (result != -1) {
        updateCrc(sink, offset, result);
        return result;
      }
      section = SECTION_TRAILER;
    }

    // The body is exhausted; time to read the trailer. We always consume the
    // trailer before returning a -1 exhausted result; that way if you read to
    // the end of a GzipSource you guarantee that the CRC has been checked.
    if (section == SECTION_TRAILER) {
      consumeTrailer();
      section = SECTION_DONE;

      // Gzip streams self-terminate: they return -1 before their underlying
      // source returns -1. Here we attempt to force the underlying stream to
      // return -1 which may trigger it to release its resources. If it doesn't
      // return -1, then our Gzip data finished prematurely!
      if (!source.exhausted(deadline)) {
        throw new IOException("gzip finished without exhausting source");
      }
    }

    return -1;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_3b20004_63678dd/rev_3b20004-63678dd/java/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
public void pamGrant(final String channel, String auth_key, boolean read,
                         boolean write, int ttl, final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING, 1));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "grant" + "\n" + "auth=" + urlEncode(auth_key) + "&" + "channel="
                            + urlEncode(channel) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                            + ((ttl > -1)?"&" + "ttl=" + ttl:"")
                            + "&" + "w=" + w;


        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }


        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", urlEncode(channel));
        parameters.put("auth", urlEncode(auth_key));
        if (ttl > 0) parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, getErrorObject(
                                    PNERROBJ_INVALID_JSON, 4,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_3b20004_63678dd/rev_3b20004-63678dd/java/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
public void pamAudit(final String channel,
                         final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING , 3));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "audit" + "\n" + "channel="
                            + urlEncode(channel) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", urlEncode(channel));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, getErrorObject(
                                    PNERROBJ_INVALID_JSON, 6,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_3b20004_63678dd/rev_3b20004-63678dd/java/src/com/pubnub/api/Pubnub.java;<<<<<<< MINE
=======
public void pamAudit(final String channel, String auth_key,
                         final Callback callback) {

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel,
                                   getErrorObject(PNERROBJ_SECRET_KEY_MISSING, 4));
            return;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n"
                            + "audit" + "\n" + "auth=" + urlEncode(auth_key) + "&" + "channel="
                            + urlEncode(channel) + "&" + "timestamp=" + timestamp;


        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel,
                                   e1.getPubnubError());
            return;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", urlEncode(channel));
        parameters.put("auth", urlEncode(auth_key));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key",
                                   this.SUBSCRIBE_KEY
                                 };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters,
        new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONObject jso;
                try {
                    jso = new JSONObject(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(
                                    PubnubError.PNERROBJ_INVALID_JSON, 2,
                                    response));
                    return;
                }
                callback.successCallback(channel, jso);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        });

        _request(hreq, nonSubscribeManager);

    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;<<<<<<< MINE
void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
=======
void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/java/examples/src/com/pubnub/examples/PubnubPushSampleCode.java;<<<<<<< MINE
        Options options = new Options();
        String publish_key = "demo-36";
        String subscribe_key = "demo-36";
        boolean nativ = false;
        boolean gcm = false;
        boolean apns = false;

        String channel = "demo";

        String origin = "gcm-beta";

        String auth_key = "";

        CommandLine cmd = null;

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
                withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
                withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
                withType(String.class).withDescription("Origin ( Ex. pubsub )").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
                withType(String.class).withDescription("Auth Key").create());

        options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
                withType(String.class).withDescription("Secret Key ( default: 'my_channel' )").create());

        options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());

        options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());

        options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());

        CommandLineParser parser = new BasicParser();
        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e1) {
            usage(options);
            return;
        }

        if (cmd.hasOption("publish_key")) {
            try {
                publish_key = cmd.getOptionValue("publish_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("subscribe_key")) {
            try {
                subscribe_key = cmd.getOptionValue("subscribe_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("origin")) {
            try {
                origin = cmd.getOptionValue("origin");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("channel")) {
            try {
                channel = cmd.getOptionValue("channel");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("auth_key")) {
            try {
                auth_key = cmd.getOptionValue("auth_key");
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("apns")) {
            try {
                apns = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }

        if (cmd.hasOption("gcm")) {
            try {
                gcm = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        if (cmd.hasOption("native")) {
            try {
                nativ = true;
            } catch (Exception e) {
                e.printStackTrace();
                usage(options);
                return;
            }
        }


        final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
        pubnub.setAuthKey(auth_key);
        pubnub.setCacheBusting(false);
        pubnub.setOrigin(origin);

        // Create APNS message

        PnApnsMessage apnsMessage = new PnApnsMessage();
        apnsMessage.setApsAlert("Game update 49ers touchdown");
        apnsMessage.setApsBadge(2);

        try {
            apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
            apnsMessage.put("score", new JSONArray().put(7).put(0));
        } catch (JSONException e1) {

        }

        // Create GCM Message

        PnGcmMessage gcmMessage = new PnGcmMessage();

        JSONObject jso = new JSONObject();
        try {
            jso.put("summary", "Game update 49ers touchdown");
            jso.put("lastplay", "5yd run up the middle");
        } catch (JSONException e) {

        }

        gcmMessage.setData(jso);


        Callback callback = new Callback() {
            @Override
            public void successCallback(String channel, Object response) {
                System.out.println(response);
                pubnub.shutdown();
            }

            @Override
            public void errorCallback(String channel, PubnubError error) {
                System.out.println(error);
                pubnub.shutdown();
            }
        };

        PubnubSender sender = new PubnubSender(channel, pubnub, callback);

        PnMessage message = null;

        if (apns && gcm) {
            message = new PnMessage(sender, apnsMessage, gcmMessage);
        } else if (apns) {
            message = new PnMessage(sender, apnsMessage);
        } else if (gcm) {
            message = new PnMessage(sender, gcmMessage);
        }
        if (message == null) message = new PnMessage(sender);
        if (nativ) {
            try {
                message.put("test", "hi");
            } catch (JSONException e1) {

            }
        }

        try {
            message.publish();
        } catch (PubnubSenderMissingException e) {
            System.out.println("Set Sender");
        }
=======
		Options options = new Options();
		String publish_key = "demo-36";
		String subscribe_key = "demo-36";
		boolean nativ = false;
		boolean gcm = false;
		boolean apns = false;
		
		String channel = "my_channel";
		
		String origin = "pubsub";
		
		String auth_key = "";
		
		CommandLine cmd = null;
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("publish_key").
				withType(String.class).withDescription("Publish Key ( default: 'demo-36' )").create());

		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("subscribe_key").
				withType(String.class).withDescription("Subscribe Key ( default: 'demo-36' )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("origin").
				withType(String.class).withDescription("Origin ( Ex. pubsub )").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("auth_key").
				withType(String.class).withDescription("Auth Key").create());
		
		options.addOption(OptionBuilder.hasArg().withArgName("String").withLongOpt("channel").
				withType(String.class).withDescription("Channel ( default: 'my_channel' )").create());
		
		options.addOption(OptionBuilder.withLongOpt("apns").withDescription("APNS message").create());
		
		options.addOption(OptionBuilder.withLongOpt("gcm").withDescription("GCM message").create());
		
		options.addOption(OptionBuilder.withLongOpt("native").withDescription("Native message").create());
		
		CommandLineParser parser = new BasicParser();
		try {
			cmd = parser.parse( options, args);
		} catch (ParseException e1) {
			usage(options);return;
		}
		
		if (cmd.hasOption("publish_key")) {
			try {
				publish_key = cmd.getOptionValue("publish_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("subscribe_key")) {
			try {
				subscribe_key = cmd.getOptionValue("subscribe_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("origin")) {
			try {
				origin = cmd.getOptionValue("origin");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("channel")) {
			try {
				channel = cmd.getOptionValue("channel");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("auth_key")) {
			try {
				auth_key = cmd.getOptionValue("auth_key");
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		if (cmd.hasOption("apns")) {
			try {
				apns = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		if (cmd.hasOption("gcm")) {
			try {
				gcm = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}

		
		if (cmd.hasOption("native")) {
			try {
				nativ = true;
			} catch (Exception e) {
				e.printStackTrace();
				usage(options);return;
			}
		}
		
		
		final Pubnub pubnub = new Pubnub(publish_key, subscribe_key);
		pubnub.setAuthKey(auth_key);
		pubnub.setCacheBusting(false);
		pubnub.setOrigin(origin);
		
		// Create APNS message
		
		PnApnsMessage apnsMessage = new PnApnsMessage();
		apnsMessage.setApsAlert("Game update 49ers touchdown");
		apnsMessage.setApsBadge(2);
		
		try {
			apnsMessage.put("teams", new JSONArray().put("49ers").put("raiders"));
			apnsMessage.put("score", new JSONArray().put(7).put(0));
		} catch (JSONException e1) {

		}
		
		// Create GCM Message	
		
		PnGcmMessage gcmMessage = new PnGcmMessage();
		
		JSONObject jso = new JSONObject();
		try {
			jso.put("summary", "Game update 49ers touchdown");
			jso.put("lastplay", "5yd run up the middle");
		} catch (JSONException e) {

		}

		gcmMessage.setData(jso);
		
		
		Callback callback = new Callback() {
			@Override
			public void successCallback(String channel, Object response) {
				System.out.println(response);
				pubnub.shutdown();
			}
			@Override
			public void errorCallback(String channel, PubnubError error) {
				System.out.println(error);
				pubnub.shutdown();
			}			
		};
		
		PubnubSender sender = new PubnubSender(channel, pubnub, callback);
		
		PnMessage message = null;
		
		if (apns && gcm) {
			message = new PnMessage(sender, apnsMessage, gcmMessage);
		} else if (apns) {
			message = new PnMessage(sender, apnsMessage);
		} else if (gcm) {
			message = new PnMessage(sender, gcmMessage);
		}
		if (message == null) message = new PnMessage(sender);
		if (nativ) {
			try {
				message.put("test","hi");
			} catch (JSONException e1) {

			}
		}
		
		try {
			message.publish();
		} catch (PubnubSenderMissingException e) {
			System.out.println("Set Sender");
		}
		
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_5580ad1_497fd11/rev_5580ad1-497fd11/android/examples/PubnubExample/src/com/pubnub/examples/pubnubExample10/MainActivity.java;<<<<<<< MINE
                    @Override
                    public void onClick(DialogInterface dialog, int which) {

                        if (TextUtils.isEmpty(REG_ID)) {
                            Toast.makeText(getApplicationContext(),
                                    "GCM Registration id not set. Register to GCM and try again.",
                                    Toast.LENGTH_LONG).show();
                            return;
                        }
                        String channel = edChannelName.getText().toString();
                        pubnub.enablePushNotificationsOnChannel(channel, REG_ID, new Callback() {
                            @Override
                            public void successCallback(String channel,
                                                        Object message) {
                                notifyUser("GCM ADD : " + message);
                            }

                            @Override
                            public void errorCallback(String channel,
                                                      PubnubError error) {
                                notifyUser("GCM ADD : " + error);
                            }
                        });
                    }
                });
=======
            @Override
            public void onClick(DialogInterface dialog, int which) {
            	   		
        		if (TextUtils.isEmpty(REG_ID)) {
        		      Toast.makeText(getApplicationContext(),
        			          "GCM Registration id not set. Register to GCM and try again.",
        			          Toast.LENGTH_LONG).show();
        		      return ;
        		}
                String channel = edChannelName.getText().toString();
				pubnub.enablePushNotificationsOnChannel(channel, REG_ID, new Callback() {
				    @Override
				    public void successCallback(String channel,
				    Object message) {
				        notifyUser("GCM ADD : " + message);
				    }
				    @Override
				    public void errorCallback(String channel,
				    PubnubError error) {
				        notifyUser("GCM ADD : " + error);
				    }
				});
            }
        });
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_8e4119c_6dbe265/rev_8e4119c-6dbe265/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE

        String[] urlargs = { getPubnubUrl(), "v2/presence/sub_key",
                this.SUBSCRIBE_KEY, "channel", PubnubUtil.urlEncode(channel),
                "leave"
        };
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", UUID);
        
        HttpRequest hreq = new HttpRequest(urlargs, parameters,
                new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {

            }

            public void handleError(HttpRequest hreq, PubnubError error) {

            }

        });
        _request(hreq, nonSubscribeManager);
=======
        _leave(PubnubUtil.urlEncode(channel), new Hashtable());
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_69f66e4_cbcfbfa/rev_69f66e4-cbcfbfa/src/main/java/com/corundumstudio/socketio/protocol/PacketDecoder.java;<<<<<<< MINE
=======
private Packet decode(UUID uuid, ByteBuf frame) throws IOException {
        PacketType type = readType(frame);
        Packet packet = new Packet(type);

        if (type == PacketType.PING) {
            packet.setData(readString(frame));
            return packet;
        }

        if (!frame.isReadable()) {
            return packet;
        }

        PacketType innerType = readInnerType(frame);
        packet.setSubType(innerType);

        int endIndex = frame.bytesBefore((byte)'[');
        if (endIndex > 0) {
            // TODO optimize
            boolean hasNsp = frame.bytesBefore(endIndex, (byte)',') != -1;
            if (hasNsp) {
                String nspAckId = readString(frame, endIndex);
                String[] parts = nspAckId.split(",");
                String nsp = parts[0];
                packet.setNsp(nsp);
                if (parts.length > 1) {
                    String ackId = parts[1];
                    packet.setAckId(Long.valueOf(ackId));
                }
            } else {
                long ackId = readLong(frame, endIndex);
                packet.setAckId(ackId);
            }
        }

        if (packet.getType() == PacketType.MESSAGE) {
            if (packet.getSubType() == PacketType.CONNECT
                    || packet.getSubType() == PacketType.DISCONNECT) {
                packet.setNsp(readString(frame));
            }

            JsonSupport jsonSupport = this.jsonSupport;
            Namespace nsp = nspHub.get(packet.getNsp());
            if(nsp != null) {
                jsonSupport = nsp.getJsonSupport();
            }


            if (packet.getSubType() == PacketType.ACK) {
                ByteBufInputStream in = new ByteBufInputStream(frame);
                AckCallback<?> callback = ackManager.getCallback(uuid, packet.getAckId());
                AckArgs args = jsonSupport.readAckArgs(in, callback);
                packet.setData(args.getArgs());
            }

            if (packet.getSubType() == PacketType.EVENT
                    || packet.getSubType() == PacketType.BINARY_EVENT) {
                ByteBufInputStream in = new ByteBufInputStream(frame);
                Event event = jsonSupport.readValue(in, Event.class);
                packet.setName(event.getName());
                packet.setData(event.getArgs());
            }
        }
        return packet;
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
private void channelGroupLeave(String group) {
    	channelGroupLeave(group, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void unsubscribe(String[] channels) {
    	unsubscribe(channels, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[]{(String) args.get("channel")};
        }
        unsubscribe(channelList);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void channelGroupUnsubscribe(String[] groups) {
    	channelGroupUnsubscribe(groups, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void unsubscribePresence(String channel) {
    	unsubscribePresence(channel, null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void unsubscribeAll() {
    	unsubscribeAll(null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void unsubscribeAllChannels() {
    	unsubscribeAllChannels(null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_0f0a6a3_6caaea9/rev_0f0a6a3-6caaea9/java/srcPubnubApi/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
=======
public void channelGroupUnsubscribeAllGroups() {
    	channelGroupUnsubscribeAllGroups(null);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_17b846c_71436c3/rev_17b846c-71436c3/src/main/java/com/pubnub/api/core/Pubnub.java;<<<<<<< MINE

        return prop.getProperty("version");

=======

        return prop.getProperty("version");


//        byte[] encoded;
//        try {
//            encoded = Files.readAllBytes(Paths.get(Pubnub.class.getClassLoader().getResource("version.properties").getPath()));
//        } catch (IOException e) {
//            return "N/A";
//        }
//        try {
//            return new String(encoded, "UTF-8").trim();
//        } catch (UnsupportedEncodingException e) {
//            return "N/A";
//        }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/EndpointTest.java;<<<<<<< MINE
=======
@Test
    public void testUUID() throws PubNubException {
        Endpoint<Object, Object> endpoint =  new Endpoint<Object, Object>(pubnub) {

            @Override
            protected void validateParams() throws PubNubException {
            }

            @Override
            protected Object createResponse(Response input) throws PubNubException {
                return null;
            }

            @Override
            protected int getConnectTimeout() {
                return 0;
            }

            @Override
            protected int getRequestTimeout() {
                return 0;
            }

            @Override
            protected PNOperationType getOperationType() {
                return null;
            }

            @Override
            protected Call doWork(Map baseParams) throws PubNubException {

                Call<Object> fakeCall = new Call<Object>() {

                    @Override
                    public Response<Object> execute() throws IOException {
                        Response<Object> newResponse = Response.success(null);
                        return newResponse;
                    }

                    @Override
                    public void enqueue(Callback<Object> callback) {

                    }

                    @Override
                    public boolean isExecuted() {
                        return false;
                    }

                    @Override
                    public void cancel() {

                    }

                    @Override
                    public boolean isCanceled() {
                        return false;
                    }

                    @Override
                    public Call<Object> clone() {
                        return null;
                    }

                    @Override
                    public Request request() {
                        return null;
                    }
                };

                Assert.assertEquals("myUUID",baseParams.get("uuid"));
                return fakeCall;
            }
        };

        endpoint.sync();
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/Crypto.java;<<<<<<< MINE
private static PubNubError newCryptoError(int code, String message) {

        return PubNubErrorBuilder.createCryptoError(code, message);
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_9208c65_6c5af23/rev_9208c65-6c5af23/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java;<<<<<<< MINE
@Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      // Skip pointer.
      if (payloadUnitStartIndicator) {
        int pointerField = data.readUnsignedByte();
        data.skip(pointerField);
      }

      data.readBytes(pmtScratch, 3);
      pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
      int sectionLength = pmtScratch.readBits(12);

      // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
      // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
      // Skip the rest of the PMT header.
      data.skip(7);

      data.readBytes(pmtScratch, 2);
      pmtScratch.skipBits(4);
      int programInfoLength = pmtScratch.readBits(12);

      // Skip the descriptors.
      data.skip(programInfoLength);

      int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
          - programInfoLength - 4 /* CRC size */;
      while (entriesSize > 0) {
        data.readBytes(pmtScratch, 5);
        int streamType = pmtScratch.readBits(8);
        pmtScratch.skipBits(3); // reserved
        int elementaryPid = pmtScratch.readBits(13);
        pmtScratch.skipBits(4); // reserved
        int esInfoLength = pmtScratch.readBits(12);

        // Skip the descriptors.
        data.skip(esInfoLength);
        entriesSize -= esInfoLength + 5;

        if (sampleQueues.get(streamType) != null) {
          continue;
        }

        ElementaryStreamReader pesPayloadReader = null;
        switch (streamType) {
          case TS_STREAM_TYPE_MPA:
          case TS_STREAM_TYPE_MPA_LSF:
            pesPayloadReader = new MpaReader(bufferPool);
            break;
          case TS_STREAM_TYPE_AAC:
            pesPayloadReader = new AdtsReader(bufferPool);
            break;
          case TS_STREAM_TYPE_H264:
            SeiReader seiReader = new SeiReader(bufferPool);
            sampleQueues.put(TS_STREAM_TYPE_EIA608, seiReader);
            pesPayloadReader = new H264Reader(bufferPool, seiReader);
            break;
          case TS_STREAM_TYPE_ID3:
            pesPayloadReader = new Id3Reader(bufferPool);
            break;
        }

        if (pesPayloadReader != null) {
          sampleQueues.put(streamType, pesPayloadReader);
          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
        }
      }

      // Skip CRC_32.
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;<<<<<<< MINE
public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }
=======
public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;<<<<<<< MINE
@Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }
=======
@Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;<<<<<<< MINE
@Override
    public void packetFinished() {
        // Do nothing.
    }
=======
@Override
  public void packetFinished() {
    // Do nothing.
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2c54363_8caaf0b/rev_2c54363-8caaf0b/demo/src/main/java/com/google/android/exoplayer2/demo/EventLogger.java;<<<<<<< MINE
=======
@Override
  public void onTrackSelectionsChanged(TrackSelections<? extends MappedTrackInfo> trackSelections) {
    Log.d(TAG, "Tracks [");
    // Log tracks associated to renderers.
    MappedTrackInfo info = trackSelections.info;
    for (int rendererIndex = 0; rendererIndex < trackSelections.length; rendererIndex++) {
      TrackGroupArray trackGroups = info.getTrackGroups(rendererIndex);
      TrackSelection trackSelection = trackSelections.get(rendererIndex);
      if (trackGroups.length > 0) {
        Log.d(TAG, "  Renderer:" + rendererIndex + " [");
        for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
          TrackGroup trackGroup = trackGroups.get(groupIndex);
          String adaptiveSupport = getAdaptiveSupportString(
              trackGroup.length, info.getAdaptiveSupport(rendererIndex, groupIndex, false));
          Log.d(TAG, "    Group:" + groupIndex + ", adaptive_supported=" + adaptiveSupport + " [");
          for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
            String status = getTrackStatusString(trackSelection, trackGroup, trackIndex);
            String formatSupport = getFormatSupportString(
                info.getTrackFormatSupport(rendererIndex, groupIndex, trackIndex));
            Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
                + getFormatString(trackGroup.getFormat(trackIndex))
                + ", supported=" + formatSupport);
          }
          Log.d(TAG, "    ]");
        }
        // Log metadata for at most one of the tracks selected for the renderer.
        if (trackSelection != null) {
          for (int selectionIndex = 0; selectionIndex < trackSelection.length(); selectionIndex++) {
            Metadata metadata = trackSelection.getFormat(selectionIndex).metadata;
            if (metadata != null) {
              Log.d(TAG, "    Metadata [");
              printMetadata(metadata, "      ");
              Log.d(TAG, "    ]");
              break;
            }
          }
        }
        Log.d(TAG, "  ]");
      }
    }
    // Log tracks not associated with a renderer.
    TrackGroupArray trackGroups = info.getUnassociatedTrackGroups();
    if (trackGroups.length > 0) {
      Log.d(TAG, "  Renderer:None [");
      for (int groupIndex = 0; groupIndex < trackGroups.length; groupIndex++) {
        Log.d(TAG, "    Group:" + groupIndex + " [");
        TrackGroup trackGroup = trackGroups.get(groupIndex);
        for (int trackIndex = 0; trackIndex < trackGroup.length; trackIndex++) {
          String status = getTrackStatusString(false);
          String formatSupport = getFormatSupportString(
              RendererCapabilities.FORMAT_UNSUPPORTED_TYPE);
          Log.d(TAG, "      " + status + " Track:" + trackIndex + ", "
              + getFormatString(trackGroup.getFormat(trackIndex))
              + ", supported=" + formatSupport);
        }
        Log.d(TAG, "    ]");
      }
      Log.d(TAG, "  ]");
    }
    Log.d(TAG, "]");
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e65110e_d79f8f6/rev_e65110e-d79f8f6/library/src/main/java/com/google/android/exoplayer2/extractor/ts/H265Reader.java;<<<<<<< MINE
=======
@Override
  public void init(ExtractorOutput extractorOutput, TrackIdGenerator idGenerator) {
    output = extractorOutput.track(idGenerator.getNextId());
    sampleReader = new SampleReader(output);
    seiReader = new SeiReader(extractorOutput.track(idGenerator.getNextId()));
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
    sampleStreams = new ClippingSampleStream[streams.length];
    SampleStream[] internalStreams = new SampleStream[streams.length];
    for (int i = 0; i < streams.length; i++) {
      sampleStreams[i] = (ClippingSampleStream) streams[i];
      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
    }
    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
        internalStreams, streamResetFlags, positionUs + startUs);
    Assertions.checkState(enablePositionUs == positionUs + startUs
        || (enablePositionUs >= startUs
        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
    for (int i = 0; i < streams.length; i++) {
      if (internalStreams[i] == null) {
        sampleStreams[i] = null;
      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
            pendingInitialDiscontinuity);
      }
      streams[i] = sampleStreams[i];
    }
    return enablePositionUs - startUs;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public long readDiscontinuity() {
    if (pendingInitialDiscontinuity) {
      for (ClippingSampleStream sampleStream : sampleStreams) {
        if (sampleStream != null) {
          sampleStream.clearPendingDiscontinuity();
        }
      }
      pendingInitialDiscontinuity = false;
      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
      long discontinuityUs = readDiscontinuity();
      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
    }
    long discontinuityUs = mediaPeriod.readDiscontinuity();
    if (discontinuityUs == C.TIME_UNSET) {
      return C.TIME_UNSET;
    }
    Assertions.checkState(discontinuityUs >= startUs);
    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
    return discontinuityUs - startUs;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public long getBufferedPositionUs() {
    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return Math.max(0, bufferedPositionUs - startUs);
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public long seekToUs(long positionUs) {
    for (ClippingSampleStream sampleStream : sampleStreams) {
      if (sampleStream != null) {
        sampleStream.clearSentEos();
      }
    }
    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
    Assertions.checkState(seekUs == positionUs + startUs
        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
    return seekUs - startUs;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public long getNextLoadPositionUs() {
    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return nextLoadPositionUs - startUs;
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
  public void onPrepared(MediaPeriod mediaPeriod) {
    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
    // If the clipping start position is non-zero, the clipping sample streams will adjust
    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
    // which may be before the clipping start point. When the renderer reads a buffer with a
    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
    // read in the previous period. Renderer implementations may not allow this, so we signal a
    // discontinuity which resets the renderers before they read the clipping sample stream.
    pendingInitialDiscontinuity = startUs != 0;
    callback.onPrepared(this);
  }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
@Override
    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
      if (pendingDiscontinuity) {
        return C.RESULT_NOTHING_READ;
      }
      if (buffer == null) {
        return stream.readData(formatHolder, null);
      }
      if (sentEos) {
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        return C.RESULT_BUFFER_READ;
      }
      int result = stream.readData(formatHolder, buffer);
      // TODO: Clear gapless playback metadata if a format was read (if applicable).
      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
        buffer.clear();
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        sentEos = true;
        return C.RESULT_BUFFER_READ;
      }
      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
        buffer.timeUs -= startUs;
      }
      return result;
    }
=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_edae29d_0468a80/rev_edae29d-0468a80/library/src/main/java/com/google/android/exoplayer2/ui/SubtitlePainter.java;<<<<<<< MINE
    int parentWidth = parentRight - parentLeft;
    int parentHeight = parentBottom - parentTop;

    textPaint.setTextSize(textSizePx);
    int textPaddingX = (int) (textSizePx * INNER_PADDING_RATIO + 0.5f);

    int availableWidth = parentWidth - textPaddingX * 2;
    if (cueSize != Cue.DIMEN_UNSET) {
      availableWidth = (int) (availableWidth * cueSize);
    }
    if (availableWidth <= 0) {
      Log.w(TAG, "Skipped drawing subtitle cue (insufficient space)");
      return;
    }

    Alignment textAlignment = cueTextAlignment == null ? Alignment.ALIGN_CENTER : cueTextAlignment;
    textLayout = new StaticLayout(cueText, textPaint, availableWidth, textAlignment, spacingMult,
        spacingAdd, true);
    int textHeight = textLayout.getHeight();
    int textWidth = 0;
    int lineCount = textLayout.getLineCount();
    for (int i = 0; i < lineCount; i++) {
      textWidth = Math.max((int) Math.ceil(textLayout.getLineWidth(i)), textWidth);
    }
    if (cueSize != Cue.DIMEN_UNSET && textWidth < availableWidth) {
      textWidth = availableWidth;
    }
    textWidth += textPaddingX * 2;

    int textLeft;
    int textRight;
    if (cuePosition != Cue.DIMEN_UNSET) {
      int anchorPosition = Math.round(parentWidth * cuePosition) + parentLeft;
      textLeft = cuePositionAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textWidth
          : cuePositionAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textWidth) / 2
          : anchorPosition;
      textLeft = Math.max(textLeft, parentLeft);
      textRight = Math.min(textLeft + textWidth, parentRight);
    } else {
      textLeft = (parentWidth - textWidth) / 2;
      textRight = textLeft + textWidth;
    }

    int textTop;
    if (cueLine != Cue.DIMEN_UNSET) {
      int anchorPosition;
      if (cueLineType == Cue.LINE_TYPE_FRACTION) {
        anchorPosition = Math.round(parentHeight * cueLine) + parentTop;
      } else {
        // cueLineType == Cue.LINE_TYPE_NUMBER
        int firstLineHeight = textLayout.getLineBottom(0) - textLayout.getLineTop(0);
        if (cueLine >= 0) {
          anchorPosition = Math.round(cueLine * firstLineHeight) + parentTop;
        } else {
          anchorPosition = Math.round((cueLine + 1) * firstLineHeight) + parentBottom;
        }
      }
      textTop = cueLineAnchor == Cue.ANCHOR_TYPE_END ? anchorPosition - textHeight
          : cueLineAnchor == Cue.ANCHOR_TYPE_MIDDLE ? (anchorPosition * 2 - textHeight) / 2
          : anchorPosition;
      if (textTop + textHeight > parentBottom) {
        textTop = parentBottom - textHeight;
      } else if (textTop < parentTop) {
        textTop = parentTop;
      }
    } else {
      textTop = parentBottom - textHeight - (int) (parentHeight * bottomPaddingFraction);
    }

    textWidth = textRight - textLeft;

    // Update the derived drawing variables.
    this.textLayout = new StaticLayout(cueText, textPaint, textWidth, textAlignment, spacingMult,
        spacingAdd, true);
    this.textLeft = textLeft;
    this.textTop = textTop;
    this.textPaddingX = textPaddingX;
=======
    if (this.cueBitmap != null)
      setupBitmapLayout();
    else
      setupTextLayout();
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java;<<<<<<< MINE
=======
@Override
  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
    if (fatalError != null) {
      return;
    }

    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
    trackSelection.updateSelectedTrack(bufferedDurationUs);

    RepresentationHolder representationHolder =
        representationHolders[trackSelection.getSelectedIndex()];

    if (representationHolder.extractorWrapper != null) {
      Representation selectedRepresentation = representationHolder.representation;
      RangedUri pendingInitializationUri = null;
      RangedUri pendingIndexUri = null;
      if (representationHolder.extractorWrapper.getSampleFormats() == null) {
        pendingInitializationUri = selectedRepresentation.getInitializationUri();
      }
      if (representationHolder.segmentIndex == null) {
        pendingIndexUri = selectedRepresentation.getIndexUri();
      }
      if (pendingInitializationUri != null || pendingIndexUri != null) {
        // We have initialization and/or index requests to make.
        out.chunk = newInitializationChunk(representationHolder, dataSource,
            trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
            trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
        return;
      }
    }

    long nowUs = getNowUnixTimeUs();
    int availableSegmentCount = representationHolder.getSegmentCount();
    if (availableSegmentCount == 0) {
      // The index doesn't define any segments.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
    int lastAvailableSegmentNum;
    if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
      // The index is itself unbounded. We need to use the current time to calculate the range of
      // available segments.
      long liveEdgeTimeUs = nowUs - manifest.availabilityStartTime * 1000;
      long periodStartUs = manifest.getPeriod(periodIndex).startMs * 1000;
      long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
      if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
        long bufferDepthUs = manifest.timeShiftBufferDepth * 1000;
        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
            representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
      }
      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
      // index of the last completed segment.
      lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
    } else {
      lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
    }

    int segmentNum;
    if (previous == null) {
      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(playbackPositionUs),
          firstAvailableSegmentNum, lastAvailableSegmentNum);
    } else {
      segmentNum = previous.getNextChunkIndex();
      if (segmentNum < firstAvailableSegmentNum) {
        // This is before the first chunk in the current manifest.
        fatalError = new BehindLiveWindowException();
        return;
      }
    }

    if (segmentNum > lastAvailableSegmentNum
        || (missingLastSegment && segmentNum >= lastAvailableSegmentNum)) {
      // This is beyond the last chunk in the current manifest.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), segmentNum,
        maxSegmentCount);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
=======
protected void skipToKeyframeBefore(long timeUs) {
    stream.skipToKeyframeBefore(timeUs - streamOffsetUs);
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/hls/src/main/java/com/google/android/exoplayer2/source/hls/playlist/HlsMasterPlaylist.java;<<<<<<< MINE
=======
public HlsMasterPlaylist(String baseUri, List<HlsUrl> variants, List<HlsUrl> audios,
      List<HlsUrl> subtitles, Format muxedAudioFormat, List<Format> muxedCaptionFormats) {
    super(baseUri);
    this.variants = Collections.unmodifiableList(variants);
    this.audios = Collections.unmodifiableList(audios);
    this.subtitles = Collections.unmodifiableList(subtitles);
    this.muxedAudioFormat = muxedAudioFormat;
    this.muxedCaptionFormats = muxedCaptionFormats != null
        ? Collections.unmodifiableList(muxedCaptionFormats) : null;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;<<<<<<< MINE
private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }
=======
private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/ui/src/main/java/com/google/android/exoplayer2/ui/DefaultTimeBar.java;<<<<<<< MINE
=======
@Override
  public void setAdBreakTimesMs(@Nullable long[] adBreakTimesMs, int adBreakCount) {
    Assertions.checkArgument(adBreakCount == 0 || adBreakTimesMs != null);
    this.adBreakCount = adBreakCount;
    this.adBreakTimesMs = adBreakTimesMs;
    update();
  }
>>>>>>> YOURS
