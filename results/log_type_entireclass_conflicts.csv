/home/arthur/analysis/projects/glide/revisions/rev_42dde93_058ef77/rev_42dde93-058ef77/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
 * starting point and example.
 *
 * Note - This class is not thread safe.
=======
 * starting point and example.
 *
 * <p>
 * Note - This class is not thread safe.
 * </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/AckManager.java;<<<<<<< MINE
/**
 * Copyright 2012 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.corundumstudio.socketio;

import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

import com.corundumstudio.socketio.parser.Packet;
import com.corundumstudio.socketio.scheduler.CancelableScheduler;
import com.corundumstudio.socketio.scheduler.SchedulerKey;
import com.corundumstudio.socketio.scheduler.SchedulerKey.Type;
import com.corundumstudio.socketio.transport.BaseClient;
import com.corundumstudio.socketio.utils.ConcurrentHashSet;

public class AckManager implements Disconnectable {

    private final AtomicLong ackIndex = new AtomicLong();
    private final Map<Long, AckCallback> ackCallbacks = new ConcurrentHashMap<Long, AckCallback>();
    private final ConcurrentMap<UUID, Set<Long>> clientCallbackIds = new ConcurrentHashMap<UUID, Set<Long>>();

    private final CancelableScheduler scheduler;

    public AckManager(CancelableScheduler scheduler) {
        super();
        this.scheduler = scheduler;
    }

    public void onAck(SocketIOClient client, Packet packet) {
        SchedulerKey key = new SchedulerKey(Type.ACK_TIMEOUT, client.getSessionId());
        scheduler.cancel(key);
        AckCallback callback = removeCallback(client.getSessionId(), packet.getAckId());
        if (callback != null) {
            callback.onSuccess();
        }
    }

    private AckCallback removeCallback(UUID sessionId, long index) {
        AckCallback callback = ackCallbacks.remove(index);
        if (callback != null) {
            Set<Long> callbackIds = clientCallbackIds.get(sessionId);
            if (callbackIds != null) {
                callbackIds.remove(index);
            }
        }
        return callback;
    }

    public long registerAck(UUID sessionId, final AckCallback callback) {
        Set<Long> callbackIds = clientCallbackIds.get(sessionId);
        if (callbackIds == null) {
            callbackIds = new ConcurrentHashSet<Long>();
            Set<Long> oldCallbackIds = clientCallbackIds.putIfAbsent(sessionId, callbackIds);
            if (oldCallbackIds != null) {
                callbackIds = oldCallbackIds;
            }
        }
        long index = ackIndex.incrementAndGet();
        callbackIds.add(index);
        ackCallbacks.put(index, callback);

        scheduleTimeout(index, sessionId, callback);

        return index;
    }

    private void scheduleTimeout(final long index, final UUID sessionId, final AckCallback callback) {
        if (callback.getTimeout() == -1) {
            return;
        }
        SchedulerKey key = new SchedulerKey(Type.ACK_TIMEOUT, sessionId);
        scheduler.schedule(key, new Runnable() {
            @Override
            public void run() {
                removeCallback(sessionId, index);
                callback.onTimeout();
            }
        }, callback.getTimeout(), TimeUnit.SECONDS);
    }

    @Override
    public void onDisconnect(BaseClient client) {
        Set<Long> callbackIds = clientCallbackIds.remove(client.getSessionId());
        if (callbackIds != null) {
            ackCallbacks.keySet().removeAll(callbackIds);
        }
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/netty-socketio/revisions/rev_2e9b5ef_e797a71/rev_2e9b5ef-e797a71/src/main/java/com/corundumstudio/socketio/AuthorizeHandler.java;<<<<<<< MINE
/**
 * Copyright 2012 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.corundumstudio.socketio;

import static org.jboss.netty.handler.codec.http.HttpVersion.HTTP_1_1;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelFutureListener;
import org.jboss.netty.channel.ChannelHandler.Sharable;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
import org.jboss.netty.handler.codec.http.DefaultHttpResponse;
import org.jboss.netty.handler.codec.http.HttpHeaders;
import org.jboss.netty.handler.codec.http.HttpRequest;
import org.jboss.netty.handler.codec.http.HttpResponse;
import org.jboss.netty.handler.codec.http.HttpResponseStatus;
import org.jboss.netty.handler.codec.http.QueryStringDecoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.corundumstudio.socketio.messages.AuthorizeMessage;
import com.corundumstudio.socketio.namespace.Namespace;
import com.corundumstudio.socketio.namespace.NamespacesHub;
import com.corundumstudio.socketio.parser.Packet;
import com.corundumstudio.socketio.parser.PacketType;
import com.corundumstudio.socketio.scheduler.CancelableScheduler;
import com.corundumstudio.socketio.scheduler.SchedulerKey;
import com.corundumstudio.socketio.scheduler.SchedulerKey.Type;
import com.corundumstudio.socketio.transport.BaseClient;
import com.corundumstudio.socketio.utils.ConcurrentHashSet;

@Sharable
public class AuthorizeHandler extends SimpleChannelUpstreamHandler implements Disconnectable {

    private final Logger log = LoggerFactory.getLogger(getClass());

    private final CancelableScheduler disconnectScheduler;
    private final Set<UUID> authorizedSessionIds = new ConcurrentHashSet<UUID>();

    private final String connectPath;
    private final Configuration configuration;
    private final NamespacesHub namespacesHub;

    public AuthorizeHandler(String connectPath, CancelableScheduler scheduler, Configuration configuration, NamespacesHub namespacesHub) {
        super();
        this.connectPath = connectPath;
        this.configuration = configuration;
        this.disconnectScheduler = scheduler;
        this.namespacesHub = namespacesHub;
    }

    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception {
        Object msg = e.getMessage();
        if (msg instanceof HttpRequest) {
            HttpRequest req = (HttpRequest) msg;
            Channel channel = ctx.getChannel();
            QueryStringDecoder queryDecoder = new QueryStringDecoder(req.getUri());
            if (!configuration.isAllowCustomRequests()
                    && !queryDecoder.getPath().startsWith(connectPath)) {
                HttpResponse res = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.BAD_REQUEST);
                ChannelFuture f = channel.write(res);
                f.addListener(ChannelFutureListener.CLOSE);
                return;
            }
            if (queryDecoder.getPath().equals(connectPath)) {
                authorize(channel, req, queryDecoder.getParameters());
                return;
            }
        }
        ctx.sendUpstream(e);
    }

    private void authorize(Channel channel, HttpRequest req, Map<String, List<String>> params)
            throws IOException {
        final UUID sessionId = UUID.randomUUID();
        authorizedSessionIds.add(sessionId);

        scheduleDisconnect(channel, sessionId);

        String transports = "websocket,xhr-polling";
        String heartbeatTimeoutVal = String.valueOf(configuration.getHeartbeatTimeout());
        if (!configuration.isHeartbeatsEnabled()) {
            heartbeatTimeoutVal = "";
        }

        String msg = sessionId + ":" + heartbeatTimeoutVal + ":" + configuration.getCloseTimeout() + ":" + transports;

        List<String> jsonpParams = params.get("jsonp");
        String jsonpParam = null;
        if (jsonpParams != null) {
            jsonpParam = jsonpParams.get(0);
        }
        String origin = req.getHeader(HttpHeaders.Names.ORIGIN);
        channel.write(new AuthorizeMessage(msg, jsonpParam, origin, sessionId));
        log.debug("New sessionId: {} authorized", sessionId);
    }

    private void scheduleDisconnect(Channel channel, final UUID sessionId) {
        ChannelFuture future = channel.getCloseFuture();
        future.addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                SchedulerKey key = new SchedulerKey(Type.AUTHORIZE, sessionId);
                disconnectScheduler.schedule(key, new Runnable() {
                    @Override
                    public void run() {
                        authorizedSessionIds.remove(sessionId);
                        log.debug("Authorized sessionId: {} removed due to connection timeout", sessionId);
                    }
                }, configuration.getCloseTimeout(), TimeUnit.SECONDS);
            }
        });
    }

    public boolean isSessionAuthorized(UUID sessionId) {
        return authorizedSessionIds.contains(sessionId);
    }

    public void connect(BaseClient client) {
        SchedulerKey key = new SchedulerKey(Type.AUTHORIZE, client.getSessionId());
        disconnectScheduler.cancel(key);
        client.send(new Packet(PacketType.CONNECT));

        Namespace ns = namespacesHub.get(Namespace.DEFAULT_NAME);
        SocketIOClient nsClient = client.getChildClient(ns);
        namespacesHub.get(ns.getName()).onConnect(nsClient);
    }

    @Override
    public void onDisconnect(BaseClient client) {
        authorizedSessionIds.remove(client.getSessionId());
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
public class ImageViewTarget extends ViewTarget<ImageView> {
    private final ImageView view;

    public ImageViewTarget(ImageView view) {
        super(view);
        this.view = view;
=======
public class ImageViewTarget implements Target {
    private static final String TAG = "ImageViewTarget";
    private final ImageView imageView;
    private final SizeDeterminer sizeDeterminer;
    private ImagePresenter imagePresenter;

    public ImageViewTarget(ImageView imageView) {
        this.imageView = imageView;
        this.sizeDeterminer = new SizeDeterminer(imageView);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_347118b_a55e201/rev_347118b-a55e201/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
=======
/*
 * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
 */
package com.bumptech.glide.resize.load;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.media.ExifInterface;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.resize.RecyclableBufferedInputStream;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;

import java.io.InputStream;
import java.util.LinkedList;
import java.util.Queue;

/**
 * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
 */
public class ImageResizer {
    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;

    private static final String TAG = "ImageResizer";
    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
    private final BitmapPool bitmapPool;

    private final BitmapFactory.Options defaultOptions;

    @TargetApi(11)
    public static BitmapFactory.Options getDefaultOptions() {
       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
       decodeBitmapOptions.inDither = false;
       decodeBitmapOptions.inScaled = false;
       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
       decodeBitmapOptions.inSampleSize = 1;
       if (CAN_RECYCLE)  {
           decodeBitmapOptions.inMutable = true;
       }
       return decodeBitmapOptions;
    }

    /**
     * Creates a new resizer that will not recycle Bitmaps
     */
    @SuppressWarnings("unused")
    public ImageResizer() {
        this(null, null);
    }

    @SuppressWarnings("unused")
    public ImageResizer(BitmapPool bitmapPool) {
        this(bitmapPool, null);
    }

    @SuppressWarnings("unused")
    @Deprecated
    public ImageResizer(BitmapFactory.Options options) {
        this(null, options);
    }

    /**
     * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
     *
     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
     */
    @Deprecated
    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
        if (bitmapPool == null) {
            this.bitmapPool = new BitmapPoolAdapter();
        } else {
            this.bitmapPool = bitmapPool;
        }

        if (defaultOptions == null) {
            this.defaultOptions = getDefaultOptions();
        } else {
            this.defaultOptions = defaultOptions;
        }
    }

    public Bitmap load(InputStream is) {
        return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight) {
        return load(is, outWidth, outHeight, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
        return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler) {
        return load(is, outWidth, outHeight, downsampler, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
        byte[] tempBytesForBis = getTempBytes();
        byte[] tempBytesForOptions = getTempBytes();

        BitmapFactory.Options options = getOptions();
        options.inTempStorage = tempBytesForOptions;

        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);

        final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
        final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);

        if (initial != result && !bitmapPool.put(initial)) {
            initial.recycle();
        }

        releaseTempBytes(tempBytesForBis);
        releaseTempBytes(tempBytesForOptions);

        return result;
    }

    private BitmapFactory.Options getOptions() {
        BitmapFactory.Options result = new BitmapFactory.Options();
        copyOptions(defaultOptions, result);
        return result;
    }

    private byte[] getTempBytes() {
        byte[] result;
        synchronized (tempQueue) {
            result = tempQueue.poll();
        }
        if (result == null) {
            result = new byte[TEMP_BYTES_SIZE];
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Created temp bytes");
            }
        }
        return result;
    }

    private void releaseTempBytes(byte[] bytes) {
        synchronized (tempQueue) {
            tempQueue.offer(bytes);
        }
    }

    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
        if (Build.VERSION.SDK_INT >= 11) {
            copyOptionsHoneycomb(from, to);
        } else if (Build.VERSION.SDK_INT >= 10) {
            copyOptionsGingerbreadMr1(from, to);
        } else {
            copyOptionsFroyo(from, to);
        }
    }

    @TargetApi(11)
    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsGingerbreadMr1(from, to);
        to.inMutable = from.inMutable;
    }

    @TargetApi(10)
    private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsFroyo(from, to);
        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
    }

    private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
        to.inDensity = from.inDensity;
        to.inDither = from.inDither;
        to.inInputShareable = from.inInputShareable;
        to.inPreferredConfig = from.inPreferredConfig;
        to.inPurgeable = from.inPurgeable;
        to.inSampleSize = from.inSampleSize;
        to.inScaled = from.inScaled;
        to.inScreenDensity = from.inScreenDensity;
        to.inTargetDensity = from.inTargetDensity;
    }

    /**
     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
     * as well.
     *
     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
     *                 into
     * @param toCrop The Bitmap to resize
     * @param width The width of the final Bitmap
     * @param height The height of the final Bitmap
     * @return The resized Bitmap (will be recycled if recycled is not null)
     */
    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
        if (toCrop == null) {
            return null;
        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
            return toCrop;
        }
        //from ImageView/Bitmap.createScaledBitmap
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
        final float scale;
        float dx = 0, dy = 0;
        Matrix m = new Matrix();
        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
            scale = (float) height / (float) toCrop.getHeight();
            dx = (width - toCrop.getWidth() * scale) * 0.5f;
        } else {
            scale = (float) width / (float) toCrop.getWidth();
            dy = (height - toCrop.getHeight() * scale) * 0.5f;
        }

        m.setScale(scale, scale);
        m.postTranslate((int) dx + 0.5f, (int) dy + 0.5f);
        final Bitmap result;
        if (recycled != null) {
            result = recycled;
        } else {
            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
        }
        Canvas canvas = new Canvas(result);
        Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toCrop, m, paint);
        return result;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its width
     * matches the given width
     *
     * @param toShrink The Bitmap to shrink
     * @param width The width of the final Bitmap
     * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
     */
    public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
        Bitmap shrunk = toShrink;
        float widthPercent = ((float) width/toShrink.getWidth());
        if (widthPercent != 1) {
            int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
            shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its height
     * matches the given height
     *
     * @param toShrink The Bitmap to shrink
     * @param height The height of the final Bitmap
     * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
     *          height
     */
    public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
        Bitmap shrunk = toShrink;
        float heightPercent = ((float) height/toShrink.getHeight());
        if (heightPercent != 1) {
            int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
            shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
     * the original proportions
     *
     * @param toFit The Bitmap to shrink
     * @param width The width the final image will fit within
     * @param height The height the final image will fit within
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    @Deprecated
    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
        if (toFit == null) return null;

        if (height > width){
            return shrinkToWidth(toFit, width);
        } else {
            return shrinkToHeight(toFit, height);
        }
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain
     * the original proportions.
     *
     * @param toFit The Bitmap to shrink.
     * @param pool The BitmapPool to try to reuse a bitmap from.
     * @param width The width the final image will fit within.
     * @param height The height the final image will fit within.
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
         final float shrinkPercentage;
        final int targetWidth;
        final int targetHeight;
        if (height > width) {
            shrinkPercentage = width / (float) toFit.getWidth();
            targetWidth = width;
            targetHeight = Math.round(shrinkPercentage * toFit.getHeight());
        } else {
            shrinkPercentage = height / (float) toFit.getHeight();
            targetWidth = Math.round(shrinkPercentage * toFit.getWidth());
            targetHeight = height;
        }

        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
        if (toReuse == null) {
            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
        }
        Canvas canvas = new Canvas(toReuse);
        Matrix matrix = new Matrix();
        matrix.setScale(shrinkPercentage, shrinkPercentage);
        Paint paint = new Paint(ImageResizer.PAINT_FLAGS);
        canvas.drawBitmap(toFit, matrix, paint);

        return toReuse;
    }


    /**
     * Returns a matrix with rotation set based on Exif orientation tag.
     * If the orientation is undefined or 0 null is returned.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @return  A rotation in degrees based on exif orientation
     */
    public static int getOrientation(String pathToOriginal) {
        int degreesToRotate = 0;
        try{
            ExifInterface exif = new ExifInterface(pathToOriginal);
            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
                degreesToRotate = 90;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
                degreesToRotate = 180;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
                degreesToRotate = 270;
            }
        } catch (Exception e){
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
            }
        }
        return degreesToRotate;
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @param imageToOrient Image Bitmap to orient.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    @SuppressWarnings("unused")
    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
        int degreesToRotate = getOrientation(pathToOriginal);
        return rotateImage(imageToOrient, degreesToRotate);
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param imageToOrient Image Bitmap to orient.
     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
        try{
            if(degreesToRotate != 0) {
                Matrix matrix = new Matrix();
                matrix.setRotate(degreesToRotate);
                imageToOrient = Bitmap.createBitmap(
                        imageToOrient,
                        0,
                        0,
                        imageToOrient.getWidth(),
                        imageToOrient.getHeight(),
                        matrix,
                        true);
            }
        } catch (Exception e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception when trying to orient image", e);
            }
            e.printStackTrace();
        }
        return imageToOrient;
    }

    /**
     * Get the # of degrees an image must be rotated to match the given exif orientation.
     *
     * @param exifOrientation The exif orientation [1-8]
     * @return the number of degrees to rotate
     */
    public static int getExifOrientationDegrees(int exifOrientation) {
        final int degreesToRotate;
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_TRANSPOSE:
            case ExifInterface.ORIENTATION_ROTATE_90:
                degreesToRotate = 90;
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                degreesToRotate = 180;
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
            case ExifInterface.ORIENTATION_ROTATE_270:
                degreesToRotate = 270;
                break;
            default:
                degreesToRotate = 0;

        }
        return degreesToRotate;
    }

    /**
     * Rotate and/or flip the image to match the given exif orientation
     *
     * @param toOrient The bitmap to rotate/flip
     * @param pool A pool that may or may not contain an image of the necessary dimensions
     * @param exifOrientation the exif orientation [1-8]
     * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary
     */
    public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
        final Matrix matrix = new Matrix();
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                matrix.setScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
                matrix.setRotate(180);
                break;
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                matrix.setRotate(180);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_TRANSPOSE:
                matrix.setRotate(90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_90:
                matrix.setRotate(90);
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
                matrix.setRotate(-90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_270:
                matrix.setRotate(-90);
                break;
            default: //case ExifInterface.ORIENTATION_NORMAL
                return toOrient;
        }

        // From Bitmap.createBitmap.
        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
        matrix.mapRect(newRect);

        final int newWidth = Math.round(newRect.width());
        final int newHeight = Math.round(newRect.height());

        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
        if (result == null) {
            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
        }

        matrix.postTranslate(-newRect.left, -newRect.top);

        final Canvas canvas = new Canvas(result);
        final Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toOrient, matrix, paint);

        return result;
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/FileLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.io.File;

/**
 * A simple model loader for {@link File}
 */
public class FileLoader implements ModelLoader<File> {

    public static class Factory implements ModelLoaderFactory<File> {
        @Override
        public ModelLoader<File> build(Context context, GenericLoaderFactory factories) {
            return new FileLoader(factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<File>> loaderClass() {
            return FileLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;

    public FileLoader(Context context) {
        this(Glide.buildModelLoader(Uri.class, context));
    }

    public FileLoader(ModelLoader<Uri> uriLoader) {
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(File model, int width, int height) {
        return uriLoader.getStreamLoader(Uri.fromFile(model), width, height);
    }

    @Override
    public String getId(File model) {
        //canonical is better, but also slower
        return model.getAbsolutePath();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/StringLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.io.File;

/**
 * A model loader for handling certain string models. Handles paths, urls, and any uri string with a scheme handled by
 * {@link android.content.ContentResolver#openInputStream(android.net.Uri)}.
 */
public class StringLoader implements ModelLoader<String> {

    public static class Factory implements ModelLoaderFactory<String> {

        @Override
        public ModelLoader<String> build(Context context, GenericLoaderFactory factories) {
            return new StringLoader(factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<String>> loaderClass() {
            return StringLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;

    public StringLoader(Context context) {
        this(Glide.buildModelLoader(Uri.class, context));
    }

    public StringLoader(ModelLoader<Uri> uriLoader) {
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(final String model, final int width, final int height) {
        Uri uri = Uri.parse(model);

        final String scheme = uri.getScheme();
        if (scheme == null) {
            uri = Uri.fromFile(new File(model));
        }

        return uriLoader.getStreamLoader(uri, width, height);
    }

    @Override
    public String getId(String model) {
        return model;
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/UriLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.ContentResolver;
import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.LocalUriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.net.MalformedURLException;
import java.net.URL;

/**
 * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
 * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
 */
public class UriLoader implements ModelLoader<Uri> {
    public static class Factory implements ModelLoaderFactory<Uri> {

        @Override
        public ModelLoader<Uri> build(Context context, GenericLoaderFactory factories) {
            return new UriLoader(context, factories.buildModelLoader(URL.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Uri>> loaderClass() {
            return UriLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final Context context;
    private final ModelLoader<URL> urlLoader;

    public UriLoader(Context context) {
        this(context, Glide.buildModelLoader(URL.class, context));
    }

    public UriLoader(Context context, ModelLoader<URL> urlLoader) {
        this.context = context;
        this.urlLoader = urlLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Uri model, int width, int height) {
        final String scheme = model.getScheme();

        StreamLoader result = null;
        if (isLocalUri(scheme)) {
            result = new LocalUriLoader(context, model);
        } else if ("http".equals(scheme) || "https".equals(scheme)) {
            try {
                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        if (result == null) {
            throw new IllegalArgumentException("No stream loader for uri=" + model);
        }

        return result;
    }

    @Override
    public String getId(Uri model) {
        return model.toString();
    }

    private boolean isLocalUri(String scheme) {
        return ContentResolver.SCHEME_FILE.equals(scheme)
                || ContentResolver.SCHEME_CONTENT.equals(scheme)
                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_809f3b3_0b2cafb/rev_809f3b3-0b2cafb/library/src/com/bumptech/glide/loader/model/ResourceLoader.java;<<<<<<< MINE
=======
package com.bumptech.glide.loader.model;

import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.StreamLoader;

/**
 * A model loader for handling resources. Model must be a resource id in the package of
 * the given context.
 */
public class ResourceLoader implements ModelLoader<Integer> {

    public static class Factory implements ModelLoaderFactory<Integer> {

        @Override
        public ModelLoader<Integer> build(Context context, GenericLoaderFactory factories) {
            return new ResourceLoader(context, factories.buildModelLoader(Uri.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Integer>> loaderClass() {
            return ResourceLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final ModelLoader<Uri> uriLoader;
    private final Context context;

    public ResourceLoader(Context context) {
        this(context, Glide.buildModelLoader(Uri.class, context));
    }

    public ResourceLoader(Context context, ModelLoader<Uri> uriLoader) {
        this.context = context;
        this.uriLoader = uriLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Integer model, int width, int height) {
        Uri uri = Uri.parse("android.resource://" + context.getPackageName() + "/" + model.toString());
        return uriLoader.getStreamLoader(uri, width, height);
    }

    @Override
    public String getId(Integer model) {
        return model.toString();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java;<<<<<<< MINE
package com.bumptech.glide.samples.flickr;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import android.os.Bundle;
import android.os.StrictMode;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.support.v4.app.FragmentTransaction;
import android.support.v4.view.ViewPager;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.actionbarsherlock.app.ActionBar;
import com.actionbarsherlock.app.SherlockFragmentActivity;
import com.bumptech.glide.Glide;
import com.bumptech.glide.samples.flickr.api.Api;
import com.bumptech.glide.samples.flickr.api.Photo;

public class FlickrSearchActivity extends SherlockFragmentActivity {
    
    private static final String TAG = "FlickrSearchActivity";

    private int searchCount = 0;
    private EditText searchText;
    private View searching;
    private TextView searchTerm;
    private Set<PhotoViewer> photoViewers = new HashSet<PhotoViewer>();
    private List<Photo> currentPhotos = new ArrayList<Photo>();
    private View searchLoading;

    private enum Page {
        SMALL,
        MEDIUM,
        LIST
    }

    private static final Map<Page, Integer> PAGE_TO_TITLE = new HashMap<Page, Integer>() {{
        put(Page.SMALL, R.string.small);
        put(Page.MEDIUM, R.string.medium);
        put(Page.LIST, R.string.list);
    }};

    @Override
    public void onAttachFragment(Fragment fragment) {
        super.onAttachFragment(fragment);
        if (!(fragment instanceof PhotoViewer)) {
            throw new IllegalStateException("Fragment class " + fragment.getClass() +
                    " does not implement PhotoViewer");
        } else {
            PhotoViewer photoViewer = (PhotoViewer) fragment;
            photoViewer.onPhotosUpdated(currentPhotos);
            if (!photoViewers.contains(photoViewer)) {
                photoViewers.add(photoViewer);
            }
        }
    }

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.flickr_search_activity);
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                .detectAll()
                .penaltyLog()
                .build());

        searching = findViewById(R.id.searching);
        searchLoading = findViewById(R.id.search_loading);
        searchTerm = (TextView) findViewById(R.id.search_term);

        searchText = (EditText) findViewById(R.id.search_text);
        searchText.setOnEditorActionListener(new TextView.OnEditorActionListener() {
            @Override
            public boolean onEditorAction(TextView textView, int actionId, KeyEvent keyEvent) {
                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
                    executeSearch();
                    return true;
                }
                return false;
            }
        });

        final Button search = (Button) findViewById(R.id.search);
        search.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                executeSearch();
            }
        });

        ViewPager pager = (ViewPager) findViewById(R.id.view_pager);
        pager.setPageMargin(50);
        pager.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
            @Override
            public void onPageScrolled(int i, float v, int i2) { }

            @Override
            public void onPageSelected(int position) {
                getSupportActionBar().getTabAt(position).select();
            }

            @Override
            public void onPageScrollStateChanged(int i) { }
        });


        final ActionBar actionBar = getSupportActionBar();
        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);

        for (Page page : Page.values()) {
            final int textId = PAGE_TO_TITLE.get(page);
            actionBar.addTab(actionBar.newTab().setText(textId).setTabListener(new TabListener(pager)));
        }

        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager()));
    }

    @Override
    public void onTrimMemory(int level) {
        super.onTrimMemory(level);
        Glide.get().getImageManager(this).trimMemory(level);
    }

    @Override
    public void onLowMemory() {
        super.onLowMemory();
        Glide.get().getImageManager(this).clearMemory();
    }

    private void executeSearch() {
        final String searchString = searchText.getText().toString();
        searchText.getText().clear();

        if ("".equals(searchString.trim())) return;

        final int currentSearch = ++searchCount;

        searching.setVisibility(View.VISIBLE);
        searchLoading.setVisibility(View.VISIBLE);
        searchTerm.setText(getString(R.string.searching_for, searchString));

        Api.get(getApplicationContext()).search(searchString, new Api.SearchCallback() {
            @Override
            public void onSearchCompleted(List<Photo> photos) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Search completed, got " + photos.size() + " results");
                }
                searching.setVisibility(View.INVISIBLE);

                for (PhotoViewer viewer : photoViewers) {
                    viewer.onPhotosUpdated(photos);
                }

                currentPhotos = photos;
            }

            @Override
            public void onSearchFailed(Exception e) {
                if (currentSearch != searchCount) return;

                if (Log.isLoggable(TAG, Log.ERROR)) {
                    Log.e(TAG, "Search failed", e);
                }
                searching.setVisibility(View.VISIBLE);
                searchLoading.setVisibility(View.INVISIBLE);
                searchTerm.setText(getString(R.string.search_failed, searchString));
            }
        });
    }

    private static class TabListener implements ActionBar.TabListener {
        private final ViewPager pager;

        public TabListener(ViewPager pager) {
            this.pager = pager;
        }

        @Override
        public void onTabSelected(ActionBar.Tab tab, FragmentTransaction ft) {
            pager.setCurrentItem(tab.getPosition());
        }

        @Override
        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }

        @Override
        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }
    }

    private class FlickrPagerAdapter extends FragmentPagerAdapter {

        public FlickrPagerAdapter(FragmentManager fm) {
            super(fm);
        }

        @Override
        public Fragment getItem(int position) {
            return pageToFragment(position);
        }

        @Override
        public int getCount() {
            return Page.values().length;
        }

        private Fragment pageToFragment(int position) {
            Page page = Page.values()[position];
            if (page == Page.SMALL) {
                int pageSize = getPageSize(R.dimen.small_photo_side);
                return FlickrPhotoGrid.newInstance(pageSize, 30);
            } else if (page == Page.MEDIUM) {
                int pageSize = getPageSize(R.dimen.medium_photo_side);
                return FlickrPhotoGrid.newInstance(pageSize, 10);
            } else if (page == Page.LIST) {
                return FlickrPhotoList.newInstance();
            } else {
                throw new IllegalArgumentException("No fragment class for page=" + page);
            }
        }

        private int getPageSize(int id) {
            return getResources().getDimensionPixelSize(id);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/samples/flickr/src/com/bumptech/glide/samples/flickr/api/Api.java;<<<<<<< MINE
package com.bumptech.glide.samples.flickr.api;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.Context;
import android.os.Build;
import android.util.Log;

import com.android.volley.DefaultRetryPolicy;
import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.Response;
import com.android.volley.VolleyError;
import com.android.volley.toolbox.StringRequest;
import com.android.volley.toolbox.Volley;
import com.bumptech.glide.Glide;
import com.bumptech.glide.resize.ImageManager;
import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
import com.bumptech.glide.resize.cache.DiskCache;
import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
import com.bumptech.glide.resize.cache.LruMemoryCache;
import com.bumptech.glide.volley.VolleyUrlLoader;

public class Api {
    private static Api API;
    private static final String TAG = "FlickrApi";
    private static final String API_KEY = "f0e6fbb5fdf1f3842294a1d21f84e8a6";
    private static final String SIGNED_API_URL = "https://api.flickr.com/services/rest/?method=%s&format=json&api_key="
            + API_KEY;
    //incomplete size independent url for photos that can be cached per photo
    private static final String CACHEABLE_PHOTO_URL = "http://farm%s.staticflickr.com/%s/%s_%s_";

    private static final Map<Integer, String> EDGE_TO_SIZE_KEY = new HashMap<Integer, String>() {{
        put(75, "s");
        put(100, "t");
        put(150, "q");
        put(240, "m");
        put(320, "n");
        put(640, "z");
        put(1024, "b");
    }};
    private static final List<Integer> SORTED_SIZE_KEYS = new ArrayList<Integer>(EDGE_TO_SIZE_KEY.size());
    static {
        SORTED_SIZE_KEYS.addAll(EDGE_TO_SIZE_KEY.keySet());
        Collections.sort(SORTED_SIZE_KEYS);
    }

    private final RequestQueue requestQueue;
    private final Context context;
    private static final String CACHE_NAME = "flickr_cache";

    private static String getSizeKey(int width, int height) {
        final int largestEdge = Math.max(width, height);

        String result = EDGE_TO_SIZE_KEY.get(SORTED_SIZE_KEYS.get(SORTED_SIZE_KEYS.size() - 1));
        for (int edge : SORTED_SIZE_KEYS) {
            if (largestEdge <= edge) {
                result = EDGE_TO_SIZE_KEY.get(edge);
                break;
            }
        }
        return result;
    }

    public interface SearchCallback {
        public void onSearchCompleted(List<Photo> photos);
        public void onSearchFailed(Exception e);
    }

    public static Api get(Context context) {
        if (API == null) {
            API = new Api(context);
        }
        return API;
    }

    protected Api(Context context) {
        this.context = context;
        requestQueue = Volley.newRequestQueue(context);

        final Glide glide = Glide.get();
        if (!glide.isImageManagerSet()) {
            File cacheDir = ImageManager.getPhotoCacheDir(context, CACHE_NAME);

            DiskCache diskCache = DiskLruCacheWrapper.get(cacheDir, 50 * 1024 * 1024);

            // When we can recycle bitmaps, the smaller our cache is, the more quickly our scrolling will become smooth
            // so prefer large bitmap pool and a small cache.
            final int safeMemCacheSize = ImageManager.getSafeMemoryCacheSize(context);
            glide.setImageManager(new ImageManager.Builder(context)
                    .setBitmapCompressQuality(70)
                    .setMemoryCache(new LruMemoryCache(
                            Build.VERSION.SDK_INT >= 11 ? safeMemCacheSize / 2 : safeMemCacheSize))
                    .setBitmapPool(new LruBitmapPool(
                            Build.VERSION.SDK_INT >= 11 ? Math.round(safeMemCacheSize * 1.5f) : safeMemCacheSize))
                    .setDiskCache(diskCache));
        }
        glide.register(URL.class, new VolleyUrlLoader.Factory(requestQueue));

    }

    public static String getPhotoURL(Photo photo, int width, int height) {
        return getPhotoUrl(photo, getSizeKey(width, height));
    }

    public static String getCacheableUrl(Photo photo) {
        return String.format(CACHEABLE_PHOTO_URL, photo.farm, photo.server, photo.id, photo.secret);
    }

    private static String getUrlForMethod(String method) {
        return String.format(SIGNED_API_URL, method);
    }

    private static String getSearchUrl(String text) {
        return getUrlForMethod("flickr.photos.search") + "&text=" + text + "&per_page=300";
    }

    private static String getPhotoUrl(Photo photo, String sizeKey) {
        return photo.getPartialUrl() + sizeKey + ".jpg";
    }

    public void search(String text, final SearchCallback cb) {
        StringRequest request = new StringRequest(Request.Method.GET, getSearchUrl(text),
                new Response.Listener<String>() {
            @Override
            public void onResponse(String response) {
                try {
                    //cut out initial flickJsonApi(
                    JSONObject searchResults = new JSONObject(response.substring(14, response.length() - 1));
                    JSONArray photos = searchResults.getJSONObject("photos").getJSONArray("photo");
                    List<Photo> results = new ArrayList<Photo>(photos.length());
                    for (int i = 0; i < photos.length(); i++) {
                        results.add(new Photo(photos.getJSONObject(i)));
                    }
                    cb.onSearchCompleted(results);
                } catch (JSONException e) {
                    cb.onSearchFailed(e);
                    if (Log.isLoggable(TAG, Log.ERROR)) {
                        Log.e(TAG, "Search failed response=" + response, e);
                    }
                }
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                cb.onSearchFailed(error);
            }
        });
        request.setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 3,
                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
        requestQueue.add(request);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/Glide.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.net.Uri;
import android.util.Log;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.ImageView;
import com.bumptech.glide.loader.image.ImageLoader;
import com.bumptech.glide.loader.image.ImageManagerLoader;
import com.bumptech.glide.loader.model.FileLoader;
import com.bumptech.glide.loader.model.GenericLoaderFactory;
import com.bumptech.glide.loader.model.ModelLoader;
import com.bumptech.glide.loader.model.ModelLoaderFactory;
import com.bumptech.glide.loader.model.ResourceLoader;
import com.bumptech.glide.loader.model.StringLoader;
import com.bumptech.glide.loader.model.UriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;
import com.bumptech.glide.loader.transformation.CenterCrop;
import com.bumptech.glide.loader.transformation.FitCenter;
import com.bumptech.glide.loader.transformation.MultiTransformationLoader;
import com.bumptech.glide.loader.transformation.None;
import com.bumptech.glide.loader.transformation.TransformationLoader;
import com.bumptech.glide.presenter.ImagePresenter;
import com.bumptech.glide.presenter.target.ImageViewTarget;
import com.bumptech.glide.presenter.target.Target;

import com.bumptech.glide.resize.ImageManager;
import com.bumptech.glide.resize.load.Downsampler;
import com.bumptech.glide.resize.load.Transformation;
import com.bumptech.glide.volley.VolleyUrlLoader;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.Map;
import java.util.WeakHashMap;

/**
 * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an
 * {@link ImageLoader} and {@link ModelLoaderFactory}s. This class provides most of the functionality of
 * {@link ImagePresenter} with a simpler but less efficient interface. For more complicated cases it may be worth
 * considering using {@link ImagePresenter} and {@link com.bumptech.glide.presenter.ImagePresenter.Builder} directly.
 *
 * <p>
 * Note - This class is not thread safe.
 * </p>
 */
public class Glide {
    private static final String TAG = "Glide";
    private static final Glide GLIDE = new Glide();
    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();
    private final GenericLoaderFactory loaderFactory = new GenericLoaderFactory();

    private ImageManager imageManager = null;

    /**
     * A class for monitoring the status of a request while images load.
     *
     * @param <T> The type of the model being loaded
     */
    public interface RequestListener<T> {

        /**
         * Called when an exception occurs during a load. Will only be called if we currently want to display an image
         * for the given model in the given target. It is recommended to create a single instance per activity/fragment
         * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn.
         *
         * <p>
         *     It is safe to reload this or a different model or change what is displayed in the target at this point.
         *     For example:
         * <pre>
         * <code>
         *     public void onException(Exception e, T model, Target target) {
         *         target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);
         *         Glide.load(model).into(target);
         *     }
         * </code>
         * </pre>
         * </p>
         *
         * <p>
         *     Note - if you want to reload this or any other model after an exception, you will need to include all
         *     relevant builder calls (like centerCrop, placeholder etc).
         * </p>
         *
         * @param e The exception, or null
         * @param model The model we were trying to load when the exception occurred
         * @param target The {@link Target} we were trying to load the image into
         */
        public abstract void onException(Exception e, T model, Target target);

        /**
         * Called when a load completes successfully, immediately after
         * {@link Target#onImageReady(android.graphics.Bitmap)}.
         *
         * @param model The specific model that was used to load the image.
         * @param target The target the model was loaded into.
         */
        public abstract void onImageReady(T model, Target target);
    }

    /**
     * Get the singleton.
     *
     * @return the singleton
     */
    public static Glide get() {
        return GLIDE;
    }

    protected Glide() {
        loaderFactory.register(File.class, new FileLoader.Factory());
        loaderFactory.register(Integer.class, new ResourceLoader.Factory());
        loaderFactory.register(String.class, new StringLoader.Factory());
        loaderFactory.register(Uri.class, new UriLoader.Factory());
        try {
            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");
            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());
        } catch (ClassNotFoundException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Volley not found, missing url loader");
            }
            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {
                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {
                    @Override
                    public StreamLoader getStreamLoader(URL model, int width, int height) {
                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");
                    }

                    @Override
                    public String getId(URL model) {
                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");
                    }
                };

                @Override
                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {
                    return errorUrlLoader;
                }

                @Override @SuppressWarnings("unchecked")
                public Class<? extends ModelLoader<URL>> loaderClass() {
                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();
                }

                @Override
                public void teardown() {
                }
            });
        }
    }

    /**
     * Return the current {@link ImageManager} or create and return a new one if one is not currently set.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)
     * @see #isImageManagerSet()
     *
     * @param context Any {@link Context}. This will not be retained passed this call
     * @return The current ImageManager
     */
    public ImageManager getImageManager(Context context) {
        if (!isImageManagerSet()) {
            setImageManager(new ImageManager.Builder(context));
        }
        return imageManager;
    }

    /**
     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in
     * {@link android.app.Activity#onCreate(android.os.Bundle) Activity.onCreate} along with
     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder) setImageManager} to set an
     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an
     * easily accessible singleton.
     *
     * @return true iff an {@link ImageManager} is currently set
     */
    public boolean isImageManagerSet() {
        return imageManager != null;
    }

    /**
     * Set the {@link ImageManager} to use with {@link Glide.Request}.
     *
     * @see #setImageManager(com.bumptech.glide.resize.ImageManager)
     *
     * @param builder The builder that will be used to construct a new ImageManager
     */
    public void setImageManager(ImageManager.Builder builder) {
        setImageManager(builder.build());
    }

    /**
     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current
     * {@link ImageManager} if one has already been set.
     *
     * @see #isImageManagerSet()
     *
     * @param imageManager The ImageManager to use
     */
    public void setImageManager(ImageManager imageManager) {
        this.imageManager = imageManager;
    }

    /**
     * Use the given factory to build a {@link ModelLoader} for models of the given class. Generally the best use of
     * this method is to replace one of the default factories or add an implementation for other similar low level
     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred
     * because it directly links the model with the ModelLoader being used to load it.
     *
     * <p>
     *     Note - If a factory already exists for the given class, it will be replaced. If that factory is not being
     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}
     *     will be called.
     * </p>
     *
     * <p>
     *     Note - The factory must not be an anonymous inner class of an Activity or another object that cannot be
     *     retained statically.
     * </p>
     *
     * @param clazz The class
     * @param factory The factory to use
     * @param <T> The type of the model
     */
    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {
        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);
        if (removed != null) {
            removed.teardown();
        }
    }

    /**
     * Build a {@link ModelLoader} for the given model class using a registered factory.
     *
     * @param clazz The class to get a {@link ModelLoader} for
     * @param context Any context
     * @param <T> The type of the model
     * @return A new {@link ModelLoader} for the given model class
     * @throws IllegalArgumentException if no factory exists for the given class
     */
    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {
        return GLIDE.loaderFactory.buildModelLoader(clazz, context);
    }

    @SuppressWarnings("unchecked")
    private <T> ModelLoaderFactory<T> getFactory(T model) {
        return loaderFactory.getFactory((Class<T>) model.getClass());
    }

    private ImageViewTarget getImageViewTarget(ImageView imageView) {
        Object tag = imageView.getTag();
        ImageViewTarget result = null;
        if (tag instanceof ImageViewTarget) {
            result = (ImageViewTarget) tag;
        } else if (tag != null) {
            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");
        }

        return result;
    }

    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {
        ImageViewTarget result = getImageViewTarget(imageView);
        if (result == null) {
            result = new ImageViewTarget(imageView);
            imageView.setTag(result);
        }
        return result;
    }

    /**
     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load.
     *
     * <p>
     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default
     *     {@link ModelLoader}/{@link ModelLoaderFactory}. You can also optionally use this method to override the
     *     default {@link ModelLoader} for a model for which there is a default. If you would like to permanently
     *     use this factory for all model loads of the this factory's type, see
     *     {@link #register(Class, com.bumptech.glide.loader.model.ModelLoaderFactory)}.
     * </p>
     *
     * <p>
     *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to
     *     supply a custom {@link ModelLoaderFactory} here to do so, even if a default exists. Fetching a smaller image
     *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to
     *     download an image using the width and the height of the target, consider passing in a factory for a subclass
     *     of {@link com.bumptech.glide.loader.model.UrlModelLoader}
     * </p>
     *
     *
     * @param factory The {@link ModelLoaderFactory} to use to load an image from a given model
     * @param <T> The type of the model to load using this factory
     * @return A {@link ModelRequest} to set the specific model to load
     */
    public static <T> ModelRequest<T> using(ModelLoaderFactory<T> factory) {
        return new ModelRequest<T>(factory);
    }

    /**
     * Set the {@link ModelLoader} and therefore the model type to use for a new load.
     *
     * @see #using(com.bumptech.glide.loader.model.ModelLoaderFactory)
     *
     * @param modelLoader The model loader to use
     * @param <T> The type of the model to load using this loader
     * @return A {@link ModelRequest} to set the specific model to load
     */
    public static <T> ModelRequest<T> using(final ModelLoader<T> modelLoader) {
        return new ModelRequest<T>(new ModelLoaderFactory<T>() {
            @Override
            public ModelLoader<T> build(Context context, GenericLoaderFactory factories) {
                return modelLoader;
            }


            @Override @SuppressWarnings("unchecked")
            public Class<? extends ModelLoader<T>> loaderClass() {
                return (Class<ModelLoader<T>>) modelLoader.getClass();
            }

            @Override
            public void teardown() { }
        });
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link String} to load the image represented by the
     * given {@link String}. Defaults to {@link StringLoader.Factory} and {@link StringLoader} to load the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(String)
     *
     * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<String> load(String string) {
        return new Request<String>(string);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link Uri} to load the image at the given uri.
     * Defaults to {@link UriLoader.Factory} and {@link UriLoader}.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(android.net.Uri)
     *
     * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<Uri> load(Uri uri) {
        return new Request<Uri>(uri);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link URL} to load the image represented by the
     * given {@link URL}. Defaults to {@link VolleyUrlLoader.Factory} and {@link VolleyUrlLoader} to load the given
     * model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(java.net.URL)
     *
     * @param url The URL representing the image.
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<URL> load(URL url) {
        return new Request<URL>(url);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link File} to load the image represented by the
     * given {@link File}. Defaults to {@link FileLoader.Factory} and {@link FileLoader} to load the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(java.io.File)
     *
     * @param file The File containing the image
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<File> load(File file) {
        return new Request<File>(file);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for {@link Integer} to load the image represented by the
     * given {@link Integer} resource id. Defaults to {@link ResourceLoader.Factory} and {@link ResourceLoader} to load
     * the given model.
     *
     * @see #using(ModelLoaderFactory)
     * @see ModelRequest#load(Integer)
     *
     * @param resourceId the id of the resource containing the image
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     */
    public static Request<Integer> load(Integer resourceId) {
        return new Request<Integer>(resourceId);
    }

    /**
     * Use the {@link ModelLoaderFactory} currently registered for the given model type to load the image represented by
     * the given model.
     *
     * @param model The model to load
     * @param <T> The type of the model to load
     * @return A {@link Request} to set options for the load and ultimately the target to load the model into
     * @throws IllegalArgumentException If no {@link ModelLoaderFactory} is registered for the given model type
     */
    public static <T> Request<T> load(T model) {
        return new Request<T>(model);
    }

    /**
     * @see #cancel(com.bumptech.glide.presenter.target.Target)
     */
    public static boolean cancel(ImageView imageView) {
        final Target target = GLIDE.getImageViewTarget(imageView);
        return target != null && cancel(target);
    }

    /**
     * Cancel any pending loads Glide may have for the target. After the load is cancelled Glide will not load
     * a placeholder or bitmap into the target so it is safe to do so yourself until you start another load.
     *
     * @param target The Target to cancel loads for
     * @return True iff Glide had ever been asked to load an image for this target
     */
    public static boolean cancel(Target target) {
        ImagePresenter current = target.getImagePresenter();
        final boolean cancelled = current != null;
        if (cancelled) {
            current.clear();
        }

        return cancelled;
    }

    /**
     * A helper class for building requests with custom {@link ModelLoader}s
     *
     * @param <T> The type of the model (and {@link ModelLoader}
     */
    public static class ModelRequest<T> {
        private final ModelLoaderFactory<T> factory;

        private ModelRequest(ModelLoaderFactory<T> factory) {
            this.factory = factory;
        }

        public Request<T> load(T model) {
            return new Request<T>(model, factory);
        }
    }

    /**
     * Sets a variety of type independent options including resizing, animations, and placeholders. Responsible
     * for building or retrieving an ImagePresenter for the given target and passing the ImagePresenter the given model.
     *
     * @param <T> The type of model that will be loaded into the target
     */
    @SuppressWarnings("unused") //public api
    public static class Request<T> {

        private Context context;
        private Target target;

        private ModelLoaderFactory<T> modelLoaderFactory;
        private final T model;

        private int animationId = -1;
        private int placeholderId = -1;
        private int errorId = -1;
        private Downsampler downsampler = Downsampler.AT_LEAST;
        private ArrayList<TransformationLoader<T>> transformationLoaders = new ArrayList<TransformationLoader<T>>();
        private RequestListener<T> requestListener;

        private Request(T model) {
            this(model, GLIDE.getFactory(model));
        }

        private Request(T model, ModelLoaderFactory<T> factory) {
            this.model = model;

            if (factory == null) {
                throw new IllegalArgumentException("No ModelLoaderFactory registered for class=" + model.getClass());
            }
            this.modelLoaderFactory = factory;
        }

        /**
         * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}.
         *
         * @see #downsample(com.bumptech.glide.resize.load.Downsampler)
         *
         * @return This Request
         */
        public Request<T> approximate() {
            return downsample(Downsampler.AT_LEAST);
        }

        /**
         * Load images at their original size using {@link Downsampler#NONE}.
         *
         * @see #downsample(com.bumptech.glide.resize.load.Downsampler)
         *
         * @return This Request
         */
        public Request<T> asIs() {
            return downsample(Downsampler.NONE);
        }

        /**
         * Load images using the given {@link Downsampler}. Replaces any existing downsampler. Defaults to
         * {@link Downsampler#AT_LEAST}
         *
         * @param downsampler The downsampler
         * @return This Request
         */
        public Request<T> downsample(Downsampler downsampler) {
            this.downsampler = downsampler;

            return this;
        }

        /**
         * Transform images using {@link com.bumptech.glide.loader.transformation.CenterCrop}.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @return This Request
         */
        public Request<T> centerCrop() {
            return transform(new CenterCrop<T>());
        }

        /**
         * Transform images using {@link com.bumptech.glide.loader.transformation.FitCenter}.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @return This Request
         */
        public Request<T> fitCenter() {
            return transform(new FitCenter<T>());
        }

        /**
         * Set an arbitrary transformation to apply after an image has been loaded into memory.
         *
         * @see #transform(com.bumptech.glide.loader.transformation.TransformationLoader)
         *
         * @param transformation The transformation to use
         * @return This Request
         */
        public Request<T> transform(final Transformation transformation) {
            return transform(new TransformationLoader<T>() {
                @Override
                public Transformation getTransformation(T model) {
                    return transformation;
                }

                @Override
                public String getId() {
                    return transformation.getId();
                }
            });
        }

        /**
         * Transform images with the given {@link TransformationLoader}. Appends this transformation onto any existing
         * transformations
         *
         * @param transformationLoader The loader to obtaian a transformation for a given model
         * @return This Request
         */
        public Request<T> transform(TransformationLoader<T> transformationLoader) {
            transformationLoaders.add(transformationLoader);

            return this;
        }

        /**
         * Sets an animation to run on the wrapped target when an image load finishes. Will only be run if the image
         * was loaded asynchronously (ie was not in the memory cache)
         *
         * @param animationId The resource id of the animation to run
         * @return This Request
         */
        public Request<T> animate(int animationId) {
            this.animationId = animationId;

            return this;
        }

        /**
         * Sets a resource to display while an image is loading
         *
         * @param resourceId The id of the resource to use as a placeholder
         * @return This Request
         */
        public Request<T> placeholder(int resourceId) {
            this.placeholderId = resourceId;

            return this;
        }

        /**
         * Sets a resource to display if a load fails
         *
         * @param resourceId The id of the resource to use as a placeholder
         * @return This request
         */
        public Request<T> error(int resourceId) {
            this.errorId = resourceId;

            return this;
        }

        /**
         * Sets a Request listener to monitor the image load. It's best to create a single instance of an exception
         * handler per type of request (usually activity/fragment) rather than pass one in per request to avoid some
         * redundant object allocation.
         *
         * @param requestListener The request listener to use
         * @return This request
         */
        public Request<T> listener(RequestListener<T> requestListener) {
            this.requestListener = requestListener;

            return this;
        }

        /**
         * Start loading the image into the view.
         *
         * <p>
         *     Note - This method will call {@link ImageView#setTag(Object)} and may silently overwrite any tag that
         *     might already be set on the view.
         * </p>
         *
         * @see ImagePresenter#setModel(Object)
         * @param imageView The view that will display the image
         */
        public void into(ImageView imageView) {
            //make an effort to support wrap content layout params. This will still blow
            //up if transformation doesn't handle wrap content, but its a start
            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();
            if (layoutParams != null &&
                    (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||
                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {
                downsampler = Downsampler.NONE;
            }

            finish(imageView.getContext(), GLIDE.getImageViewTargetOrSet(imageView));
        }

        /**
         * Set the target the image will be loaded into.
         *
         * <p>
         *     Note - This method does not actually start loading the view. You must first pass in a {@link Context} to
         *     returned Request via {@link ContextRequest#with(android.content.Context)}.
         * </p>
         *
         * @param target The target to load te image for
         * @return A {@link ContextRequest} that can start the load
         */
        public ContextRequest into(Target target) {
            return new ContextRequest(this, target);
        }

        private void finish(Context context, Target target) {
            this.context = context;
            this.target = target;

            ImagePresenter<T> imagePresenter = getImagePresenter(target);
            imagePresenter.setModel(model);
        }

        /**
         * Creates the new {@link ImagePresenter} if one does not currently exist for the current target and sets it as
         * the target's ImagePresenter via {@link Target#setImagePresenter(com.bumptech.glide.presenter.ImagePresenter)}
         */
        @SuppressWarnings("unchecked")
        private ImagePresenter<T> getImagePresenter(Target target) {
            ImagePresenter<T> result = target.getImagePresenter();

            Metadata previous = GLIDE.metadataTracker.get(target);
            Metadata current = new Metadata(this);

            if (previous != null && result == null) {
                previous = null;
            }

            if (!current.isIdenticalTo(previous)) {
                if (result != null) {
                    result.clear();
                }

                result = buildImagePresenter(target);
                target.setImagePresenter(result);

                GLIDE.metadataTracker.put(target, current);
            }

            return result;
        }

        private ImagePresenter<T> buildImagePresenter(final Target target) {
            TransformationLoader<T> transformationLoader = getFinalTransformationLoader();

            ImagePresenter.Builder<T> builder = new ImagePresenter.Builder<T>()
                    .setTarget(target, context)
                    .setModelLoader(modelLoaderFactory.build(context, GLIDE.loaderFactory))
                    .setImageLoader(new ImageManagerLoader(context, downsampler))
                    .setTransformationLoader(transformationLoader);

            if (animationId != -1 || requestListener != null) {
                final Animation animation;
                if (animationId != -1) {
                    animation = AnimationUtils.loadAnimation(context, animationId);
                } else {
                    animation = null;
                }
                builder.setImageReadyCallback(new ImagePresenter.ImageReadyCallback<T>() {
                    @Override
                    public void onImageReady(T model, Target target, boolean fromCache) {
                        if (animation != null && !fromCache) {
                            target.startAnimation(animation);
                        }
                        if (requestListener != null) {
                            requestListener.onImageReady(null, target);
                        }
                    }
                });
            }

            if (placeholderId != -1) {
                builder.setPlaceholderResource(placeholderId);
            }

            if (errorId != -1) {
                builder.setErrorResource(errorId);
            }

            if (requestListener != null) {
                builder.setExceptionHandler(new ImagePresenter.ExceptionHandler<T>() {
                    @Override
                    public void onException(Exception e, T model, boolean isCurrent) {
                        if (isCurrent) {
                            requestListener.onException(e, model, target);
                        }
                    }
                });
            }

            return builder.build();
        }

        private TransformationLoader<T> getFinalTransformationLoader() {
            switch (transformationLoaders.size()) {
                case 0:
                    return new None<T>();
                case 1:
                    return transformationLoaders.get(0);
                default:
                    return new MultiTransformationLoader<T>(transformationLoaders);
            }
        }

        private String getFinalTransformationId() {
            switch (transformationLoaders.size()) {
                case 0:
                    return Transformation.NONE.getId();
                case 1:
                    return transformationLoaders.get(0).getId();
                default:
                    StringBuilder sb = new StringBuilder();
                    for (TransformationLoader transformationLoader : transformationLoaders) {
                        sb.append(transformationLoader.getId());
                    }
                    return sb.toString();
            }
        }
    }

    /**
     * An request for the user to provide an {@link Context} to start an image load
     */
    public static class ContextRequest {
        private final Request request;
        private final Target target;

        private ContextRequest(Request request, Target target) {
            this.request = request;
            this.target = target;
        }

        /**
         * Start loading the image using the given context. The context will not be referenced statically so any
         * context is acceptable.
         *
         * @param context The context to use to help load the image
         */
        public void with(Context context) {
            request.finish(context, target);
        }
    }

    private static class Metadata {
        public final Class modelClass;
        public final Class modelLoaderClass;
        public final int animationId;
        public final int placeholderId;
        public final int errorId;

        private final String downsamplerId;
        private final String transformationId;
        private final Class requestListenerClass;

        public Metadata(Request request) {
            modelClass = request.model != null ? request.model.getClass() : null;
            modelLoaderClass = request.modelLoaderFactory.loaderClass();
            downsamplerId = request.downsampler.getId();
            transformationId = request.getFinalTransformationId();
            animationId = request.animationId;
            placeholderId = request.placeholderId;
            errorId = request.errorId;
            requestListenerClass = (request.requestListener != null ?
                    request.requestListener.getClass() : null);
        }

        //we don't want to change behavior in sets/maps, just be able to compare properties
        public boolean isIdenticalTo(Metadata metadata) {
            if (metadata == null) {
                return false;
            }
            if (animationId != metadata.animationId) {
                return false;
            }
            if (errorId != metadata.errorId) {
                return false;
            }
            if (placeholderId != metadata.placeholderId) {
                return false;
            }
            if (!downsamplerId.equals(metadata.downsamplerId)) {
                return false;
            }
            if (modelClass != null ? !modelClass.equals(metadata.modelClass) : metadata.modelClass != null) {
                return false;
            }
            if (!modelLoaderClass.equals(metadata.modelLoaderClass)) {
                return false;
            }
            if (!transformationId.equals(metadata.transformationId)) {
                return false;
            }
            if (requestListenerClass == null ? metadata.requestListenerClass != null :
                    !requestListenerClass.equals(metadata.requestListenerClass)) {
                return false;
            }

            return true;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java;<<<<<<< MINE
package com.bumptech.glide.presenter.target;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.Display;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.animation.Animation;
import android.widget.ImageView;
import com.bumptech.glide.presenter.ImagePresenter;

import java.lang.ref.WeakReference;

import static android.view.ViewGroup.LayoutParams;

/**
 * A target wrapping an ImageView. Obtains the runtime dimensions of the ImageView.
 */
public class ImageViewTarget implements Target {
    private static final String TAG = "ImageViewTarget";
    private final ImageView imageView;
    private final SizeDeterminer sizeDeterminer;
    private ImagePresenter imagePresenter;

    public ImageViewTarget(ImageView imageView) {
        this.imageView = imageView;
        this.sizeDeterminer = new SizeDeterminer(imageView);
    }

    @Override
    public void onImageReady(Bitmap bitmap) {
        imageView.setImageBitmap(bitmap);
    }

    @Override
    public void setPlaceholder(Drawable placeholder) {
        imageView.setImageDrawable(placeholder);
    }

    @Override
    public void getSize(SizeReadyCallback cb) {
        sizeDeterminer.getSize(cb);
    }

    @Override
    public void startAnimation(Animation animation) {
        imageView.clearAnimation();

        imageView.startAnimation(animation);
    }

    @Override
    public void setImagePresenter(ImagePresenter imagePresenter) {
        this.imagePresenter = imagePresenter;
    }

    @Override
    public ImagePresenter getImagePresenter() {
        return imagePresenter;
    }

    @Override
    public int hashCode() {
        return imageView.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        } else if (!(o instanceof ImageViewTarget)) {
            return false;
        }
        ImageViewTarget other = (ImageViewTarget) o;
        return imageView.equals(other.imageView);
    }

    private static class SizeDeterminer {
        private final View view;
        private SizeReadyCallback cb;
        private SizeDeterminerLayoutListener layoutListener;

        private void checkCurrentDimens() {
            if (cb == null) return;

            boolean calledCallback = true;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else {
                calledCallback = false;
            }

            if (calledCallback) {
                cb = null;
                // Keep a reference to the layout listener and remove it here
                // rather than having the observer remove itself because the observer
                // we add the listener to will be almost immediately merged into
                // another observer and will therefore never be alive. If we instead
                // keep a reference to the listener and remove it here, we get the
                // current view tree observer and should succeed.
                ViewTreeObserver observer = view.getViewTreeObserver();
                if (observer.isAlive()) {
                    observer.removeOnPreDrawListener(layoutListener);
                }
            }
        }

        public SizeDeterminer(View view) {
            this.view = view;
        }

        public void getSize(SizeReadyCallback cb) {
            this.cb = null;
            LayoutParams layoutParams = view.getLayoutParams();
            if (isViewSizeValid()) {
                cb.onSizeReady(view.getWidth(), view.getHeight());
            } else if (isLayoutParamsSizeValid()) {
                cb.onSizeReady(layoutParams.width, layoutParams.height);
            } else if (isUsingWrapContent()) {
                WindowManager windowManager =
                        (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
                Display display = windowManager.getDefaultDisplay();
                final int width = display.getWidth();
                final int height = display.getHeight();
                if (Log.isLoggable(TAG, Log.WARN)) {
                    Log.w(TAG, "Trying to load image into ImageView using WRAP_CONTENT, defaulting to screen" +
                            " dimensions: [" + width + "x" + height + "]. Give the view an actual width and height " +
                            " for better performance.");
                }
                cb.onSizeReady(display.getWidth(), display.getHeight());
            } else {
                this.cb = cb;
                final ViewTreeObserver observer = view.getViewTreeObserver();
                layoutListener = new SizeDeterminerLayoutListener(this);
                observer.addOnPreDrawListener(layoutListener);
            }
        }

        private boolean isViewSizeValid() {
            return view.getWidth() > 0 && view.getHeight() > 0;
        }

        private boolean isUsingWrapContent() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width == LayoutParams.WRAP_CONTENT
                    || layoutParams.height == LayoutParams.WRAP_CONTENT);
        }

        private boolean isLayoutParamsSizeValid() {
            final LayoutParams layoutParams = view.getLayoutParams();
            return layoutParams != null && (layoutParams.width > 0 && layoutParams.height > 0);
        }

        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {
            private final WeakReference<SizeDeterminer> sizeDeterminerRef;

            public SizeDeterminerLayoutListener(SizeDeterminer sizeDeterminer) {
                sizeDeterminerRef = new WeakReference<SizeDeterminer>(sizeDeterminer);
            }

            @Override
            public boolean onPreDraw() {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "OnGlobalLayoutListener called listener=" + this);
                }
                SizeDeterminer sizeDeterminer = sizeDeterminerRef.get();
                if (sizeDeterminer != null) {
                    sizeDeterminer.checkCurrentDimens();
                }
                return true;
            }
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/loader/model/UriLoader.java;<<<<<<< MINE
package com.bumptech.glide.loader.model;

import android.content.ContentResolver;
import android.content.Context;
import android.net.Uri;
import com.bumptech.glide.Glide;
import com.bumptech.glide.loader.stream.LocalUriLoader;
import com.bumptech.glide.loader.stream.StreamLoader;

import java.net.MalformedURLException;
import java.net.URL;

/**
 * A model loader for trying to load Uris. Capable of handling 'http', 'https', 'android.resource', 'content', and
 * 'file' schemes. Unsupported schemes will throw an exception in {@link #getStreamLoader(android.net.Uri, int, int)}
 */
public class UriLoader implements ModelLoader<Uri> {
    public static class Factory implements ModelLoaderFactory<Uri> {

        @Override
        public ModelLoader<Uri> build(Context context, GenericLoaderFactory factories) {
            return new UriLoader(context, factories.buildModelLoader(URL.class, context));
        }

        @Override
        public Class<? extends ModelLoader<Uri>> loaderClass() {
            return UriLoader.class;
        }

        @Override
        public void teardown() { }
    }

    private final Context context;
    private final ModelLoader<URL> urlLoader;

    public UriLoader(Context context) {
        this(context, Glide.buildModelLoader(URL.class, context));
    }

    public UriLoader(Context context, ModelLoader<URL> urlLoader) {
        this.context = context;
        this.urlLoader = urlLoader;
    }

    @Override
    public StreamLoader getStreamLoader(Uri model, int width, int height) {
        final String scheme = model.getScheme();

        StreamLoader result = null;
        if (isLocalUri(scheme)) {
            result = new LocalUriLoader(context, model);
        } else if ("http".equals(scheme) || "https".equals(scheme)) {
            try {
                result = urlLoader.getStreamLoader(new URL(model.toString()), width, height);
            } catch (MalformedURLException e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    @Override
    public String getId(Uri model) {
        return model.toString();
    }

    private boolean isLocalUri(String scheme) {
        return ContentResolver.SCHEME_FILE.equals(scheme)
                || ContentResolver.SCHEME_CONTENT.equals(scheme)
                || ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/bitmap_recycle/SizeStrategy.java;<<<<<<< MINE
package com.bumptech.glide.resize.bitmap_recycle;

import android.annotation.TargetApi;
import android.graphics.Bitmap;

import java.util.TreeMap;

/**
 * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}. Requires KitKat
 * (API 19) or higher.
 */
@TargetApi(19)
class SizeStrategy implements LruPoolStrategy {
    private static final int MAX_SIZE_MULTIPLE = 4;
    private final KeyPool keyPool = new KeyPool();
    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();
    private final TreeMap<Integer, Integer> sortedSizes = new TreeMap<Integer, Integer>();

    @Override
    public void put(Bitmap bitmap) {
        final Key key = keyPool.get(bitmap.getAllocationByteCount());

        groupedMap.put(key, bitmap);

        Integer current = sortedSizes.get(key.size);
        sortedSizes.put(key.size, current == null ? 1 : current + 1);
    }

    @Override
    public Bitmap get(int width, int height, Bitmap.Config config) {
        final int size = getSize(width, height, config);
        Key key = keyPool.get(size);

        Integer possibleSize = sortedSizes.ceilingKey(size);
        if (possibleSize != null && possibleSize != size && possibleSize <= size * MAX_SIZE_MULTIPLE) {
            keyPool.offer(key);
            key = keyPool.get(possibleSize);
        }

        // Do a get even if we know we don't have a bitmap so that the key moves to the front in the lru pool
        final Bitmap result = groupedMap.get(key);
        if (result != null) {
            result.reconfigure(width, height, config);
            decrementBitmapOfSize(possibleSize);
        }

        return result;
    }

    @Override
    public Bitmap removeLast() {
        Bitmap removed = groupedMap.removeLast();
        if (removed != null) {
            final int removedSize = removed.getAllocationByteCount();
            decrementBitmapOfSize(removedSize);
        }
        return removed;
    }

    private void decrementBitmapOfSize(Integer size) {
        Integer current = sortedSizes.get(size);
        if (current == 1) {
            sortedSizes.remove(size);
        } else {
            sortedSizes.put(size, current - 1);
        }
    }

    @Override
    public String logBitmap(Bitmap bitmap) {
        return getBitmapString(bitmap);
    }

    @Override
    public String logBitmap(int width, int height, Bitmap.Config config) {
        return getBitmapString(getSize(width, height, config));
    }

    @Override
    public int getSize(Bitmap bitmap) {
        return bitmap.getAllocationByteCount();
    }

    @Override
    public String toString() {
        String result = "SizeStrategy:\n  " + groupedMap + "\n  SortedSizes( ";
        boolean hadAtLeastOneKey = false;
        for (Integer size : sortedSizes.keySet()) {
            hadAtLeastOneKey = true;
            result += "{" + getBitmapString(size) + ":" + sortedSizes.get(size) + "}, ";
        }
        if (hadAtLeastOneKey) {
            result = result.substring(0, result.length() - 2);
        }
        return result + " )";
    }

    private static String getBitmapString(Bitmap bitmap) {
        return getBitmapString(bitmap.getAllocationByteCount());
    }

    private static String getBitmapString(int size) {
        return "[" + size + "]";
    }

    private static int getSize(int width, int height, Bitmap.Config config) {
        return width * height * getBytesPerPixel(config);
    }

    private static int getBytesPerPixel(Bitmap.Config config) {
      // a bitmap by decoding a gif has null "config" in certain environments.
      if (config == null) {
          return 4;
      }

      switch (config) {
          case ARGB_8888:
              return 4;
          case RGB_565:
              return 2;
          case ARGB_4444:
              return 2;
          case ALPHA_8:
              return 1;
          default:
              // We only use this to calculate sizes to get, so choosing 4 bytes per pixel is conservative and
              // probably forces us to get a larger bitmap than we really need. Since we can't tell for sure, probably
              // better safe than sorry.
              return 4;
        }
    }

    private static class KeyPool extends BaseKeyPool<Key> {

        public Key get(int size) {
            Key result = get();
            result.init(size);
            return result;
        }

        @Override
        protected Key create() {
            return new Key(this);
        }
    }

    private static class Key implements Poolable {
        private final KeyPool pool;
        private int size;

        private Key(KeyPool pool) {
            this.pool = pool;
        }

        public void init(int size) {
            this.size = size;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Key key = (Key) o;

            return size == key.size;
        }

        @Override
        public int hashCode() {
            return size;
        }

        @Override
        public String toString() {
            return getBitmapString(size);
        }

        @Override
        public void offer() {
            pool.offer(this);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/ImageManager.java;<<<<<<< MINE
/*
 * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved.
 */

package com.bumptech.glide.resize;

import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import com.bumptech.glide.loader.stream.StreamLoader;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;
import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounter;
import com.bumptech.glide.resize.bitmap_recycle.BitmapReferenceCounterAdapter;
import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.SerialBitmapReferenceCounter;
import com.bumptech.glide.resize.cache.DiskCache;
import com.bumptech.glide.resize.cache.DiskCacheAdapter;
import com.bumptech.glide.resize.cache.DiskLruCacheWrapper;
import com.bumptech.glide.resize.cache.LruMemoryCache;
import com.bumptech.glide.resize.cache.MemoryCache;
import com.bumptech.glide.resize.cache.MemoryCacheAdapter;
import com.bumptech.glide.resize.load.Downsampler;
import com.bumptech.glide.resize.load.ImageResizer;
import com.bumptech.glide.resize.load.Transformation;

import java.io.File;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;

import static android.os.Process.THREAD_PRIORITY_BACKGROUND;

/**
 * A class to coordinate image loading, resizing, recycling, and caching. Depending on the provided options and the
 * sdk version, uses a combination of an LRU disk cache and an LRU hard memory cache to try to reduce the number of
 * load and resize operations performed and to maximize the number of times Bitmaps are recycled as opposed to
 * allocated. If no options are given defaults to using both a memory and a disk cache and to recycling bitmaps if
 * possible.
 *
 * <p>
 * Note that Bitmap recycling is only available on Honeycomb and up.
 * </p>
 */
public class ImageManager {
    private static final String TAG = "ImageManager";
    private static final String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";
    private static final int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;
    private static final int DEFAULT_BITMAP_COMPRESS_QUALITY = 90;
    private static final float MEMORY_SIZE_RATIO = 1f/10f;
    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final BitmapReferenceCounter bitmapReferenceCounter;
    private final int bitmapCompressQuality;
    private final BitmapPool bitmapPool;
    private final Map<String, ImageManagerJob> jobs = new HashMap<String, ImageManagerJob>();
    private final Bitmap.CompressFormat bitmapCompressFormat;
    private boolean shutdown = false;

    private final Handler mainHandler = new Handler();
    private final Handler bgHandler;
    private final ExecutorService executor;
    private final MemoryCache memoryCache;
    private final ImageResizer resizer;
    private final DiskCache diskCache;
    private final SafeKeyGenerator safeKeyGenerator = new SafeKeyGenerator();

    /**
     * Get the maximum safe memory cache size for this particular device based on the # of mb allocated to each app.
     * This is a conservative estimate that has been safe for 2.2+ devices consistently. It is probably rather small
     * for newer devices.
     *
     * @param context A context
     * @return The maximum safe size for the memory cache for this devices in bytes
     */
    public static int getSafeMemoryCacheSize(Context context){
        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        return Math.round(MEMORY_SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);
    }

    /**
     * Try to get the external cache directory if available and default to the internal. Use a default name for the
     * cache directory if no name is provided
     *
     * @param context A context
     * @return A File representing the default disk cache directory
     */
    public static File getPhotoCacheDir(Context context) {
        return getPhotoCacheDir(context, DEFAULT_DISK_CACHE_DIR);
    }

    /**
     * Try to get the external cache directory if available and default to the internal. Use a default name for the
     * cache directory if no name is provided
     *
     * @param context A context
     * @param cacheName The name of the subdirectory in which to store the cache
     * @return A File representing the default disk cache directory
     */
    @SuppressWarnings("ResultOfMethodCallIgnored")
    public static File getPhotoCacheDir(Context context, String cacheName) {
        File cacheDir = context.getCacheDir();
        if (cacheDir != null) {
            File result = new File(cacheDir, cacheName);
            result.mkdirs();
            return result;
        }
        if (Log.isLoggable(TAG, Log.ERROR)) {
            Log.e(TAG, "default disk cache dir is null");
        }
        return null;
    }

    @SuppressWarnings("unused")
    public static class Builder {
        private final Context context;

        private ExecutorService resizeService = null;
        private MemoryCache memoryCache = null;
        private DiskCache diskCache = null;

        private Bitmap.CompressFormat bitmapCompressFormat = null;
        private boolean recycleBitmaps = CAN_RECYCLE;

        @Deprecated
        public BitmapFactory.Options decodeBitmapOptions = ImageResizer.getDefaultOptions();

        private BitmapPool bitmapPool;
        private BitmapReferenceCounter bitmapReferenceCounter;
        private int bitmapCompressQuality = DEFAULT_BITMAP_COMPRESS_QUALITY;

        /**
         * Create a new builder. No options are required. By default will create an lru memory cache, an lru disk
         * cache, and will recycle bitmaps if the device sdk version allows it.
         *
         * @param context Any context (will not be retained after build)
         */
        public Builder(Context context) {
            this.context = context;
            if (!CAN_RECYCLE) {
                bitmapPool = new BitmapPoolAdapter();
            }
        }

        /**
         * Builds an ImageManager. Any defaults that haven't been set will be set
         *
         * @return A new ImageManager
         */
        public ImageManager build() {
            setDefaults();

            return new ImageManager(this);
        }

        /**
         * Sets the service that will be used to load and resize images not yet in the disk cache.
         *
         * Defaults to a fixed thread pool with the number of threads equal to the number of available processors
         * where every thread is run at min priority.
         *
         * @param resizeService The executor service to use to resize images
         * @return This Builder
         */
        public Builder setResizeService(ExecutorService resizeService) {
            this.resizeService = resizeService;
            return this;
        }

        /**
         * Sets the format that will be used to write all bitmaps to disk in the disk cache (if one is present). By
         * default bitmaps without transparency are written as JPEGs for the fastest possible decodes and bitmaps with
         * transparency are written as PNGs to maximize quality. This will override the format used for all bitmaps,
         * regardless of whether or not they contain transparency.
         *
         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
         *
         *
         * @param bitmapCompressFormat The format to pass to
         *  {@link Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)} when saving
         *  to the disk cache
         * @return This Builder
         */
        public Builder setBitmapCompressFormat(Bitmap.CompressFormat bitmapCompressFormat) {
            this.bitmapCompressFormat = bitmapCompressFormat;
            return this;
        }

        /**
         * Set the compression quality for Bitmaps when writing them out to the disk cache.
         *
         * @see Bitmap#compress(android.graphics.Bitmap.CompressFormat, int, java.io.OutputStream)
         * @see #setBitmapCompressFormat(android.graphics.Bitmap.CompressFormat)
         *
         * <Note>
         *     This will only apply to bitmaps saved to the disk cache as JPEGs (bitmaps with the RGB_565 config)
         * </Note>
         *
         * @param quality Hint for compression in range 0-100 with 0 being lowest and 100 being highest quality. Will
         *                only be applied for certain lossy compression formats
         * @return This Builder
         */
        public Builder setBitmapCompressQuality(int quality) {
            if (quality < 0) {
                throw new IllegalArgumentException("Bitmap compression quality must be >= 0");
            }
            this.bitmapCompressQuality = quality;
            return this;
        }

        /**
         * Set the implementation of a {@link BitmapPool} to use to store and retrieve recycled bitmaps based on their
         * width and height. Should be thread safe and size limited in some way to avoid OOM exceptions.
         *
         * @param bitmapPool The BitmapPool implementation to use
         * @return This Builder
         */
        public Builder setBitmapPool(BitmapPool bitmapPool) {
            if (CAN_RECYCLE) {
                this.bitmapPool = bitmapPool;
            }
            return this;
        }

        /**
         * Call to prevent the ImageManager from recycling bitmaps.
         *
         * @return This Builder
         */
        public Builder disableBitmapRecycling() {
            recycleBitmaps = false;
            return this;
        }

        /**
         * Set the memory cache implementation. See also
         * {@link com.bumptech.glide.resize.ImageManager.Builder#disableMemoryCache()}
         *
         * @param memoryCache The memory cache implementation to use
         * @return This Builder
         */
        public Builder setMemoryCache(MemoryCache memoryCache) {
            this.memoryCache = memoryCache;
            return this;
        }

        /**
         * Call to prevent the ImageManager from using a memory cache.
         *
         * @return This Builder
         */
        public Builder disableMemoryCache() {
            return setMemoryCache(new MemoryCacheAdapter());
        }

        /**
         * Set the disk cache implementation. See also
         *  {@link com.bumptech.glide.resize.ImageManager.Builder#disableDiskCache()}
         *
         * @param diskCache The disk cache implementation to use
         * @return This Builder
         */
        public Builder setDiskCache(DiskCache diskCache) {
            this.diskCache = diskCache;
            return this;
        }

        /**
         * Call to prevent the ImageManager from using a disk cache
         * @return This Builder
         */
        public Builder disableDiskCache() {
            return setDiskCache(new DiskCacheAdapter());
        }

        private void setDefaults() {
            if (resizeService == null) {
                final int numThreads = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);
                resizeService = Executors.newFixedThreadPool(numThreads, new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable runnable) {
                        final Thread result = new Thread(runnable);
                        result.setPriority(THREAD_PRIORITY_BACKGROUND);
                        return result;
                    }
                });
            }
            final int safeCacheSize = getSafeMemoryCacheSize(context);
            final boolean isLowMemoryDevice = isLowMemoryDevice(context);

            if (memoryCache == null) {
                // On low ram devices we double the default bitmap pool size by default so we decrease
                // the default memory cache size here to compensate.
                memoryCache = new LruMemoryCache(
                        !isLowMemoryDevice && recycleBitmaps ? safeCacheSize / 2 : safeCacheSize);
            }

            if (diskCache == null) {
                File cacheDir = getPhotoCacheDir(context);
                if (cacheDir != null) {
                    diskCache = DiskLruCacheWrapper.get(cacheDir, DEFAULT_DISK_CACHE_SIZE);
                }

                if (diskCache == null) {
                    diskCache = new DiskCacheAdapter();
                }
            }

            if (!recycleBitmaps) {
                bitmapPool = new BitmapPoolAdapter();
                bitmapReferenceCounter = new BitmapReferenceCounterAdapter();
            } else {
                if (bitmapPool == null) {
                    bitmapPool = new LruBitmapPool(
                            isLowMemoryDevice ? safeCacheSize : 2 * safeCacheSize);
                }
                bitmapReferenceCounter = new SerialBitmapReferenceCounter(bitmapPool);
            }
        }
    }

    @TargetApi(19)
    private static boolean isLowMemoryDevice(Context context) {
        final ActivityManager activityManager =
                (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        return Build.VERSION.SDK_INT < 11 ||
                (Build.VERSION.SDK_INT >= 19 && activityManager.isLowRamDevice());
    }

    private ImageManager(Builder builder) {
        HandlerThread bgThread = new HandlerThread("image_manager_thread", THREAD_PRIORITY_BACKGROUND);
        bgThread.start();
        bgHandler = new Handler(bgThread.getLooper());
        executor = builder.resizeService;
        bitmapCompressFormat = builder.bitmapCompressFormat;
        bitmapCompressQuality = builder.bitmapCompressQuality;
        memoryCache = builder.memoryCache;
        diskCache = builder.diskCache;
        bitmapReferenceCounter = builder.bitmapReferenceCounter;
        bitmapPool = builder.bitmapPool;
        resizer = new ImageResizer(builder.bitmapPool, builder.decodeBitmapOptions);
        memoryCache.setImageRemovedListener(new MemoryCache.ImageRemovedListener() {
            @Override
            public void onImageRemoved(Bitmap removed) {
                releaseBitmap(removed);
            }
        });
    }

    /**
     * Get the {@link BitmapPool} this ImageManager is using. If Bitmap recycling is not supported, an
     * {@link BitmapPoolAdapter} will be returned. For the pool to be useful you must return a bitmap to the pool for
     * every bitmap you obtain from the pool.
     *
     * <p>
     *     Note the BitmapPool api is likely to change in the near future to support some new features released in
     *     KitKat.
     * </p>
     *
     * @return The bitmap pool.
     */
    public BitmapPool getBitmapPool() {
        return bitmapPool;
    }

    /**
     * Load an image
     *
     * @param id A unique id for this image (it may include the width and height but is not required to)
     * @param streamLoader An object that can fetch the image for the given id, width, and height if it is not cached
     * @param transformation A transformation to apply to the image
     * @param downsampler A downsampler to load the image from disk
     * @param width The desired width of the final image
     * @param height The desired height of the final image
     * @param cb A callback to call when the image is ready
     * @return An {@link ImageManagerJob} that must be retained while the job is still relevant and that can be used
     *          to cancel a job if the image is no longer needed
     */
    public LoadToken getImage(String id, StreamLoader streamLoader, Transformation transformation,
                              Downsampler downsampler, int width, int height, LoadedCallback cb) {
        if (shutdown) return null;

        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);
        LoadToken result = null;
        if (!returnFromCache(key, cb)) {
            ImageManagerJob job = jobs.get(key);
            if (job == null) {
                ImageManagerRunner runner = new ImageManagerRunner(key, streamLoader, transformation, downsampler,
                        width, height);
                job = new ImageManagerJob(runner, key);
                jobs.put(key, job);
                job.addCallback(cb);
                runner.execute();
            } else {
                job.addCallback(cb);
            }
            result = new LoadToken(cb, job);
        }
        return result;
    }

    /**
     * Notify the ImageManager that a Bitmap it loaded is no longer being used and decrement the reference counter for
     * that Bitmap. This will cause an exception if acquire was not called first, or if each call to release does not
     * come after a call to acquire. If the reference count drops to zero, places the Bitmap into a queue to be
     * recycled. Does nothing if recycling is disabled or impossible.
     *
     * @param b The releasedBitmap
     */
    public void releaseBitmap(final Bitmap b) {
        bitmapReferenceCounter.releaseBitmap(b);
    }

    public void clearMemory() {
        memoryCache.clearMemory();
        bitmapPool.clearMemory();
    }

    public void trimMemory(int level) {
        memoryCache.trimMemory(level);
        bitmapPool.trimMemory(level);
    }

    /**
     * Shuts down all of the background threads used by the ImageManager including the executor service
     */
    @SuppressWarnings("unused")
    public void shutdown() {
        shutdown = true;
        executor.shutdown();
        bgHandler.getLooper().quit();
    }

    private boolean returnFromCache(String key, LoadedCallback cb) {
        Bitmap inCache = memoryCache.get(key);
        boolean found = inCache != null;
        if (found) {
            bitmapReferenceCounter.acquireBitmap(inCache);
            cb.onLoadCompleted(inCache);
        }
        return found;
    }

    /**
     * A class for tracking a particular job in the {@link ImageManager}. Cancel does not guarantee that the
     * job will not finish, but rather is a best effort attempt.
     */
    private class ImageManagerJob {
        private final ImageManagerRunner runner;
        private final String key;
        private final List<LoadedCallback> cbs = new ArrayList<LoadedCallback>();

        public ImageManagerJob(ImageManagerRunner runner, String key) {
            this.runner = runner;
            this.key = key;
        }

        public void addCallback(LoadedCallback cb) {
            cbs.add(cb);
        }

        /**
         * Try to cancel the job. Does not guarantee that the job will not finish.
         */
        public void cancel(LoadedCallback cb) {
            cbs.remove(cb);
            if (cbs.size() == 0) {
                // Note: this is potentially dangerous. The runner asynchronously asks our jobs map for a job
                // matching our key after posting a runnable to the main thread and as a result, the job it gets back
                // may not be this job. We protect against this for cancellation by not delivering failures from
                // cancelled runners, so new jobs will not receive errors from cancelled jobs. However, new jobs may
                // receive results from old runners if the old runner was cancelled, but completed successfully anyway
                // because it received the cancellation too late.
                runner.cancel();
                if (jobs.get(key) == this) {
                    jobs.remove(key);
                }
            }
        }

        public void onLoadComplete(Bitmap result) {
            for (LoadedCallback cb : cbs) {
                bitmapReferenceCounter.acquireBitmap(result);
                cb.onLoadCompleted(result);
            }
            jobs.remove(key);
        }

        public void onLoadFailed(Exception e) {
            for (LoadedCallback cb : cbs) {
                cb.onLoadFailed(e);
            }
            jobs.remove(key);
        }
    }

    private void putInDiskCache(String key, final Bitmap bitmap) {
        diskCache.put(key, new DiskCache.Writer() {
            @Override
            public void write(OutputStream os) {
                Bitmap.CompressFormat compressFormat = getCompressFormat(bitmap);
                bitmap.compress(compressFormat, bitmapCompressQuality, os);
            }
        });
    }

    private Bitmap.CompressFormat getCompressFormat(Bitmap bitmap) {
        final Bitmap.CompressFormat format;
        if (bitmapCompressFormat != null) {
            format = bitmapCompressFormat;
        } else {
            if (bitmap.getConfig() == Bitmap.Config.RGB_565 || !bitmap.hasAlpha()) {
                format = Bitmap.CompressFormat.JPEG;
            } else {
                format = Bitmap.CompressFormat.PNG;
            }
        }
        return format;
    }

    private void putInMemoryCache(String key, final Bitmap bitmap) {
        final boolean inCache;
        inCache = memoryCache.contains(key);
        if (!inCache) {
            bitmapReferenceCounter.acquireBitmap(bitmap);
            memoryCache.put(key, bitmap);
        }
    }

    private class ImageManagerRunner implements Runnable {
        public final String key;
        public final int width;
        public final int height;
        private final StreamLoader streamLoader;
        private final Transformation transformation;
        private final Downsampler downsampler;

        private volatile Future<?> future;
        private volatile boolean isCancelled = false;

        public ImageManagerRunner(String key, StreamLoader sl, Transformation t, Downsampler d, int width, int height) {
            this.key = key;
            this.height = height;
            this.width = width;

            this.streamLoader = sl;
            this.transformation = t;
            this.downsampler = d;
        }

        private void execute() {
            bgHandler.post(this);
        }

        public void cancel() {
            if (isCancelled) {
                return;
            }
            isCancelled = true;

            bgHandler.removeCallbacks(this);

            final Future current = future;
            if (current != null) {
                current.cancel(false);
            }

            if (streamLoader != null) {
                streamLoader.cancel();
            }
        }

        @Override
        public void run() {
            Bitmap result = null;
            try {
                result = getFromDiskCache(key);
            } catch (Exception e) {
                handleException(e);
            }

            if (result == null) {
                try {
                    resizeWithPool();
                } catch (Exception e) {
                    handleException(e);
                }
            } else {
                finishResize(result, true);
            }
        }

        private Bitmap getFromDiskCache(String key) {
            Bitmap result = null;
            final InputStream is = diskCache.get(key);
            if (is != null) {
                result = resizer.load(is, width, height, Downsampler.NONE);
                if (result == null) {
                    diskCache.delete(key); //the image must have been corrupted
                }
            }
            return result;
        }

        private void resizeWithPool() {
            future = executor.submit(new Runnable() {
                @Override
                public void run() {

                    streamLoader.loadStream(new StreamLoader.StreamReadyCallback() {
                        @Override
                        public void onStreamReady(final InputStream is) {
                            if (isCancelled) {
                                return;
                            }

                            //this callback might be called on some other thread,
                            //we want to do resizing on our thread, especially if we're called
                            //back on the main thread, so we will resubmit
                            future = executor.submit(new Runnable() {
                                @Override
                                public void run() {
                                    try {
                                        final Bitmap result = resizeIfNotFound(is, downsampler, transformation);
                                        finishResize(result, false);
                                    } catch (Exception e) {
                                        handleException(e);
                                    }
                                }
                            });
                        }

                        @Override
                        public void onException(Exception e) {
                            handleException(e);
                        }
                    });
                }
            });
        }

        private Bitmap resizeIfNotFound(InputStream is, Downsampler downsampler, Transformation transformation) {
            return resizer.load(is, width, height, downsampler, transformation);
        }

        private void finishResize(final Bitmap result, boolean isInDiskCache) {
            if (result != null) {
                if (!isInDiskCache) {
                    putInDiskCache(key, result);
                }

                mainHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        // Acquire the bitmap for this runnable until we've finished notifying
                        // all consumers. This prevents the bitmap from being put in the bitmap pool
                        // before all consumers have a change to acquire the bitmap if one of the first
                        // consumers (usually the memory cache) synchronously releases the bitmap.
                        bitmapReferenceCounter.acquireBitmap(result);
                        putInMemoryCache(key, result);
                        final ImageManagerJob job = jobs.get(key);
                        if (job != null) {
                            job.onLoadComplete(result);
                        }
                        // All consumers have had their chance, it's now safe to release the
                        // bitmap.
                        bitmapReferenceCounter.releaseBitmap(result);
                    }
                });
            } else {
                handleException(null);
            }
        }

        private void handleException(final Exception e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Exception loading image", e);
            }
            mainHandler.post(new Runnable() {
                @Override
                public void run() {
                    if (isCancelled) {
                        return;
                    }

                    final ImageManagerJob job = jobs.get(key);
                    if (job != null) {
                        job.onLoadFailed(e);
                    }
                }
            });
        }
    }

    public static class LoadToken {
        private final ImageManagerJob job;
        private final LoadedCallback cb;

        public LoadToken(LoadedCallback cb, ImageManagerJob job) {
            this.cb = cb;
            this.job = job;
        }

        public void cancel() {
            job.cancel(cb);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_a7fbd5b_60b0657/rev_a7fbd5b-60b0657/library/src/com/bumptech/glide/resize/load/ImageResizer.java;<<<<<<< MINE
/*
 * Copyright (c) 2012 Bump Technologies Inc. All rights reserved.
 */
package com.bumptech.glide.resize.load;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.RectF;
import android.media.ExifInterface;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.resize.RecyclableBufferedInputStream;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;
import com.bumptech.glide.resize.bitmap_recycle.BitmapPoolAdapter;

import java.io.InputStream;
import java.util.LinkedList;
import java.util.Queue;

/**
 * A class for synchronously resizing bitmaps with or without Bitmaps to reuse
 */
public class ImageResizer {
    public static final int PAINT_FLAGS = Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG | Paint.FILTER_BITMAP_FLAG;

    private static final String TAG = "ImageResizer";
    private static final int TEMP_BYTES_SIZE = 16 * 1024; //16kb
    private static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;

    private final Queue<byte[]> tempQueue = new LinkedList<byte[]>();
    private final BitmapPool bitmapPool;

    private final BitmapFactory.Options defaultOptions;

    @TargetApi(11)
    public static BitmapFactory.Options getDefaultOptions() {
       BitmapFactory.Options decodeBitmapOptions = new BitmapFactory.Options();
       decodeBitmapOptions.inDither = false;
       decodeBitmapOptions.inScaled = false;
       decodeBitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;
       decodeBitmapOptions.inSampleSize = 1;
       if (CAN_RECYCLE)  {
           decodeBitmapOptions.inMutable = true;
       }
       return decodeBitmapOptions;
    }

    /**
     * Creates a new resizer that will not recycle Bitmaps
     */
    @SuppressWarnings("unused")
    public ImageResizer() {
        this(null, null);
    }

    @SuppressWarnings("unused")
    public ImageResizer(BitmapPool bitmapPool) {
        this(bitmapPool, null);
    }

    @SuppressWarnings("unused")
    @Deprecated
    public ImageResizer(BitmapFactory.Options options) {
        this(null, options);
    }

    /**
     * Creates a new resizer that will attempt to recycle {@link android.graphics.Bitmap}s if any are available in the given dimensions
     *
     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from
     */
    @Deprecated
    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){
        if (bitmapPool == null) {
            this.bitmapPool = new BitmapPoolAdapter();
        } else {
            this.bitmapPool = bitmapPool;
        }

        if (defaultOptions == null) {
            this.defaultOptions = getDefaultOptions();
        } else {
            this.defaultOptions = defaultOptions;
        }
    }

    public Bitmap load(InputStream is) {
        return load(is, -1, -1, Downsampler.NONE, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight) {
        return load(is, outWidth, outHeight, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Transformation transformation) {
        return load(is, outWidth, outHeight, Downsampler.AT_LEAST, transformation);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler) {
        return load(is, outWidth, outHeight, downsampler, Transformation.NONE);
    }

    public Bitmap load(InputStream is, int outWidth, int outHeight, Downsampler downsampler, Transformation transformation) {
        byte[] tempBytesForBis = getTempBytes();
        byte[] tempBytesForOptions = getTempBytes();

        BitmapFactory.Options options = getOptions();
        options.inTempStorage = tempBytesForOptions;

        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytesForBis);

        final Bitmap initial = downsampler.downsample(bis, options, bitmapPool, outWidth, outHeight);
        final Bitmap result = transformation.transform(initial, bitmapPool, outWidth, outHeight);

        if (initial != result && !bitmapPool.put(initial)) {
            initial.recycle();
        }

        releaseTempBytes(tempBytesForBis);
        releaseTempBytes(tempBytesForOptions);

        return result;
    }

    private BitmapFactory.Options getOptions() {
        BitmapFactory.Options result = new BitmapFactory.Options();
        copyOptions(defaultOptions, result);
        return result;
    }

    private byte[] getTempBytes() {
        byte[] result;
        synchronized (tempQueue) {
            result = tempQueue.poll();
        }
        if (result == null) {
            result = new byte[TEMP_BYTES_SIZE];
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Created temp bytes");
            }
        }
        return result;
    }

    private void releaseTempBytes(byte[] bytes) {
        synchronized (tempQueue) {
            tempQueue.offer(bytes);
        }
    }

    private static void copyOptions(BitmapFactory.Options from, BitmapFactory.Options to) {
        if (Build.VERSION.SDK_INT >= 11) {
            copyOptionsHoneycomb(from, to);
        } else if (Build.VERSION.SDK_INT >= 10) {
            copyOptionsGingerbreadMr1(from, to);
        } else {
            copyOptionsFroyo(from, to);
        }
    }

    @TargetApi(11)
    private static void copyOptionsHoneycomb(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsGingerbreadMr1(from, to);
        to.inMutable = from.inMutable;
    }

    @TargetApi(10)
    private static void copyOptionsGingerbreadMr1(BitmapFactory.Options from, BitmapFactory.Options to) {
        copyOptionsFroyo(from, to);
        to.inPreferQualityOverSpeed = from.inPreferQualityOverSpeed;
    }

    private static void copyOptionsFroyo(BitmapFactory.Options from, BitmapFactory.Options to) {
        to.inDensity = from.inDensity;
        to.inDither = from.inDither;
        to.inInputShareable = from.inInputShareable;
        to.inPreferredConfig = from.inPreferredConfig;
        to.inPurgeable = from.inPurgeable;
        to.inSampleSize = from.inSampleSize;
        to.inScaled = from.inScaled;
        to.inScreenDensity = from.inScreenDensity;
        to.inTargetDensity = from.inTargetDensity;
    }

    /**
     * A potentially expensive operation to crop the given Bitmap so that it fills the given dimensions. This operation
     * is significantly less expensive in terms of memory if a mutable Bitmap with the given dimensions is passed in
     * as well.
     *
     * @param recycled A mutable Bitmap with dimensions width and height that we can load the cropped portion of toCrop
     *                 into
     * @param toCrop The Bitmap to resize
     * @param width The width of the final Bitmap
     * @param height The height of the final Bitmap
     * @return The resized Bitmap (will be recycled if recycled is not null)
     */
    public static Bitmap centerCrop(Bitmap recycled, Bitmap toCrop, int width, int height) {
        if (toCrop == null) {
            return null;
        } else if (toCrop.getWidth() == width && toCrop.getHeight() == height) {
            return toCrop;
        }
        //from ImageView/Bitmap.createScaledBitmap
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/java/android/widget/ImageView.java
        //https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/graphics/java/android/graphics/Bitmap.java
        final float scale;
        float dx = 0, dy = 0;
        Matrix m = new Matrix();
        if (toCrop.getWidth() * height > width * toCrop.getHeight()) {
            scale = (float) height / (float) toCrop.getHeight();
            dx = (width - toCrop.getWidth() * scale) * 0.5f;
        } else {
            scale = (float) width / (float) toCrop.getWidth();
            dy = (height - toCrop.getHeight() * scale) * 0.5f;
        }

        m.setScale(scale, scale);
        m.postTranslate((int) (dx + 0.5f), (int) (dy + 0.5f));
        final Bitmap result;
        if (recycled != null) {
            result = recycled;
        } else {
            result = Bitmap.createBitmap(width, height, toCrop.getConfig() == null ?
                                                            Bitmap.Config.ARGB_8888 : toCrop.getConfig());
        }
        Canvas canvas = new Canvas(result);
        Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toCrop, m, paint);
        return result;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its width
     * matches the given width
     *
     * @param toShrink The Bitmap to shrink
     * @param width The width of the final Bitmap
     * @return A new Bitmap shrunk to the given width, or toShrink if toShrink's width is equivalent to the given width
     */
    public static Bitmap shrinkToWidth(Bitmap toShrink, int width){
        Bitmap shrunk = toShrink;
        float widthPercent = ((float) width/toShrink.getWidth());
        if (widthPercent != 1) {
            int shrunkImageHeight = Math.round(widthPercent * toShrink.getHeight());
            shrunk = Bitmap.createScaledBitmap(toShrink, width, shrunkImageHeight, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given image, maintaining the original proportions, so that its height
     * matches the given height
     *
     * @param toShrink The Bitmap to shrink
     * @param height The height of the final Bitmap
     * @return A new Bitmap shrunk to the given height, or toShrink if toShink's height is equivalent to the given
     *          height
     */
    public static Bitmap shrinkToHeight(Bitmap toShrink, int height){
        Bitmap shrunk = toShrink;
        float heightPercent = ((float) height/toShrink.getHeight());
        if (heightPercent != 1) {
            int shrunkImageWidth = Math.round(heightPercent * toShrink.getWidth());
            shrunk = Bitmap.createScaledBitmap(toShrink, shrunkImageWidth, height, true);
        }
        return shrunk;
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintaining
     * the original proportions
     *
     * @param toFit The Bitmap to shrink
     * @param width The width the final image will fit within
     * @param height The height the final image will fit within
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    @Deprecated
    public static Bitmap fitInSpace(Bitmap toFit, int width, int height){
        if (toFit == null) return null;

        if (height > width){
            return shrinkToWidth(toFit, width);
        } else {
            return shrinkToHeight(toFit, height);
        }
    }

    /**
     * An expensive operation to resize the given Bitmap down so that it fits within the given dimensions maintain
     * the original proportions.
     *
     * @param toFit The Bitmap to shrink.
     * @param pool The BitmapPool to try to reuse a bitmap from.
     * @param width The width the final image will fit within.
     * @param height The height the final image will fit within.
     * @return A new Bitmap shrunk to fit within the given dimensions, or toFit if toFit's width or height matches the
     * given dimensions and toFit fits within the given dimensions
     */
    public static Bitmap fitCenter(Bitmap toFit, BitmapPool pool, int width, int height) {
         final float shrinkPercentage;
        final int targetWidth;
        final int targetHeight;
        if (height > width) {
            shrinkPercentage = width / (float) toFit.getWidth();
            targetWidth = width;
            targetHeight = Math.round(shrinkPercentage * toFit.getHeight());
        } else {
            shrinkPercentage = height / (float) toFit.getHeight();
            targetWidth = Math.round(shrinkPercentage * toFit.getWidth());
            targetHeight = height;
        }

        Bitmap.Config config = toFit.getConfig() != null ? toFit.getConfig() : Bitmap.Config.ARGB_8888;
        Bitmap toReuse = pool.get(targetWidth, targetHeight, config);
        if (toReuse == null) {
            toReuse = Bitmap.createBitmap(targetWidth, targetHeight, config);
        }
        Canvas canvas = new Canvas(toReuse);
        Matrix matrix = new Matrix();
        matrix.setScale(shrinkPercentage, shrinkPercentage);
        Paint paint = new Paint(ImageResizer.PAINT_FLAGS);
        canvas.drawBitmap(toFit, matrix, paint);

        return toReuse;
    }


    /**
     * Returns a matrix with rotation set based on Exif orientation tag.
     * If the orientation is undefined or 0 null is returned.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @return  A rotation in degrees based on exif orientation
     */
    public static int getOrientation(String pathToOriginal) {
        int degreesToRotate = 0;
        try{
            ExifInterface exif = new ExifInterface(pathToOriginal);
            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
            if (orientation == ExifInterface.ORIENTATION_ROTATE_90){
                degreesToRotate = 90;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_180){
                degreesToRotate = 180;
            } else if (orientation == ExifInterface.ORIENTATION_ROTATE_270){
                degreesToRotate = 270;
            }
        } catch (Exception e){
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Unable to get orientation for image with path=" + pathToOriginal, e);
            }
        }
        return degreesToRotate;
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param pathToOriginal Path to original image file that may have exif data.
     * @param imageToOrient Image Bitmap to orient.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    @SuppressWarnings("unused")
    public static Bitmap orientImage(String pathToOriginal, Bitmap imageToOrient){
        int degreesToRotate = getOrientation(pathToOriginal);
        return rotateImage(imageToOrient, degreesToRotate);
    }

    /**
     * This is an expensive operation that copies the image in place with the pixels rotated.
     * If possible rather use getOrientationMatrix, and set that as the imageMatrix on an ImageView.
     *
     * @param imageToOrient Image Bitmap to orient.
     * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is returned unmodified.
     * @return The oriented bitmap. May be the imageToOrient without modification, or a new Bitmap.
     */
    public static Bitmap rotateImage(Bitmap imageToOrient, int degreesToRotate) {
        try{
            if(degreesToRotate != 0) {
                Matrix matrix = new Matrix();
                matrix.setRotate(degreesToRotate);
                imageToOrient = Bitmap.createBitmap(
                        imageToOrient,
                        0,
                        0,
                        imageToOrient.getWidth(),
                        imageToOrient.getHeight(),
                        matrix,
                        true);
            }
        } catch (Exception e) {
            if (Log.isLoggable(TAG, Log.ERROR)) {
                Log.e(TAG, "Exception when trying to orient image", e);
            }
            e.printStackTrace();
        }
        return imageToOrient;
    }

    /**
     * Get the # of degrees an image must be rotated to match the given exif orientation.
     *
     * @param exifOrientation The exif orientation [1-8]
     * @return the number of degrees to rotate
     */
    public static int getExifOrientationDegrees(int exifOrientation) {
        final int degreesToRotate;
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_TRANSPOSE:
            case ExifInterface.ORIENTATION_ROTATE_90:
                degreesToRotate = 90;
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                degreesToRotate = 180;
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
            case ExifInterface.ORIENTATION_ROTATE_270:
                degreesToRotate = 270;
                break;
            default:
                degreesToRotate = 0;

        }
        return degreesToRotate;
    }

    /**
     * Rotate and/or flip the image to match the given exif orientation
     *
     * @param toOrient The bitmap to rotate/flip
     * @param pool A pool that may or may not contain an image of the necessary dimensions
     * @param exifOrientation the exif orientation [1-8]
     * @return The rotated and/or flipped image or toOrient if no rotation or flip was necessary
     */
    public static Bitmap rotateImageExif(Bitmap toOrient, BitmapPool pool, int exifOrientation) {
        final Matrix matrix = new Matrix();
        switch (exifOrientation) {
            case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:
                matrix.setScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_180:
                matrix.setRotate(180);
                break;
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                matrix.setRotate(180);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_TRANSPOSE:
                matrix.setRotate(90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_90:
                matrix.setRotate(90);
                break;
            case ExifInterface.ORIENTATION_TRANSVERSE:
                matrix.setRotate(-90);
                matrix.postScale(-1, 1);
                break;
            case ExifInterface.ORIENTATION_ROTATE_270:
                matrix.setRotate(-90);
                break;
            default: //case ExifInterface.ORIENTATION_NORMAL
                return toOrient;
        }

        // From Bitmap.createBitmap.
        final RectF newRect = new RectF(0, 0, toOrient.getWidth(), toOrient.getHeight());
        matrix.mapRect(newRect);

        final int newWidth = Math.round(newRect.width());
        final int newHeight = Math.round(newRect.height());

        Bitmap result = pool.get(newWidth, newHeight, toOrient.getConfig());
        if (result == null) {
            result = Bitmap.createBitmap(newWidth, newHeight, toOrient.getConfig());
        }

        matrix.postTranslate(-newRect.left, -newRect.top);

        final Canvas canvas = new Canvas(result);
        final Paint paint = new Paint(PAINT_FLAGS);
        canvas.drawBitmap(toOrient, matrix, paint);

        return result;
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/retrolambda/revisions/rev_757247b_52364bc/rev_757247b-52364bc/end-to-end-tests/src/test/java/net/orfjackal/retrolambda/test/anotherpackage/DifferentPackageBase.java;<<<<<<< MINE
=======
// Copyright  2013-2016 Esko Luontola <www.orfjackal.net>
// This software is released under the Apache License 2.0.
// The license text is at http://www.apache.org/licenses/LICENSE-2.0

package net.orfjackal.retrolambda.test.anotherpackage;

public class DifferentPackageBase {
    protected static String value() {
        return "Hello";
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java;<<<<<<< MINE
  private final RequestQueue requestQueue;
=======
    /**
     * The default factory for {@link VolleyUrlLoader}s.
     */
    public static class Factory implements ModelLoaderFactory<GlideUrl, InputStream> {
        private static RequestQueue internalQueue;
        private RequestQueue requestQueue;
        private final VolleyRequestFactory requestFactory;

        private static RequestQueue getInternalQueue(Context context) {
            if (internalQueue == null) {
                synchronized (Factory.class) {
                    if (internalQueue == null) {
                        internalQueue = Volley.newRequestQueue(context);
                    }
                }
            }
            return internalQueue;
        }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java;<<<<<<< MINE
=======
package com.bumptech.glide;

import static com.bumptech.glide.tests.BackgroundUtil.testInBackground;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.widget.ImageView;

import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.tests.BackgroundUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

@SuppressWarnings("unchecked")
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestBuilderTest {
    private RequestTracker requestTracker;

    @Before
    public void setUp() {
        requestTracker = mock(RequestTracker.class);
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsIfContextIsNull() {
        new GenericRequestBuilder(null, Object.class, mock(LoadProvider.class), Object.class, mock(Glide.class),
                requestTracker, mock(Lifecycle.class));
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsIfNonNullModelAndNullLoadProvider() {
        new GenericRequestBuilder(Robolectric.application, Object.class, null, Object.class, mock(Glide.class),
                requestTracker, mock(Lifecycle.class));
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenGlideAnimationFactoryIsNull() {
        getNullModelRequest().animate((GlideAnimationFactory) null);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideWidthLessThanZero() {
        getNullModelRequest().override(-1, 100);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideWidthEqualToZero() {
        getNullModelRequest().override(0, 100);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideHeightLessThanZero() {
        getNullModelRequest().override(100, -5);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void testThrowsWhenOverrideHeightEqualToZero() {
        getNullModelRequest().override(100, 0);
    }

    @Test
    public void testDoesNotThrowWhenWidthIsSizeOriginal() {
        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);
    }

    @Test
    public void testDoesNotThrowWhenHeightIsSizeOriginal() {
        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);
    }

    @Test
    public void testDoesNotThrowWhenModelAndLoaderNull() {
        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,
                mock(Lifecycle.class));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testProvidingSelfAsThumbnailThrows() {
        GenericRequestBuilder request = getNullModelRequest();
        request.thumbnail(request);
    }

    @Test(expected = IllegalStateException.class)
    public void testProvidingSelfAsChildOfThumbnailThrows() {
        GenericRequestBuilder first = getNullModelRequest();
        GenericRequestBuilder second = first.clone();
        second.thumbnail(first);
        first.thumbnail(second);
        first.into(mock(Target.class));
    }

    @Test
    public void testCanPassedClonedSelfToThumbnail() {
        GenericRequestBuilder first = getNullModelRequest();
        GenericRequestBuilder second = first.clone();
        GenericRequestBuilder third = second.clone();
        first.thumbnail(second.thumbnail(third)).into(mock(Target.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenDecoderSet() {
        getNullModelRequest().decoder(mock(ResourceDecoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenCacheDecoderSet() {
        getNullModelRequest().cacheDecoder(mock(ResourceDecoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenEncoderSet() {
        getNullModelRequest().encoder(mock(ResourceEncoder.class));
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenDiskCacheStrategySet() {
        getNullModelRequest().diskCacheStrategy(DiskCacheStrategy.ALL);
    }

    @Test
    public void testDoesNotThrowWithNullModelWhenRequestIsBuilt() {
        getNullModelRequest().into(mock(Target.class));
    }

    @Test
    public void testAddsNewRequestToRequestTracker() {
        getNullModelRequest().into(mock(Target.class));
        verify(requestTracker).runRequest(any(Request.class));
    }

    @Test
    public void testRemovesPreviousRequestFromRequestTracker() {
        Request previous = mock(Request.class);
        Target target = mock(Target.class);
        when(target.getRequest()).thenReturn(previous);

        getNullModelRequest().into(target);

        verify(requestTracker).removeRequest(eq(previous));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullTarget() {
        getNullModelRequest().into((Target) null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testThrowsIfGivenNullView() {
        getNullModelRequest().into((ImageView) null);
    }

    @Test(expected = RuntimeException.class)
    public void testThrowsIfIntoViewCalledOnBackgroundThread() throws InterruptedException {
        final ImageView imageView = new ImageView(Robolectric.application);
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                getNullModelRequest().into(imageView);

            }
        });
    }

    @Test(expected = RuntimeException.class)
    public void testThrowsIfIntoTargetCalledOnBackgroundThread() throws InterruptedException {
        final Target target = mock(Target.class);
        testInBackground(new BackgroundUtil.BackgroundTester() {
            @Override
            public void runTest() throws Exception {
                getNullModelRequest().into(target);
            }
        });
    }

    private GenericRequestBuilder getNullModelRequest() {
        Glide glide = mock(Glide.class);
        when(glide.buildImageViewTarget(any(ImageView.class), any(Class.class))).thenReturn(
                mock(Target.class));
        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,
                mock(Lifecycle.class)).load(null);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.request;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestTest {
    private RequestHarness harness;

    /**
     * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
     * Both are in the middle of the hierarchy having multiple descendants and ancestors.
     */
    @SuppressWarnings("unchecked")
    private static class RequestHarness {
        ModelLoader<Number, Object> modelLoader;
        Engine engine = mock(Engine.class);
        Number model = 123456;
        Target<List> target = mock(Target.class);
        Context context = Robolectric.application;
        Resource<List> resource = mock(Resource.class);
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        Priority priority = Priority.NORMAL;
        int placeholderResourceId = 0;
        Drawable placeholderDrawable = null;
        int errorResourceId = 0;
        Transformation transformation = mock(Transformation.class);
        Drawable errorDrawable = null;
        LoadProvider<Number, Object, Object, List> loadProvider = mock(LoadProvider.class);
        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
        Encoder<Object> sourceEncoder = mock(Encoder.class);
        RequestListener<Number, List> requestListener = mock(RequestListener.class);
        boolean skipMemoryCache;
        GlideAnimationFactory<List> factory = mock(GlideAnimationFactory.class);
        int overrideWidth = -1;
        int overrideHeight = -1;
        List result = new ArrayList();
        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
        Key signature = mock(Key.class);

        public RequestHarness() {
            modelLoader = mock(ModelLoader.class);
            when(modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt()))
                    .thenReturn(mock(DataFetcher.class));
            when(loadProvider.getModelLoader()).thenReturn(modelLoader);
            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
            when(loadProvider.getEncoder()).thenReturn(encoder);
            when(loadProvider.getTranscoder()).thenReturn(transcoder);
            when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
            when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);

            when(resource.get()).thenReturn(result);
        }

        public GenericRequest<Number, Object, Object, List> getRequest() {
            return GenericRequest.obtain(loadProvider,
                    model,
                    signature,
                    context,
                    priority,
                    target,
                    1f,
                    placeholderDrawable,
                    placeholderResourceId,
                    errorDrawable,
                    errorResourceId,
                    requestListener,
                    requestCoordinator,
                    engine,
                    transformation,
                    List.class,
                    skipMemoryCache,
                    factory,
                    overrideWidth,
                    overrideHeight,
                    diskCacheStrategy);
        }
    }

    @Before
    public void setUp() {
        harness = new RequestHarness();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testReturnsWhenMissingCacheDecoderAndNeeded3() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingCacheDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenMissingTranscoder() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getTranscoder()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testThrowsWhenMissingModelLoader() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getModelLoader()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenTransformationIsNull() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            harness.transformation = null;

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testIsNotCompleteBeforeReceivingResource() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isComplete());
    }

    @Test
    public void testCanHandleNullResources() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);

        assertTrue(request.isFailed());
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleEmptyResources() {
        GenericRequest request = harness.getRequest();
        when(harness.resource.get()).thenReturn(null);

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleNonConformingResources() {
        GenericRequest request = harness.getRequest();
        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testIsNotFailedAfterClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.clear();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsPausedAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertTrue(request.isPaused());
    }

    @Test
    public void testIsNotCancelledAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertFalse(request.isCancelled());
    }

    @Test
    public void testIsNotPausedAfterBeginningWhilePaused() {
        GenericRequest request = harness.getRequest();
        request.pause();
        request.begin();

        assertFalse(request.isPaused());
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotFailedAfterBegin() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.begin();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsCompleteAfterReceivingResource() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        assertTrue(request.isComplete());
    }

    @Test
    public void testIsNotCompleteAfterClear() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);
        request.clear();

        assertFalse(request.isComplete());
    }

    @Test
    public void testIsCancelledAfterClear() {
        GenericRequest request = harness.getRequest();
        request.clear();

        assertTrue(request.isCancelled());
    }

    @Test
    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
        GenericRequest request = harness.getRequest();
        request.clear();
        request.clear();

        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
    }

    @Test
    public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Request request = (Request) invocation.getArguments()[0];
                assertFalse(request.isComplete());
                return true;
            }
        }).when(requestCoordinator).canSetImage(any(Request.class));

        harness.requestCoordinator = requestCoordinator;
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        verify(requestCoordinator).canSetImage(eq(request));
    }

    @Test
    public void testIsNotFailedWithoutException() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsFailedAfterException() {
        GenericRequest request = harness.getRequest();

        request.onException(new Exception("test"));
        assertTrue(request.isFailed());
    }

    @Test
    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onSizeReady(100, 100);
        request.onSizeReady(100, 100);

        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testIsFailedAfterNoResultAndNullException() {
        GenericRequest request = harness.getRequest();

        request.onException(null);
        assertTrue(request.isFailed());
    }

    @Test
    public void testEngineLoadPassedCorrectPriority() {
        Priority expected = Priority.HIGH;
        harness.priority = expected;
        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);

        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testEngineLoadCancelledOnCancel() {
        Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenReturn(loadStatus);

        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);
        request.cancel();

        verify(loadStatus).cancel();
    }

    @Test
    public void testResourceIsRecycledOnClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);
        request.clear();

        verify(harness.engine).release(eq(harness.resource));
    }

    @Test
    public void testPlaceholderResourceIsSet() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.placeholderResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableIsSet() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorResourceIsSetOnLoadFailed() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.errorResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableIsSetOnLoadFailed() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.errorDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void setTestPlaceholderDrawableSetOnNullModel() {
        Drawable placeholder = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(placeholder, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableSetOnNullModel() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(errorPlaceholder, target.currentPlaceholder);
    }

    @Test
    public void testIsNotRunningBeforeRunCalled() {
        assertFalse(harness.getRequest().isRunning());
    }

    @Test
    public void testIsRunningAfterRunCalled() {
        Request request = harness.getRequest();
        request.begin();
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterComplete() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onResourceReady(harness.resource);

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterFailing() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onException(new RuntimeException("Test"));

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterClear() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.clear();

        assertFalse(request.isRunning());
    }

    @Test
    public void testCallsTargetOnResourceReadyIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.target, never()).onResourceReady(any(List.class), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnExceptionIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        Exception exception = new IOException("test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(false);
        Exception exception = new IOException("Test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(true);

        request.onException(new IllegalArgumentException("test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testRequestListenerIsCalledWithResourceResult() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithModel() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), eq(harness.model), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithTarget() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
        final GenericRequest request = harness.getRequest();
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(),  any(DiskCacheStrategy.class),
                any(ResourceCallback.class))).thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        request.onResourceReady(harness.resource);
                        return null;
                    }
                });

        request.begin();
        request.onSizeReady(100, 100);
        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(true), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
        GenericRequest request = harness.getRequest();
        request.onSizeReady(100, 100);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(false), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
        harness.requestCoordinator = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(false));
    }

    @Test
    public void testTargetIsCalledWithAnimationFromFactory() {
        GenericRequest request = harness.getRequest();
        GlideAnimation<List> glideAnimation = mock(GlideAnimation.class);
        when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(glideAnimation);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), eq(glideAnimation));
    }

    @Test
    public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
        harness.overrideWidth = -1;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
        harness.overrideHeight = -1;
        harness.overrideWidth = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
        harness.overrideWidth = 100;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
        harness.overrideWidth = 1;
        harness.overrideHeight = 2;

        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(harness.overrideWidth), eq(harness.overrideHeight),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    @Test
    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
        harness.errorDrawable = new ColorDrawable(Color.RED);
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
        request.onException(new IOException("Test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testCanReRunCancelledRequests() {
        doAnswer(new CallSizeReady(100, 100)).when(harness.target)
                .getSize(any(SizeReadyCallback.class));
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenAnswer(new CallResourceCallback(harness.resource));
        GenericRequest request = harness.getRequest();

        request.begin();
        request.cancel();
        request.begin();

        verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testResourceOnlyReceivesOneGetOnResourceReady() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.resource, times(1)).get();
    }

    @Test
    public void testOnSizeReadyWithNullDataFetcherCallsOnException() {
        GenericRequest request = harness.getRequest();
        when(harness.modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt())).thenReturn(null);
        request.begin();
        request.onSizeReady(100, 100);

        verify(harness.requestListener).onException(any(Exception.class), any(Number.class), any(Target.class),
                anyBoolean());
    }

    @Test
    public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
        GenericRequest request = harness.getRequest();
        request.cancel();
        request.onSizeReady(100, 100);

        verify(harness.engine, never()).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testStartsLoadImmediatelyWhenGivenOverrideWithSizeOriginal() {
        harness.overrideWidth = Target.SIZE_ORIGINAL;
        harness.overrideHeight = Target.SIZE_ORIGINAL;
        GenericRequest<Number, Object, Object, List> request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(Target.SIZE_ORIGINAL), eq(Target.SIZE_ORIGINAL),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    private static class CallResourceCallback implements Answer {

        private Resource resource;

        public CallResourceCallback(Resource resource) {
            this.resource = resource;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            ResourceCallback cb = (ResourceCallback)
                    invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 1];
            cb.onResourceReady(resource);
            return null;
        }
    }

    private static class CallSizeReady implements Answer {

        private int width;
        private int height;

        public CallSizeReady(int width, int height) {
            this.width = width;
            this.height = height;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            SizeReadyCallback cb =
                    (SizeReadyCallback) invocationOnMock.getArguments()[0];
            cb.onSizeReady(width, height);
            return null;
        }
    }

    private Context mockContextToReturn(int resourceId, Drawable drawable) {
        Resources resources = mock(Resources.class);
        Context context = mock(Context.class);

        when(context.getApplicationContext()).thenReturn(context);
        when(context.getResources()).thenReturn(resources);
        when(resources.getDrawable(eq(resourceId))).thenReturn(drawable);

        return context;
    }

    private static class MockTarget implements Target {
        private Drawable currentPlaceholder;

        @Override
        public void onLoadCleared(Drawable placeholder) {
            currentPlaceholder = placeholder;
        }

        @Override
        public void onLoadStarted(Drawable placeholder) {
            currentPlaceholder = placeholder;

        }

        @Override
        public void onLoadFailed(Exception e, Drawable errorDrawable) {
            currentPlaceholder = errorDrawable;

        }

        @Override
        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
            currentPlaceholder = null;
        }


        @Override
        public void getSize(SizeReadyCallback cb) {
        }

        @Override
        public void setRequest(Request request) {
        }

        @Override
        public Request getRequest() {
            return null;
        }

        @Override
        public void onStart() {
        }

        @Override
        public void onStop() {

        }

        @Override
        public void onDestroy() {

        }
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoderTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.resource.bitmap;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.graphics.Bitmap;

import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.tests.Util;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class StreamBitmapDecoderTest {
    private DecoderHarness harness;

    @Before
    public void setUp() {
        harness = new DecoderHarness();
    }

    @Test
    public void testNonNullResourceIsReturned() {
        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
                eq(harness.height), eq(harness.decodeFormat))).thenReturn(harness.result);
        assertNotNull(harness.decode());
    }

    @Test
    public void testNullResourceIsReturnedForNullBitmap() {
        when(harness.downsampler.decode(eq(harness.source), eq(harness.bitmapPool), eq(harness.width),
                eq(harness.height), eq(harness.decodeFormat))).thenReturn(null);
        assertNull(harness.decode());
    }

    @Test
    public void testHasValidId() {
        String downsamplerId = "downsamplerId";
        when(harness.downsampler.getId()).thenReturn(downsamplerId);

        String actualId = harness.decoder.getId();
        assertThat(actualId).contains(downsamplerId);
        assertThat(actualId).contains(harness.decodeFormat.toString());
        assertThat(actualId).contains(Util.getExpectedClassId(StreamBitmapDecoder.class));
    }

    private static class DecoderHarness {
        Downsampler downsampler = mock(Downsampler.class);
        BitmapPool bitmapPool = mock(BitmapPool.class);
        DecodeFormat decodeFormat = DecodeFormat.PREFER_ARGB_8888;
        InputStream source = new ByteArrayInputStream(new byte[0]);
        int width = 100;
        int height = 100;
        Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        StreamBitmapDecoder decoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);

        public DecoderHarness() {
        }

        public Resource decode() {
            return decoder.decode(source, width, height);
        }

    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
=======
package com.bumptech.glide;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.MultiTransformation;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.UnitTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.ChildLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.FutureTarget;
import com.bumptech.glide.request.GenericRequest;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.RequestCoordinator;
import com.bumptech.glide.request.RequestFutureTarget;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.ThumbnailRequestCoordinator;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.animation.NoAnimation;
import com.bumptech.glide.request.animation.ViewAnimationFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
import com.bumptech.glide.request.target.PreloadTarget;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.signature.EmptySignature;
import com.bumptech.glide.util.Util;

import java.io.File;

/**
 * A generic class that can handle setting options and staring loads for generic resource types.
 *
 * @param <ModelType> The type of model representing the resource.
 * @param <DataType> The data type that the resource {@link com.bumptech.glide.load.model.ModelLoader} will provide that
 *                  can be decoded by the {@link com.bumptech.glide.load.ResourceDecoder}.
 * @param <ResourceType> The type of the resource that will be loaded.
 * @param <TranscodeType> The type of resource the decoded resource will be transcoded to.
 */
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable {
    protected final Class<ModelType> modelClass;
    protected final Context context;
    protected final Glide glide;
    protected final Class<TranscodeType> transcodeClass;
    protected final RequestTracker requestTracker;
    protected final Lifecycle lifecycle;
    private ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider;

    private ModelType model;
    private Key signature = EmptySignature.obtain();
    // model may occasionally be null, so to enforce that load() was called, set a boolean rather than relying on model
    // not to be null.
    private boolean isModelSet;
    private int placeholderId;
    private int errorId;
    private RequestListener<? super ModelType, TranscodeType> requestListener;
    private Float thumbSizeMultiplier;
    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
    private Float sizeMultiplier = 1f;
    private Drawable placeholderDrawable;
    private Drawable errorPlaceholder;
    private Priority priority = null;
    private boolean isCacheable = true;
    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
    private int overrideHeight = -1;
    private int overrideWidth = -1;
    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
    private Transformation<ResourceType> transformation = UnitTransformation.get();
    private boolean isTransformationSet;
    private boolean isThumbnailBuilt;

    GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        this(other.context, other.modelClass, loadProvider, transcodeClass, other.glide, other.requestTracker,
                other.lifecycle);
        this.model = other.model;
        this.isModelSet = other.isModelSet;
        this.signature = other.signature;
        this.diskCacheStrategy = other.diskCacheStrategy;
        this.isCacheable = other.isCacheable;
    }

    GenericRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {
        this.context = context;
        this.modelClass = modelClass;
        this.transcodeClass = transcodeClass;
        this.glide = glide;
        this.requestTracker = requestTracker;
        this.lifecycle = lifecycle;
        this.loadProvider = loadProvider != null
                ? new ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType>(loadProvider) : null;

        if (context == null) {
            throw new NullPointerException("Context can't be null");
        }
        if (modelClass != null && loadProvider == null) {
            throw new NullPointerException("LoadProvider must not be null");
        }
    }

    /**
     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before this request.
     * Best used for loading thumbnail resources that are smaller and will be loaded more quickly than the full size
     * resource. There are no guarantees about the order in which the requests will actually finish. However, if the
     * thumb request completes after the full request, the thumb resource will never replace the full resource.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        if (this.equals(thumbnailRequest)) {
            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
                    + "clone() on the request you are passing to thumbnail()");
        }
        this.thumbnailRequestBuilder = thumbnailRequest;

        return this;
    }

    /**
     * Loads a resource in an identical manner to this request except with the dimensions of the target multiplied
     * by the given size multiplier. If the thumbnail load completes before the fullsize load, the thumbnail will
     * be shown. If the thumbnail load completes afer the fullsize load, the thumbnail will not be shown.
     *
     * <p>
     *     Note - The thumbnail resource will be smaller than the size requested so the target (or {@link ImageView})
     *     must be able to scale the thumbnail appropriately. See {@link android.widget.ImageView.ScaleType}.
     * </p>
     *
     * <p>
     *     Almost all options will be copied from the original load, including the
     *     {@link com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder}, and
     *     {@link Transformation}s. However, {@link #placeholder(int)} and {@link #error(int)},
     *     and {@link #listener(RequestListener)} will only be used on the fullsize load and will not be copied for
     *     the thumbnail load.
     * </p>
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.thumbSizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Applies a multiplier to the {@link Target}'s size before loading the resource. Useful for loading thumbnails
     * or trying to avoid loading huge resources (particularly {@link android.graphics.Bitmap}s on devices with overly
     * dense screens.
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sizeMultiplier(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.sizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the original data.
     * By default, this decoder will only be used if the final transformed resource is not in the disk cache.
     *
     * @see #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param decoder The {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> decoder(
            ResourceDecoder<DataType, ResourceType> decoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setSourceDecoder(decoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the disk cache. By
     * default, this decoder will only be used if the final transformed resource is already in the disk cache.
     *
     * @see #decoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param cacheDecoder The decoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> cacheDecoder(
            ResourceDecoder<File, ResourceType> cacheDecoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setCacheDecoder(cacheDecoder);
        }

        return this;
    }

    /**
     * Sets the source encoder to use to encode the data retrieved by this request directly into cache. The returned
     * resource will then be decoded from the cached data.
     *
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param sourceEncoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sourceEncoder(
            Encoder<DataType> sourceEncoder) {
        if (loadProvider != null) {
            loadProvider.setSourceEncoder(sourceEncoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.
     *
     * <p>
     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal.
     *     Applications that use the same resource multiple times in multiple sizes and are willing to trade off some
     *     speed and disk space in return for lower bandwidth usage may want to consider using
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should
     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}.
     * </p>
     *
     * @param strategy The strategy to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(
            DiskCacheStrategy strategy) {
        this.diskCacheStrategy = strategy;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.Encoder} to use to encode the original data directly to cache. Will only
     * be used if the original data is not already in cache and if the
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} is set to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}.
     *
     * @see #sourceEncoder(com.bumptech.glide.load.Encoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param encoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> encoder(
            ResourceEncoder<ResourceType> encoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the encoder.
        if (loadProvider != null) {
            loadProvider.setEncoder(encoder);
        }

        return this;
    }

    /**
     * Sets the priority for this load.
     *
     * @param priority A priority.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> priority(
            Priority priority) {
        this.priority = priority;

        return this;
    }

    /**
     * Transform resources with the given {@link Transformation}s. Replaces any existing transformation or
     * transformations.
     *
     * @param transformations the transformations to apply in order.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transform(
            Transformation<ResourceType>... transformations) {
        isTransformationSet = true;
        if (transformations.length == 1) {
            transformation = transformations[0];
        } else {
            transformation = new MultiTransformation<ResourceType>(transformations);
        }

        return this;
    }

    /**
     * Removes the current {@link com.bumptech.glide.load.Transformation}.
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontTransform() {
        Transformation<ResourceType> transformation = UnitTransformation.get();
        return transform(transformation);
    }

    /**
     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use for this load.
     *
     * @see com.bumptech.glide.load.resource.transcode.UnitTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder
     *
     * @param transcoder The transcoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcoder(
            ResourceTranscoder<ResourceType, TranscodeType> transcoder) {
        if (loadProvider != null) {
            loadProvider.setTranscoder(transcoder);
        }

        return this;
    }

    /**
     * Removes any existing animation set on the builder. Will be overridden by subsequent calls that set an animation.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontAnimate() {
        GlideAnimationFactory<TranscodeType> animation = NoAnimation.getFactory();
        return animate(animation);
    }

    /**
     * Sets an animation to run on the wrapped target when an resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @param animationId The resource id of the animation to run
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
    }

    /**
     * Sets an animation to run on the wrapped target when a resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @see #animate(int)
     * @see #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)
     *
     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
     * views animating repeatedly. Use {@link #animate(int)} or
     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
     * Glide 4.0.
     * @param animation The animation to run
     * @return This request builder.
     */
    @Deprecated
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
        return animate(new ViewAnimationFactory<TranscodeType>(animation));
    }

    /**
     * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target may be wrapping
     * when a resource load finishes. Will only be run if the load was loaded asynchronously (ie was not in the
     * memory cache).
     *
     * @param animator The {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} to run.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            ViewPropertyAnimation.Animator animator) {
        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
    }

    GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            GlideAnimationFactory<TranscodeType> animationFactory) {
        if (animationFactory == null) {
            throw new NullPointerException("Animation factory must not be null!");
        }
        this.animationFactory = animationFactory;

        return this;
    }

    /**
     * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resourceto display while a resource
     * is loading.
     *
     * @param resourceId The id of the resource to use as a placeholder
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            int resourceId) {
        this.placeholderId = resourceId;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            Drawable drawable) {
        this.placeholderDrawable = drawable;

        return this;
    }

    /**
     * Sets a resource to display if a load fails.
     *
     * @param resourceId The id of the resource to use as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            int resourceId) {
        this.errorId = resourceId;

        return this;
    }

    /**
     * Sets a {@link Drawable} to display if a load fails.
     *
     * @param drawable The drawable to display.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            Drawable drawable) {
        this.errorPlaceholder = drawable;

        return this;
    }

    /**
     * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single instance of an
     * exception handler per type of request (usually activity/fragment) rather than pass one in per request to
     * avoid some redundant object allocation.
     *
     * @param requestListener The request listener to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        this.requestListener = requestListener;

        return this;
    }

    /**
     * Allows the loaded resource to skip the memory cache.
     *
     * <p>
     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not
     *     also skipping the memory cache, the resource will be cached in memory.
     * </p>
     *
     * @param skip True to allow the resource to skip the memory cache.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {
        this.isCacheable = !skip;

        return this;
    }

    /**
     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for
     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
     *
     * @param width The width in pixels to use to load the resource.
     * @param height The height in pixels to use to load the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
        if (!Util.isValidDimensions(width, height)) {
            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");
        }
        this.overrideWidth = width;
        this.overrideHeight = height;

        return this;
    }

    /**
     * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over
     * when cached data is invalidated.
     *
     * <p>
     *     Note - The signature does not replace the cache key, it is purely additive.
     * </p>
     *
     * @see com.bumptech.glide.signature.StringSignature
     *
     * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current state of the
     *                  model that will be mixed in to the cache key.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> signature(Key signature) {
        if (signature == null) {
            throw new NullPointerException("Signature must not be null");
        }
        this.signature = signature;
        return this;
    }

    /**
     * Sets the specific model to load data for.
     *
     * <p>
     *      This method must be called at least once before {@link #into(com.bumptech.glide.request.target.Target)} is
     *      called.
     * </p>
     *
     * @param model The model to load data for, or null.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {
        this.model = model;
        isModelSet = true;
        return this;
    }

    /**
     * Returns a copy of this request builder with all of the options set so far on this builder.
     *
     * <p>
     *     This method returns a "deep" copy in that all non-immutable arguments are copied such that changes to one
     *     builder will not affect the other builder. However, in addition to immutable arguments, the current model
     *     is not copied copied so changes to the model will affect both builders.
     * </p>
     */
    @SuppressWarnings("unchecked")
    @Override
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone() {
        try {
            GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone =
                    (GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>) super.clone();
            clone.loadProvider = loadProvider != null ? loadProvider.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Set the target the resource will be loaded into.
     *
     * @see Glide#clear(com.bumptech.glide.request.target.Target)
     *
     * @param target The target to load the resource into.
     * @return The given target.
     */
    public <Y extends Target<TranscodeType>> Y into(Y target) {
        Util.assertMainThread();
        if (target == null) {
            throw new IllegalArgumentException("You must pass in a non null Target");
        }
        if (!isModelSet) {
            throw new IllegalArgumentException("You must first set a model (try #load())");
        }

        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        Request request = buildRequest(target);
        target.setRequest(request);
        lifecycle.addListener(target);
        requestTracker.runRequest(request);

        return target;
    }

    /**
     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into the view, and frees
     * any resources Glide may have previously loaded into the view so they may be reused.
     *
     * @see Glide#clear(android.view.View)
     *
     * @param view The view to cancel previous loads for and load the new resource into.
     * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
     */
    public Target<TranscodeType> into(ImageView view) {
        Util.assertMainThread();
        if (view == null) {
            throw new IllegalArgumentException("You must pass in a non null View");
        }

        if (!isTransformationSet && view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                //$CASES-OMITTED$
                default:
                    // Do nothing.
            }
        }

        return into(glide.buildImageViewTarget(view, transcodeClass));
    }

    /**
     * Returns a future that can be used to do a blocking get on a background thread.
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     *
     * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
     *
     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
     *         resource in a blocking manner.
     */
    public FutureTarget<TranscodeType> into(int width, int height) {
        final RequestFutureTarget<ModelType, TranscodeType> target =
                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);

        // TODO: Currently all loads must be started on the main thread...
        glide.getMainHandler().post(new Runnable() {
            @Override
            public void run() {
                if (!target.isCancelled()) {
                    into(target);
                }
            }
        });

        return target;
    }

    /**
     * Preloads the resource into the cache using the given width and height.
     *
     * <p>
     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are
     *     available quickly.
     * </p>
     *
     *
     * @see com.bumptech.glide.ListPreloader
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload(int width, int height) {
        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
        return into(target);
    }

    /**
     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and height.
     * Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as the width and height.
     *
     * @see #preload(int, int)
     *
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload() {
        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
    }

    void applyCenterCrop() {
        // To be implemented by subclasses when possible.
    }

    void applyFitCenter() {
        // To be implemented by subclasses when possible.
    }

    private Priority getThumbnailPriority() {
        final Priority result;
        if (priority == Priority.LOW) {
            result = Priority.NORMAL;
        } else if (priority == Priority.NORMAL) {
            result = Priority.HIGH;
        } else {
            result = Priority.IMMEDIATE;
        }
        return result;
    }

    private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        isThumbnailBuilt = false;
        return buildRequestRecursive(target, null);
    }

    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }

    private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
            RequestCoordinator requestCoordinator) {
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_f389e91_431ccaf/rev_f389e91-431ccaf/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
=======
package com.bumptech.glide.request;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.util.LogTime;
import com.bumptech.glide.util.Util;

import java.util.Queue;

/**
 * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given {@link Target}.
 *
 * @param <A> The type of the model that the resource will be loaded from.
 * @param <T> The type of the data that the resource will be loaded from.
 * @param <Z> The type of the resource that will be loaded.
 * @param <R> The type of the resource that will be transcoded from the loaded resource.
 */
public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,
        ResourceCallback {
    private static final String TAG = "GenericRequest";
    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);
    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);

    private enum Status {
        /** Created but not yet running. */
        PENDING,
        /** In the process of fetching media. */
        RUNNING,
        /** Waiting for a callback given to the Target to be called to determine target dimensions. */
        WAITING_FOR_SIZE,
        /** Finished loading media successfully. */
        COMPLETE,
        /** Failed to load media, may be restarted. */
        FAILED,
        /** Cancelled by the user, may not be restarted. */
        CANCELLED,
        /** Cleared by the user with a placeholder set, may not be restarted. */
        CLEARED,
        /** Temporarily paused by the system, may be restarted. */
        PAUSED,
    }

    private final String tag = String.valueOf(hashCode());

    private Key signature;
    private int placeholderResourceId;
    private int errorResourceId;
    private Context context;
    private Transformation<Z> transformation;
    private LoadProvider<A, T, Z, R> loadProvider;
    private RequestCoordinator requestCoordinator;
    private A model;
    private Class<R> transcodeClass;
    private boolean isMemoryCacheable;
    private Priority priority;
    private Target<R> target;
    private RequestListener<? super A, R> requestListener;
    private float sizeMultiplier;
    private Engine engine;
    private GlideAnimationFactory<R> animationFactory;
    private int overrideWidth;
    private int overrideHeight;
    private DiskCacheStrategy diskCacheStrategy;

    private Drawable placeholderDrawable;
    private Drawable errorDrawable;
    private boolean loadedFromMemoryCache;
    // doing our own type check
    private Resource<?> resource;
    private Engine.LoadStatus loadStatus;
    private long startTime;
    private Status status;

    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        @SuppressWarnings("unchecked")
        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
        if (request == null) {
            request = new GenericRequest<A, T, Z, R>();
        }
        request.init(loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderResourceId,
                errorDrawable,
                errorResourceId,
                requestListener,
                requestCoordinator,
                engine,
                transformation,
                transcodeClass,
                isMemoryCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
        return request;
    }

    private GenericRequest() {
        // just create, instances are reused with recycle/init
    }

    @Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }

    private void init(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        this.loadProvider = loadProvider;
        this.model = model;
        this.signature = signature;
        this.context = context.getApplicationContext();
        this.priority = priority;
        this.target = target;
        this.sizeMultiplier = sizeMultiplier;
        this.placeholderDrawable = placeholderDrawable;
        this.placeholderResourceId = placeholderResourceId;
        this.errorDrawable = errorDrawable;
        this.errorResourceId = errorResourceId;
        this.requestListener = requestListener;
        this.requestCoordinator = requestCoordinator;
        this.engine = engine;
        this.transformation = transformation;
        this.transcodeClass = transcodeClass;
        this.isMemoryCacheable = isMemoryCacheable;
        this.animationFactory = animationFactory;
        this.overrideWidth = overrideWidth;
        this.overrideHeight = overrideHeight;
        this.diskCacheStrategy = diskCacheStrategy;
        status = Status.PENDING;

        // We allow null models by just setting an error drawable. Null models will always have empty providers, we
        // simply skip our sanity checks in that unusual case.
        if (model != null) {
            check("ModelLoader", loadProvider.getModelLoader(), "try .using(ModelLoader)");
            check("Transcoder", loadProvider.getTranscoder(), "try .as*(Class).transcode(ResourceTranscoder)");
            check("Transformation", transformation, "try .transform(UnitTransformation.get())");
            if (diskCacheStrategy.cacheSource()) {
                check("SourceEncoder", loadProvider.getSourceEncoder(),
                        "try .sourceEncoder(Encoder) or .diskCacheStrategy(NONE/RESULT)");
            } else {
                check("SourceDecoder", loadProvider.getSourceDecoder(),
                        "try .decoder/.imageDecoder/.videoDecoder(ResourceDecoder) or .diskCacheStrategy(ALL/SOURCE)");
            }
            if (diskCacheStrategy.cacheSource() || diskCacheStrategy.cacheResult()) {
                // TODO if(resourceClass.isAssignableFrom(InputStream.class) it is possible to wrap sourceDecoder
                // and use it instead of cacheDecoder: new FileToStreamDecoder<Z>(sourceDecoder)
                // in that case this shouldn't throw
                check("CacheDecoder", loadProvider.getCacheDecoder(),
                        "try .cacheDecoder(ResouceDecoder) or .diskCacheStrategy(NONE)");
            }
            if (diskCacheStrategy.cacheResult()) {
                check("Encoder", loadProvider.getEncoder(),
                        "try .encode(ResourceEncoder) or .diskCacheStrategy(NONE/SOURCE)");
            }
        }
    }

    private static void check(String name, Object object, String suggestion) {
        if (object == null) {
            StringBuilder message = new StringBuilder(name);
            message.append(" must not be null");
            if (suggestion != null) {
                message.append(", ");
                message.append(suggestion);
            }
            throw new NullPointerException(message.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }

    /**
     * Cancels the current load but does not release any resources held by the request and continues to display
     * the loaded resource if the load completed before the call to cancel.
     *
     * <p>
     *     Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
     * </p>
     *
     * @see #clear()
     */
    void cancel() {
        status = Status.CANCELLED;
        if (loadStatus != null) {
            loadStatus.cancel();
            loadStatus = null;
        }
    }

    /**
     * Cancels the current load if it is in progress, clears any resources held onto by the request and replaces
     * the loaded resource if the load completed with the placeholder.
     *
     * <p>
     *     Cleared requests can be restarted with a subsequent call to {@link #begin()}
     * </p>
     *
     * @see #cancel()
     */
    @Override
    public void clear() {
        Util.assertMainThread();
        if (status == Status.CLEARED) {
            return;
        }
        cancel();
        // Resource must be released before canNotifyStatusChanged is called.
        if (resource != null) {
            releaseResource(resource);
        }
        if (canNotifyStatusChanged()) {
            target.onLoadCleared(getPlaceholderDrawable());
        }
        // Must be after cancel().
        status = Status.CLEARED;
    }

    @Override
    public boolean isPaused() {
        return status == Status.PAUSED;
    }

    @Override
    public void pause() {
        clear();
        status = Status.PAUSED;
    }

    private void releaseResource(Resource resource) {
        engine.release(resource);
        this.resource = null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isRunning() {
        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isComplete() {
        return status == Status.COMPLETE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isResourceSet() {
        return isComplete();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isCancelled() {
        return status == Status.CANCELLED || status == Status.CLEARED;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = getErrorDrawable();
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }

    private Drawable getErrorDrawable() {
        if (errorDrawable == null && errorResourceId > 0) {
            errorDrawable = context.getResources().getDrawable(errorResourceId);
        }
        return errorDrawable;
    }

    private Drawable getPlaceholderDrawable() {
        if (placeholderDrawable == null && placeholderResourceId > 0) {
            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
        }
        return placeholderDrawable;
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Got null fetcher from model loader"));
            return;
        }
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }

    private boolean canSetResource() {
        return requestCoordinator == null || requestCoordinator.canSetImage(this);
    }

    private boolean canNotifyStatusChanged() {
        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
    }

    private boolean isFirstReadyResource() {
        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
    }

    private void notifyLoadSuccess() {
      if (requestCoordinator != null) {
        requestCoordinator.onRequestSuccess(this);
      }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void onResourceReady(Resource<?> resource) {
        if (resource == null) {
            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
                    + " inside, but instead got null."));
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            onException(new Exception("Expected to receive an object of " + transcodeClass
                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
                    + " inside Resource{" + resource + "}."
                    + (received != null ? "" : " "
                        + "To indicate failure return a null Resource object, "
                        + "rather than a Resource object containing null data.")
            ));
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't set the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady(resource, (R) received);
    }

    /**
     * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
     *
     * @param resource original {@link Resource}, never <code>null</code>
     * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
     */
    private void onResourceReady(Resource<?> resource, R result) {
        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstReadyResource())) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstReadyResource());
            target.onResourceReady(result, animation);
        }

        status = Status.COMPLETE;
        this.resource = resource;
        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onException(Exception e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, "load failed", e);
        }

        status = Status.FAILED;
        //TODO: what if this is a thumbnail request?
        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {
            setErrorPlaceholder(e);
        }
    }

    private void logV(String message) {
        Log.v(TAG, message + " this: " + tag);
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/MainActivity.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;
import static com.bumptech.glide.request.RequestOptions.placeholderOf;

import android.app.Activity;
import android.content.ContentResolver;
import android.graphics.drawable.PictureDrawable;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.ImageView;
import android.widget.TextView;

import com.bumptech.glide.Glide;
import com.bumptech.glide.RequestBuilder;

import java.io.File;

/**
 * Displays an SVG image loaded from an android raw resource.
 */
public class MainActivity extends Activity {
  private static final String TAG = "SVGActivity";

  private ImageView imageViewRes;
  private ImageView imageViewNet;
  private RequestBuilder<PictureDrawable> requestBuilder;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);
    imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);

    requestBuilder = Glide.with(this)
        .as(PictureDrawable.class)
        .apply(placeholderOf(R.drawable.image_loading)
            .error(R.drawable.image_error))
        .transition(withCrossFade())
        .listener(new SvgSoftwareLayerSetter());
  }

  @Override
  protected void onStart() {
    super.onStart();
    reload();
  }

  public void clearCache(View v) {
    Log.w(TAG, "clearing cache");
    Glide.with(this).clear(imageViewRes);
    Glide.with(this).clear(imageViewNet);
    Glide.get(this).clearMemory();
    File cacheDir = Glide.getPhotoCacheDir(this);
    if (cacheDir.isDirectory()) {
      for (File child : cacheDir.listFiles()) {
        if (!child.delete()) {
          Log.w(TAG, "cannot delete: " + child);
        }
      }
    }
    reload();
  }

  public void cycleScaleType(View v) {
    ImageView.ScaleType curr = imageViewRes.getScaleType();
    Log.w(TAG, "cycle: current=" + curr);
    ImageView.ScaleType[] all = ImageView.ScaleType.values();
    int nextOrdinal = (curr.ordinal() + 1) % all.length;
    ImageView.ScaleType next = all[nextOrdinal];
    Log.w(TAG, "cycle: next=" + next);
    imageViewRes.setScaleType(next);
    imageViewNet.setScaleType(next);
    reload();
  }

  private void reload() {
    Log.w(TAG, "reloading");
    ((TextView) findViewById(R.id.button))
        .setText(getString(R.string.scaleType, imageViewRes.getScaleType()));
    loadRes();
    loadNet();
  }

  private void loadRes() {
    Uri uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getPackageName() + "/"
        + R.raw.android_toy_h);
    requestBuilder.load(uri).into(imageViewRes);
  }

  private void loadNet() {
    Uri uri = Uri.parse("http://www.clker.com/cliparts/u/Z/2/b/a/6/android-toy-h.svg");
    requestBuilder.load(uri).into(imageViewNet);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDrawableTranscoder.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import android.graphics.Picture;
import android.graphics.drawable.PictureDrawable;

import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.resource.SimpleResource;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.caverock.androidsvg.SVG;

/**
 * Convert the {@link SVG}'s internal representation to an Android-compatible one
 * ({@link Picture}).
 */
public class SvgDrawableTranscoder implements ResourceTranscoder<SVG, PictureDrawable> {
  @Override
  public Resource<PictureDrawable> transcode(Resource<SVG> toTranscode) {
    SVG svg = toTranscode.get();
    Picture picture = svg.renderToPicture();
    PictureDrawable drawable = new PictureDrawable(picture);
    return new SimpleResource<PictureDrawable>(drawable);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgDecoder.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import com.bumptech.glide.load.Options;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.resource.SimpleResource;
import com.caverock.androidsvg.SVG;
import com.caverock.androidsvg.SVGParseException;

import java.io.IOException;
import java.io.InputStream;

/**
 * Decodes an SVG internal representation from an {@link InputStream}.
 */
public class SvgDecoder implements ResourceDecoder<InputStream, SVG> {

  @Override
  public boolean handles(InputStream source, Options options) throws IOException {
    // TODO: Can we tell?
    return true;
  }

  public Resource<SVG> decode(InputStream source, int width, int height, Options options)
      throws IOException {
    try {
      SVG svg = SVG.getFromInputStream(source);
      return new SimpleResource<SVG>(svg);
    } catch (SVGParseException ex) {
      throw new IOException("Cannot load SVG from stream", ex);
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/samples/svg/src/main/java/com/bumptech/svgsample/app/SvgSoftwareLayerSetter.java;<<<<<<< MINE
=======
package com.bumptech.svgsample.app;

import android.annotation.TargetApi;
import android.graphics.drawable.PictureDrawable;
import android.os.Build;
import android.widget.ImageView;

import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.target.ImageViewTarget;
import com.bumptech.glide.request.target.Target;

/**
 * Listener which updates the {@link ImageView} to be software rendered, because
 * {@link com.caverock.androidsvg.SVG SVG}/{@link android.graphics.Picture Picture} can't render on
 * a hardware backed {@link android.graphics.Canvas Canvas}.
 */
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public class SvgSoftwareLayerSetter implements RequestListener<PictureDrawable> {

  @Override
  public boolean onLoadFailed(Object model, Target<PictureDrawable> target,
      boolean isFirstResource) {
    ImageView view = ((ImageViewTarget<?>) target).getView();
    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
      view.setLayerType(ImageView.LAYER_TYPE_NONE, null);
    }
    return false;
  }

  @Override
  public boolean onResourceReady(PictureDrawable resource, Object model,
      Target<PictureDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
    ImageView view = ((ImageViewTarget<?>) target).getView();
    if (Build.VERSION_CODES.HONEYCOMB <= Build.VERSION.SDK_INT) {
      view.setLayerType(ImageView.LAYER_TYPE_SOFTWARE, null);
    }
    return false;
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java;<<<<<<< MINE
package com.bumptech.glide.request;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyBoolean;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class GenericRequestTest {
    private RequestHarness harness;

    /**
     * {@link Number} and {@link List} are arbitrarily chosen types to test some type safety as well.
     * Both are in the middle of the hierarchy having multiple descendants and ancestors.
     */
    @SuppressWarnings("unchecked")
    private static class RequestHarness {
        ModelLoader<Number, Object> modelLoader;
        Engine engine = mock(Engine.class);
        Number model = 123456;
        Target<List> target = mock(Target.class);
        Context context = Robolectric.application;
        Resource<List> resource = mock(Resource.class);
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        Priority priority = Priority.NORMAL;
        int placeholderResourceId = 0;
        Drawable placeholderDrawable = null;
        int errorResourceId = 0;
        Drawable fallbackDrawable = null;
        int fallbackResourceId = 0;
        Transformation transformation = mock(Transformation.class);
        Drawable errorDrawable = null;
        LoadProvider<Number, Object, Object, List> loadProvider = mock(LoadProvider.class);
        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);
        ResourceDecoder<Object, Object> sourceDecoder = mock(ResourceDecoder.class);
        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);
        ResourceTranscoder transcoder = mock(ResourceTranscoder.class);
        Encoder<Object> sourceEncoder = mock(Encoder.class);
        RequestListener<Number, List> requestListener = mock(RequestListener.class);
        boolean skipMemoryCache;
        GlideAnimationFactory<List> factory = mock(GlideAnimationFactory.class);
        int overrideWidth = -1;
        int overrideHeight = -1;
        List result = new ArrayList();
        DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
        Key signature = mock(Key.class);

        public RequestHarness() {
            modelLoader = mock(ModelLoader.class);
            when(modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt()))
                    .thenReturn(mock(DataFetcher.class));
            when(loadProvider.getModelLoader()).thenReturn(modelLoader);
            when(loadProvider.getCacheDecoder()).thenReturn(cacheDecoder);
            when(loadProvider.getSourceDecoder()).thenReturn(sourceDecoder);
            when(loadProvider.getSourceEncoder()).thenReturn(sourceEncoder);
            when(loadProvider.getEncoder()).thenReturn(encoder);
            when(loadProvider.getTranscoder()).thenReturn(transcoder);
            when(requestCoordinator.canSetImage(any(Request.class))).thenReturn(true);
            when(requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(true);

            when(resource.get()).thenReturn(result);
        }

        public GenericRequest<Number, Object, Object, List> getRequest() {
            return GenericRequest.obtain(loadProvider,
                    model,
                    signature,
                    context,
                    priority,
                    target,
                    1f,
                    placeholderDrawable,
                    placeholderResourceId,
                    errorDrawable,
                    errorResourceId,
                    fallbackDrawable,
                    fallbackResourceId,
                    requestListener,
                    requestCoordinator,
                    engine,
                    transformation,
                    List.class,
                    skipMemoryCache,
                    factory,
                    overrideWidth,
                    overrideHeight,
                    diskCacheStrategy);
        }
    }

    @Before
    public void setUp() {
        harness = new RequestHarness();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingCacheDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testReturnsWhenMissingCacheDecoderAndNeeded3() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingCacheDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getCacheDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceDecoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceDecoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceDecoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected =  NullPointerException.class)
    public void testThrowsWhenMissingEncoderWhenNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingEncoderWhenNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenMissingTranscoder() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getTranscoder()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testThrowsWhenMissingModelLoader() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            when(harness.loadProvider.getModelLoader()).thenReturn(null);

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.SOURCE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test(expected = NullPointerException.class)
    public void testThrowsWhenMissingSourceEncoderAndNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.ALL;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        harness.getRequest();
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded1() {
        harness.diskCacheStrategy = DiskCacheStrategy.RESULT;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testReturnsWhenMissingSourceEncoderAndNotNeeded2() {
        harness.diskCacheStrategy = DiskCacheStrategy.NONE;
        when(harness.loadProvider.getSourceEncoder()).thenReturn(null);

        assertNotNull(harness.getRequest());
    }

    @Test
    public void testThrowsWhenTransformationIsNull() {
        for (DiskCacheStrategy strategy : DiskCacheStrategy.values()) {
            harness = new RequestHarness();
            harness.diskCacheStrategy = strategy;
            harness.transformation = null;

            try {
                harness.getRequest();
                fail(NullPointerException.class.getSimpleName() + " expected for " + strategy);
            } catch (NullPointerException ex) {
                // expected
            }
        }
    }

    @Test
    public void testIsNotCompleteBeforeReceivingResource() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isComplete());
    }

    @Test
    public void testCanHandleNullResources() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);

        assertTrue(request.isFailed());
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }

    @Test
    public void testCanHandleEmptyResources() {
        GenericRequest request = harness.getRequest();
        when(harness.resource.get()).thenReturn(null);

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean());
    }

    @Test
    public void testCanHandleNonConformingResources() {
        GenericRequest request = harness.getRequest();
        when(((Resource) (harness.resource)).get()).thenReturn("Invalid mocked String, this should be a List");

        request.onResourceReady(harness.resource);

        assertTrue(request.isFailed());
        verify(harness.engine).release(eq(harness.resource));
        verify(harness.requestListener)
                .onException(any(Exception.class), any(Number.class), eq(harness.target),
                    anyBoolean());
    }

    @Test
    public void testIsNotFailedAfterClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.clear();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsPausedAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertTrue(request.isPaused());
    }

    @Test
    public void testIsNotCancelledAfterPause() {
        GenericRequest request = harness.getRequest();
        request.pause();

        assertFalse(request.isCancelled());
    }

    @Test
    public void testIsNotPausedAfterBeginningWhilePaused() {
        GenericRequest request = harness.getRequest();
        request.pause();
        request.begin();

        assertFalse(request.isPaused());
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotFailedAfterBegin() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(null);
        request.begin();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsCompleteAfterReceivingResource() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        assertTrue(request.isComplete());
    }

    @Test
    public void testIsNotCompleteAfterClear() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);
        request.clear();

        assertFalse(request.isComplete());
    }

    @Test
    public void testIsCancelledAfterClear() {
        GenericRequest request = harness.getRequest();
        request.clear();

        assertTrue(request.isCancelled());
    }

    @Test
    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {
        GenericRequest request = harness.getRequest();
        request.clear();
        request.clear();

        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));
    }

    @Test
    public void testResourceIsNotCompleteWhenAskingCoordinatorIfCanSetImage() {
        RequestCoordinator requestCoordinator = mock(RequestCoordinator.class);
        doAnswer(new Answer() {
            @Override
            public Object answer(InvocationOnMock invocation) throws Throwable {
                Request request = (Request) invocation.getArguments()[0];
                assertFalse(request.isComplete());
                return true;
            }
        }).when(requestCoordinator).canSetImage(any(Request.class));

        harness.requestCoordinator = requestCoordinator;
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);

        verify(requestCoordinator).canSetImage(eq(request));
    }

    @Test
    public void testIsNotFailedWithoutException() {
        GenericRequest request = harness.getRequest();

        assertFalse(request.isFailed());
    }

    @Test
    public void testIsFailedAfterException() {
        GenericRequest request = harness.getRequest();

        request.onException(new Exception("test"));
        assertTrue(request.isFailed());
    }

    @Test
    public void testIgnoresOnSizeReadyIfNotWaitingForSize() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onSizeReady(100, 100);
        request.onSizeReady(100, 100);

        verify(harness.engine, times(1)).load(eq(harness.signature), eq(100), eq(100),
            any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
            any(ResourceTranscoder.class), any(Priority.class), anyBoolean(),
            any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testIsFailedAfterNoResultAndNullException() {
        GenericRequest request = harness.getRequest();

        request.onException(null);
        assertTrue(request.isFailed());
    }

    @Test
    public void testEngineLoadPassedCorrectPriority() {
        Priority expected = Priority.HIGH;
        harness.priority = expected;
        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);

        verify(harness.engine).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
            any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
            eq(expected), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testEngineLoadCancelledOnCancel() {
        Engine.LoadStatus loadStatus = mock(Engine.LoadStatus.class);
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenReturn(loadStatus);

        GenericRequest request = harness.getRequest();
        request.begin();

        request.onSizeReady(100, 100);
        request.cancel();

        verify(loadStatus).cancel();
    }

    @Test
    public void testResourceIsRecycledOnClear() {
        GenericRequest request = harness.getRequest();

        request.onResourceReady(harness.resource);
        request.clear();

        verify(harness.engine).release(eq(harness.resource));
    }

    @Test
    public void testPlaceholderResourceIsSet() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.placeholderResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableIsSet() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();
        request.begin();

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorResourceIsSetOnLoadFailed() {
        final int expectedId = 12345;
        Drawable expected = new ColorDrawable(Color.RED);

        Context context = mockContextToReturn(expectedId, expected);
        MockTarget target = new MockTarget();

        harness.context = context;
        harness.errorResourceId = expectedId;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableIsSetOnLoadFailed() {
        Drawable expected = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.errorDrawable = expected;
        harness.target = target;
        GenericRequest request = harness.getRequest();

        request.onException(null);

        assertEquals(expected, target.currentPlaceholder);
    }

    @Test
    public void testPlaceholderDrawableSetOnNullModelWithNoErrorDrawable() {
        Drawable placeholder = new ColorDrawable(Color.RED);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(placeholder, target.currentPlaceholder);
    }

    @Test
    public void testErrorDrawableSetOnNullModelWithErrorDrawable() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(errorPlaceholder, target.currentPlaceholder);
    }

    @Test
    public void testFallbackDrawableSetOnNullModelWithErrorAndFallbackDrawables() {
        Drawable placeholder = new ColorDrawable(Color.RED);
        Drawable errorPlaceholder = new ColorDrawable(Color.GREEN);
        Drawable fallback = new ColorDrawable(Color.BLUE);

        MockTarget target = new MockTarget();

        harness.placeholderDrawable = placeholder;
        harness.errorDrawable = errorPlaceholder;
        harness.fallbackDrawable = fallback;
        harness.target = target;
        harness.model = null;
        GenericRequest request = harness.getRequest();

        request.begin();

        assertEquals(fallback, target.currentPlaceholder);
    }

    @Test
    public void testIsNotRunningBeforeRunCalled() {
        assertFalse(harness.getRequest().isRunning());
    }

    @Test
    public void testIsRunningAfterRunCalled() {
        Request request = harness.getRequest();
        request.begin();
        assertTrue(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterComplete() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onResourceReady(harness.resource);

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterFailing() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.onException(new RuntimeException("Test"));

        assertFalse(request.isRunning());
    }

    @Test
    public void testIsNotRunningAfterClear() {
        GenericRequest request = harness.getRequest();
        request.begin();
        request.clear();

        assertFalse(request.isRunning());
    }

    @Test
    public void testCallsTargetOnResourceReadyIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnResourceReadyIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testDoesNotCallTargetOnResourceReadyIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener.onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean())).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.target, never()).onResourceReady(any(List.class), any(GlideAnimation.class));
    }

    @Test
    public void testCallsTargetOnExceptionIfNoRequestListener() {
        harness.requestListener = null;
        GenericRequest request = harness.getRequest();
        Exception exception = new IOException("test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testCallsTargetOnExceptionIfRequestListenerReturnsFalse() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(false);
        Exception exception = new IOException("Test");
        request.onException(exception);

        verify(harness.target).onLoadFailed(eq(exception), eq(harness.errorDrawable));
    }

    @Test
    public void testDoesNotCallTargetOnExceptionIfRequestListenerReturnsTrue() {
        GenericRequest request = harness.getRequest();
        when(harness.requestListener
                .onException(any(Exception.class), any(Number.class), eq(harness.target), anyBoolean()))
                .thenReturn(true);

        request.onException(new IllegalArgumentException("test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testRequestListenerIsCalledWithResourceResult() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithModel() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), eq(harness.model), any(Target.class),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithTarget() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(any(List.class), any(Number.class), eq(harness.target),
                anyBoolean(), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithLoadedFromMemoryIfLoadCompletesSynchronously() {
        final GenericRequest request = harness.getRequest();
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(),  any(DiskCacheStrategy.class),
                any(ResourceCallback.class))).thenAnswer(new Answer<Object>() {
                    @Override
                    public Object answer(InvocationOnMock invocation) throws Throwable {
                        request.onResourceReady(harness.resource);
                        return null;
                    }
                });

        request.begin();
        request.onSizeReady(100, 100);
        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(true), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithNotLoadedFromMemoryCacheIfLoadCompletesAsynchronously() {
        GenericRequest request = harness.getRequest();
        request.onSizeReady(100, 100);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                eq(false), anyBoolean());
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstResourceIfNoRequestCoordinator() {
        harness.requestCoordinator = null;
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithIsFirstImageIfRequestCoordinatorReturnsNoResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(false);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(true));
    }

    @Test
    public void testRequestListenerIsCalledWithNotIsFirstRequestIfRequestCoordinatorReturnsResourceSet() {
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.isAnyResourceSet()).thenReturn(true);
        request.onResourceReady(harness.resource);

        verify(harness.requestListener).onResourceReady(eq(harness.result), any(Number.class), any(Target.class),
                anyBoolean(), eq(false));
    }

    @Test
    public void testTargetIsCalledWithAnimationFromFactory() {
        GenericRequest request = harness.getRequest();
        GlideAnimation<List> glideAnimation = mock(GlideAnimation.class);
        when(harness.factory.build(anyBoolean(), anyBoolean())).thenReturn(glideAnimation);
        request.onResourceReady(harness.resource);

        verify(harness.target).onResourceReady(eq(harness.result), eq(glideAnimation));
    }

    @Test
    public void testCallsGetSizeIfOverrideWidthIsLessThanZero() {
        harness.overrideWidth = -1;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsGetSizeIfOverrideHeightIsLessThanZero() {
        harness.overrideHeight = -1;
        harness.overrideWidth = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testDoesNotCallGetSizeIfOverrideWidthAndHeightAreSet() {
        harness.overrideWidth = 100;
        harness.overrideHeight = 100;
        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.target, never()).getSize(any(SizeReadyCallback.class));
    }

    @Test
    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {
        harness.overrideWidth = 1;
        harness.overrideHeight = 2;

        GenericRequest request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(harness.overrideWidth), eq(harness.overrideHeight),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    @Test
    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {
        harness.errorDrawable = new ColorDrawable(Color.RED);
        GenericRequest request = harness.getRequest();
        when(harness.requestCoordinator.canNotifyStatusChanged(any(Request.class))).thenReturn(false);
        request.onException(new IOException("Test"));

        verify(harness.target, never()).onLoadFailed(any(Exception.class), any(Drawable.class));
    }

    @Test
    public void testCanReRunCancelledRequests() {
        doAnswer(new CallSizeReady(100, 100)).when(harness.target)
                .getSize(any(SizeReadyCallback.class));
        when(harness.engine.load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class)))
                .thenAnswer(new CallResourceCallback(harness.resource));
        GenericRequest request = harness.getRequest();

        request.begin();
        request.cancel();
        request.begin();

        verify(harness.target, times(2)).onResourceReady(eq(harness.result), any(GlideAnimation.class));
    }

    @Test
    public void testResourceOnlyReceivesOneGetOnResourceReady() {
        GenericRequest request = harness.getRequest();
        request.onResourceReady(harness.resource);

        verify(harness.resource, times(1)).get();
    }

    @Test
    public void testOnSizeReadyWithNullDataFetcherCallsOnException() {
        GenericRequest request = harness.getRequest();
        when(harness.modelLoader.getResourceFetcher(any(Number.class), anyInt(), anyInt())).thenReturn(null);
        request.begin();
        request.onSizeReady(100, 100);

        verify(harness.requestListener).onException(any(Exception.class), any(Number.class), any(Target.class),
                anyBoolean());
    }

    @Test
    public void testDoesNotStartALoadIfOnSizeReadyIsCalledAfterCancel() {
        GenericRequest request = harness.getRequest();
        request.cancel();
        request.onSizeReady(100, 100);

        verify(harness.engine, never()).load(any(Key.class), anyInt(), anyInt(), any(DataFetcher.class),
                any(DataLoadProvider.class), any(Transformation.class), any(ResourceTranscoder.class),
                any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class), any(ResourceCallback.class));
    }

    @Test
    public void testStartsLoadImmediatelyWhenGivenOverrideWithSizeOriginal() {
        harness.overrideWidth = Target.SIZE_ORIGINAL;
        harness.overrideHeight = Target.SIZE_ORIGINAL;
        GenericRequest<Number, Object, Object, List> request = harness.getRequest();
        request.begin();

        verify(harness.engine).load(any(Key.class), eq(Target.SIZE_ORIGINAL), eq(Target.SIZE_ORIGINAL),
                any(DataFetcher.class), any(DataLoadProvider.class), any(Transformation.class),
                any(ResourceTranscoder.class), any(Priority.class), anyBoolean(), any(DiskCacheStrategy.class),
                any(ResourceCallback.class));
    }

    private static class CallResourceCallback implements Answer {

        private Resource resource;

        public CallResourceCallback(Resource resource) {
            this.resource = resource;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            ResourceCallback cb = (ResourceCallback)
                    invocationOnMock.getArguments()[invocationOnMock.getArguments().length - 1];
            cb.onResourceReady(resource);
            return null;
        }
    }

    private static class CallSizeReady implements Answer {

        private int width;
        private int height;

        public CallSizeReady(int width, int height) {
            this.width = width;
            this.height = height;
        }

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            SizeReadyCallback cb =
                    (SizeReadyCallback) invocationOnMock.getArguments()[0];
            cb.onSizeReady(width, height);
            return null;
        }
    }

    private Context mockContextToReturn(int resourceId, Drawable drawable) {
        Resources resources = mock(Resources.class);
        Context context = mock(Context.class);

        when(context.getApplicationContext()).thenReturn(context);
        when(context.getResources()).thenReturn(resources);
        when(resources.getDrawable(eq(resourceId))).thenReturn(drawable);

        return context;
    }

    private static class MockTarget implements Target {
        private Drawable currentPlaceholder;

        @Override
        public void onLoadCleared(Drawable placeholder) {
            currentPlaceholder = placeholder;
        }

        @Override
        public void onLoadStarted(Drawable placeholder) {
            currentPlaceholder = placeholder;

        }

        @Override
        public void onLoadFailed(Exception e, Drawable errorDrawable) {
            currentPlaceholder = errorDrawable;

        }

        @Override
        public void onResourceReady(Object resource, GlideAnimation glideAnimation) {
            currentPlaceholder = null;
        }


        @Override
        public void getSize(SizeReadyCallback cb) {
        }

        @Override
        public void setRequest(Request request) {
        }

        @Override
        public Request getRequest() {
            return null;
        }

        @Override
        public void onStart() {
        }

        @Override
        public void onStop() {

        }

        @Override
        public void onDestroy() {

        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java;<<<<<<< MINE
package com.bumptech.glide.load.model.stream;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assume.assumeTrue;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.verify;

import android.net.Uri;

import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.tests.Util;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

/**
 * Tests for the {@link StreamStringLoader} class.
 */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class StringLoaderTest {
    // Not a magic number, just an arbitrary non zero value.
    private static final int IMAGE_SIDE = 100;

    private StreamStringLoader stringLoader;
    @Mock ModelLoader<Uri, InputStream> uriLoader;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        stringLoader = new StreamStringLoader(uriLoader);
    }

    @Test
    public void testHandlesPaths() throws IOException {
        // TODO on windows it will fail with schema being the drive letter (C:\... -> C)
        assumeTrue(!Util.isWindows());
        File f = Robolectric.application.getCacheDir();
        stringLoader.getResourceFetcher(f.getAbsolutePath(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testCanHandleComplexFilePaths() {
        assumeTrue(!Util.isWindows());
        String testPath = "/storage/emulated/0/DCIM/Camera/IMG_20140520_100001:nopm:.jpg,mimeType=image/jpeg,"
                + "2448x3264,orientation=0,date=Tue";
        stringLoader.getResourceFetcher(testPath, IMAGE_SIDE, IMAGE_SIDE);

        Uri expected = Uri.fromFile(new File(testPath));
        verify(uriLoader).getResourceFetcher(eq(expected), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesFileUris() throws IOException {
        File f = Robolectric.application.getCacheDir();
        stringLoader.getResourceFetcher(Uri.fromFile(f)
                .toString(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.fromFile(f)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesResourceUris() throws IOException {
        Uri resourceUri = Uri.parse("android.resource://com.bumptech.glide.tests/raw/ic_launcher");
        stringLoader.getResourceFetcher(resourceUri.toString(), IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(resourceUri), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesHttp() {
        String url = "http://www.google.com";
        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesHttps() {
        String url = "https://www.google.com";
        stringLoader.getResourceFetcher(url, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(url)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testHandlesContent() {
        String content = "content://com.bumptech.glide";
        stringLoader.getResourceFetcher(content, IMAGE_SIDE, IMAGE_SIDE);

        verify(uriLoader).getResourceFetcher(eq(Uri.parse(content)), eq(IMAGE_SIDE), eq(IMAGE_SIDE));
    }

    @Test
    public void testGetResourceFetcher_withEmptyString_returnsNull() {
        assertThat(stringLoader.getResourceFetcher("", IMAGE_SIDE, IMAGE_SIDE)).isNull();
        assertThat(stringLoader.getResourceFetcher("    ", IMAGE_SIDE, IMAGE_SIDE)).isNull();
        assertThat(stringLoader.getResourceFetcher("  \n", IMAGE_SIDE, IMAGE_SIDE)).isNull();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/stream/ResourceLoaderTest.java;<<<<<<< MINE
package com.bumptech.glide.load.model.stream;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

import android.net.Uri;

import com.bumptech.glide.load.model.ModelLoader;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.InputStream;

/**
 * Tests for the {@link StreamResourceLoader} class.
 */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ResourceLoaderTest {

    @Mock ModelLoader<Uri, InputStream> streamUriLoader;
    private StreamResourceLoader resourceLoader;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        resourceLoader = new StreamResourceLoader(Robolectric.application, streamUriLoader);
    }

    @Test
    public void testCanHandleId() {
        int id = android.R.drawable.star_off;
        resourceLoader.getResourceFetcher(id, 0, 0);

        Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");
        verify(streamUriLoader).getResourceFetcher(eq(contentUri), anyInt(), anyInt());
    }

    @Test
    public void testDoesNotThrowOnInvalidOrMissingId() {
        assertThat(resourceLoader.getResourceFetcher(1234, 0, 0)).isNull();
        verify(streamUriLoader, never()).getResourceFetcher(any(Uri.class), anyInt(), anyInt());
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.model;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.google.common.testing.EqualsTester;

import com.bumptech.glide.load.model.LazyHeaders.Builder;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.util.Map;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class LazyHeadersTest {

    @Test
    public void testIncludesEagerHeaders() {
        Map<String, String> headers = new Builder()
            .addHeader("key", "value")
            .build()
            .getHeaders();
        assertThat(headers).containsEntry("key", "value");
        assertThat(headers).hasSize(1);
    }

    @Test
    public void testIncludesLazyHeaders() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("value");
        Map<String, String> headers = new Builder()
            .addHeader("key", factory)
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "value");
    }

    @Test
    public void testMultipleEagerValuesAreSeparatedByCommas() {
        Map<String, String> headers = new Builder()
            .addHeader("key", "first")
            .addHeader("key", "second")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");
    }

    @Test
    public void testMultipleLazyValuesAreSeparatedByCommas() {
        LazyHeaderFactory first = mock(LazyHeaderFactory.class);
        when(first.buildHeader()).thenReturn("first");
        LazyHeaderFactory second = mock(LazyHeaderFactory.class);
        when(second.buildHeader()).thenReturn("second");

        Map<String, String> headers = new Builder()
            .addHeader("key", first)
            .addHeader("key", second)
            .build()
            .getHeaders();
        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");
    }

    @Test
    public void testMixedEagerAndLazyValuesAreIncluded() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("first");
        Map<String, String> headers = new Builder()
            .addHeader("key", factory)
            .addHeader("key", "second")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "first,second");

        headers = new Builder()
            .addHeader("key", "second")
            .addHeader("key", factory)
            .build()
            .getHeaders();

        assertThat(headers).hasSize(1);
        assertThat(headers).containsEntry("key", "second,first");
    }

    @Test
    public void testCanAddMultipleKeys() {
        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("lazy");
        Map<String, String> headers = new Builder()
            .addHeader("first", factory)
            .addHeader("second", "eager")
            .build()
            .getHeaders();

        assertThat(headers).hasSize(2);
        assertThat(headers).containsEntry("first", "lazy");
        assertThat(headers).containsEntry("second", "eager");
    }

    @Test
    public void testUpdatingBuilderAfterBuildingDoesNotModifyOriginalHeaders() {
        Builder builder = new Builder();
        builder.addHeader("key", "firstValue");
        LazyHeaders first = builder.build();

        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);
        when(factory.buildHeader()).thenReturn("otherValue");
        builder.addHeader("key", "secondValue");
        builder.addHeader("otherKey", factory);
        LazyHeaders second = builder.build();

        assertThat(first.getHeaders()).isNotEqualTo(second.getHeaders());

        assertThat(first.getHeaders()).hasSize(1);
        assertThat(first.getHeaders()).containsEntry("key", "firstValue");

        assertThat(second.getHeaders()).hasSize(2);
        assertThat(second.getHeaders()).containsEntry("key", "firstValue,secondValue");
        assertThat(second.getHeaders()).containsEntry("otherKey", "otherValue");
    }

    @Test
    public void testEquals() {
        LazyHeaderFactory firstLazyFactory = mock(LazyHeaderFactory.class);
        LazyHeaderFactory secondLazyFactory = mock(LazyHeaderFactory.class);
        new EqualsTester()
            .addEqualityGroup(
                new Builder().build(),
                new Builder().build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "value").build(),
                new Builder().addHeader("key", "value").build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "value").addHeader("key", "value").build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", firstLazyFactory).build(),
                new Builder().addHeader("key", firstLazyFactory).build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("key", firstLazyFactory)
                    .addHeader("key", firstLazyFactory)
                    .build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", "value")
                    .addHeader("secondKey", firstLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("secondKey", firstLazyFactory)
                    .addHeader("firstKey", "value")
                    .build()
            )
            .addEqualityGroup(
                new Builder().addHeader("key", "secondValue")
            )
            .addEqualityGroup(
                new Builder().addHeader("secondKey", "value")
            )
            .addEqualityGroup(
                new Builder().addHeader("key", secondLazyFactory)
            )
            .addEqualityGroup(
                new Builder().addHeader("secondKey", firstLazyFactory)
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", "firstValue")
                    .addHeader("secondKey", "secondValue")
                    .build(),
                new Builder()
                    .addHeader("firstKey", "firstValue")
                    .addHeader("secondKey", "secondValue")
                    .build(),
                new Builder()
                    .addHeader("secondKey", "secondValue")
                    .addHeader("firstKey", "firstValue")
                    .build()
            )
            .addEqualityGroup(
                new Builder()
                    .addHeader("firstKey", firstLazyFactory)
                    .addHeader("secondKey", secondLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("firstKey", firstLazyFactory)
                    .addHeader("secondKey", secondLazyFactory)
                    .build(),
                new Builder()
                    .addHeader("secondKey", secondLazyFactory)
                    .addHeader("firstKey", firstLazyFactory)
                    .build()
            )
            .testEquals();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ThumbnailStreamOpenerTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.database.MatrixCursor;
import android.net.Uri;
import android.provider.MediaStore;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
import org.robolectric.tester.android.database.SimpleTestCursor;
import org.robolectric.tester.android.database.TestCursor;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ThumbnailStreamOpenerTest {
    private Harness harness;

    @Before
    public void setUp() {
        harness = new Harness();
    }

    @Test
    public void testReturnsNullIfCursorIsNull() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfCursorIsEmpty() throws FileNotFoundException {
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(
                new MatrixCursor(new String[1]));
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfCursorHasEmptyPath() throws FileNotFoundException {
        MatrixCursor cursor = new MatrixCursor(new String[1]);
        cursor.addRow(new Object[]{ "" });
        when(harness.query.queryPath(eq(Robolectric.application), eq(harness.uri))).thenReturn(cursor);
        assertNull(harness.get()
                .open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnsNullIfFileDoesNotExist() throws FileNotFoundException {
        when(harness.service.get(anyString())).thenReturn(harness.file);
        when(harness.service.exists(eq(harness.file))).thenReturn(false);
        assertNull(harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testReturnNullIfFileLengthIsZero() throws FileNotFoundException {
        when(harness.service.get(anyString())).thenReturn(harness.file);
        when(harness.service.length(eq(harness.file))).thenReturn(0L);
        assertNull(harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testClosesCursor() throws FileNotFoundException {
        harness.get().open(Robolectric.application, harness.uri);
        assertTrue(harness.cursor.isClosed());
    }

    @Test
    public void testReturnsOpenedInputStreamWhenFileFound() throws FileNotFoundException {
        InputStream expected = new ByteArrayInputStream(new byte[0]);
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).registerInputStream(harness.uri, expected);
        assertEquals(expected, harness.get().open(Robolectric.application, harness.uri));
    }

    @Test
    public void testVideoQueryReturnsVideoCursor() {
        Uri queryUri = MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.VideoThumbnailQuery query = new MediaStoreThumbFetcher.VideoThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }

    @Test
    public void testImageQueryReturnsImageCurosr() {
        Uri queryUri = MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI;
        MediaStoreThumbFetcher.ImageThumbnailQuery query = new MediaStoreThumbFetcher.ImageThumbnailQuery();
        TestCursor testCursor = new SimpleTestCursor();
        Robolectric.shadowOf(Robolectric.application.getContentResolver()).setCursor(queryUri, testCursor);
        assertEquals(testCursor, query.queryPath(Robolectric.application, harness.uri));
    }

    private static class Harness {
        MatrixCursor cursor = new MatrixCursor(new String[1]);
        File file = new File("fake/uri");
        Uri uri = Uri.fromFile(file);
        MediaStoreThumbFetcher.ThumbnailQuery query = mock(MediaStoreThumbFetcher.ThumbnailQuery.class);
        MediaStoreThumbFetcher.FileService service = mock(MediaStoreThumbFetcher.FileService.class);

        public Harness() {
            cursor.addRow(new String[] { file.getAbsolutePath() });
            when(query.queryPath(eq(Robolectric.application), eq(uri))).thenReturn(cursor);
            when(service.get(eq(file.getAbsolutePath()))).thenReturn(file);
            when(service.exists(eq(file))).thenReturn(true);
            when(service.length(eq(file))).thenReturn(1L);
        }

        public MediaStoreThumbFetcher.ThumbnailStreamOpener get() {
            return new MediaStoreThumbFetcher.ThumbnailStreamOpener(service, query);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import android.net.Uri;
import android.provider.MediaStore;

import com.bumptech.glide.Priority;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class MediaStoreThumbFetcherTest {
    private Harness harness;

    @Before
    public void setUp() {
        harness = new Harness();
    }

    @Test
    public void testReturnsInputStreamFromThumbnailOpener() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(
            expected);

        InputStream result = harness.get().loadData(Priority.LOW);
        assertNotNull(result);
    }

    @Test
    public void testReturnsInputStreamFromDefaultFetcherIfStreamFromThumbnailOpenerIsNull() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(null);
        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);

        assertEquals(expected, harness.get().loadData(Priority.HIGH));
    }

    @Test
    public void testReturnsInputStreamFromDefaultFetcherIfFactoryReturnsNull() throws Exception {
        InputStream expected = new ByteArrayInputStream(new byte[0]);

        when(harness.factory.build(any(Uri.class), anyInt(), anyInt())).thenReturn(null);
        when(harness.defaultFetcher.loadData(any(Priority.class))).thenReturn(expected);

        assertEquals(expected, harness.get().loadData(Priority.IMMEDIATE));
    }

    @Test
    public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {
        InputStream expected = mock(InputStream.class);

        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(expected);

        MediaStoreThumbFetcher fetcher = harness.get();
        fetcher.loadData(Priority.HIGH);

        fetcher.cleanup();
        verify(expected).close();
    }

    @Test
    public void testCallsCleanupOnDefaultFetcherOnCleanup() {
        harness.get().cleanup();
        verify(harness.defaultFetcher).cleanup();
    }

    @Test
    public void testDoesNotThrowIfCleanupWithNullInputStream() {
        harness.get().cleanup();
    }

    @Test
    public void testContainsAllRelevantPartsInId() {
        String id = harness.get().getId();
        assertThat(id).contains(harness.uri.toString());
    }

    @SuppressWarnings("unchecked")
    private static class Harness {
        Uri uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");
        DataFetcher<InputStream> defaultFetcher = mock(DataFetcher.class);
        int width = 123;
        int height = 222;

        MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory factory = mock(
                MediaStoreThumbFetcher.ThumbnailStreamOpenerFactory.class);
        MediaStoreThumbFetcher.ThumbnailStreamOpener
                thumbnailFetcher = mock(MediaStoreThumbFetcher.ThumbnailStreamOpener.class);

        public Harness() {
            when(factory.build(eq(uri), eq(width), eq(height))).thenReturn(thumbnailFetcher);
        }

        public MediaStoreThumbFetcher get() {
            return new MediaStoreThumbFetcher(Robolectric.application, uri, defaultFetcher, width, height, factory);
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}=======
package com.bumptech.glide.load.data;

import static com.google.common.truth.Truth.assertThat;

import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.testutil.TestResourceUtil;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ExifOrientationStreamTest {
  private LruByteArrayPool byteArrayPool;

  private InputStream openOrientationExample(boolean isLandscape, int item) {
    String filePrefix = isLandscape ? "Landscape" : "Portrait";
    return TestResourceUtil.openResource(getClass(),
        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");
  }

  @Before
  public void setUp() {
    byteArrayPool = new LruByteArrayPool();
  }

  @Test
  public void testIncludesGivenExifOrientation() throws IOException {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);
        InputStream wrapped = new ExifOrientationStream(toWrap, i);
        ImageHeaderParser parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);

        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);
        wrapped = new ExifOrientationStream(toWrap, i);
        parser = new ImageHeaderParser(wrapped, byteArrayPool);
        assertThat(parser.getOrientation()).isEqualTo(i);
      }
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java;<<<<<<< MINE
=======
package com.bumptech.glide.util;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

import java.io.IOException;
import java.io.InputStream;

@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE, emulateSdk = 18)
public class ContentLengthInputStreamTest {
  @Mock InputStream wrapped;

  @Before
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength()
      throws IOException {
    int value = 123356;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));

    assertThat(is.available()).isEqualTo(value);
  }

  @Test
  public void testAvailable_withNullContentLength_returnsWrappedAvailable()
      throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);
    int expected = 1234;
    when(wrapped.available()).thenReturn(expected);

    assertThat(is.available()).isEqualTo(expected);
  }

  @Test
  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    int expected = 567;
    when(wrapped.available()).thenReturn(expected);

    assertThat(is.available()).isEqualTo(expected);
  }

  @Test
  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {
    int contentLength = 999;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(1);

    assertThat(is.read()).isEqualTo(1);
    assertThat(is.available()).isEqualTo(contentLength - 1);
  }

  @Test
  public void testAvailable_handlesReadValueOfZero() throws IOException {
    int contentLength = 999;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(0);

    assertThat(is.read()).isEqualTo(0);
    assertThat(is.available()).isEqualTo(contentLength);
  }

  @Test
  public void testAvailable_withReadBytes_returnsContentLengthOffsetByNumberOfBytes()
      throws IOException {
    int contentLength = 678;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    int read = 100;
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(read);

    assertThat(is.read(new byte[500], 0, 0)).isEqualTo(read);
    assertThat(is.available()).isEqualTo(contentLength - read);
  }

  @Test
  public void testRead_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
      throws IOException {
    int contentLength = 1;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read()).thenReturn(-1);

    try {
      is.read();
      fail("Failed to throw expected exception");
    } catch (IOException e) {
      // Expected.
    }
  }

  @Test
  public void testReadBytes_whenReturnsLessThanZeroWithoutReadingAllContent_throwsIOException()
      throws IOException {
    int contentLength = 2;
    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);

    try {
      is.read(new byte[10], 0, 0);
      fail("Failed to throw expected exception");
    } catch (IOException e) {
      // Expected.
    }
  }

  @Test
  public void testRead_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow() throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    when(wrapped.read()).thenReturn(-1);
    is.read();
  }

  @Test
  public void testReadBytes_whenReturnsLessThanZeroWithInvalidLength_doesNotThrow()
      throws IOException {
    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");
    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1);
    is.read(new byte[10], 0, 0);
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java;<<<<<<< MINE
=======
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Collections;
import java.util.Set;

/**
 * A {@link RequestManagerTreeNode} that returns no relatives.
 */
final class EmptyRequestManagerTreeNode implements RequestManagerTreeNode {
    @Override
    public Set<RequestManager> getDescendants() {
        return Collections.emptySet();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/manager/RequestManagerTreeNode.java;<<<<<<< MINE
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context hierarchy
 * is provided by nesting in Activity and Fragments; the application context does not provide access to
 * any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();
}=======
package com.bumptech.glide.manager;

import com.bumptech.glide.RequestManager;

import java.util.Set;

/**
 * Provides access to the relatives of a RequestManager based on the current context. The context
 * hierarchy is provided by nesting in Activity and Fragments; the application context does not
 * provide access to any other RequestManagers hierarchically.
 */
public interface RequestManagerTreeNode {
    /**
     * Returns all descendant {@link RequestManager}s relative to the context of the current
     * {@link RequestManager}.
     */
    Set<RequestManager> getDescendants();
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.gif.GifDrawable;
import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;

import java.io.File;
import java.io.InputStream;

/**
 * A class for creating a request to load an animated gif.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 */
public class GifRequestBuilder<ModelType>
        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>
        implements BitmapOptions, DrawableOptions {

    GifRequestBuilder(LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider,
            Class<GifDrawable> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        super(loadProvider, transcodeClass, other);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> thumbnail(GenericRequestBuilder<?, ?, ?, GifDrawable> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * Loads and displays the GIF retrieved by the given thumbnail request if it finishes before this
     * request. Best used for loading thumbnail GIFs that are smaller and will be loaded more quickly
     * than the fullsize GIF. There are no guarantees about the order in which the requests will actually
     * finish. However, if the thumb request completes after the full request, the thumb GIF will never
     * replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full GIF loads or the thumbnail loads,
     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This builder object.
     */
    public GifRequestBuilder<ModelType> thumbnail(GifRequestBuilder<?> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> decoder(
            ResourceDecoder<InputStream, GifDrawable> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> cacheDecoder(
            ResourceDecoder<File, GifDrawable> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> encoder(
            ResourceEncoder<GifDrawable> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> centerCrop() {
        return transformFrame(glide.getBitmapCenterCrop());
    }

    /**
     * Transforms each frame of the GIF using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder..
     */
    public GifRequestBuilder<ModelType> fitCenter() {
        return transformFrame(glide.getBitmapFitCenter());
    }

    /**
     * Transforms each frame of the GIF using the given transformations.
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param bitmapTransformations The transformations to apply in order to each frame.
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> transformFrame(BitmapTransformation... bitmapTransformations) {
        return transform(toGifTransformations(bitmapTransformations));
    }

    /**
     * Transforms each frame of the GIF using the given transformations.
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param bitmapTransformations The transformations to apply in order to each frame.
     * @return This request builder.
     */
    public GifRequestBuilder<ModelType> transformFrame(Transformation<Bitmap>... bitmapTransformations) {
        return transform(toGifTransformations(bitmapTransformations));
    }

    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {
        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];
        for (int i = 0; i < bitmapTransformations.length; i++) {
            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());
        }
        return transformations;
    }

    /**
     * {@inheritDoc}
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transformFrame(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transformFrame(com.bumptech.glide.load.Transformation[])
     *
     */
    @Override
    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade() {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>());
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade(int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @Override
    public GifRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(animation, duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> crossFade(int animationId, int duration) {
        super.animate(new DrawableCrossFadeFactory<GifDrawable>(context, animationId,
                duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public GifRequestBuilder<ModelType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> listener(
            RequestListener<? super ModelType, GifDrawable> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> sourceEncoder(Encoder<InputStream> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GifRequestBuilder<ModelType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public GifRequestBuilder<ModelType> clone() {
        return (GifRequestBuilder<ModelType>) super.clone();
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.MultiTransformation;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.resource.UnitTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.ChildLoadProvider;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.FutureTarget;
import com.bumptech.glide.request.GenericRequest;
import com.bumptech.glide.request.Request;
import com.bumptech.glide.request.RequestCoordinator;
import com.bumptech.glide.request.RequestFutureTarget;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.ThumbnailRequestCoordinator;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.animation.NoAnimation;
import com.bumptech.glide.request.animation.ViewAnimationFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.animation.ViewPropertyAnimationFactory;
import com.bumptech.glide.request.target.PreloadTarget;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.signature.EmptySignature;
import com.bumptech.glide.util.Util;

import java.io.File;

/**
 * A generic class that can handle setting options and staring loads for generic resource types.
 *
 * @param <ModelType> The type of model representing the resource.
 * @param <DataType> The data type that the resource {@link com.bumptech.glide.load.model.ModelLoader} will provide that
 *                  can be decoded by the {@link com.bumptech.glide.load.ResourceDecoder}.
 * @param <ResourceType> The type of the resource that will be loaded.
 * @param <TranscodeType> The type of resource the decoded resource will be transcoded to.
 */
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> implements Cloneable {
    protected final Class<ModelType> modelClass;
    protected final Context context;
    protected final Glide glide;
    protected final Class<TranscodeType> transcodeClass;
    protected final RequestTracker requestTracker;
    protected final Lifecycle lifecycle;
    private ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider;

    private ModelType model;
    private Key signature = EmptySignature.obtain();
    // model may occasionally be null, so to enforce that load() was called, set a boolean rather than relying on model
    // not to be null.
    private boolean isModelSet;
    private int placeholderId;
    private int errorId;
    private RequestListener<? super ModelType, TranscodeType> requestListener;
    private Float thumbSizeMultiplier;
    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
    private Float sizeMultiplier = 1f;
    private Drawable placeholderDrawable;
    private Drawable errorPlaceholder;
    private Priority priority = null;
    private boolean isCacheable = true;
    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
    private int overrideHeight = -1;
    private int overrideWidth = -1;
    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
    private Transformation<ResourceType> transformation = UnitTransformation.get();
    private boolean isTransformationSet;
    private boolean isThumbnailBuilt;
    private Drawable fallbackDrawable;
    private int fallbackResource;

    GenericRequestBuilder(LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        this(other.context, other.modelClass, loadProvider, transcodeClass, other.glide, other.requestTracker,
                other.lifecycle);
        this.model = other.model;
        this.isModelSet = other.isModelSet;
        this.signature = other.signature;
        this.diskCacheStrategy = other.diskCacheStrategy;
        this.isCacheable = other.isCacheable;
    }

    GenericRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, DataType, ResourceType, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {
        this.context = context;
        this.modelClass = modelClass;
        this.transcodeClass = transcodeClass;
        this.glide = glide;
        this.requestTracker = requestTracker;
        this.lifecycle = lifecycle;
        this.loadProvider = loadProvider != null
                ? new ChildLoadProvider<ModelType, DataType, ResourceType, TranscodeType>(loadProvider) : null;

        if (context == null) {
            throw new NullPointerException("Context can't be null");
        }
        if (modelClass != null && loadProvider == null) {
            throw new NullPointerException("LoadProvider must not be null");
        }
    }

    /**
     * Loads and displays the resource retrieved by the given thumbnail request if it finishes before this request.
     * Best used for loading thumbnail resources that are smaller and will be loaded more quickly than the full size
     * resource. There are no guarantees about the order in which the requests will actually finish. However, if the
     * thumb request completes after the full request, the thumb resource will never replace the full resource.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        if (this.equals(thumbnailRequest)) {
            throw new IllegalArgumentException("You cannot set a request as a thumbnail for itself. Consider using "
                    + "clone() on the request you are passing to thumbnail()");
        }
        this.thumbnailRequestBuilder = thumbnailRequest;

        return this;
    }

    /**
     * Loads a resource in an identical manner to this request except with the dimensions of the target multiplied
     * by the given size multiplier. If the thumbnail load completes before the fullsize load, the thumbnail will
     * be shown. If the thumbnail load completes afer the fullsize load, the thumbnail will not be shown.
     *
     * <p>
     *     Note - The thumbnail resource will be smaller than the size requested so the target (or {@link ImageView})
     *     must be able to scale the thumbnail appropriately. See {@link android.widget.ImageView.ScaleType}.
     * </p>
     *
     * <p>
     *     Almost all options will be copied from the original load, including the
     *     {@link com.bumptech.glide.load.model.ModelLoader}, {@link com.bumptech.glide.load.ResourceDecoder}, and
     *     {@link Transformation}s. However, {@link #placeholder(int)} and {@link #error(int)},
     *     and {@link #listener(RequestListener)} will only be used on the fullsize load and will not be copied for
     *     the thumbnail load.
     * </p>
     *
     * <p>
     *     Recursive calls to thumbnail are supported.
     * </p>
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the thumbnail.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnail(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.thumbSizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Applies a multiplier to the {@link Target}'s size before loading the resource. Useful for loading thumbnails
     * or trying to avoid loading huge resources (particularly {@link android.graphics.Bitmap}s on devices with overly
     * dense screens.
     *
     * @param sizeMultiplier The multiplier to apply to the {@link Target}'s dimensions when loading the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sizeMultiplier(
            float sizeMultiplier) {
        if (sizeMultiplier < 0f || sizeMultiplier > 1f) {
            throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");
        }
        this.sizeMultiplier = sizeMultiplier;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the original data.
     * By default, this decoder will only be used if the final transformed resource is not in the disk cache.
     *
     * @see #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param decoder The {@link com.bumptech.glide.load.ResourceDecoder} to use to decode the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> decoder(
            ResourceDecoder<DataType, ResourceType> decoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setSourceDecoder(decoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} to use to load the resource from the disk cache. By
     * default, this decoder will only be used if the final transformed resource is already in the disk cache.
     *
     * @see #decoder(com.bumptech.glide.load.ResourceDecoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param cacheDecoder The decoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> cacheDecoder(
            ResourceDecoder<File, ResourceType> cacheDecoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the decoder.
        if (loadProvider != null) {
            loadProvider.setCacheDecoder(cacheDecoder);
        }

        return this;
    }

    /**
     * Sets the source encoder to use to encode the data retrieved by this request directly into cache. The returned
     * resource will then be decoded from the cached data.
     *
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param sourceEncoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> sourceEncoder(
            Encoder<DataType> sourceEncoder) {
        if (loadProvider != null) {
            loadProvider.setSourceEncoder(sourceEncoder);
        }

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.
     *
     * <p>
     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal.
     *     Applications that use the same resource multiple times in multiple sizes and are willing to trade off some
     *     speed and disk space in return for lower bandwidth usage may want to consider using
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should
     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}.
     * </p>
     *
     * @param strategy The strategy to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(
            DiskCacheStrategy strategy) {
        this.diskCacheStrategy = strategy;

        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.Encoder} to use to encode the original data directly to cache. Will only
     * be used if the original data is not already in cache and if the
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} is set to
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or
     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#ALL}.
     *
     * @see #sourceEncoder(com.bumptech.glide.load.Encoder)
     * @see com.bumptech.glide.load.engine.DiskCacheStrategy
     *
     * @param encoder The encoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> encoder(
            ResourceEncoder<ResourceType> encoder) {
        // loadProvider will be null if model is null, in which case we're not going to load anything so it's ok to
        // ignore the encoder.
        if (loadProvider != null) {
            loadProvider.setEncoder(encoder);
        }

        return this;
    }

    /**
     * Sets the priority for this load.
     *
     * @param priority A priority.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> priority(
            Priority priority) {
        this.priority = priority;

        return this;
    }

    /**
     * Transform resources with the given {@link Transformation}s. Replaces any existing transformation or
     * transformations.
     *
     * @param transformations the transformations to apply in order.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transform(
            Transformation<ResourceType>... transformations) {
        isTransformationSet = true;
        if (transformations.length == 1) {
            transformation = transformations[0];
        } else {
            transformation = new MultiTransformation<ResourceType>(transformations);
        }

        return this;
    }

    /**
     * Removes the current {@link com.bumptech.glide.load.Transformation}.
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontTransform() {
        Transformation<ResourceType> transformation = UnitTransformation.get();
        return transform(transformation);
    }

    /**
     * Sets the {@link com.bumptech.glide.load.resource.transcode.ResourceTranscoder} to use for this load.
     *
     * @see com.bumptech.glide.load.resource.transcode.UnitTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder
     * @see com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder
     *
     * @param transcoder The transcoder to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> transcoder(
            ResourceTranscoder<ResourceType, TranscodeType> transcoder) {
        if (loadProvider != null) {
            loadProvider.setTranscoder(transcoder);
        }

        return this;
    }

    /**
     * Removes any existing animation set on the builder. Will be overridden by subsequent calls that set an animation.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> dontAnimate() {
        GlideAnimationFactory<TranscodeType> animation = NoAnimation.getFactory();
        return animate(animation);
    }

    /**
     * Sets an animation to run on the wrapped target when an resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @param animationId The resource id of the animation to run
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(int animationId) {
        return animate(new ViewAnimationFactory<TranscodeType>(context, animationId));
    }

    /**
     * Sets an animation to run on the wrapped target when a resource load finishes. Will only be run if the resource
     * was loaded asynchronously (ie was not in the memory cache)
     *
     * @see #animate(int)
     * @see #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)
     *
     * @deprecated If this builder is used for multiple loads, using this method will result in multiple view's being
     * asked to start an animation using a single {@link android.view.animation.Animation} object which results in
     * views animating repeatedly. Use {@link #animate(int)} or
     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in
     * Glide 4.0.
     * @param animation The animation to run
     * @return This request builder.
     */
    @Deprecated
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(Animation animation) {
        return animate(new ViewAnimationFactory<TranscodeType>(animation));
    }

    /**
     * Sets an animator to run a {@link android.view.ViewPropertyAnimator} on a view that the target may be wrapping
     * when a resource load finishes. Will only be run if the load was loaded asynchronously (ie was not in the
     * memory cache).
     *
     * @param animator The {@link com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator} to run.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            ViewPropertyAnimation.Animator animator) {
        return animate(new ViewPropertyAnimationFactory<TranscodeType>(animator));
    }

    GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> animate(
            GlideAnimationFactory<TranscodeType> animationFactory) {
        if (animationFactory == null) {
            throw new NullPointerException("Animation factory must not be null!");
        }
        this.animationFactory = animationFactory;

        return this;
    }

    /**
     * Sets an Android resource id for a {@link android.graphics.drawable.Drawable} resourceto display while a resource
     * is loading.
     *
     * @param resourceId The id of the resource to use as a placeholder
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            int resourceId) {
        this.placeholderId = resourceId;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display while a resource is loading.
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> placeholder(
            Drawable drawable) {
        this.placeholderDrawable = drawable;

        return this;
    }

    /**
     * Sets an {@link android.graphics.drawable.Drawable} to display if the model provided to
     * {@link #load(Object)} is {@code null}.
     *
     * <p>
     *   If a fallback is not set, null models will cause the error drawable to be displayed. If
     *   the error drawable is not set, the placeholder will be displayed.
     * </p>
     *
     * @see #placeholder(Drawable)
     * @see #placeholder(int)
     *
     * @param drawable The drawable to display as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> fallback(
            Drawable drawable) {
        this.fallbackDrawable = drawable;

        return this;
    }

    /**
     * Sets a resource to display if the model provided to {@link #load(Object)} is {@code null}.
     *
     * <p>
     *   If a fallback is not set, null models will cause the error drawable to be displayed. If
     *   the error drawable is not set, the placeholder will be displayed.
     * </p>
     *
     * @see #placeholder(Drawable)
     * @see #placeholder(int)
     *
     * @param resourceId The id of the resource to use as a fallback.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> fallback(
            int resourceId) {
        this.fallbackResource = resourceId;

        return this;
    }

    /**
     * Sets a resource to display if a load fails.
     *
     * @param resourceId The id of the resource to use as a placeholder.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            int resourceId) {
        this.errorId = resourceId;

        return this;
    }

    /**
     * Sets a {@link Drawable} to display if a load fails.
     *
     * @param drawable The drawable to display.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> error(
            Drawable drawable) {
        this.errorPlaceholder = drawable;

        return this;
    }

    /**
     * Sets a RequestBuilder listener to monitor the resource load. It's best to create a single instance of an
     * exception handler per type of request (usually activity/fragment) rather than pass one in per request to
     * avoid some redundant object allocation.
     *
     * @param requestListener The request listener to use.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        this.requestListener = requestListener;

        return this;
    }

    /**
     * Allows the loaded resource to skip the memory cache.
     *
     * <p>
     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not
     *     also skipping the memory cache, the resource will be cached in memory.
     * </p>
     *
     * @param skip True to allow the resource to skip the memory cache.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {
        this.isCacheable = !skip;

        return this;
    }

    /**
     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for
     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or
     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}.
     *
     * @param width The width in pixels to use to load the resource.
     * @param height The height in pixels to use to load the resource.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {
        if (!Util.isValidDimensions(width, height)) {
            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");
        }
        this.overrideWidth = width;
        this.overrideHeight = height;

        return this;
    }

    /**
     * Sets some additional data to be mixed in to the memory and disk cache keys allowing the caller more control over
     * when cached data is invalidated.
     *
     * <p>
     *     Note - The signature does not replace the cache key, it is purely additive.
     * </p>
     *
     * @see com.bumptech.glide.signature.StringSignature
     *
     * @param signature A unique non-null {@link com.bumptech.glide.load.Key} representing the current state of the
     *                  model that will be mixed in to the cache key.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> signature(Key signature) {
        if (signature == null) {
            throw new NullPointerException("Signature must not be null");
        }
        this.signature = signature;
        return this;
    }

    /**
     * Sets the specific model to load data for.
     *
     * <p>
     *      This method must be called at least once before {@link #into(com.bumptech.glide.request.target.Target)} is
     *      called.
     * </p>
     *
     * @param model The model to load data for, or null.
     * @return This request builder.
     */
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {
        this.model = model;
        isModelSet = true;
        return this;
    }

    /**
     * Returns a copy of this request builder with all of the options set so far on this builder.
     *
     * <p>
     *     This method returns a "deep" copy in that all non-immutable arguments are copied such that changes to one
     *     builder will not affect the other builder. However, in addition to immutable arguments, the current model
     *     is not copied copied so changes to the model will affect both builders.
     * </p>
     */
    @SuppressWarnings("unchecked")
    @Override
    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone() {
        try {
            GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> clone =
                    (GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>) super.clone();
            clone.loadProvider = loadProvider != null ? loadProvider.clone() : null;
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Set the target the resource will be loaded into.
     *
     * @see Glide#clear(com.bumptech.glide.request.target.Target)
     *
     * @param target The target to load the resource into.
     * @return The given target.
     */
    public <Y extends Target<TranscodeType>> Y into(Y target) {
        Util.assertMainThread();
        if (target == null) {
            throw new IllegalArgumentException("You must pass in a non null Target");
        }
        if (!isModelSet) {
            throw new IllegalArgumentException("You must first set a model (try #load())");
        }

        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }

        Request request = buildRequest(target);
        target.setRequest(request);
        lifecycle.addListener(target);
        requestTracker.runRequest(request);

        return target;
    }

    /**
     * Sets the {@link ImageView} the resource will be loaded into, cancels any existing loads into the view, and frees
     * any resources Glide may have previously loaded into the view so they may be reused.
     *
     * @see Glide#clear(android.view.View)
     *
     * @param view The view to cancel previous loads for and load the new resource into.
     * @return The {@link com.bumptech.glide.request.target.Target} used to wrap the given {@link ImageView}.
     */
    public Target<TranscodeType> into(ImageView view) {
        Util.assertMainThread();
        if (view == null) {
            throw new IllegalArgumentException("You must pass in a non null View");
        }

        if (!isTransformationSet && view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                //$CASES-OMITTED$
                default:
                    // Do nothing.
            }
        }

        return into(glide.buildImageViewTarget(view, transcodeClass));
    }

    /**
     * Returns a future that can be used to do a blocking get on a background thread.
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     *
     * @see Glide#clear(com.bumptech.glide.request.FutureTarget)
     *
     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the
     *         resource in a blocking manner.
     */
    public FutureTarget<TranscodeType> into(int width, int height) {
        final RequestFutureTarget<ModelType, TranscodeType> target =
                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);

        // TODO: Currently all loads must be started on the main thread...
        glide.getMainHandler().post(new Runnable() {
            @Override
            public void run() {
                if (!target.isCancelled()) {
                    into(target);
                }
            }
        });

        return target;
    }

    /**
     * Preloads the resource into the cache using the given width and height.
     *
     * <p>
     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are
     *     available quickly.
     * </p>
     *
     *
     * @see com.bumptech.glide.ListPreloader
     *
     * @param width The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *             {@link #override * (int, int)} if previously called.
     * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be overridden by
     *              {@link #override * (int, int)}} if previously called).
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload(int width, int height) {
        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);
        return into(target);
    }

    /**
     * Preloads the resource into the cache using {@link Target#SIZE_ORIGINAL} as the target width and height.
     * Equivalent to calling {@link #preload(int, int)} with {@link Target#SIZE_ORIGINAL} as the width and height.
     *
     * @see #preload(int, int)
     *
     * @return A {@link Target} that can be used to cancel the load via
     *        {@link Glide#clear(com.bumptech.glide.request.target.Target)}.
     */
    public Target<TranscodeType> preload() {
        return preload(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
    }

    void applyCenterCrop() {
        // To be implemented by subclasses when possible.
    }

    void applyFitCenter() {
        // To be implemented by subclasses when possible.
    }

    private Priority getThumbnailPriority() {
        final Priority result;
        if (priority == Priority.LOW) {
            result = Priority.NORMAL;
        } else if (priority == Priority.NORMAL) {
            result = Priority.HIGH;
        } else {
            result = Priority.IMMEDIATE;
        }
        return result;
    }

    private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        return buildRequestRecursive(target, null);
    }

    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            if (isThumbnailBuilt) {
                throw new IllegalStateException("You cannot use a request as both the main request and a thumbnail, "
                        + "consider using clone() on the request(s) passed to thumbnail()");
            }
            // Recursive case: contains a potentially recursive thumbnail request builder.
            if (thumbnailRequestBuilder.animationFactory.equals(NoAnimation.getFactory())) {
                thumbnailRequestBuilder.animationFactory = animationFactory;
            }

            if (thumbnailRequestBuilder.priority == null) {
                thumbnailRequestBuilder.priority = getThumbnailPriority();
            }

            if (Util.isValidDimensions(overrideWidth, overrideHeight)
                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,
                            thumbnailRequestBuilder.overrideHeight)) {
              thumbnailRequestBuilder.override(overrideWidth, overrideHeight);
            }

            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            // Guard against infinite recursion.
            isThumbnailBuilt = true;
            // Recursively generate thumbnail requests.
            Request thumbRequest = thumbnailRequestBuilder.buildRequestRecursive(target, coordinator);
            isThumbnailBuilt = false;
            coordinator.setRequests(fullRequest, thumbRequest);
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
            ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
            Request fullRequest = obtainRequest(target, sizeMultiplier, priority, coordinator);
            Request thumbnailRequest = obtainRequest(target, thumbSizeMultiplier, getThumbnailPriority(), coordinator);
            coordinator.setRequests(fullRequest, thumbnailRequest);
            return coordinator;
        } else {
            // Base case: no thumbnail.
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }

    private Request obtainRequest(Target<TranscodeType> target, float sizeMultiplier, Priority priority,
            RequestCoordinator requestCoordinator) {
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                fallbackDrawable,
                fallbackResource,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.ParcelFileDescriptor;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.load.model.ImageVideoWrapper;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.bitmap.Downsampler;
import com.bumptech.glide.load.resource.bitmap.FileDescriptorBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.ImageVideoBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.StreamBitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.VideoBitmapDecoder;
import com.bumptech.glide.load.resource.file.FileToStreamDecoder;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.target.Target;

import java.io.File;
import java.io.InputStream;

/**
 * A class for creating a request to load a bitmap for an image or from a video. Sets a variety of type independent
 * options including resizing, animations, and placeholders.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 * @param <TranscodeType> The type of the transcoded resource that the target will receive
 */
public class BitmapRequestBuilder<ModelType, TranscodeType>
        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> implements BitmapOptions {
    private final BitmapPool bitmapPool;

    private Downsampler downsampler = Downsampler.AT_LEAST;
    private DecodeFormat decodeFormat;
    private ResourceDecoder<InputStream, Bitmap> imageDecoder;
    private ResourceDecoder<ParcelFileDescriptor, Bitmap> videoDecoder;

    BitmapRequestBuilder(LoadProvider<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> loadProvider,
            Class<TranscodeType> transcodeClass, GenericRequestBuilder<ModelType, ?, ?, ?> other) {
        super(loadProvider, transcodeClass, other);
        this.bitmapPool = other.glide.getBitmapPool();
        this.decodeFormat =  other.glide.getDecodeFormat();

        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);
        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);
    }

    /**
     * Load images at a size near the size of the target using {@link Downsampler#AT_LEAST}.
     *
     * @see #downsample(Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> approximate() {
        return downsample(Downsampler.AT_LEAST);
    }

    /**
     * Load images at their original size using {@link Downsampler#NONE}.
     *
     * @see #downsample(Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> asIs() {
        return downsample(Downsampler.NONE);
    }

    /**
     * Load images at a size that is at most exactly as big as the target using
     * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#AT_MOST}.
     *
     * @see #downsample(com.bumptech.glide.load.resource.bitmap.Downsampler)
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> atMost() {
        return downsample(Downsampler.AT_MOST);
    }

    /**
     * Load images using the given {@link Downsampler}. Replaces any existing image decoder. Defaults to
     * {@link Downsampler#AT_LEAST}. Will be ignored if the data represented by the model is a video. This replaces any
     * previous calls to {@link #imageDecoder(ResourceDecoder)}  and {@link #decoder(ResourceDecoder)} with default
     * decoders with the appropriate options set.
     *
     * @see #imageDecoder
     *
     * @param downsampler The downsampler.
     * @return This request builder.
     */
    private BitmapRequestBuilder<ModelType, TranscodeType> downsample(Downsampler downsampler) {
        this.downsampler = downsampler;
        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, decodeFormat);
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * Loads and displays the {@link android.graphics.Bitmap} retrieved by the given thumbnail request if it finishes
     * before this request. Best used for loading thumbnail {@link Bitmap}s that are smaller and will be loaded more
     * quickly than the fullsize {@link Bitmap}. There are no guarantees about the order in which the requests will
     * actually finish. However, if the thumb request completes after the full request, the thumb
     * {@link android.graphics.Bitmap} will never replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full {@link android.graphics.Bitmap} loads or the thumbnail
     *     loads, you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(BitmapRequestBuilder<?, TranscodeType>
            thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> decoder(ResourceDecoder<ImageVideoWrapper, Bitmap> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> encoder(ResourceEncoder<Bitmap> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
     * from an {@link java.io.InputStream}.
     *
     * @see #videoDecoder
     *
     * @param decoder The decoder to use to decode {@link Bitmap}s.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> imageDecoder(ResourceDecoder<InputStream, Bitmap> decoder) {
        imageDecoder = decoder;
        super.decoder(new ImageVideoBitmapDecoder(decoder, videoDecoder));
        return this;
    }

    /**
     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained
     * from an {@link android.os.ParcelFileDescriptor}.
     *
     * @param decoder The decoder to use to decode {@link Bitmap}s.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> videoDecoder(
            ResourceDecoder<ParcelFileDescriptor, Bitmap> decoder) {
        videoDecoder = decoder;
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, decoder));
        return this;
    }

    /**
     * Sets the preferred format for {@link Bitmap}s decoded in this request. Defaults to
     * {@link DecodeFormat#PREFER_RGB_565}. This replaces any previous calls to {@link #imageDecoder(ResourceDecoder)},
     * {@link #videoDecoder(ResourceDecoder)}, {@link #decoder(ResourceDecoder)} and
     * {@link #cacheDecoder(com.bumptech.glide.load.ResourceDecoder)}} with default decoders with the appropriate
     * options set.
     *
     * <p>
     *     Note - If using a {@link Transformation} that expect bitmaps to support transparency, this should always be
     *     set to ALWAYS_ARGB_8888. RGB_565 requires fewer bytes per pixel and is generally preferable, but it does not
     *     support transparency.
     * </p>
     *
     * @see DecodeFormat
     *
     * @param format The format to use.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> format(DecodeFormat format) {
        this.decodeFormat = format;
        imageDecoder = new StreamBitmapDecoder(downsampler, bitmapPool, format);
        videoDecoder = new FileDescriptorBitmapDecoder(new VideoBitmapDecoder(), bitmapPool, format);
        super.cacheDecoder(new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(downsampler, bitmapPool, format)));
        super.decoder(new ImageVideoBitmapDecoder(imageDecoder, videoDecoder));
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param transformations The transformations to apply in order.
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> centerCrop() {
        return transform(glide.getBitmapCenterCrop());
    }

    /**
     * Transform images using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public BitmapRequestBuilder<ModelType, TranscodeType> fitCenter() {
        return transform(glide.getBitmapFitCenter());
    }

    /**
     * {@inheritDoc}
     *
     * @see #fitCenter()
     * @see #centerCrop()
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> transform(Transformation<Bitmap>... transformations) {
        super.transform(transformations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> transcoder(
            ResourceTranscoder<Bitmap, TranscodeType> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> listener(
            RequestListener<? super ModelType, TranscodeType> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(
            GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public BitmapRequestBuilder<ModelType, TranscodeType> clone() {
        return (BitmapRequestBuilder<ModelType, TranscodeType>) super.clone();
    }

    /**
     * {@inheritDoc}
     *
     * <p>
     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
     *     use {@link #dontTransform()}.
     * </p>
     *
     * @param view {@inheritDoc}
     * @return {@inheritDoc}
     */
    @Override
    public Target<TranscodeType> into(ImageView view) {
        return super.into(view);
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java;<<<<<<< MINE
public class ThumbnailRequestCoordinator implements RequestCoordinator, Request {
    private Request full;
    private Request thumb;
    private RequestCoordinator coordinator;

    public ThumbnailRequestCoordinator() {
        this(null);
    }

    public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
        this.coordinator = coordinator;
    }

    public void setRequests(Request full, Request thumb) {
        this.full = full;
        this.thumb = thumb;
    }

    /**
     *
     * Returns true if the request is either the request loading the fullsize image or if the request loading the
     * full size image has not yet completed.
     *
     * @param request {@inheritDoc}
     */
    @Override
    public boolean canSetImage(Request request) {
        return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
    }

    private boolean parentCanSetImage() {
        return coordinator == null || coordinator.canSetImage(this);
    }

    /**
     * Returns true if the request is the request loading the fullsize image and if neither the full nor the thumbnail
     * image have completed sucessfully.
     *
     * @param request {@inheritDoc}.
     */
    @Override
    public boolean canNotifyStatusChanged(Request request) {
        return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
    }

    private boolean parentCanNotifyStatusChanged() {
        return coordinator == null || coordinator.canNotifyStatusChanged(this);
    }

    @Override
    public boolean isAnyResourceSet() {
        return parentIsAnyResourceSet() || isResourceSet();
    }

    @Override
    public void onRequestSuccess(Request request) {
        if (request.equals(thumb)) {
            return;
        }
        if (coordinator != null) {
            coordinator.onRequestSuccess(this);
        }
        // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
        // as a layer in a cross fade for example. The only way we know the thumb is not being
        // displayed and is therefore safe to clear is if the thumb request has not yet completed.
        if (!thumb.isComplete()) {
          thumb.clear();
        }
    }

    private boolean parentIsAnyResourceSet() {
        return coordinator != null && coordinator.isAnyResourceSet();
    }

    /**
     * Starts first the thumb request and then the full request.
     */
    @Override
    public void begin() {
        if (!thumb.isRunning()) {
            thumb.begin();
        }
        if (!full.isRunning()) {
            full.begin();
        }
    }

    @Override
    public void pause() {
        full.pause();
        thumb.pause();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clear() {
        thumb.clear();
        full.clear();
    }

    @Override
    public boolean isPaused() {
        return full.isPaused();
    }

    /**
     * Returns true if the full request is still running.
     */
    @Override
    public boolean isRunning() {
        return full.isRunning();
    }

    /**
     * Returns true if the full request is complete.
     */
    @Override
    public boolean isComplete() {
        return full.isComplete() || thumb.isComplete();
    }

    @Override
    public boolean isResourceSet() {
        return full.isResourceSet() || thumb.isResourceSet();
    }

    @Override
    public boolean isCancelled() {
        return full.isCancelled();
    }

    /**
     * Returns true if the full request has failed.
     */
    @Override
    public boolean isFailed() {
        return full.isFailed();
    }

    /**
     * {@inheritDoc}.
     */
    @Override
    public void recycle() {
        full.recycle();
        thumb.recycle();
    }
=======
public class ThumbnailRequestCoordinator implements RequestCoordinator,
    Request {
  private Request full;
  private Request thumb;
  private RequestCoordinator coordinator;
  private boolean isRunning;

  public ThumbnailRequestCoordinator() {
    this(null);
  }

  public ThumbnailRequestCoordinator(RequestCoordinator coordinator) {
    this.coordinator = coordinator;
  }

  public void setRequests(Request full, Request thumb) {
    this.full = full;
    this.thumb = thumb;
  }

  /**
   * Returns true if the request is either the request loading the fullsize image or if the request
   * loading the full size image has not yet completed.
   *
   * @param request {@inheritDoc}
   */
  @Override
  public boolean canSetImage(Request request) {
    return parentCanSetImage() && (request.equals(full) || !full.isResourceSet());
  }

  private boolean parentCanSetImage() {
    return coordinator == null || coordinator.canSetImage(this);
  }

  /**
   * Returns true if the request is the request loading the fullsize image and if neither the full
   * nor the thumbnail image have completed sucessfully.
   *
   * @param request {@inheritDoc}.
   */
  @Override
  public boolean canNotifyStatusChanged(Request request) {
    return parentCanNotifyStatusChanged() && request.equals(full) && !isAnyResourceSet();
  }

  private boolean parentCanNotifyStatusChanged() {
    return coordinator == null || coordinator.canNotifyStatusChanged(this);
  }

  @Override
  public boolean isAnyResourceSet() {
    return parentIsAnyResourceSet() || isResourceSet();
  }

  @Override
  public void onRequestSuccess(Request request) {
    if (request.equals(thumb)) {
      return;
    }
    if (coordinator != null) {
      coordinator.onRequestSuccess(this);
    }
    // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,
    // as a layer in a cross fade for example. The only way we know the thumb is not being
    // displayed and is therefore safe to clear is if the thumb request has not yet completed.
    if (!thumb.isComplete()) {
      thumb.clear();
    }
  }

  private boolean parentIsAnyResourceSet() {
    return coordinator != null && coordinator.isAnyResourceSet();
  }

  /**
   * Starts first the thumb request and then the full request.
   */
  @Override
  public void begin() {
    isRunning = true;
    if (!thumb.isRunning()) {
      thumb.begin();
    }
    if (isRunning && !full.isRunning()) {
      full.begin();
    }
  }

  @Override
  public void pause() {
    isRunning = false;
    full.pause();
    thumb.pause();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void clear() {
    isRunning = false;
    thumb.clear();
    full.clear();
  }

  @Override
  public boolean isPaused() {
    return full.isPaused();
  }

  /**
   * Returns true if the full request is still running.
   */
  @Override
  public boolean isRunning() {
    return full.isRunning();
  }

  /**
   * Returns true if the full request is complete.
   */
  @Override
  public boolean isComplete() {
    return full.isComplete() || thumb.isComplete();
  }

  @Override
  public boolean isResourceSet() {
    return full.isResourceSet() || thumb.isResourceSet();
  }

  @Override
  public boolean isCancelled() {
    return full.isCancelled();
  }

  /**
   * Returns true if the full request has failed.
   */
  @Override
  public boolean isFailed() {
    return full.isFailed();
  }

  /**
   * {@inheritDoc}.
   */
  @Override
  public void recycle() {
    full.recycle();
    thumb.recycle();
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java;<<<<<<< MINE
package com.bumptech.glide.request.target;

import android.annotation.TargetApi;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.ColorFilter;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.Build;

import com.bumptech.glide.load.resource.drawable.GlideDrawable;

/**
 * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with exactly the given side
 * length. The goal of this drawable is to ensure that square thumbnail drawables always match the size of the view
 * they will be displayed in to avoid a costly requestLayout call. This class should not be used with views or drawables
 * that are not square.
 */
public class SquaringDrawable extends GlideDrawable {
    private GlideDrawable wrapped;
    private State state;
    private boolean mutated;

    public SquaringDrawable(GlideDrawable wrapped, int side) {
        this(new State(wrapped.getConstantState(), side), wrapped, null /*res*/);
    }

    SquaringDrawable(State state, GlideDrawable wrapped, Resources res) {
        this.state = state;
        if (wrapped == null) {
          if (res != null) {
            this.wrapped = (GlideDrawable) state.wrapped.newDrawable(res);
          } else {
            this.wrapped = (GlideDrawable) state.wrapped.newDrawable();
          }
        } else {
          this.wrapped = wrapped;
        }
    }

    @Override
    public void setBounds(int left, int top, int right, int bottom) {
        super.setBounds(left, top, right, bottom);
        wrapped.setBounds(left, top, right, bottom);
    }

    @Override
    public void setBounds(Rect bounds) {
        super.setBounds(bounds);
        wrapped.setBounds(bounds);
    }

    @Override
    public void setChangingConfigurations(int configs) {
        wrapped.setChangingConfigurations(configs);
    }

    @Override
    public int getChangingConfigurations() {
        return wrapped.getChangingConfigurations();
    }

    @Override
    public void setDither(boolean dither) {
        wrapped.setDither(dither);
    }

    @Override
    public void setFilterBitmap(boolean filter) {
        wrapped.setFilterBitmap(filter);
    }

    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public Callback getCallback() {
        return wrapped.getCallback();
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    @Override
    public int getAlpha() {
        return wrapped.getAlpha();
    }

    @Override
    public void setColorFilter(int color, PorterDuff.Mode mode) {
        wrapped.setColorFilter(color, mode);
    }

    @Override
    public void clearColorFilter() {
        wrapped.clearColorFilter();
    }

    @Override
    public Drawable getCurrent() {
        return wrapped.getCurrent();
    }

    @Override
    public boolean setVisible(boolean visible, boolean restart) {
        return wrapped.setVisible(visible, restart);
    }

    @Override
    public int getIntrinsicWidth() {
        return state.side;
    }

    @Override
    public int getIntrinsicHeight() {
        return state.side;
    }

    @Override
    public int getMinimumWidth() {
        return wrapped.getMinimumWidth();
    }

    @Override
    public int getMinimumHeight() {
        return wrapped.getMinimumHeight();
    }

    @Override
    public boolean getPadding(Rect padding) {
        return wrapped.getPadding(padding);
    }

    @Override
    public void invalidateSelf() {
        super.invalidateSelf();
        wrapped.invalidateSelf();
    }

    @Override
    public void unscheduleSelf(Runnable what) {
        super.unscheduleSelf(what);
        wrapped.unscheduleSelf(what);
    }

    @Override
    public void scheduleSelf(Runnable what, long when) {
        super.scheduleSelf(what, when);
        wrapped.scheduleSelf(what, when);
    }

    @Override
    public void draw(Canvas canvas) {
        wrapped.draw(canvas);
    }

    @Override
    public void setAlpha(int i) {
        wrapped.setAlpha(i);
    }

    @Override
    public void setColorFilter(ColorFilter colorFilter) {
        wrapped.setColorFilter(colorFilter);
    }

    @Override
    public int getOpacity() {
        return wrapped.getOpacity();
    }

    @Override
    public boolean isAnimated() {
        return wrapped.isAnimated();
    }

    @Override
    public void setLoopCount(int loopCount) {
        wrapped.setLoopCount(loopCount);
    }

    @Override
    public void start() {
        wrapped.start();
    }

    @Override
    public void stop() {
        wrapped.stop();
    }

    @Override
    public boolean isRunning() {
        return wrapped.isRunning();
    }

    @Override
    public Drawable mutate() {
        if (!mutated && super.mutate() == this) {
            wrapped = (GlideDrawable) wrapped.mutate();
            state = new State(state);
            mutated = true;
        }
        return this;
    }

    @Override
    public ConstantState getConstantState() {
        return state;
    }

    static class State extends ConstantState {
        private final ConstantState wrapped;
        private final int side;

        State(State other) {
          this(other.wrapped, other.side);
        }

        State(ConstantState wrapped, int side) {
          this.wrapped = wrapped;
          this.side = side;
        }

        @Override
        public Drawable newDrawable() {
          return newDrawable(null /*res*/);
        }

        @Override
        public Drawable newDrawable(Resources res) {
          return new SquaringDrawable(this, null /*wrapped*/, res);
        }

        @Override
        public int getChangingConfigurations() {
          return 0;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/animation/DrawableCrossFadeFactory.java;<<<<<<< MINE
package com.bumptech.glide.request.animation;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;

/**
 * A factory class that produces a new {@link com.bumptech.glide.request.animation.GlideAnimation} that varies depending
 * on whether or not the drawable was loaded from the memory cache and whether or not the drawable is the first
 * image to be set on the target.
 *
 * <p>
 *     Resources are usually loaded from the memory cache just before the user can see the view,
 *     for example when the user changes screens or scrolls back and forth in a list. In those cases the user
 *     typically does not expect to see an animation. As a result, when the resource is loaded from the memory
 *     cache this factory produces an {@link com.bumptech.glide.request.animation.NoAnimation}.
 * </p>
 *
 * @param <T> The type of the {@link android.graphics.drawable.Drawable} that will be animated.
 */
public class DrawableCrossFadeFactory<T extends Drawable> implements GlideAnimationFactory<T> {
    private static final int DEFAULT_DURATION_MS = 300;
    private final ViewAnimationFactory<T> animationFactory;
    private final int duration;
    private DrawableCrossFadeViewAnimation<T> firstResourceAnimation;
    private DrawableCrossFadeViewAnimation<T> secondResourceAnimation;

    public DrawableCrossFadeFactory() {
        this(DEFAULT_DURATION_MS);
    }

    public DrawableCrossFadeFactory(int duration) {
        this(new ViewAnimationFactory<T>(new DefaultAnimationFactory(duration)), duration);
    }

    public DrawableCrossFadeFactory(Context context, int defaultAnimationId, int duration) {
        this(new ViewAnimationFactory<T>(context, defaultAnimationId), duration);
    }

    public DrawableCrossFadeFactory(Animation defaultAnimation, int duration) {
        this(new ViewAnimationFactory<T>(defaultAnimation), duration);
    }

    DrawableCrossFadeFactory(ViewAnimationFactory<T> animationFactory, int duration) {
        this.animationFactory = animationFactory;
        this.duration = duration;
    }

    @Override
    public GlideAnimation<T> build(boolean isFromMemoryCache, boolean isFirstResource) {
        if (isFromMemoryCache) {
            return NoAnimation.get();
        } else if (isFirstResource) {
            return getFirstResourceAnimation();
        } else {
            return getSecondResourceAnimation();
        }
    }

    private GlideAnimation<T> getFirstResourceAnimation() {
        if (firstResourceAnimation == null) {
            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
                true /*isFirstResource*/);
            firstResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
        }
        return firstResourceAnimation;
    }

    private GlideAnimation<T> getSecondResourceAnimation() {
        if (secondResourceAnimation == null) {
            GlideAnimation<T> defaultAnimation = animationFactory.build(false /*isFromMemoryCache*/,
                false /*isFirstResource*/);
            secondResourceAnimation = new DrawableCrossFadeViewAnimation<T>(defaultAnimation, duration);
        }
        return secondResourceAnimation;
    }

    private static class DefaultAnimationFactory implements ViewAnimation.AnimationFactory {

        private final int duration;

        DefaultAnimationFactory(int duration) {
            this.duration = duration;
        }

        @Override
        public Animation build() {
            AlphaAnimation animation = new AlphaAnimation(0f, 1f);
            animation.setDuration(duration);
            return animation;
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/request/GenericRequest.java;<<<<<<< MINE
package com.bumptech.glide.request;

import android.content.Context;
import android.graphics.drawable.Drawable;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.Engine;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.model.ModelLoader;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.animation.GlideAnimation;
import com.bumptech.glide.request.animation.GlideAnimationFactory;
import com.bumptech.glide.request.target.SizeReadyCallback;
import com.bumptech.glide.request.target.Target;
import com.bumptech.glide.util.LogTime;
import com.bumptech.glide.util.Util;

import java.util.Queue;

/**
 * A {@link Request} that loads a {@link com.bumptech.glide.load.engine.Resource} into a given {@link Target}.
 *
 * @param <A> The type of the model that the resource will be loaded from.
 * @param <T> The type of the data that the resource will be loaded from.
 * @param <Z> The type of the resource that will be loaded.
 * @param <R> The type of the resource that will be transcoded from the loaded resource.
 */
public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,
        ResourceCallback {
    private static final String TAG = "GenericRequest";
    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL = Util.createQueue(0);
    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);

    private enum Status {
        /** Created but not yet running. */
        PENDING,
        /** In the process of fetching media. */
        RUNNING,
        /** Waiting for a callback given to the Target to be called to determine target dimensions. */
        WAITING_FOR_SIZE,
        /** Finished loading media successfully. */
        COMPLETE,
        /** Failed to load media, may be restarted. */
        FAILED,
        /** Cancelled by the user, may not be restarted. */
        CANCELLED,
        /** Cleared by the user with a placeholder set, may not be restarted. */
        CLEARED,
        /** Temporarily paused by the system, may be restarted. */
        PAUSED,
    }

    private final String tag = String.valueOf(hashCode());

    private Key signature;
    private Drawable fallbackDrawable;
    private int fallbackResourceId;
    private int placeholderResourceId;
    private int errorResourceId;
    private Context context;
    private Transformation<Z> transformation;
    private LoadProvider<A, T, Z, R> loadProvider;
    private RequestCoordinator requestCoordinator;
    private A model;
    private Class<R> transcodeClass;
    private boolean isMemoryCacheable;
    private Priority priority;
    private Target<R> target;
    private RequestListener<? super A, R> requestListener;
    private float sizeMultiplier;
    private Engine engine;
    private GlideAnimationFactory<R> animationFactory;
    private int overrideWidth;
    private int overrideHeight;
    private DiskCacheStrategy diskCacheStrategy;

    private Drawable placeholderDrawable;
    private Drawable errorDrawable;
    private boolean loadedFromMemoryCache;
    // doing our own type check
    private Resource<?> resource;
    private Engine.LoadStatus loadStatus;
    private long startTime;
    private Status status;

    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        @SuppressWarnings("unchecked")
        GenericRequest<A, T, Z, R> request = (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
        if (request == null) {
            request = new GenericRequest<A, T, Z, R>();
        }
        request.init(loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderResourceId,
                errorDrawable,
                errorResourceId,
                fallbackDrawable,
                fallbackResourceId,
                requestListener,
                requestCoordinator,
                engine,
                transformation,
                transcodeClass,
                isMemoryCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
        return request;
    }

    private GenericRequest() {
        // just create, instances are reused with recycle/init
    }

    @Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        fallbackDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }

    private void init(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
        this.loadProvider = loadProvider;
        this.model = model;
        this.signature = signature;
        this.fallbackDrawable = fallbackDrawable;
        this.fallbackResourceId = fallbackResourceId;
        this.context = context.getApplicationContext();
        this.priority = priority;
        this.target = target;
        this.sizeMultiplier = sizeMultiplier;
        this.placeholderDrawable = placeholderDrawable;
        this.placeholderResourceId = placeholderResourceId;
        this.errorDrawable = errorDrawable;
        this.errorResourceId = errorResourceId;
        this.requestListener = requestListener;
        this.requestCoordinator = requestCoordinator;
        this.engine = engine;
        this.transformation = transformation;
        this.transcodeClass = transcodeClass;
        this.isMemoryCacheable = isMemoryCacheable;
        this.animationFactory = animationFactory;
        this.overrideWidth = overrideWidth;
        this.overrideHeight = overrideHeight;
        this.diskCacheStrategy = diskCacheStrategy;
        status = Status.PENDING;

        // We allow null models by just setting an error drawable. Null models will always have empty providers, we
        // simply skip our sanity checks in that unusual case.
        if (model != null) {
            check("ModelLoader", loadProvider.getModelLoader(), "try .using(ModelLoader)");
            check("Transcoder", loadProvider.getTranscoder(), "try .as*(Class).transcode(ResourceTranscoder)");
            check("Transformation", transformation, "try .transform(UnitTransformation.get())");
            if (diskCacheStrategy.cacheSource()) {
                check("SourceEncoder", loadProvider.getSourceEncoder(),
                        "try .sourceEncoder(Encoder) or .diskCacheStrategy(NONE/RESULT)");
            } else {
                check("SourceDecoder", loadProvider.getSourceDecoder(),
                        "try .decoder/.imageDecoder/.videoDecoder(ResourceDecoder) or .diskCacheStrategy(ALL/SOURCE)");
            }
            if (diskCacheStrategy.cacheSource() || diskCacheStrategy.cacheResult()) {
                // TODO if(resourceClass.isAssignableFrom(InputStream.class) it is possible to wrap sourceDecoder
                // and use it instead of cacheDecoder: new FileToStreamDecoder<Z>(sourceDecoder)
                // in that case this shouldn't throw
                check("CacheDecoder", loadProvider.getCacheDecoder(),
                        "try .cacheDecoder(ResouceDecoder) or .diskCacheStrategy(NONE)");
            }
            if (diskCacheStrategy.cacheResult()) {
                check("Encoder", loadProvider.getEncoder(),
                        "try .encode(ResourceEncoder) or .diskCacheStrategy(NONE/SOURCE)");
            }
        }
    }

    private static void check(String name, Object object, String suggestion) {
        if (object == null) {
            StringBuilder message = new StringBuilder(name);
            message.append(" must not be null");
            if (suggestion != null) {
                message.append(", ");
                message.append(suggestion);
            }
            throw new NullPointerException(message.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
            target.onLoadStarted(getPlaceholderDrawable());
        }
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished run method in " + LogTime.getElapsedMillis(startTime));
        }
    }

    /**
     * Cancels the current load but does not release any resources held by the request and continues to display
     * the loaded resource if the load completed before the call to cancel.
     *
     * <p>
     *     Cancelled requests can be restarted with a subsequent call to {@link #begin()}.
     * </p>
     *
     * @see #clear()
     */
    void cancel() {
        status = Status.CANCELLED;
        if (loadStatus != null) {
            loadStatus.cancel();
            loadStatus = null;
        }
    }

    /**
     * Cancels the current load if it is in progress, clears any resources held onto by the request and replaces
     * the loaded resource if the load completed with the placeholder.
     *
     * <p>
     *     Cleared requests can be restarted with a subsequent call to {@link #begin()}
     * </p>
     *
     * @see #cancel()
     */
    @Override
    public void clear() {
        Util.assertMainThread();
        if (status == Status.CLEARED) {
            return;
        }
        cancel();
        // Resource must be released before canNotifyStatusChanged is called.
        if (resource != null) {
            releaseResource(resource);
        }
        if (canNotifyStatusChanged()) {
            target.onLoadCleared(getPlaceholderDrawable());
        }
        // Must be after cancel().
        status = Status.CLEARED;
    }

    @Override
    public boolean isPaused() {
        return status == Status.PAUSED;
    }

    @Override
    public void pause() {
        clear();
        status = Status.PAUSED;
    }

    private void releaseResource(Resource resource) {
        engine.release(resource);
        this.resource = null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isRunning() {
        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isComplete() {
        return status == Status.COMPLETE;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isResourceSet() {
        return isComplete();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isCancelled() {
        return status == Status.CANCELLED || status == Status.CLEARED;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    private Drawable getFallbackDrawable() {
      if (fallbackDrawable == null && fallbackResourceId > 0) {
        fallbackDrawable = context.getResources().getDrawable(fallbackResourceId);
      }
      return fallbackDrawable;
    }

    private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = model == null ? getFallbackDrawable() : null;
        if (error == null) {
          error = getErrorDrawable();
        }
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }

    private Drawable getErrorDrawable() {
        if (errorDrawable == null && errorResourceId > 0) {
            errorDrawable = context.getResources().getDrawable(errorResourceId);
        }
        return errorDrawable;
    }

    private Drawable getPlaceholderDrawable() {
        if (placeholderDrawable == null && placeholderResourceId > 0) {
            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
        }
        return placeholderDrawable;
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onSizeReady(int width, int height) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;

        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
        final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);

        if (dataFetcher == null) {
            onException(new Exception("Failed to load model: \'" + model + "\'"));
            return;
        }
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
        }
        loadedFromMemoryCache = true;
        loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
        }
    }

    private boolean canSetResource() {
        return requestCoordinator == null || requestCoordinator.canSetImage(this);
    }

    private boolean canNotifyStatusChanged() {
        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
    }

    private boolean isFirstReadyResource() {
        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
    }

    private void notifyLoadSuccess() {
      if (requestCoordinator != null) {
        requestCoordinator.onRequestSuccess(this);
      }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @SuppressWarnings("unchecked")
    @Override
    public void onResourceReady(Resource<?> resource) {
        if (resource == null) {
            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
                    + " inside, but instead got null."));
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            onException(new Exception("Expected to receive an object of " + transcodeClass
                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
                    + " inside Resource{" + resource + "}."
                    + (received != null ? "" : " "
                        + "To indicate failure return a null Resource object, "
                        + "rather than a Resource object containing null data.")
            ));
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't set the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady(resource, (R) received);
    }

    /**
     * Internal {@link #onResourceReady(Resource)} where arguments are known to be safe.
     *
     * @param resource original {@link Resource}, never <code>null</code>
     * @param result object returned by {@link Resource#get()}, checked for type and never <code>null</code>
     */
    private void onResourceReady(Resource<?> resource, R result) {
        // We must call isFirstReadyResource before setting status.
        boolean isFirstResource = isFirstReadyResource();
        status = Status.COMPLETE;
        this.resource = resource;

        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstResource)) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);
            target.onResourceReady(result, animation);
        }

        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }

    /**
     * A callback method that should never be invoked directly.
     */
    @Override
    public void onException(Exception e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, "load failed", e);
        }

        status = Status.FAILED;
        //TODO: what if this is a thumbnail request?
        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {
            setErrorPlaceholder(e);
        }
    }

    private void logV(String message) {
        Log.v(TAG, message + " this: " + tag);
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/Headers.java;<<<<<<< MINE
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 * Implementations must implement equals() and hashcode().
 */
public interface Headers {

    /** An empty Headers object that can be used if users don't want to provide headers. */
    Headers NONE = new Headers() {
        @Override
        public Map<String, String> getHeaders() {
            return Collections.emptyMap();
        }
    };

    Map<String, String> getHeaders();

}=======
package com.bumptech.glide.load.model;

import java.util.Collections;
import java.util.Map;

/**
 * An interface for a wrapper for a set of headers to be included in a Glide request.
 *
 * <p> Implementations must implement equals() and hashcode(). </p>
 */
public interface Headers {

  /** An empty Headers object that can be used if users don't want to provide headers. */
  Headers NONE = new Headers() {
      @Override
      public Map<String, String> getHeaders() {
          return Collections.emptyMap();
      }
  };

  /**
   * Returns a non-null map containing a set of headers to apply to an http request.
   */
  Map<String, String> getHeaders();
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java;<<<<<<< MINE
=======
package com.bumptech.glide.load.model;

/**
 * An interface for lazily creating headers that allows expensive to calculate headers (oauth for
 * example) to be generated in the background during the first fetch.
 *
 * <p> Implementations should implement equals() and hashcode() </p> .
 */
public interface LazyHeaderFactory {

    String buildHeader();

}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
 * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call
 * {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache key, call
 * {@link #getCacheKey()}. </p>
 *
 * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for convenience. </p>
=======
 * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for
 * convenience. </p>
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java;<<<<<<< MINE
public class GlideUrl {
    private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

    private final URL url;
    private final Headers headers;
    private final String stringUrl;

    private String safeStringUrl;
    private URL safeUrl;

    public GlideUrl(URL url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(String url) {
        this(url, Headers.NONE);
    }

    public GlideUrl(URL url, Headers headers) {
        if (url == null) {
            throw new IllegalArgumentException("URL must not be null!");
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.url = url;
        stringUrl = null;
        this.headers = headers;
    }

    public GlideUrl(String url, Headers headers) {
        if (TextUtils.isEmpty(url)) {
            throw new IllegalArgumentException("String url must not be empty or null: " + url);
        }
        if (headers == null) {
            throw new IllegalArgumentException("Headers must not be null");
        }
        this.stringUrl = url;
        this.url = null;
        this.headers = headers;
    }

    /**
     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests.
     *
     * @see #toStringUrl()
     * @see #getCacheKey()
     * @throws MalformedURLException
     */
    public URL toURL() throws MalformedURLException {
        return getSafeUrl();
    }

    // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer using URI would work,
    // using it would require both decoding and encoding each string which is more complicated, slower and generates
    // more objects than the solution below. See also issue #133.
    private URL getSafeUrl() throws MalformedURLException {
        if (safeUrl == null) {
            safeUrl = new URL(getSafeStringUrl());
        }
        return safeUrl;
    }

    /**
     * Returns a properly escaped {@link String} url that can be used to make http/https requests.
     *
     * @see #toURL()
     * @see #getCacheKey()
     */
    public String toStringUrl() {
        return getSafeStringUrl();
    }

    private String getSafeStringUrl() {
        if (TextUtils.isEmpty(safeStringUrl)) {
            String unsafeStringUrl = stringUrl;
            if (TextUtils.isEmpty(unsafeStringUrl)) {
                unsafeStringUrl = url.toString();
            }
            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
        }
        return safeStringUrl;
    }

    /**
     * Returns a non-null {@link Map} containing headers.
     */
    public Map<String, String> getHeaders() {
        return headers.getHeaders();
    }

    /**
     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
     *
     * <p> This method does not include headers. </p>
     *
     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>
     */
    public String getCacheKey() {
      return stringUrl != null ? stringUrl : url.toString();
    }

    @Override
    public String toString() {
        return getCacheKey() + '\n' + headers.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof GlideUrl) {
          GlideUrl other = (GlideUrl) o;
          return getCacheKey().equals(other.getCacheKey())
              && headers.equals(other.headers);
        }
        return false;
    }

    @Override
    public int hashCode() {
        int hashCode = getCacheKey().hashCode();
        hashCode = 31 * hashCode + headers.hashCode();
        return hashCode;
    }
=======
public class GlideUrl implements Key {
  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%";

  private final URL url;
  private final Headers headers;
  private final String stringUrl;

  private String safeStringUrl;
  private URL safeUrl;
  private volatile byte[] cacheKeyBytes;

  public GlideUrl(URL url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(String url) {
    this(url, Headers.NONE);
  }

  public GlideUrl(URL url, Headers headers) {
    this.url = Preconditions.checkNotNull(url);
    stringUrl = null;
    this.headers = Preconditions.checkNotNull(headers);
  }

  public GlideUrl(String url, Headers headers) {
    this.url = null;
    this.stringUrl = Preconditions.checkNotEmpty(url);
    this.headers = Preconditions.checkNotNull(headers);
  }

  public URL toURL() throws MalformedURLException {
    return getSafeUrl();
  }

  // See http://stackoverflow.com/questions/3286067/url-encoding-in-android. Although the answer
  // using URI would work, using it would require both decoding and encoding each string which is
  // more complicated, slower and generates more objects than the solution below. See also issue
  // #133.
  private URL getSafeUrl() throws MalformedURLException {
    if (safeUrl == null) {
      safeUrl = new URL(getSafeStringUrl());
    }
    return safeUrl;
  }

  /**
   * Returns a properly escaped {@link String} url that can be used to make http/https requests.
   *
   * @see #toURL()
   * @see #getCacheKey()
   */
  public String toStringUrl() {
    return getSafeStringUrl();
  }

  private String getSafeStringUrl() {
    if (TextUtils.isEmpty(safeStringUrl)) {
      String unsafeStringUrl = stringUrl;
      if (TextUtils.isEmpty(unsafeStringUrl)) {
        unsafeStringUrl = url.toString();
      }
      safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);
    }
    return safeStringUrl;
  }

  /**
   * Returns a non-null {@link Map} containing headers.
   */
  public Map<String, String> getHeaders() {
    return headers.getHeaders();
  }

  /**
   * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key.
   *
   * <p> This method does not include headers. </p>
   *
   * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape
   * input. </p>
   */
  public String getCacheKey() {
    return stringUrl != null ? stringUrl : url.toString();
  }

  @Override
  public String toString() {
    return getCacheKey();
  }

  @Override
  public void updateDiskCacheKey(MessageDigest messageDigest) {
    messageDigest.update(getCacheKeyBytes());
  }

  private byte[] getCacheKeyBytes() {
    if (cacheKeyBytes == null) {
      cacheKeyBytes = getCacheKey().getBytes(CHARSET);
    }
    return cacheKeyBytes;
  }

  @Override
  public boolean equals(Object o) {
    if (o instanceof GlideUrl) {
      GlideUrl other = (GlideUrl) o;
      return getCacheKey().equals(other.getCacheKey())
          && headers.equals(other.headers);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hashCode = getCacheKey().hashCode();
    hashCode = 31 * hashCode + headers.hashCode();
    return hashCode;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/engine/cache/InternalCacheDiskCacheFactory.java;<<<<<<< MINE
public final class InternalCacheDiskCacheFactory extends DiskLruCacheFactory {

    public InternalCacheDiskCacheFactory(Context context) {
        this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);
=======
public final class InternalCacheDiskCacheFactory implements DiskCache.Factory {
  private final Context context;
  private final String diskCacheName;
  private final int diskCacheSize;

  public InternalCacheDiskCacheFactory(Context context, int diskCacheSize) {
    this(context, null /*diskCacheName*/, diskCacheSize);
  }

  public InternalCacheDiskCacheFactory(Context context, String diskCacheName, int diskCacheSize) {
    this.context = context;
    this.diskCacheName = diskCacheName;
    this.diskCacheSize = diskCacheSize;
  }

  @Override
  public DiskCache build() {
    DiskCache diskCache = null;
    final File cacheDir;

    if (diskCacheName != null) {
      cacheDir = Glide.getPhotoCacheDir(context, diskCacheName);
    } else {
      cacheDir = Glide.getPhotoCacheDir(context);
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public class ExifOrientationStream extends FilterInputStream {
    /** Allow two bytes for the file format. */
    private static final int SEGMENT_START_POSITION = 2;
    private static final byte[] EXIF_SEGMENT = new byte[] {
        /** segment start id. */
        (byte) 0xFF,
        /** segment type. */
        (byte) 0xE1,
        /** segmentLength. */
        0x00,
        (byte) 0x1C,
        /** exif identifier. */
        0x45,
        0x78,
        0x69,
        0x66,
        0x00,
        0x00,
        /** mototorola byte order (big endian). */
        (byte) 0x4D,
        (byte) 0x4D,
        /** filler? */
        0x00,
        0x00,
        /** first id offset. */
        0x00,
        0x00,
        0x00,
        0x08,
        /** tagCount. */
        0x00,
        0x01,
        /** exif tag type. */
        0x01,
        0x12,
        /** 2 byte format. */
        0x00,
        0x02,
        /** component count. */
        0x00,
        0x00,
        0x00,
        0x01,
        /** 2 byte orientation value, the first byte of which is always 0. */
        0x00,
    };
    private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
    private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
    private final byte orientation;
    private int position;

    public ExifOrientationStream(InputStream in, int orientation) {
        super(in);
        if (orientation < -1 || orientation > 8) {
            throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
        }
        this.orientation = (byte) orientation;
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public void mark(int readlimit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public int read() throws IOException {
        final int result;
        if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
            result = super.read();
        } else if (position == ORIENTATION_POSITION) {
            result = orientation;
        } else {
            result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
        }
        if (result != -1) {
            position++;
        }
        return result;
    }

    @Override
    public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
        int read;
        if (position > ORIENTATION_POSITION) {
            read = super.read(buffer, byteOffset, byteCount);
        } else if (position == ORIENTATION_POSITION) {
            buffer[byteOffset] = orientation;
            read = 1;
        } else if (position < SEGMENT_START_POSITION) {
            read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
        } else {
            read = Math.min(ORIENTATION_POSITION - position, byteCount);
            System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset,
                read);
        }
        if (read > 0) {
            position += read;
        }
        return read;
    }

    @Override
    public long skip(long byteCount) throws IOException {
        long skipped = super.skip(byteCount);
        if (skipped > 0) {
            position += skipped;
        }
        return skipped;
    }

    @Override
    public void reset() throws IOException {
        throw new UnsupportedOperationException();
    }
}=======
package com.bumptech.glide.load.data;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Adds an exif segment with an orientation attribute to a wrapped {@link InputStream} containing
 * image data.
 *
 * <p>This class assumes that the wrapped stream contains an image format that can contain
 * exif information and performs no verification. </p>
 */
public final class ExifOrientationStream extends FilterInputStream {
  /** Allow two bytes for the file format. */
  private static final int SEGMENT_START_POSITION = 2;
  private static final byte[] EXIF_SEGMENT = new byte[] {
      /** segment start id. */
      (byte) 0xFF,
      /** segment type. */
      (byte) 0xE1,
      /** segmentLength. */
      0x00,
      (byte) 0x1C,
      /** exif identifier. */
      0x45,
      0x78,
      0x69,
      0x66,
      0x00,
      0x00,
      /** motorola byte order (big endian). */
      (byte) 0x4D,
      (byte) 0x4D,
      /** filler? */
      0x00,
      0x00,
      /** first id offset. */
      0x00,
      0x00,
      0x00,
      0x08,
      /** tagCount. */
      0x00,
      0x01,
      /** exif tag type. */
      0x01,
      0x12,
      /** 2 byte format. */
      0x00,
      0x02,
      /** component count. */
      0x00,
      0x00,
      0x00,
      0x01,
      /** 2 byte orientation value, the first byte of which is always 0. */
      0x00,
  };
  private static final int SEGMENT_LENGTH = EXIF_SEGMENT.length;
  private static final int ORIENTATION_POSITION = SEGMENT_LENGTH + SEGMENT_START_POSITION;
  private final byte orientation;
  private int position;

  public ExifOrientationStream(InputStream in, int orientation) {
    super(in);
    if (orientation < -1 || orientation > 8) {
      throw new IllegalArgumentException("Cannot add invalid orientation: " + orientation);
    }
    this.orientation = (byte) orientation;
  }

  @Override
  public boolean markSupported() {
    return false;
  }

  @Override
  public void mark(int readlimit) {
    throw new UnsupportedOperationException();
  }

  @Override
  public int read() throws IOException {
    final int result;
    if (position < SEGMENT_START_POSITION || position > ORIENTATION_POSITION) {
      result = super.read();
    } else if (position == ORIENTATION_POSITION) {
      result = orientation;
    } else {
      result = EXIF_SEGMENT[position - SEGMENT_START_POSITION] & 0xFF;
    }
    if (result != -1) {
      position++;
    }
    return result;
  }

  @Override
  public int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    int read;
    if (position > ORIENTATION_POSITION) {
      read = super.read(buffer, byteOffset, byteCount);
    } else if (position == ORIENTATION_POSITION) {
      buffer[byteOffset] = orientation;
      read = 1;
    } else if (position < SEGMENT_START_POSITION) {
      read = super.read(buffer, byteOffset, SEGMENT_START_POSITION - position);
    } else {
      read = Math.min(ORIENTATION_POSITION - position, byteCount);
      System.arraycopy(EXIF_SEGMENT, position - SEGMENT_START_POSITION, buffer, byteOffset, read);
    }
    if (read > 0) {
      position += read;
    }
    return read;
  }

  @Override
  public long skip(long byteCount) throws IOException {
    long skipped = super.skip(byteCount);
    if (skipped > 0) {
      position += skipped;
    }
    return skipped;
  }

  @Override
  public void reset() throws IOException {
    throw new UnsupportedOperationException();
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
    private static final String TAG = "HttpUrlFetcher";
    private static final String ENCODING_HEADER = "Accept-Encoding";
    private static final String DEFAULT_ENCODING = "identity";
    private static final int MAXIMUM_REDIRECTS = 5;
    private static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY = new DefaultHttpUrlConnectionFactory();

    private final GlideUrl glideUrl;
    private final HttpUrlConnectionFactory connectionFactory;

    private HttpURLConnection urlConnection;
    private InputStream stream;
    private volatile boolean isCancelled;

    public HttpUrlFetcher(GlideUrl glideUrl) {
        this(glideUrl, DEFAULT_CONNECTION_FACTORY);
    }

    // Visible for testing.
    HttpUrlFetcher(GlideUrl glideUrl, HttpUrlConnectionFactory connectionFactory) {
        this.glideUrl = glideUrl;
        this.connectionFactory = connectionFactory;
    }

    @Override
    public InputStream loadData(Priority priority) throws Exception {
        return loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/, glideUrl.getHeaders());
    }

    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl, Map<String, String> headers)
            throws IOException {
        if (redirects >= MAXIMUM_REDIRECTS) {
            throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
        } else {
            // Comparing the URLs using .equals performs additional network I/O and is generally broken.
            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
            try {
                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
                    throw new IOException("In re-direct loop");
                }
            } catch (URISyntaxException e) {
                // Do nothing, this is best effort.
            }
        }
        urlConnection = connectionFactory.build(url);
        for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
          urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
        }
        // Do our best to avoid gzip since it's both inefficient for images and also makes it more
        // difficult for us to detect and prevent partial content rendering. See #440.
        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {
            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);
        }
        urlConnection.setConnectTimeout(2500);
        urlConnection.setReadTimeout(2500);
        urlConnection.setUseCaches(false);
        urlConnection.setDoInput(true);

        // Connect explicitly to avoid errors in decoders if connection fails.
        urlConnection.connect();
        if (isCancelled) {
            return null;
        }
        final int statusCode = urlConnection.getResponseCode();
        if (statusCode / 100 == 2) {
            return getStreamForSuccessfulRequest(urlConnection);
        } else if (statusCode / 100 == 3) {
            String redirectUrlString = urlConnection.getHeaderField("Location");
            if (TextUtils.isEmpty(redirectUrlString)) {
                throw new IOException("Received empty or null redirect url");
            }
            URL redirectUrl = new URL(url, redirectUrlString);
            return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
        } else {
            if (statusCode == -1) {
                throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
            }
            throw new IOException("Request failed " + statusCode + ": " + urlConnection.getResponseMessage());
        }
    }
=======
  private static final String CONTENT_LENGTH_HEADER = "Content-Length";
  private static final int MAXIMUM_REDIRECTS = 5;
  private static final int DEFAULT_TIMEOUT_MS = 2500;
  // Visible for testing.
  static final HttpUrlConnectionFactory DEFAULT_CONNECTION_FACTORY =
      new DefaultHttpUrlConnectionFactory();

  private final GlideUrl glideUrl;
  private final int timeout;
  private final HttpUrlConnectionFactory connectionFactory;

  private HttpURLConnection urlConnection;
  private InputStream stream;
  private volatile boolean isCancelled;

  public HttpUrlFetcher(GlideUrl glideUrl) {
    this(glideUrl, DEFAULT_TIMEOUT_MS, DEFAULT_CONNECTION_FACTORY);
  }

  // Visible for testing.
  HttpUrlFetcher(GlideUrl glideUrl, int timeout, HttpUrlConnectionFactory connectionFactory) {
    this.glideUrl = glideUrl;
    this.timeout = timeout;
    this.connectionFactory = connectionFactory;
  }

  @Override
  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {
    long startTime = LogTime.getLogTime();
    InputStream result = null;
    try {
      result = loadDataWithRedirects(glideUrl.toURL(), 0 /*redirects*/, null /*lastUrl*/,
          glideUrl.getHeaders());
    } catch (IOException e) {
      if (Logs.isEnabled(Log.DEBUG)) {
        Logs.log(Log.DEBUG, "Failed to load data for url", e);
      }
    }
    if (Logs.isEnabled(Log.VERBOSE)) {
      Logs.log(Log.VERBOSE, "Finished http url fetcher fetch in "
          + LogTime.getElapsedMillis(startTime) + " ms and loaded "  + result);
    }
    callback.onDataReady(result);
  }

  private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new IOException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
            throw new IOException("In re-direct loop");
        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }
    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);

    // Connect explicitly to avoid errors in decoders if connection fails.
    urlConnection.connect();
    if (isCancelled) {
        return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (statusCode / 100 == 2) {
      String contentLength = urlConnection.getHeaderField(CONTENT_LENGTH_HEADER);
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
      return stream;
    } else if (statusCode / 100 == 3) {
      String redirectUrlString = urlConnection.getHeaderField("Location");
      if (TextUtils.isEmpty(redirectUrlString)) {
          throw new IOException("Received empty or null redirect url");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else {
      if (statusCode == -1) {
          throw new IOException("Unable to retrieve response code from HttpUrlConnection.");
      }
      throw new IOException("Request failed " + statusCode + ": "
          + urlConnection.getResponseMessage());
    }
  }

  @Override
  public void cleanup() {
    if (stream != null) {
      try {
        stream.close();
      } catch (IOException e) {
        // Ignore
      }
    }
    if (urlConnection != null) {
      urlConnection.disconnect();
    }
  }

  @Override
  public void cancel() {
    // TODO: we should consider disconnecting the url connection here, but we can't do so
    // directly because cancel is often called on the main thread.
    isCancelled = true;
  }

  @Override
  public Class<InputStream> getDataClass() {
    return InputStream.class;
  }

  @Override
  public DataSource getDataSource() {
    return DataSource.REMOTE;
  }

  interface HttpUrlConnectionFactory {
    HttpURLConnection build(URL url) throws IOException;
  }
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java;<<<<<<< MINE
    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
            throws IOException {
        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
            int contentLength = urlConnection.getContentLength();
            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);
        } else {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());
            }
            stream = urlConnection.getInputStream();
        }
        return stream;
    }

=======
  private static class DefaultHttpUrlConnectionFactory implements HttpUrlConnectionFactory {
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java;<<<<<<< MINE
package com.bumptech.glide.load.data;

import android.content.ContentResolver;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.MediaStore;
import android.text.TextUtils;
import android.util.Log;

import com.bumptech.glide.Priority;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

/**
 * A DataFetcher that retrieves an {@link java.io.InputStream} for a local Uri that may or may not be for a resource
 * in the media store. If the local Uri is for a resource in the media store and the size requested is less than or
 * equal to the media store thumbnail size, preferentially attempts to fetch data for the pre-generated media store
 * thumbs using {@link android.provider.MediaStore.Images.Thumbnails} and
 * {@link android.provider.MediaStore.Video.Thumbnails}.
 */
public class MediaStoreThumbFetcher implements DataFetcher<InputStream> {
    private static final String TAG = "MediaStoreThumbFetcher";
    private static final int MINI_WIDTH = 512;
    private static final int MINI_HEIGHT = 384;
    private static final ThumbnailStreamOpenerFactory DEFAULT_FACTORY = new ThumbnailStreamOpenerFactory();

    private final Context context;
    private final Uri mediaStoreUri;
    private final DataFetcher<InputStream> defaultFetcher;
    private final int width;
    private final int height;
    private final ThumbnailStreamOpenerFactory factory;
    private InputStream inputStream;

    public MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher,
            int width, int height) {
        this(context, mediaStoreUri, defaultFetcher, width, height, DEFAULT_FACTORY);
    }

    MediaStoreThumbFetcher(Context context, Uri mediaStoreUri, DataFetcher<InputStream> defaultFetcher, int width,
            int height, ThumbnailStreamOpenerFactory factory) {
        this.context = context;
        this.mediaStoreUri = mediaStoreUri;
        this.defaultFetcher = defaultFetcher;
        this.width = width;
        this.height = height;
        this.factory = factory;
    }

    @Override
    public InputStream loadData(Priority priority) throws Exception {
        ThumbnailStreamOpener fetcher = factory.build(mediaStoreUri, width, height);

        if (fetcher != null) {
            inputStream = openThumbInputStream(fetcher);
        }

        if (inputStream == null) {
            inputStream = defaultFetcher.loadData(priority);
        }

        return inputStream;
    }

    private InputStream openThumbInputStream(ThumbnailStreamOpener fetcher) {
        InputStream result = null;
        try {
            result = fetcher.open(context, mediaStoreUri);
        } catch (FileNotFoundException e) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Failed to find thumbnail file", e);
            }
        }

        int orientation = -1;
        if (result != null) {
            orientation = fetcher.getOrientation(context, mediaStoreUri);
        }

        if (orientation != -1) {
            result = new ExifOrientationStream(result, orientation);
        }
        return result;
    }

    @Override
    public void cleanup() {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                // Do nothing.
            }
        }
        defaultFetcher.cleanup();
    }

    @Override
    public String getId() {
        return mediaStoreUri.toString();
    }

    @Override
    public void cancel() {
        // Do nothing.
    }

    private static boolean isMediaStoreUri(Uri uri) {
        return uri != null
                && ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())
                && MediaStore.AUTHORITY.equals(uri.getAuthority());
    }

    private static boolean isMediaStoreVideo(Uri uri) {
        return isMediaStoreUri(uri) && uri.getPathSegments().contains("video");
    }

    static class FileService {
        public boolean exists(File file) {
            return file.exists();
        }

        public long length(File file) {
            return file.length();
        }

        public File get(String path) {
            return new File(path);
        }
    }

    interface ThumbnailQuery {
        Cursor queryPath(Context context, Uri uri);
    }

    static class ThumbnailStreamOpener {
        private static final FileService DEFAULT_SERVICE = new FileService();
        private final FileService service;
        private ThumbnailQuery query;

        public ThumbnailStreamOpener(ThumbnailQuery query) {
            this(DEFAULT_SERVICE, query);
        }

        public ThumbnailStreamOpener(FileService service, ThumbnailQuery query) {
            this.service = service;
            this.query = query;
        }

        public int getOrientation(Context context, Uri uri) {
            int orientation = -1;
            InputStream is = null;
            try {
                is = context.getContentResolver().openInputStream(uri);
                orientation = new ImageHeaderParser(is).getOrientation();
            } catch (IOException e) {
                if (Log.isLoggable(TAG, Log.DEBUG)) {
                    Log.d(TAG, "Failed to open uri: " + uri, e);
                }
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        // Ignored.
                    }
                }
            }
            return orientation;
        }

        public InputStream open(Context context, Uri uri) throws FileNotFoundException {
            Uri thumbnailUri = null;
            InputStream inputStream = null;

            final Cursor cursor = query.queryPath(context, uri);
            try {
                if (cursor != null && cursor.moveToFirst()) {
                    thumbnailUri = parseThumbUri(cursor);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            if (thumbnailUri != null) {
                inputStream = context.getContentResolver().openInputStream(thumbnailUri);
            }
            return inputStream;
        }

        private Uri parseThumbUri(Cursor cursor) {
            Uri result = null;
            String path = cursor.getString(0);
            if (!TextUtils.isEmpty(path)) {
                File file = service.get(path);
                if (service.exists(file) && service.length(file) > 0) {
                    result = Uri.fromFile(file);
                }
            }
            return result;
        }
    }

    static class ImageThumbnailQuery implements ThumbnailQuery {
        private static final String[] PATH_PROJECTION = {
            MediaStore.Images.Thumbnails.DATA,
        };
        private static final String PATH_SELECTION =
            MediaStore.Images.Thumbnails.KIND + " = " + MediaStore.Images.Thumbnails.MINI_KIND
            + " AND " + MediaStore.Images.Thumbnails.IMAGE_ID + " = ?";

        @Override
        public Cursor queryPath(Context context, Uri uri) {
            String imageId = uri.getLastPathSegment();
            return context.getContentResolver().query(
                MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,
                PATH_PROJECTION,
                PATH_SELECTION,
                new String[] { imageId },
                null /*sortOrder*/);
        }
    }

    static class VideoThumbnailQuery implements ThumbnailQuery {
        private static final String[] PATH_PROJECTION = {
            MediaStore.Video.Thumbnails.DATA
        };
        private static final String PATH_SELECTION =
            MediaStore.Video.Thumbnails.KIND + " = " + MediaStore.Video.Thumbnails.MINI_KIND
            + " AND " + MediaStore.Video.Thumbnails.VIDEO_ID + " = ?";

        @Override
        public Cursor queryPath(Context context, Uri uri) {
            String videoId = uri.getLastPathSegment();
            return context.getContentResolver().query(
                MediaStore.Video.Thumbnails.EXTERNAL_CONTENT_URI,
                PATH_PROJECTION,
                PATH_SELECTION,
                new String[] { videoId },
                null /*sortOrder*/);
        }
    }

    static class ThumbnailStreamOpenerFactory {

        public ThumbnailStreamOpener build(Uri uri, int width, int height) {
            if (!isMediaStoreUri(uri) || width > MINI_WIDTH || height > MINI_HEIGHT) {
                return null;
            } else if (isMediaStoreVideo(uri)) {
                return new ThumbnailStreamOpener(new VideoThumbnailQuery());
            } else {
                return new ThumbnailStreamOpener(new ImageThumbnailQuery());
            }
        }
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java;<<<<<<< MINE
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final long contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return obtain(other, parseContentLength(contentLengthHeader));
  }

  public static InputStream obtain(InputStream other, long contentLength) {
    return new ContentLengthInputStream(other, contentLength);
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, long contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return (int) Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}=======
package com.bumptech.glide.util;

import android.text.TextUtils;
import android.util.Log;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Uses the content length as the basis for the return value of {@link #available()} and verifies
 * that at least content length bytes are returned from the various read methods.
 */
public final class ContentLengthInputStream extends FilterInputStream {
  private static final String TAG = "ContentLengthStream";
  private static final int UNKNOWN = -1;

  private final int contentLength;
  private int readSoFar;

  public static InputStream obtain(InputStream other, String contentLengthHeader) {
    return new ContentLengthInputStream(other, parseContentLength(contentLengthHeader));
  }

  private static int parseContentLength(String contentLengthHeader) {
    int result = UNKNOWN;
    if (!TextUtils.isEmpty(contentLengthHeader)) {
      try {
        result = Integer.parseInt(contentLengthHeader);
      } catch (NumberFormatException e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG, "failed to parse content length header: " + contentLengthHeader, e);
        }
      }
    }
    return result;
  }

  ContentLengthInputStream(InputStream in, int contentLength) {
    super(in);
    this.contentLength = contentLength;
  }

  @Override
  public synchronized int available() throws IOException {
    return Math.max(contentLength - readSoFar, in.available());
 }

  @Override
  public synchronized int read() throws IOException {
    return checkReadSoFarOrThrow(super.read());
  }

  @Override
  public int read(byte[] buffer) throws IOException {
    return read(buffer, 0 /*byteOffset*/, buffer.length /*byteCount*/);
  }

  @Override
  public synchronized int read(byte[] buffer, int byteOffset, int byteCount) throws IOException {
    return checkReadSoFarOrThrow(super.read(buffer, byteOffset, byteCount));
  }

  private int checkReadSoFarOrThrow(int read) throws IOException {
    if (read >= 0) {
      readSoFar += read;
    } else if (contentLength - readSoFar > 0) {
      throw new IOException("Failed to read all expected data"
          + ", expected: " + contentLength
          + ", but read: " + readSoFar);
    }
    return read;
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/glide/revisions/rev_e161ca9_7e0f873/rev_e161ca9-7e0f873/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java;<<<<<<< MINE
package com.bumptech.glide;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.animation.Animation;
import android.widget.ImageView;

import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.model.ImageVideoWrapper;
import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;
import com.bumptech.glide.load.resource.drawable.GlideDrawable;
import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;
import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.manager.Lifecycle;
import com.bumptech.glide.manager.RequestTracker;
import com.bumptech.glide.provider.LoadProvider;
import com.bumptech.glide.request.RequestListener;
import com.bumptech.glide.request.animation.DrawableCrossFadeFactory;
import com.bumptech.glide.request.animation.ViewPropertyAnimation;
import com.bumptech.glide.request.target.Target;

import java.io.File;

/**
 * A class for creating a request to load a {@link GlideDrawable}.
 *
 * <p>
 *     Warning - It is <em>not</em> safe to use this builder after calling <code>into()</code>, it may be pooled and
 *     reused.
 * </p>
 *
 * @param <ModelType> The type of model that will be loaded into the target.
 */
public class DrawableRequestBuilder<ModelType>
        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>
        implements BitmapOptions, DrawableOptions {

    DrawableRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,
            RequestTracker requestTracker, Lifecycle lifecycle) {
        super(context, modelClass, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);
        // Default to animating.
        crossFade();
    }

    /**
     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this
     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly
     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will
     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}
     * will never replace the full image.
     *
     * @see #thumbnail(float)
     *
     * <p>
     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if
     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,
     *     you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail
     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}.
     * </p>
     *
     * <p>
     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored.
     * </p>
     *
     * @param thumbnailRequest The request to use to load the thumbnail.
     * @return This builder object.
     */
    public DrawableRequestBuilder<ModelType> thumbnail(
            DrawableRequestBuilder<?> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> thumbnail(
            GenericRequestBuilder<?, ?, ?, GlideDrawable> thumbnailRequest) {
        super.thumbnail(thumbnailRequest);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {
        super.thumbnail(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {
        super.sizeMultiplier(sizeMultiplier);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> decoder(ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {
        super.decoder(decoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> cacheDecoder(ResourceDecoder<File, GifBitmapWrapper> cacheDecoder) {
        super.cacheDecoder(cacheDecoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> encoder(ResourceEncoder<GifBitmapWrapper> encoder) {
        super.encoder(encoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> priority(Priority priority) {
        super.priority(priority);
        return this;
    }

    /**
     * Transform {@link GlideDrawable}s using the given
     * {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s.
     *
     * <p>
     *     Note - Bitmap transformations will apply individually to each frame of animated GIF images and also to
     *     individual {@link Bitmap}s.
     * </p>
     *
     * @see #centerCrop()
     * @see #fitCenter()
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @param transformations The transformations to apply in order.
     * @return This request builder.
     */
    public DrawableRequestBuilder<ModelType> transform(BitmapTransformation... transformations) {
        return bitmapTransform(transformations);
    }

    /**
     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}.
     *
     * @see #fitCenter()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public DrawableRequestBuilder<ModelType> centerCrop() {
        return transform(glide.getDrawableCenterCrop());
    }

    /**
     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}.
     *
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    @SuppressWarnings("unchecked")
    public DrawableRequestBuilder<ModelType> fitCenter() {
        return transform(glide.getDrawableFitCenter());
    }

    /**
     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any
     * previous transformations.
     *
     * @see #fitCenter()
     * @see #centerCrop()
     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...)
     * @see #transform(com.bumptech.glide.load.Transformation[])
     *
     * @return This request builder.
     */
    public DrawableRequestBuilder<ModelType> bitmapTransform(Transformation<Bitmap>... bitmapTransformations) {
        GifBitmapWrapperTransformation[] transformations =
                new GifBitmapWrapperTransformation[bitmapTransformations.length];
        for (int i = 0; i < bitmapTransformations.length; i++) {
            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);
        }
        return transform(transformations);
    }



    /**
     * {@inheritDoc}
     *
     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[])
     * @see #centerCrop()
     * @see #fitCenter()
     */
    @Override
    public DrawableRequestBuilder<ModelType> transform(Transformation<GifBitmapWrapper>... transformation) {
        super.transform(transformation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> transcoder(
            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {
        super.transcoder(transcoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public final DrawableRequestBuilder<ModelType> crossFade() {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>());
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public DrawableRequestBuilder<ModelType> crossFade(int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(animation, duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {
        super.animate(new DrawableCrossFadeFactory<GlideDrawable>(context, animationId,
                duration));
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> dontAnimate() {
        super.dontAnimate();
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {
        super.animate(animator);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> animate(int animationId) {
        super.animate(animationId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Deprecated
    @SuppressWarnings("deprecation")
    @Override
    public DrawableRequestBuilder<ModelType> animate(Animation animation) {
        super.animate(animation);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> placeholder(int resourceId) {
        super.placeholder(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> placeholder(Drawable drawable) {
        super.placeholder(drawable);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> fallback(Drawable drawable) {
        super.fallback(drawable);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> fallback(int resourceId) {
        super.fallback(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> error(int resourceId) {
        super.error(resourceId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> error(Drawable drawable) {
        super.error(drawable);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> listener(
            RequestListener<? super ModelType, GlideDrawable> requestListener) {
        super.listener(requestListener);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {
        super.diskCacheStrategy(strategy);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> skipMemoryCache(boolean skip) {
        super.skipMemoryCache(skip);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> override(int width, int height) {
        super.override(width, height);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {
        super.sourceEncoder(sourceEncoder);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DrawableRequestBuilder<ModelType> dontTransform() {
        super.dontTransform();
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> signature(Key signature) {
        super.signature(signature);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> load(ModelType model) {
        super.load(model);
        return this;
    }

    @Override
    public DrawableRequestBuilder<ModelType> clone() {
        return (DrawableRequestBuilder<ModelType>) super.clone();
    }

    /**
     * {@inheritDoc}
     *
     * <p>
     *     Note - If no transformation is set for this load, a default transformation will be applied based on the
     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,
     *     use {@link #dontTransform()}.
     * </p>
     *
     * @param view {@inheritDoc}
     * @return {@inheritDoc}
     */
    @Override
    public Target<GlideDrawable> into(ImageView view) {
        return super.into(view);
    }

    @Override
    void applyFitCenter() {
        fitCenter();
    }

    @Override
    void applyCenterCrop() {
        centerCrop();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/grpc-java/revisions/rev_977c3d1_24a9f39/rev_977c3d1-24a9f39/core/src/test/java/io/grpc/transport/AbstractStreamTest.java;<<<<<<< MINE
=======
/*
 * Copyright 2015, Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 *    * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package io.grpc.transport;

import static org.junit.Assert.fail;
import static org.mockito.Mockito.verify;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

import io.grpc.transport.AbstractStream.Phase;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.io.InputStream;

import javax.annotation.Nullable;

@RunWith(JUnit4.class)
public class AbstractStreamTest {
  @Mock private StreamListener streamListener;

  @Before
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }

  @Test
  public void onStreamAllocated_shouldNotifyReady() {
    AbstractStream<Object> stream = new AbstractStreamBase<Object>(null);

    stream.onStreamAllocated();

    verify(streamListener).onReady();
  }

  @Test
  public void validPhaseTransitions() {
    AbstractStream<Object> stream = new AbstractStreamBase<Object>(null);
    Multimap<Phase, Phase> validTransitions = ImmutableMultimap.<Phase, Phase>builder()
        .put(Phase.HEADERS, Phase.HEADERS)
        .put(Phase.HEADERS, Phase.MESSAGE)
        .put(Phase.HEADERS, Phase.STATUS)
        .put(Phase.MESSAGE, Phase.MESSAGE)
        .put(Phase.MESSAGE, Phase.STATUS)
        .put(Phase.STATUS, Phase.STATUS)
        .build();

    for (Phase startPhase : Phase.values()) {
      for (Phase endPhase : Phase.values()) {
        if (validTransitions.containsEntry(startPhase, endPhase)) {
          stream.verifyNextPhase(startPhase, endPhase);
        } else {
          try {
            stream.verifyNextPhase(startPhase, endPhase);
            fail();
          } catch (IllegalStateException expected) {
            // continue
          }
        }
      }
    }
  }

  /**
   * Base class for testing.
   */
  private class AbstractStreamBase<IdT> extends AbstractStream<IdT> {
    private AbstractStreamBase(WritableBufferAllocator bufferAllocator) {
      super(bufferAllocator);
    }

    @Override
    public void request(int numMessages) {
      throw new UnsupportedOperationException();
    }

    @Override
    @Nullable
    public IdT id() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected StreamListener listener() {
      return streamListener;
    }

    @Override
    protected void internalSendFrame(WritableBuffer frame, boolean endOfStream, boolean flush) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void receiveMessage(InputStream is) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void inboundDeliveryPaused() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void remoteEndClosed() {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void returnProcessedBytes(int processedBytes) {
      throw new UnsupportedOperationException();
    }

    @Override
    protected void deframeFailed(Throwable cause) {
      throw new UnsupportedOperationException();
    }
  }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_2eca1ae_f111de1/rev_2eca1ae-f111de1/java/examples/src/com/pubnub/examples/PubnubPresenceTest.java;<<<<<<< MINE
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
					jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.6";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}=======
package com.pubnub.examples;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;


import com.pubnub.api.Callback;
import com.pubnub.api.Pubnub;
import com.pubnub.api.PubnubException;

enum Status {
	PASS,
	FAIL
};

class Test {
	private String subkey;
	private String origin;
	private Map<String, String> channels;
	private String channelA;
	private String channelB;
	private JSONObject steps;
	private JSONArray events;
	private Status result;
	private int id;
	private String description;
	private boolean ssl;
	private int currentStep = -1;
	
	Test(int id, String description, String subkey, String origin, String channelA, String channelB, boolean ssl, JSONObject steps) {
	   this.id = id;
	   this.description = description;
	   this.subkey = subkey;
	   this.origin = origin;
	   this.channels = new LinkedHashMap<String,String>();
	   channels.put("channelA", channelA);
	   channels.put("channelB", channelB);
	   this.ssl = ssl;
	   this.result = Status.FAIL;
	   this.steps = steps;  
	}
	
	void updateStatus() {
		for (int i = 0; i < steps.size(); i++) {

			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray expectedEvents = (JSONArray) step.get("listener");
			JSONArray observedEvents = (JSONArray) step.get("events");
			
			if (expectedEvents.size() != observedEvents.size()) {
				result = Status.FAIL;
				return;
			}
			
			if (expectedEvents.size() <= 2) { 
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					if ( !expectedEventChannel.equals(observedEventChannel) || 
							!expectedEventAction.equals(observedEventAction)) {
						result = Status.FAIL;
						return;
					}
				}
			} else {
				Set expected = new LinkedHashSet();
				Set observed = new LinkedHashSet();
				for (int j = 0; j < expectedEvents.size(); j++) {
					String expectedEventChannel = channels.get((String)((JSONArray)expectedEvents.get(j)).get(1));
					String expectedEventAction = (String)((JSONArray)expectedEvents.get(j)).get(0);
					
					String observedEventChannel = (String)((JSONObject)observedEvents.get(j)).get("channel");
					String observedEventAction = (String)((JSONObject)observedEvents.get(j)).get("action");
					
					expected.add(expectedEventChannel + "," + expectedEventAction);
					observed.add(observedEventChannel + "," + observedEventAction);
				}
				if (!expected.equals(observed)) {
					result = Status.FAIL;
					return;
				}
				
			}
			result = Status.PASS;
		}
	}
	void printResult () {
		updateStatus();
		System.out.println();
		System.out.println("-----------------");
		System.out.println("Test Id : " + id + ", " + description);
		System.out.println("Status : " + result);
		System.out.println("Origin : " + origin);
		System.out.println("SSL : " + ssl);
		System.out.println("Sub Key : " + subkey);
		System.out.println();

		for (int i = 0 ; i < steps.size() ; i++) {
			JSONObject jso = (JSONObject) steps.get(String.valueOf(i));
			jso.toJSONString();
			System.out.println(jso.toJSONString());
		}
		System.out.println("-----------------");
		System.out.println();
	}
	
	void run() {

		Pubnub listener = new Pubnub("", subkey);
		Pubnub actor = new Pubnub("",subkey, ssl);
		listener.setCacheBusting(false);
		actor.setCacheBusting(false);
		listener.setOrigin(origin);
		actor.setOrigin(origin);
		
		
		try {
			listener.presence(channels.get("channelA"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		try {
			listener.presence(channels.get("channelB"), new Callback(){

				@Override
				public void successCallback(String channel, Object message) {
					System.out.println(channel + " : " + message);
					JSONObject jso = null;
					try {
						jso = (JSONObject)new JSONParser().parse(message.toString());
					} catch (ParseException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					jso.put("channel", channel.split("-pnpres")[0]);
                    jso.put("time", Calendar.getInstance().getTime());
					
					JSONObject step =  (JSONObject)steps.get(String.valueOf(currentStep));
					JSONArray events = (JSONArray) step.get("events");
					if (events == null) {
						step.put("events", new JSONArray());
						events = (JSONArray) step.get("events");
					}
					events.add(jso);
					
				}
				
			});
		} catch (PubnubException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		
		for (int i = 0 ; i < steps.size(); i++) {
			currentStep++;
			JSONObject step = (JSONObject) steps.get(String.valueOf(i));
			JSONArray actorStep = (JSONArray) step.get("actor");
			
			if (actorStep.get(0).equals("subscribe")) {
				System.out.println("SUBSCRIBE : " +  channels.get(actorStep.get(1)));
				try {
					actor.subscribe(channels.get(actorStep.get(1)), new Callback(){

						@Override
						public void successCallback(String channel,
								Object message) {
							
						}
						
					});
				} catch (PubnubException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} else {
				System.out.println("UNSUBSCRIBE : " +  channels.get(actorStep.get(1)));
				actor.unsubscribe(channels.get(actorStep.get(1)));
				
			}
			JSONArray listenerStep = (JSONArray)step.get("listener");
			
			Long stepDelay = 0L;
			
			for (int k = 0; k < listenerStep.size(); k++) {
				Long delay = (Long) ((JSONArray)listenerStep.get(k)).get(2);
				if (delay > stepDelay) stepDelay = delay;
			}
			
			System.out.println("[" + Calendar.getInstance().getTime() + "] :  wait for " + (stepDelay/1000.00) + " seconds");
			try {
				Thread.sleep(stepDelay);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			
		}
		
	}
	
	
}


public class PubnubPresenceTest {
	static List<Test> testsList = new ArrayList<Test>();
	static String client = "3.5";

	public static void main(String[] args) {
		
		JSONParser parser = new JSONParser();
		


	    try {

	        Object obj = parser.parse(new FileReader("./tests.json"));

	        JSONArray tests =  (JSONArray) obj;
	        obj = parser.parse(new FileReader("./keysets.json"));
	        JSONObject keysets = (JSONObject) obj;
	        for (int i = 0 ; i < tests.size();i++) {
	        	JSONObject jso = (JSONObject) tests.get(i);
	        	JSONObject common = (JSONObject) jso.get("common");
	        	String description = (String) common.get("description");
	        	JSONObject steps = (JSONObject) jso.get("steps");
	        	boolean ssl = (Boolean) common.get("ssl");
	        	String server = (String) common.get("server");
	        	String clientStr = (String) common.get("client");
	        	if (!client.equals(clientStr)) {
	        		System.out.println("Skipping Test Due to Client Mismatch : " + clientStr);
	        		continue;
	        	}
	        	String origin = "pubsub";
	        	String subkey = (String) ((JSONObject)(keysets.get(common.get("keyset")))).get("subKey") ;
	        	long time = new Date().getTime();
	        	String channelA = "A-java-" + i + 1 + "-" + time;
	        	String channelB = "B-java-" + i + 1 + "-"+ time;
	        	

	        	Test t = new Test(i + 1, description, subkey, origin, channelA, channelB, ssl, steps);
	        	testsList.add(t);		
	        }
	        

	    } catch (FileNotFoundException e) {
	        e.printStackTrace();
	    } catch (IOException e) {
	        e.printStackTrace();
	    } catch (ParseException e) {
	        e.printStackTrace();
	    }
	    
	    System.out.println("Total Number of Tests : " + testsList.size());
	    for (int i = 0; i < testsList.size(); i++) {
	    	System.out.println("Running Test : " + (i + 1));
	    	testsList.get(i).run();
	    	testsList.get(i).printResult();
	    }
	    System.out.println("++++++++ RESULTS ++++++++");
	    for (int i = 0; i < testsList.size(); i++) {
	    	testsList.get(i).printResult();
	    }
	}	
	
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/pubsub/SubscribeEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.pubsub;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.server.SubscribeEnvelope;
import com.pubnub.api.models.server.SubscribeMessage;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class SubscribeEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    PubNub pubnub;
    Subscribe instance;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        instance = new Subscribe(pubnub);
    }

    @Test
    public void subscribeChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        SubscribeEnvelope subscribeEnvelope = instance.channels(Arrays.asList("coolChannel")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());

        assertEquals("1", subscribeEnvelope.getMetadata().getRegion());
        assertTrue(subscribeEnvelope.getMetadata().getTimetoken().equals(14607577960932487L));

        assertEquals(1, subscribeEnvelope.getMessages().size());
        SubscribeMessage subscribeMessage = subscribeEnvelope.getMessages().get(0);
        assertEquals("4", subscribeMessage.getShard());
        assertEquals("0", subscribeMessage.getFlags());
        assertEquals("coolChannel", subscribeMessage.getChannel());
        assertEquals("coolChan-bnel", subscribeMessage.getSubscriptionMatch());
        assertEquals("sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f", subscribeMessage.getSubscribeKey());
        assertEquals("Client-g5d4g", subscribeMessage.getIssuingClientId());
        assertEquals("{text=Enter Message Here}", subscribeMessage.getPayload().toString());
    }

    @Test
    public void subscribeChannelsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }

    @Test
    public void subscribeChannelsAuthSync() throws PubNubException {

        pubnub.getConfiguration().setAuthKey("authKey");

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals("authKey", requests.get(0).queryParameter("auth").firstValue());
        assertEquals(1, requests.size());
    }

    @Test
    public void subscribeChannelsWithGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel,coolChannel2/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1", "cg2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeWithTimeTokenSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).timetoken(1337L).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("1337", requests.get(0).queryParameter("tt").firstValue());
    }

    @Test
    public void subscribeWithFilter() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).filterExpression("this=1&that=cool").sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("this%3D1%26that%3Dcool", requests.get(0).queryParameter("filter-expr").firstValue());
    }

    @Test
    public void subscribeWithRegion() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/,/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        instance.channelGroups(Arrays.asList("cg1")).region("10").sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
        assertEquals("10", requests.get(0).queryParameter("tr").firstValue());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void subscribeMissingChannelAndGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/subscribe/mySubscribeKey/coolChannel/0"))
                .willReturn(aResponse().withBody("{\"t\":{\"t\":\"14607577960932487\",\"r\":1},\"m\":[{\"a\":\"4\",\"f\":0,\"i\":\"Client-g5d4g\",\"p\":{\"t\":\"14607577960925503\",\"r\":1},\"k\":\"sub-c-4cec9f8e-01fa-11e6-8180-0619f8945a4f\",\"c\":\"coolChannel\",\"d\":{\"text\":\"Enter Message Here\"},\"b\":\"coolChan-bnel\"}]}")));

        SubscribeEnvelope subscribeEnvelope = instance.sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/access/AuditEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.access;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerAuditResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static com.github.tomakehurst.wiremock.client.WireMock.matching;
import static org.junit.Assert.assertEquals;

public class AuditEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Audit partialAudit;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {

        pubnub = this.createPubNubInstance(8080);
        partialAudit = pubnub.audit();

        pubnub.getConfiguration().setSecretKey("secretKey");

    }

    @Test
    public void testSuccessChannelGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("IjnQ0J7c0SYT3gHBxrIC_8OkDHTqsF9KnI0SlBRLNfg%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel-group\":\"cg2\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channelGroup("cg1").authKeys(Arrays.asList("key1")).sync();

        Assert.assertEquals("cg2", pnAccessManagerAuditResult.getChannelGroup());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isManageEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isReadEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isWriteEnabled());
        Assert.assertEquals("channel-group+auth", pnAccessManagerAuditResult.getLevel());
        Assert.assertEquals("sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f", pnAccessManagerAuditResult.getSubscribeKey());

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/v1/auth/audit/sub-key/mySubscribeKey.*")));
        assertEquals(1, requests.size());

    }

    @Test
    public void testSuccessChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("ZlPruaId7jzupmK4LUynpnjvA2CQYyrrT0475wWkbwY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channel("ch1").authKeys(Arrays.asList("key1")).sync();

        Assert.assertEquals("ch1", pnAccessManagerAuditResult.getChannel());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isManageEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isReadEnabled());
        Assert.assertEquals(true, pnAccessManagerAuditResult.getAuthKeys().get("key1").isWriteEnabled());
        Assert.assertEquals("user", pnAccessManagerAuditResult.getLevel());
        Assert.assertEquals("sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f", pnAccessManagerAuditResult.getSubscribeKey());

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSuccessChannelMissingKeySync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/audit/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("ZlPruaId7jzupmK4LUynpnjvA2CQYyrrT0475wWkbwY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":1,\"m\":1,\"w\":1}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerAuditResult pnAccessManagerAuditResult = partialAudit.channel("ch1").sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/access/GrantEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.access;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerGrantResult;
import com.pubnub.api.models.consumer.access_manager.PNAccessManagerKeyData;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static com.github.tomakehurst.wiremock.client.WireMock.matching;

public class GrantEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Grant partialGrant;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {

        pubnub = this.createPubNubInstance(8080);
        partialGrant = pubnub.grant();

        pubnub.getConfiguration().setSecretKey("secretKey");

    }

    @Test
    public void NoGroupsOneChannelOneKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("KQ1g-hpCnWGD6DfR0J30xkB0KwBhbIBlLqKi8GNoD7M%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelTwoKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("hlFr8HmcEIK51rEc-jhwym89SgCeAKvzhTYphwD_Sqw%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
    }

    @Test
    public void NoGroupsTwoChannelOneKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("YSf7ataHaZQj0-kE9P5-0ACR4fjrzzGJbzRSoF3J4UQ%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(1, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
    }

    @Test
    public void NoGroupsTwoChannelTwoKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("q9gzdsS-Z_Ff21ZfiXEakG3fkOWsT49MEn4ZKFxjehY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(2, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());
    }

    @Test
    public void OneGroupNoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("BGNIzQq6T-X_ES7RjSeUh0L_THx6RP956DBRIfilQCE%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

    }

    @Test
    public void OneGroupNoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("vBxdD0-HPCuKoVlXL2c7JYeAmDVBN-TGodVJXFbOLcI%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

    }

    @Test
    public void OneGroupOneChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("eRwmB_DpD7rdR6qZDm4fh2PiXfdYbFXbwIcq-oVQOaY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":\"cg1\"},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void OneGroupOneChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("4ogB_IAapikN32FOCXJQD2FOHfrFbZqFrOCRry2C3AY%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":\"cg1\"},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());

    }

    @Test
    public void OneGroupTwoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("SMoWF-RgW-2wGZ-wbzkaKwd6b3Zigq2gYFCxmw0Equs%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1", "ch2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());

    }

    @Test
    public void OneGroupTwoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("FF-8u5mhNhbrWD5_XyIrCOPitG8YQbmeGYZXaiOQYBA%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":\"cg1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channels(Arrays.asList("ch1", "ch2")).channelGroups(Arrays.asList("cg1")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(1, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());
    }

    //

    @Test
    public void TwoGroupNoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("6mss-Lh0eaN0G_TfY6WfFKBqePYe1j4blNGwJPMxTOs%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

    }

    @Test
    public void TwoGroupNoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("q2AUprf6ZUD4N96hMTCVm7hoMfDRC7xfG4XPyLLNWB4%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).sync();

        Assert.assertEquals(0, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

    }

    @Test
    public void TwoGroupOneChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("pRlfFAiCrKIqSPUjZgaI3ZLq9wK4-VUvhf_ispH6ow8%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
    }

    @Test
    public void TwoGroupOneChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("8H6V_0LqSBinnK5Po5LA29ny8CH8eGonzB6UomoXvXo%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1")).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(2, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());

    }

    @Test
    public void TwoGroupTwoChannelOneKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("yBYF6-JTkM8F-U-K4ACwzrPEN0iihJQUygz4JOh4rwU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(1, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(1, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
    }

    @Test
    public void TwoGroupTwoChannelTwoKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1,ch2"))
                .withQueryParam("channel-group", matching("cg1,cg2"))
                .withQueryParam("auth", matching("key1,key2"))
                .withQueryParam("signature", matching("JLTTsGTwaaEORmY_zoZcCzYl4qEZVkid-YRSvKYMwUU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"channel-group+auth\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channels\":{\"ch1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"ch2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}},\"channel-groups\":{\"cg1\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}},\"cg2\":{\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0},\"key2\":{\"r\":0,\"w\":0,\"m\":0}}}}},\"service\":\"Access Manager\",\"status\":200}\n")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1", "key2")).channelGroups(Arrays.asList("cg1", "cg2")).channels(Arrays.asList("ch1", "ch2")).sync();

        Assert.assertEquals(2, result.getChannels().size());
        Assert.assertEquals(2, result.getChannelGroups().size());

        Assert.assertEquals(2, result.getChannelGroups().get("cg1").size());
        Assert.assertEquals(2, result.getChannelGroups().get("cg2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannelGroups().get("cg2").get("key2").getClass());

        Assert.assertEquals(2, result.getChannels().get("ch1").size());
        Assert.assertEquals(2, result.getChannels().get("ch2").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key2").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key1").getClass());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch2").get("key2").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneKeyTTLTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("pzSNXZSiBMkzg15vOQrKoDkue8OWoxEB1afup9Godac%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .withQueryParam("ttl", matching("1334"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).ttl(1334).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneReadKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("uVcT9Q_XiLPpR1kmIzD9OJ6mTa1V1GyvyBcKBWSDrJU%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("1"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).read(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneWriteKeyTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("-MirRhU4989XbPZEza82xvhZ0CdQIngM8b7qSUL1kDI%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("1"))
                .withQueryParam("m", matching("0"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).write(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }

    @Test
    public void NoGroupsOneChannelOneKeyManageTest() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("_znR67zw5cdCq3Cmn1QHUHtFolkquYARh_JYCeMb8ig%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("1"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.authKeys(Arrays.asList("key1")).channels(Arrays.asList("ch1")).manage(true).sync();

        Assert.assertEquals(1, result.getChannels().size());
        Assert.assertEquals(0, result.getChannelGroups().size());

        Assert.assertEquals(1, result.getChannels().get("ch1").size());
        Assert.assertEquals(PNAccessManagerKeyData.class, result.getChannels().get("ch1").get("key1").getClass());

    }


    @org.junit.Test(expected=PubNubException.class)
    public void NoGroupsOneChannelMissingKey() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v1/auth/grant/sub-key/mySubscribeKey"))
                .withQueryParam("pnsdk", matching("Java/suchJava"))
                .withQueryParam("channel", matching("ch1"))
                .withQueryParam("auth", matching("key1"))
                .withQueryParam("signature", matching("_znR67zw5cdCq3Cmn1QHUHtFolkquYARh_JYCeMb8ig%3D%0A"))
                .withQueryParam("uuid", matching("myUUID"))
                .withQueryParam("timestamp", matching("1337"))
                .withQueryParam("r", matching("0"))
                .withQueryParam("w", matching("0"))
                .withQueryParam("m", matching("1"))
                .willReturn(aResponse().withBody("{\"message\":\"Success\",\"payload\":{\"level\":\"user\",\"subscribe_key\":\"sub-c-82ab2196-b64f-11e5-8622-0619f8945a4f\",\"ttl\":1,\"channel\":\"ch1\",\"auths\":{\"key1\":{\"r\":0,\"w\":0,\"m\":0}}},\"service\":\"Access Manager\",\"status\":200}")));

        PNAccessManagerGrantResult result = partialGrant.channels(Arrays.asList("ch1")).manage(true).sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/HistoryEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.history.PNHistoryResult;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.*;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class HistoryEndpointTest extends TestHarness {

    private History partialHistory;
    private PubNub pubnub;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        partialHistory = pubnub.history();
    }


    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(true).sync();

        Assert.assertTrue(response.getStartTimeToken().equals(1234L));
        Assert.assertTrue(response.getEndTimeToken().equals(4321L));

        Assert.assertEquals(response.getMessages().size(), 2);

        Assert.assertTrue(response.getMessages().get(0).getTimetoken().equals(1111L));
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("a").asInt(), 11);
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("b").asInt(), 22);

        Assert.assertTrue(response.getMessages().get(1).getTimetoken().equals(2222L));
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("a").asInt(), 33);
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("b").asInt(), 44);
    }

    @Test
    public void testSyncAuthSuccess() throws PubNubException, JsonProcessingException {

        pubnub.getConfiguration().setAuthKey("authKey");

        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));


        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(true).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals("authKey", requests.get(0).queryParameter("auth").firstValue());
        assertEquals(1, requests.size());
    }


    @org.junit.Test
    public void testSyncEncryptedSuccess() throws IOException, PubNubException {
        pubnub.getConfiguration().setCipherKey("testCipher");

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody("[[\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\",\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\",\"EGwV+Ti43wh2TprPIq7o0KMuW5j6B3yWy352ucWIOmU=\\n\"],14606134331557853,14606134485013970]")));

        PNHistoryResult response = partialHistory.channel("niceChannel").includeTimetoken(false).sync();

        Assert.assertTrue(response.getStartTimeToken().equals(14606134331557853L));
        Assert.assertTrue(response.getEndTimeToken().equals(14606134485013970L));

        Assert.assertEquals(response.getMessages().size(), 3);

        Assert.assertEquals(response.getMessages().get(0).getTimetoken(), null);
        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(0).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(0).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(0).getEntry()).get(2).asText());

        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(1).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(1).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(1).getEntry()).get(2).asText());

        Assert.assertEquals("m1", ((JsonNode) response.getMessages().get(2).getEntry()).get(0).asText());
        Assert.assertEquals("m2", ((JsonNode) response.getMessages().get(2).getEntry()).get(1).asText());
        Assert.assertEquals("m3", ((JsonNode) response.getMessages().get(2).getEntry()).get(2).asText());

    }

    @org.junit.Test
    public void testSyncSuccessWithoutTimeToken() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);

        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);

        historyItems.add(historyItem1);
        historyItems.add(historyItem2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("niceChannel").sync();

        Assert.assertTrue(response.getStartTimeToken().equals(1234L));
        Assert.assertTrue(response.getEndTimeToken().equals(4321L));

        Assert.assertEquals(response.getMessages().size(), 2);

        Assert.assertNull(response.getMessages().get(0).getTimetoken());
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("a").asInt(), 11);
        Assert.assertEquals(((JsonNode) response.getMessages().get(0).getEntry()).get("b").asInt(), 22);

        Assert.assertNull(response.getMessages().get(1).getTimetoken());
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("a").asInt(), 33);
        Assert.assertEquals(((JsonNode) response.getMessages().get(1).getEntry()).get("b").asInt(), 44);
    }


    @org.junit.Test(expected=PubNubException.class)
    public void testMissinChannel() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.includeTimetoken(true).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testChannelIsEmpty() throws IOException, PubNubException {
        List<Object> testArray = new ArrayList<Object>();
        List<Object> historyItems = new ArrayList<Object>();
        ObjectMapper mapper = new ObjectMapper();


        Map<String, Object> historyEnvelope1 = new HashMap<String, Object>();
        Map<String, Object> historyItem1 = new HashMap<String, Object>();
        historyItem1.put("a", 11);
        historyItem1.put("b", 22);
        historyEnvelope1.put("timetoken", 1111);
        historyEnvelope1.put("message", historyItem1);

        Map<String, Object> historyEnvelope2 = new HashMap<String, Object>();
        Map<String, Object> historyItem2 = new HashMap<String, Object>();
        historyItem2.put("a", 33);
        historyItem2.put("b", 44);
        historyEnvelope2.put("timetoken", 2222);
        historyEnvelope2.put("message", historyItem2);

        historyItems.add(historyEnvelope1);
        historyItems.add(historyEnvelope2);

        testArray.add(historyItems);
        testArray.add(1234);
        testArray.add(4321);

        stubFor(get(urlPathEqualTo("/v2/history/sub-key/mySubscribeKey/channel/niceChannel"))
                .willReturn(aResponse().withBody(mapper.writeValueAsString(testArray))));

        PNHistoryResult response = partialHistory.channel("").includeTimetoken(true).sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/EndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints;

import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.enums.PNOperationType;
import okhttp3.Request;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

import java.io.IOException;
import java.util.Map;

public class EndpointTest extends TestHarness {

    PubNub pubnub;


    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
    }

    @Test
    public void testUUID() throws PubNubException {
        Endpoint<Object, Object> endpoint =  new Endpoint<Object, Object>(pubnub) {

            @Override
            protected void validateParams() throws PubNubException {
            }

            @Override
            protected Object createResponse(Response input) throws PubNubException {
                return null;
            }

            @Override
            protected int getConnectTimeout() {
                return 0;
            }

            @Override
            protected int getRequestTimeout() {
                return 0;
            }

            @Override
            protected PNOperationType getOperationType() {
                return null;
            }

            @Override
            protected Call doWork(Map baseParams) throws PubNubException {

                Call<Object> fakeCall = new Call<Object>() {

                    @Override
                    public Response<Object> execute() throws IOException {
                        Response<Object> newResponse = Response.success(null);
                        return newResponse;
                    }

                    @Override
                    public void enqueue(Callback<Object> callback) {

                    }

                    @Override
                    public boolean isExecuted() {
                        return false;
                    }

                    @Override
                    public void cancel() {

                    }

                    @Override
                    public boolean isCanceled() {
                        return false;
                    }

                    @Override
                    public Call<Object> clone() {
                        return null;
                    }

                    @Override
                    public Request request() {
                        return null;
                    }
                };

                Assert.assertEquals("myUUID",baseParams.get("uuid"));
                return fakeCall;
            }
        };

        endpoint.sync();
    }



}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/AddChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class AddChannelChannelGroupEndpointTest extends TestHarness {
    private AddChannelChannelGroup partialAddChannelChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialAddChannelChannelGroup = this.createPubNubInstance(8080).addChannelsToChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncGroupMissing() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncGroupIsEmpty() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("").channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncChannelMissing() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {} , \"service\": \"ChannelGroups\"}")));

        boolean response = partialAddChannelChannelGroup.channelGroup("groupA").sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/DeleteChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class DeleteChannelGroupEndpointTest extends TestHarness {
    private DeleteChannelGroup partialDeleteChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialDeleteChannelGroup = this.createPubNubInstance(8080).deleteChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA/remove"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialDeleteChannelGroup.channelGroup("groupA").sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissingGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA/remove"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialDeleteChannelGroup.sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/AllChannelsChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.channel_group.PNChannelGroupsAllChannelsResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class AllChannelsChannelGroupEndpointTest extends TestHarness {
    private AllChannelsChannelGroup partialAllChannelsChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialAllChannelsChannelGroup = this.createPubNubInstance(8080).listChannelsForChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {\"channels\": [\"a\",\"b\"]}, \"service\": \"ChannelGroups\"}")));

        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.channelGroup("groupA").sync();
        assertThat(response.getChannels(), org.hamcrest.Matchers.contains("a", "b"));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissingGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {\"channels\": [\"a\",\"b\"]}, \"service\": \"ChannelGroups\"}")));

        PNChannelGroupsAllChannelsResult response = partialAllChannelsChannelGroup.sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/channel_groups/RemoveChannelChannelGroupEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.channel_groups;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.pubnub.api.PubNubException;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;

import java.io.IOException;
import java.util.Arrays;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertThat;

public class RemoveChannelChannelGroupEndpointTest extends TestHarness {
    private RemoveChannelChannelGroup partialRemoveChannelChannelGroup;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    @Before
    public void beforeEach() throws IOException {
        partialRemoveChannelChannelGroup = this.createPubNubInstance(8080).removeChannelsFromChannelGroup();
    }

    @org.junit.Test
    public void testSyncSuccess() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channelGroup("groupA").channels(Arrays.asList("ch1", "ch2")).sync();
        assertThat(response, org.hamcrest.Matchers.equalTo(true));
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissinGroup() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channels(Arrays.asList("ch1", "ch2")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testSyncMissinChannel() throws IOException, PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v1/channel-registration/sub-key/mySubscribeKey/channel-group/groupA"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"payload\": {}, \"service\": \"ChannelGroups\"}")));

        boolean response = partialRemoveChannelChannelGroup.channelGroup("groupA").sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/GetStateEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.presence.PNGetStateResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class GetStateEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private GetState partialGetState;

    @Before
    public void beforeEach() throws IOException {
        partialGetState = this.createPubNubInstance(8080).getPresenceState();
    }

    @Test
    public void testOneChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));


        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("testChannel");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
    }

    @Test
    public void testOneChannelWithoutUUIDSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));


        PNGetStateResult result = partialGetState.channels(Arrays.asList("testChannel")).sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("testChannel");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
    }


    @org.junit.Test(expected=PubNubException.class)
    public void testFailedPayloadSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));

        partialGetState.channels(Arrays.asList("testChannel")).uuid("sampleUUID").sync();
    }

    @Test
    public void testMultipleChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1,ch2/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"ch1\": { \"age\" : 20, \"status\" : \"online\"}, \"ch2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channels(Arrays.asList("ch1", "ch2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("ch1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("ch2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");
    }

    @Test
    public void testOneChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channelGroups(Arrays.asList("cg1")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void testManyChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channelGroups(Arrays.asList("cg1", "cg2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void testCombinationSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"chcg1\": { \"age\" : 20, \"status\" : \"online\"}, \"chcg2\": { \"age\": 100, \"status\": \"offline\" } }, \"service\": \"Presence\"}")));

        PNGetStateResult result = partialGetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).uuid("sampleUUID").sync();
        Map<String, Object> ch1Data = (Map<String, Object>) result.getStateByUUID().get("chcg1");
        Assert.assertEquals(ch1Data.get("age"), 20);
        Assert.assertEquals(ch1Data.get("status"), "online");
        Map<String, Object> ch2Data = (Map<String, Object>) result.getStateByUUID().get("chcg2");
        Assert.assertEquals(ch2Data.get("age"), 100);
        Assert.assertEquals(ch2Data.get("status"), "offline");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @org.junit.Test(expected=PubNubException.class)
    public void testMissingChannelAndGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/sampleUUID"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\"}, \"service\": \"Presence\"}")));
        PNGetStateResult result = partialGetState.uuid("sampleUUID").sync();
    }
}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/LeaveTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.jayway.awaitility.Awaitility;
import com.pubnub.api.callbacks.PNCallback;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.PNStatus;
import com.pubnub.api.endpoints.TestHarness;
import com.pubnub.api.models.consumer.presence.PNGetStateResult;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class LeaveTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private Leave instance;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);
        instance = new Leave(pubnub);
    }

    @Test
    public void subscribeChannelSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());

    }

    @Test
    public void subscribeChannelsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
    }


    @Test
    public void subscribeChannelsWithGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeChannelsWithGroupASync() throws PubNubException {

        final AtomicBoolean statusArrived = new AtomicBoolean();

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel,coolChannel2/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channels(Arrays.asList("coolChannel", "coolChannel2")).channelGroups(Arrays.asList("cg1")) .async(new PNCallback<Boolean>() {
            @Override
            public void onResponse(Boolean result, PNStatus status) {
                assertEquals(status.getAffectedChannels().get(0), "coolChannel");
                assertEquals(status.getAffectedChannels().get(1), "coolChannel2");
                assertEquals(status.getAffectedChannelGroups().get(0), "cg1");
                statusArrived.set(true);
            }
        });


        Awaitility.await().atMost(2, TimeUnit.SECONDS).untilAtomic(statusArrived, org.hamcrest.core.IsEqual.equalTo(true));
    }

    @Test
    public void subscribeGroupsSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channelGroups(Arrays.asList("cg1", "cg2")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void subscribeGroupSync() throws PubNubException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.channelGroups(Arrays.asList("cg1")).sync();

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @org.junit.Test(expected=PubNubException.class)
    public void testMissingChannelAndGroupSync() throws PubNubException, InterruptedException {
        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/coolChannel/leave"))
                .willReturn(aResponse().withBody("{\"status\": 200, \"message\": \"OK\", \"service\": \"Presence\", \"action\": \"leave\"}")));

        instance.sync();
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/test/java/com.pubnub.api/endpoints/presence/SetStateEndpointTest.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.presence;

import com.github.tomakehurst.wiremock.junit.WireMockRule;
import com.github.tomakehurst.wiremock.verification.LoggedRequest;
import com.pubnub.api.PubNub;
import com.pubnub.api.PubNubException;
import com.pubnub.api.models.consumer.presence.PNSetStateResult;
import com.pubnub.api.endpoints.TestHarness;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.Assert.assertEquals;


public class SetStateEndpointTest extends TestHarness {

    @Rule
    public WireMockRule wireMockRule = new WireMockRule();

    private SetState partialSetState;
    private PubNub pubnub;

    @Before
    public void beforeEach() throws IOException {
        pubnub = this.createPubNubInstance(8080);

        partialSetState = pubnub.setPresenceState();
    }

    @Test
    public void applyStateForChannelSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel")).state(Arrays.asList("s1", "s2", "s3")).sync();
        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());

    }

    @Test
    public void applyStateForChannelsSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel,testChannel2/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel", "testChannel2")).state(Arrays.asList("s1", "s2", "s3")).sync();
        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
    }

    @Test
    public void applyStateForChannelGroupSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channelGroups(Arrays.asList("cg1")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1", requests.get(0).queryParameter("channel-group").firstValue());
    }

    @Test
    public void applyStateForChannelGroupsSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/,/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @Test
    public void applyStateForMixSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();

        assertEquals(result.getState().get("age"), 20);
        assertEquals(result.getState().get("status"), "online");

        List<LoggedRequest> requests = findAll(getRequestedFor(urlMatching("/.*")));
        assertEquals(1, requests.size());
        assertEquals("%5B%22s1%22%2C%22s2%22%2C%22s3%22%5D", requests.get(0).queryParameter("state").firstValue());
        assertEquals("cg1,cg2", requests.get(0).queryParameter("channel-group").firstValue());

    }

    @org.junit.Test(expected=PubNubException.class)
    public void applyNon200Sync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/ch1/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}").withStatus(400)));


        PNSetStateResult result = partialSetState.channels(Arrays.asList("ch1")).channelGroups(Arrays.asList("cg1", "cg2")).state(Arrays.asList("s1", "s2", "s3")).sync();
    }

    @org.junit.Test(expected=PubNubException.class)
    public void MissimStateSync() throws PubNubException, InterruptedException {

        stubFor(get(urlPathEqualTo("/v2/presence/sub-key/mySubscribeKey/channel/testChannel/uuid/myUUID/data"))
                .willReturn(aResponse().withBody("{ \"status\": 200, \"message\": \"OK\", \"payload\": { \"age\" : 20, \"status\" : \"online\" }, \"service\": \"Presence\"}")));

        PNSetStateResult result = partialSetState.channels(Arrays.asList("testChannel")).sync();
    }


}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_45c9719_e3860f0/rev_45c9719-e3860f0/src/main/java/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
=======
package com.pubnub.api;

import com.pubnub.api.utils.Base64;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

/**
 * Created by Frederick on 3/30/16.
 */
public class PubnubUtil {


    public static String joinString(List<String> val, String delim){
        StringBuilder builder = new StringBuilder();
        for(String l: val){
            builder.append(l);
            builder.append(",");
        }

        return builder.toString().substring(0,builder.toString().length() - 1);

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.
                    replace("*", "%2A")
                    .replace("!", "%21")
                    .replace("'", "%27")
                    .replace("(", "%28")
                    .replace(")", "%29")
                    .replace("[", "%5B")
                    .replace("]", "%5D")
                    .replace("~", "%7E");
        }
        return encoded;
    }


    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String preparePamArguments(Map<String, String> pamArgs){
        Set<String> pamKeys = new TreeSet(pamArgs.keySet());
        String stringifiedArguments = "";
        int i = 0;

        for (String pamKey : pamKeys) {
            if (i != 0) {
                stringifiedArguments += "&";
            }


            stringifiedArguments += pamEncode(pamKey);
            stringifiedArguments += "=";
            stringifiedArguments += pamEncode(pamArgs.get(pamKey));

            i += 1;
        }

        return stringifiedArguments;
    }

    public static String signSHA256(final String key, final String data) throws PubNubException {
        Mac sha256HMAC;
        byte[] hmacData;
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), "HmacSHA256");

        try {
            sha256HMAC = Mac.getInstance("HmacSHA256");
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        try {
            sha256HMAC.init(secretKey);
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        try {
            hmacData = sha256HMAC.doFinal(data.getBytes("UTF-8"));
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(PubNubError.PNERROBJ_CRYPTO_ERROR).errormsg(e.getMessage()).build();
        }

        return new String(Base64.encode(hmacData, 0)).replace('+', '-').replace('/', '_');
    }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/examples/eclipse_project_console/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/j2me/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import org.json.me.*;

public class PubnubUtil extends PubnubUtilCore {

    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }

    public static String escapeJava(String s) {
        s = s.replaceAll("\"", "\\\\\"");
        return s;
    }
		

    private static String replace(String str, String pattern, String replace) {
        int s = 0;
        int e = 0;
        StringBuffer result = new StringBuffer();

        while ((e = str.indexOf(pattern, s)) >= 0) {
            result.append(str.substring(s, e));
            result.append(replace);
            s = e + pattern.length();
        }
        result.append(str.substring(s));
        return result.toString();
    }

    /**
     * Returns encoded String
     * 
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = replace(encoded, "*", "%2A");
            encoded = replace(encoded, "!", "%21");
            encoded = replace(encoded, "'", "%27");
            encoded = replace(encoded, "(", "%28");
            encoded = replace(encoded, ")", "%29");
            encoded = replace(encoded, "[", "%5B");
            encoded = replace(encoded, "]", "%5D");
            encoded = replace(encoded, "~", "%7E");
        }
        return encoded;
    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return replace(encode(sUrl, "UTF-8"), "+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    public static String encode(String s, String enc) throws UnsupportedEncodingException {

        boolean needToChange = false;
        boolean wroteUnencodedChar = false;
        int maxBytesPerChar = 10;
        StringBuffer out = new StringBuffer(s.length());
        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);

        OutputStreamWriter writer = new OutputStreamWriter(buf, enc);

        for (int i = 0; i < s.length(); i++) {
            int c = (int) s.charAt(i);
            if (dontNeedEncoding(c)) {
                if (c == ' ') {
                    c = '+';
                    needToChange = true;
                }
                out.append((char) c);
                wroteUnencodedChar = true;
            } else {
                try {
                    if (wroteUnencodedChar) {
                        writer = new OutputStreamWriter(buf, enc);
                        wroteUnencodedChar = false;
                    }
                    writer.write(c);
                    if (c >= 0xD800 && c <= 0xDBFF) {

                        if ((i + 1) < s.length()) {
                            int d = (int) s.charAt(i + 1);
                            if (d >= 0xDC00 && d <= 0xDFFF) {
                                writer.write(d);
                                i++;
                            }
                        }
                    }
                    writer.flush();
                } catch (IOException e) {
                    buf.reset();
                    continue;
                }
                byte[] ba = buf.toByteArray();
                for (int j = 0; j < ba.length; j++) {
                    out.append('%');
                    char ch = CCharacter.forDigit((ba[j] >> 4) & 0xF, 16);
                    out.append(ch);
                    ch = CCharacter.forDigit(ba[j] & 0xF, 16);
                    out.append(ch);
                }
                buf.reset();
                needToChange = true;
            }
        }

        return (needToChange ? out.toString() : s);
    }

    static class CCharacter {
        public static char forDigit(int digit, int radix) {
            if ((digit >= radix) || (digit < 0)) {
                return '\0';
            }
            if ((radix < Character.MIN_RADIX) || (radix > Character.MAX_RADIX)) {
                return '\0';
            }
            if (digit < 10) {
                return (char) ('0' + digit);
            }
            return (char) ('a' - 10 + digit);
        }
    }

    public static boolean dontNeedEncoding(int ch) {
        int len = _dontNeedEncoding.length();
        boolean en = false;
        for (int i = 0; i < len; i++) {
            if (_dontNeedEncoding.charAt(i) == ch) {
                en = true;
                break;
            }
        }

        return en;
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        return str;
    }

    private static String _dontNeedEncoding = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ -_.*";
    

    
    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */
    public static String[] splitString(String source, String delimiter) {
        System.out.println("[" + delimiter + "] : " + source );
        int delimiterCount = 0;
        int index = 0;
        String tmpStr = source;

        String[] splittedList;

        while ((index = tmpStr.indexOf(delimiter)) != -1) {

            tmpStr = tmpStr.substring(index + delimiter.length());
            delimiterCount++;
        }

        splittedList = new String[delimiterCount + 1];

        int counter = 0;
        tmpStr = source;
        System.out.println("Delimiter Count : " + delimiterCount);
        do {
            int nextIndex = tmpStr.indexOf(delimiter, index + 1);
            
            System.out.println("Next Index : " + nextIndex);
            
            if (nextIndex != -1) {
                System.out.println(tmpStr);
                System.out.println(index);
                System.out.println(index + delimiter.length() + " : " + nextIndex);
                splittedList[counter++] = tmpStr.substring(index + delimiter.length(), nextIndex);
                tmpStr = tmpStr.substring(nextIndex);

            } else {
                splittedList[counter++] = tmpStr.substring(index + delimiter.length());
                tmpStr = tmpStr.substring(index + 1);
            }
        } while ((index = tmpStr.indexOf(delimiter)) != -1);

        return splittedList;
    }

    /**
     * Takes String[] of tokens, and String delimiter as input and returns
     * joined String
     *
     * @param sourceArray
     *            , input tokens in String array
     * @param delimiter
     *            , delimiter to join on
     * @return String , string of tokens joined by delimiter
     */
    public static String joinString(String[] sourceArray, String delimiter) {
        if (sourceArray == null || delimiter == null || sourceArray.length <= 0) {
            return "";
        }
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < sourceArray.length - 1; i++) {
            sb.append(sourceArray[i]).append(delimiter);
        }
        sb.append(sourceArray[sourceArray.length - 1]);

        return sb.toString();
    }
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/src1/com/pubnub/api/PubnubUtil.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Locale;


/**
 * PubnubUtil class provides utility methods like urlEncode etc
 *
 * @author Pubnub
 *
 */
public class PubnubUtil extends PubnubUtilCore {


    public static String stringEscapeSlashes(String s, String a, String b) {
        return s.replace(a, b);
    }
    public static String stringReplaceAll(String s, String a, String b) {
        return s.replaceAll(a, b);
    }
    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String pamEncode(String sUrl) {
        /* !'()*~ */

        String encoded = urlEncode(sUrl);
        if (encoded != null) {
            encoded = encoded.replace("*", "%2A").replace("!", "%21").replace("'", "%27").replace("(", "%28")
                    .replace(")", "%29").replace("[", "%5B").replace("]", "%5D").replace("~", "%7E");
        }
        return encoded;

    }

    /**
     * Returns encoded String
     *
     * @param sUrl
     *            , input string
     * @return , encoded string
     */
    public static String urlEncode(String sUrl) {
        try {
            return URLEncoder.encode(sUrl, "UTF-8").replace("+", "%20");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * Convert input String to JSONObject, JSONArray, or String
     *
     * @param str
     *            JSON data in string format
     *
     * @return JSONArray or JSONObject or String
     */
    static Object stringToJSON(String str) {
        try {
            return new JSONArray(str);
        } catch (JSONException e) {
        }
        try {
            return new JSONObject(str);
        } catch (JSONException ex) {
        }
        try {
            return Integer.parseInt(str);
        } catch (Exception ex) {
        }
        try {
            return Double.parseDouble(str);
        } catch (Exception ex) {
        }
        return str;
    }

    /**
     * Takes source and delimiter string as inputs and returns splitted string
     * in form of tokens in String array
     *
     * @param source
     *            , input String
     * @param delimiter
     *            , delimiter to split on
     * @return String[] , tokens in and array
     */

    public static String[] splitString(String source, String delimiter) {
        return source.split(delimiter);
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCore.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.*;

abstract class PubnubCore implements PubnubInterface {

    protected static String VERSION = "";
    protected volatile boolean CACHE_BUSTING = true;

    protected String HOSTNAME = "pubsub";
    protected int HOSTNAME_SUFFIX = 1;
    protected String DOMAIN = "pubnub.com";
    protected String ORIGIN_STR = null;
    protected String PUBLISH_KEY = "";
    protected String SUBSCRIBE_KEY = "";
    protected String SECRET_KEY = "";
    protected String CIPHER_KEY = "";
    protected String IV = null;
    protected volatile String AUTH_STR = null;
    private Random generator = new Random();

    protected Hashtable params;

    private boolean SSL = true;
    protected String UUID = null;

    protected SubscribeManager subscribeManager;
    protected NonSubscribeManager nonSubscribeManager;

    protected abstract String getUserAgent();

    protected HttpResponse fetch(String url) throws IOException, PubnubException {
        return null;
    }

    // abstract String uuid();

    protected String getPubnubUrl() {

        if (ORIGIN_STR == null) {
            // SSL On?
            if (this.SSL) {
                ORIGIN_STR = "https://";
            } else {
                ORIGIN_STR = "http://";
            }
            ORIGIN_STR += HOSTNAME;
            ORIGIN_STR += ((!this.CACHE_BUSTING) ? "" : "-" + String.valueOf(HOSTNAME_SUFFIX));
            ORIGIN_STR += "." + DOMAIN;
        }
        return ORIGIN_STR;
    }

    public void setOrigin(String origin) {
        this.HOSTNAME = origin;
    }

    public String getOrigin() {
        return this.HOSTNAME;
    }

    public void setDomain(String domain) {
        this.DOMAIN = domain;
    }

    public String getDomain() {
        return this.DOMAIN;
    }

    public String getAuthKey() {
        return this.AUTH_STR;
    }

    public void setAuthKey(String authKey) {

        this.AUTH_STR = authKey;
        if (authKey == null || authKey.length() == 0) {
            params.remove("auth");
        } else {
            params.put("auth", this.AUTH_STR);
        }
    }

    public void unsetAuthKey() {
        this.AUTH_STR = null;
        params.remove("auth");
    }

    protected int getRandom() {
        return Math.abs(this.generator.nextInt());
    }

    protected Callback voidCallback = new Callback() {
        public void successCallback(String channel, Object message) {
        }
    };

    protected Callback getWrappedCallback(Callback callback) {
        if (callback == null) {
            return voidCallback;
        } else
            return callback;
    }

    protected PubnubError getPubnubError(PubnubException px, PubnubError error, int code, String message) {
        PubnubError pe = px.getPubnubError();
        if (pe == null) {
            pe = PubnubError.getErrorObject(error, code, message);
        }
        return pe;
    }

    protected void decryptJSONArray(JSONArray messages) throws JSONException, IllegalStateException, IOException,
            PubnubException {

        if (CIPHER_KEY.length() > 0) {
            for (int i = 0; i < messages.length(); i++) {
                PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);

                String message;
                message = pc.decrypt(messages.get(i).toString());
                messages.put(i, PubnubUtil.stringToJSON(message));
            }
        }
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, "", ssl_on);
    }

    public PubnubCore(String publish_key, String subscribe_key) {
        this.init(publish_key, subscribe_key, "", "", false);
    }

    public PubnubCore(String publish_key, String subscribe_key, boolean ssl) {
        this.init(publish_key, subscribe_key, "", "", ssl);
    }

    public PubnubCore(String publish_key, String subscribe_key, String secret_key) {
        this.init(publish_key, subscribe_key, secret_key, "", false);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on) {
        this.init(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, null);
    }

    private void init(String publish_key, String subscribe_key, String secret_key, String cipher_key, boolean ssl_on,
            String initialization_vector) {
        this.PUBLISH_KEY = publish_key;
        this.SUBSCRIBE_KEY = subscribe_key;
        this.SECRET_KEY = secret_key;
        this.CIPHER_KEY = cipher_key;
        this.SSL = ssl_on;

        if (UUID == null)
            UUID = uuid();

        if (params == null)
            params = new Hashtable();

        params.put("pnsdk", getUserAgent());

    }

    public void setUUID(String uuid) {
        this.UUID = uuid;
    }

    public String getUUID() {
        return this.UUID;
    }

    protected Object _publish(Hashtable args, boolean sync) {

        final String channel = (String) args.get("channel");
        final Object message = args.get("message");
        Callback cb = (Callback) args.get("callback");

        String storeInHistory = (String) args.get("storeInHistory");
        String msgStr = message.toString();
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        parameters.put("uuid", getUUID());

        if (storeInHistory != null && storeInHistory.length() > 0)
            parameters.put("store", storeInHistory);
        
        JSONObject meta = (JSONObject) args.get("meta");
        if (meta != null && meta.length() > 0)
            parameters.put("meta", meta.toString());


        final Callback callback = getWrappedCallback(cb);



        if (this.CIPHER_KEY.length() > 0) {
            // Encrypt Message
            PubnubCrypto pc = new PubnubCrypto(this.CIPHER_KEY, this.IV);
            try {

                if (message instanceof String) {
                    msgStr = "\"" + msgStr + "\"";
                }
                msgStr = "\"" + pc.encrypt(msgStr) + "\"";
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 4, msgStr + " : " + e.toString()));
                return null;
            }
        } else {
            if (message instanceof String) {
                /*
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\\n", "\\\\n");
                msgStr = PubnubUtil.stringEscapeSlashes(msgStr, "\\", "\\\\");
                msgStr = PubnubUtil.stringReplaceAll(msgStr, "\"", "\\\\\"");
                */
                msgStr = PubnubUtil.escapeJava(msgStr);
                msgStr = "\"" + msgStr + "\"";
            }
        }

        // Generate String to Sign
        String signature = "0";

        if (this.SECRET_KEY.length() > 0) {
            StringBuffer string_to_sign = new StringBuffer();
            string_to_sign.append(this.PUBLISH_KEY).append('/').append(this.SUBSCRIBE_KEY).append('/')
                    .append(this.SECRET_KEY).append('/').append(channel).append('/').append(msgStr);

            // Sign Message
            try {
                signature = new String(PubnubCrypto.hexEncode(PubnubCrypto.md5(string_to_sign.toString())), "UTF-8");
            } catch (UnsupportedEncodingException e) {
                PubnubError pe = PubnubError.getErrorObject(PubnubError.PNERROBJ_ENCRYPTION_ERROR, 6, msgStr + " : "
                        + e.toString());
                callback.errorCallback(channel, pe);
            } catch (PubnubException e) {
                callback.errorCallback(channel,
                        getPubnubError(e, PubnubError.PNERROBJ_ENCRYPTION_ERROR, 5, msgStr + " : " + e.toString()));
            }
        }
        String[] urlComponents = { getPubnubUrl(), "publish", this.PUBLISH_KEY, this.SUBSCRIBE_KEY,
                PubnubUtil.urlEncode(signature), PubnubUtil.urlEncode(channel), "0", PubnubUtil.urlEncode(msgStr) };

        class PublishResponseHandler extends ResponseHandler {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                callback.successCallback(channel, jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                callback.errorCallback(channel, error);
                return;
            }
        }
        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new PublishResponseHandler());

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    JSONObject _whereNow(final String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] urlargs = { getPubnubUrl(), "v2", "presence", "sub_key", this.SUBSCRIBE_KEY, "uuid",
                PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlargs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return (JSONObject) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _request(final HttpRequest hreq, RequestManager connManager, boolean abortExisting) {
        if (abortExisting) {
            connManager.resetHttpManager();
        }
        if (connManager == null) {
            try {
                HttpResponse resp = fetch(hreq.getUrl());
                return PubnubUtil.stringToJSON(resp.getResponse());

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                return null;
            } catch (PubnubException e) {
                // System.out.println(e);
                return e.getErrorJsonObject();
            }
        }
        connManager.queue(hreq);
        return null;
    }

    protected Object _request(final HttpRequest hreq, RequestManager simpleConnManager) {
        return _request(hreq, simpleConnManager, false);
    }

    protected JSONArray _time(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = { getPubnubUrl(), "time", "0" };
        HttpRequest hreq = new HttpRequest(url, params, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 7, response));
                    return;
                }
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return (JSONArray) _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void keepOnlyPluralSubscriptionItems(Hashtable args) {
        String _channel = (String) args.get("channel");
        String _group = (String) args.get("group");

        if (_channel != null && !(_channel.equals(""))) {
            args.put("channels", new String[] { _channel });
            args.remove("channel");
        }

        if (_group != null && !(_group.equals(""))) {
            args.put("groups", new String[] { _group });
            args.remove("group");
        }
    }

    protected boolean inputsValid(Hashtable args) throws PubnubException {
        boolean channelsOk;
        boolean groupsOk;

        if (!(args.get("callback") instanceof Callback) || args.get("callback") == null) {
            throw new PubnubException("Invalid Callback");
        }

        String[] _channels = (String[]) args.get("channels");
        String[] _groups = (String[]) args.get("groups");

        channelsOk = (_channels != null && _channels.length > 0);
        groupsOk = (_groups != null && _groups.length > 0);

        if (!channelsOk && !groupsOk) {
            throw new PubnubException("Channel or Channel Group Missing");
        }

        return true;
    }

    protected Object _history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        if (count == -1)
            count = 100;

        parameters.put("count", String.valueOf(count));
        parameters.put("reverse", String.valueOf(reverse));
        parameters.put("include_token", String.valueOf(includeTimetoken));

        if (start != -1)
            parameters.put("start", Long.toString(start).toLowerCase());

        if (end != -1)
            parameters.put("end", Long.toString(end).toLowerCase());

        String[] urlargs = { getPubnubUrl(), "v2", "history", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel) };

        class HistoryResponseHandler extends ResponseHandler {

            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray respArr;
                try {
                    respArr = new JSONArray(response);
                    decryptJSONArray((JSONArray) respArr.get(0));
                    cb.successCallback(channel, respArr);
                } catch (JSONException e) {
                    cb.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 3));
                } catch (IOException e) {
                    cb.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 9, response));
                } catch (PubnubException e) {
                    cb.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 10,
                                    response + " : " + e.toString()));
                } catch (Exception e) {
                    cb.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 11,
                                    response + " : " + e.toString()));
                }

            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        }

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new HistoryResponseHandler());
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids,
            Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        ArrayList urlArgs = new ArrayList();

        urlArgs.add(getPubnubUrl());
        urlArgs.add("v2");
        urlArgs.add("presence");
        urlArgs.add("sub_key");
        urlArgs.add(this.SUBSCRIBE_KEY);

        if (channels != null || channelGroups != null) {
            String channelsString = PubnubUtil.joinString(channels, ",");
            if ("".equals(channelsString)) {
                channelsString = ",";
            } else {
                channelsString = PubnubUtil.urlEncode(channelsString);
            }

            urlArgs.add("channel");
            urlArgs.add(channelsString);
        }

        if (state)
            parameters.put("state", "1");
        if (!uuids)
            parameters.put("disable_uuids", "1");
        if (channelGroups != null && channelGroups.length > 0) {
            parameters.put("channel-group", PubnubUtil.joinString(channelGroups, ","));
        }

        String[] path = (String[]) urlArgs.toArray(new String[urlArgs.size()]);

        HttpRequest hreq = new HttpRequest(path, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(null, response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected boolean validateInput(String name, Object input, Callback callback) {

        if (input == null) {
            callback.errorCallback("",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 1, name + " cannot be null"));
            return false;
        }

        if (input instanceof String && ((String) input).length() == 0) {
            callback.errorCallback(
                    "",
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_ARGUMENTS, 2, name
                            + " cannot be zero length"));
            return false;
        }
        return true;
    }

    protected Object _setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback, boolean sync) {
        SubscriptionItem item = sub.getItem(channel);
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel", channel,
                "uuid", PubnubUtil.urlEncode(uuid), "data" };

        if (state != null)
            parameters.put("state", state.toString());
        if (group != null)
            parameters.put("channel-group", group);

        if (item != null) {
            try {
                sub.state.put(channel, state);
            } catch (JSONException e) {

            }
        }

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _getState(String channel, String uuid, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String[] urlArgs = { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "uuid", PubnubUtil.urlEncode(uuid) };

        HttpRequest hreq = new HttpRequest(urlArgs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 1);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback, int extendedErrorCode) {
        invokeCallback(channel, response, key, callback, extendedErrorCode, false);
    }

    protected void invokeCallback(String channel, String response, String key, Callback callback,
            int extendedErrorCode, boolean key_strict) {
        JSONObject responseJso = null;
        try {
            responseJso = new JSONObject(response);
        } catch (JSONException e) {
            callback.errorCallback(channel,
                    PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
            return;
        }

        JSONObject payloadJso = null;

        if (key != null && key.length() > 0) {
            try {
                payloadJso = (JSONObject) responseJso.get(key);
            } catch (JSONException e) {
                if (!key_strict) {
                    callback.successCallback(channel, responseJso);
                } else {
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, extendedErrorCode, response));
                }
                return;

            }
            callback.successCallback(channel, payloadJso);
            return;
        }
    }

    protected void invokeJSONStringCallback(String response, String key, Callback callback) {
        String responseJSON;

        try {
            responseJSON = (new JSONObject(response)).getString(key);
            callback.successCallback(null, responseJSON);
        } catch (JSONException e) {
            callback.errorCallback(null, PubnubError.getErrorObject(PubnubError.PNERROBJ_JSON_ERROR, 0, response));
        }
    }

    protected Object _channelGroupRemoveNamespace(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace", namespace, "remove" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListGroups(String namespace, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        String[] url;

        if (namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", namespace, "channel-group" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListChannels(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupUpdate(String action, String group, String[] channels, final Callback callback,
            boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        if (channels.length > 0) {
            parameters.put(action, PubnubUtil.joinString(channels, ","));
        }

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupRemoveGroup(String group, Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        ChannelGroup channelGroup;
        String[] url;

        try {
            channelGroup = new ChannelGroup(group);
        } catch (PubnubException e) {
            cb.errorCallback(null, PubnubError.PNERROBJ_CHANNEL_GROUP_PARSING_ERROR);
            return null;
        }

        if (channelGroup.namespace != null) {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "namespace", channelGroup.namespace, "channel-group", channelGroup.group, "remove" };
        } else {
            url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                    "channel-group", channelGroup.group, "remove" };
        }

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeJSONStringCallback(response, "message", cb);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }

        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _channelGroupListNamespaces(Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        String[] url = new String[] { getPubnubUrl(), "v1", "channel-registration", "sub-key", this.SUBSCRIBE_KEY,
                "namespace" };

        Hashtable parameters = PubnubUtil.hashtableClone(params);

        HttpRequest hreq = new HttpRequest(url, parameters, new ResponseHandler() {

            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback("", response, "payload", cb, 0);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _disablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("remove", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _requestPushNotificationEnabledChannelsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _removeAllPushNotificationsForDeviceRegistrationId(String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId, "remove" };

        parameters.put("type", "gcm");

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });
        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _enablePushNotificationsOnChannels(final String[] channels, String gcmRegistrationId,
            final Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        String[] urlargs = null;
        urlargs = new String[] { getPubnubUrl(), "v1", "push", "sub-key", this.SUBSCRIBE_KEY, "devices",
                gcmRegistrationId };

        parameters.put("type", "gcm");
        parameters.put("add", PubnubUtil.joinString(channels, ","));

        HttpRequest hreq = new HttpRequest(urlargs, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                JSONArray jsarr;
                try {
                    jsarr = new JSONArray(response);
                } catch (JSONException e) {
                    handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                    return;
                }
                cb.successCallback("", jsarr);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback("", error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected String pamSign(String key, String data) throws PubnubException {
        return null;
    }

    protected Object _pamAuditChannelGroup(final String group, String auth_key, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + auth_key + "&";

        sign_input += "channel-group=" + PubnubUtil.urlEncode(group) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel-group", group);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamAudit(final String channel, String auth_key, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 4));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "auth="
                + PubnubUtil.urlEncode(auth_key) + "&" + "channel=" + PubnubUtil.urlEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.urlEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("channel", channel);
        parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 2);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamAudit(final String channel, Callback callback, boolean sync) {

        final Callback cb = getWrappedCallback(callback);

        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 3));
            return null;
        }
        String sign_input = null;
        if (channel != null) {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "channel="
                    + PubnubUtil.pamEncode(channel) + "&" + "pnsdk=" + PubnubUtil.pamEncode(getUserAgent()) + "&"
                    + "timestamp=" + timestamp;
        } else {
            sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "audit" + "\n" + "pnsdk="
                    + PubnubUtil.pamEncode(getUserAgent()) + "&" + "timestamp=" + timestamp;
        }

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        if (channel != null)
            parameters.put("channel", channel);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "audit", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 6);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

    protected Object _pamGrantChannelGroup(final String group, String auth_key, boolean read, boolean management,
            int ttl, Callback callback, boolean sync) {
        String signature;
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);

        String r = (read) ? "1" : "0";
        String m = (management) ? "1" : "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(group, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel-group=" + PubnubUtil.pamEncode(group) + "&" + "m=" + m + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "");

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(group, e1.getPubnubError());
            return null;
        }

        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("m", m);
        parameters.put("channel-group", group);

        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));
        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(group, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(group, error);
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);
    }

    protected Object _pamGrant(final String channel, String auth_key, boolean read, boolean write, int ttl,
            Callback callback, boolean sync) {
        final Callback cb = getWrappedCallback(callback);
        Hashtable parameters = PubnubUtil.hashtableClone(params);
        parameters.remove("auth");

        String r = (read) ? "1" : "0";
        String w = (write) ? "1" : "0";

        String signature = "0";

        int timestamp = (int) ((new Date().getTime()) / 1000);

        if (this.SECRET_KEY.length() == 0) {
            callback.errorCallback(channel, PubnubError.getErrorObject(PubnubError.PNERROBJ_SECRET_KEY_MISSING, 1));
            return null;
        }

        String sign_input = this.SUBSCRIBE_KEY + "\n" + this.PUBLISH_KEY + "\n" + "grant" + "\n";

        if (auth_key != null && auth_key.length() > 0)
            sign_input += "auth=" + PubnubUtil.pamEncode(auth_key) + "&";

        sign_input += "channel=" + PubnubUtil.pamEncode(channel) + "&" + "pnsdk="
                + PubnubUtil.pamEncode(getUserAgent()) + "&" + "r=" + r + "&" + "timestamp=" + timestamp
                + ((ttl >= -1) ? "&" + "ttl=" + ttl : "") + "&" + "w=" + w;

        try {
            signature = pamSign(this.SECRET_KEY, sign_input);
        } catch (PubnubException e1) {
            callback.errorCallback(channel, e1.getPubnubError());
            return null;
        }

        parameters.put("w", w);
        parameters.put("timestamp", String.valueOf(timestamp));
        parameters.put("signature", signature);
        parameters.put("r", r);
        parameters.put("channel", channel);

        if (auth_key != null && auth_key.length() > 0)
            parameters.put("auth", auth_key);
        if (ttl >= -1)
            parameters.put("ttl", String.valueOf(ttl));

        String[] urlComponents = { getPubnubUrl(), "v1", "auth", "grant", "sub-key", this.SUBSCRIBE_KEY };

        HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                invokeCallback(channel, response, "payload", cb, 4);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(channel, error);
                return;
            }
        });

        return _request(hreq, (sync) ? null : nonSubscribeManager);

    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_bb2e795_2bf2aee/rev_bb2e795-2bf2aee/scala/scala-pubnub-tests/java/srcPubnubApi/srcCore/com/pubnub/api/PubnubCoreAsync.java;<<<<<<< MINE
package com.pubnub.api;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Random;

abstract class PubnubCoreAsync extends PubnubCore implements PubnubAsyncInterface {

    private volatile boolean resumeOnReconnect;

    public static boolean daemonThreads = false;

    private Subscriptions channelSubscriptions;
    private Subscriptions channelGroupSubscriptions;

    protected TimedTaskManager timedTaskManager;
    private volatile String _timetoken = "0";
    private volatile String _region = null;
    private volatile String _saved_timetoken = "0";

    protected static String PRESENCE_SUFFIX = "-pnpres";
    protected static String WILDCARD_SUFFIX = "*";
    protected static String WILDCARD_PRESENCE_SUFFIX = WILDCARD_SUFFIX + PRESENCE_SUFFIX;

    private static Logger log = new Logger(PubnubCore.class);

    private int PRESENCE_HEARTBEAT_TASK = 0;
    private int HEARTBEAT = 320;
    private volatile int PRESENCE_HB_INTERVAL = 0;

    private boolean V2 = true;

    public void setV2(boolean v2) {
        this.V2 = v2;
    }    
    
    public void shutdown() {
        nonSubscribeManager.stop();
        subscribeManager.stop();
        timedTaskManager.stop();
    }

    public boolean isResumeOnReconnect() {
        return resumeOnReconnect;
    }

    public void setRetryInterval(int retryInterval) {
        subscribeManager.setRetryInterval(retryInterval);
    }

    public void setWindowInterval(int windowInterval) {
        subscribeManager.setWindowInterval(windowInterval);
    }

    public int getRetryInterval() {
        return subscribeManager.retryInterval;
    }

    public int getWindowInterval() {
        return subscribeManager.windowInterval;
    }

    String[] getPresenceHeartbeatUrl() {
        String channelString = channelSubscriptions.getItemStringNoPresence();
        String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();

        if (channelString.length() <= 0 && channelGroupString.length() <= 0) {
            return null;
        }

        // if we do not have any channels but only channel groups: add , as channelString.
        if (channelString.length() <= 0 && channelGroupString.length() > 0 ) {
            channelString = ",";
        }

        return new String[] { getPubnubUrl(), "v2", "presence", "sub-key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channelString), "heartbeat" };
    }

    private String getState() {
        return (channelSubscriptions.state.length() > 0) ? channelSubscriptions.state.toString() : null;
    }

    class PresenceHeartbeatTask extends TimedTask {
        private Callback callback;

        PresenceHeartbeatTask(int interval, Callback callback) {
            super(interval);
            this.callback = callback;
        }

        public void run() {

            String[] urlComponents = getPresenceHeartbeatUrl();
            if (urlComponents == null)
                return;
            // String[] urlComponents = { getPubnubUrl(), "time", "0"};

            Hashtable parameters = PubnubUtil.hashtableClone(params);
            if (parameters.get("uuid") == null)
                parameters.put("uuid", UUID);

            String channelGroupString = channelGroupSubscriptions.getItemStringNoPresence();
            if (channelGroupString.length() > 0) {
                parameters.put("channel-group", channelGroupString);
            }

            String st = getState();
            if (st != null)
                parameters.put("state", st);

            if (HEARTBEAT > 0 && HEARTBEAT < 320)
                parameters.put("heartbeat", String.valueOf(HEARTBEAT));

            HttpRequest hreq = new HttpRequest(urlComponents, parameters, new ResponseHandler() {
                public void handleResponse(HttpRequest hreq, String response) {
                    JSONObject jso;
                    try {
                        jso = new JSONObject(response);
                        response = jso.getString("message");
                    } catch (JSONException e) {
                        handleError(hreq, PubnubError.getErrorObject(PubnubError.PNERROBJ_INVALID_JSON, 1, response));
                        return;
                    }
                    callback.successCallback(channelSubscriptions.getItemStringNoPresence(), response);
                }

                public void handleError(HttpRequest hreq, PubnubError error) {
                    callback.errorCallback(channelSubscriptions.getItemStringNoPresence(), error);
                }
            });

            _request(hreq, nonSubscribeManager);

        }

    }

    public void setPnExpires(int pnexpires, Callback callback) {
        setHeartbeat(pnexpires, callback);
    }

    public void setHeartbeat(int heartbeat, Callback callback) {
        Callback cb = getWrappedCallback(callback);

        HEARTBEAT = (heartbeat > 0 && heartbeat < 5) ? 5 : heartbeat;
        if (PRESENCE_HB_INTERVAL == 0) {
            PRESENCE_HB_INTERVAL = (HEARTBEAT - 3 >= 1) ? HEARTBEAT - 3 : 1;
        }
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }
        disconnectAndResubscribe();
    }

    public void setPnExpires(int pnexpires) {
        setPnExpires(pnexpires, null);
    }

    public void setHeartbeat(int heartbeat) {
        setHeartbeat(heartbeat, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval) {
        setHeartbeatInterval(heartbeatInterval, null);
    }

    public void setHeartbeatInterval(int heartbeatInterval, Callback callback) {

        Callback cb = getWrappedCallback(callback);
        PRESENCE_HB_INTERVAL = heartbeatInterval;
        if (PRESENCE_HEARTBEAT_TASK == 0) {
            PRESENCE_HEARTBEAT_TASK = timedTaskManager.addTask("Presence-Heartbeat", new PresenceHeartbeatTask(
                    PRESENCE_HB_INTERVAL, cb));
        } else if (PRESENCE_HB_INTERVAL == 0 || PRESENCE_HB_INTERVAL > 320) {
            timedTaskManager.removeTask(PRESENCE_HEARTBEAT_TASK);
        } else {
            timedTaskManager.updateTask(PRESENCE_HEARTBEAT_TASK, PRESENCE_HB_INTERVAL);
        }

    }

    public int getHeartbeatInterval() {
        return PRESENCE_HB_INTERVAL;
    }

    public int getPnExpires() {
        return getHeartbeat();
    }

    public int getHeartbeat() {
        return HEARTBEAT;
    }

    public void setMaxRetries(int maxRetries) {
        subscribeManager.setMaxRetries(maxRetries);
    }

    public int getMaxRetries() {
        return subscribeManager.maxRetries;
    }

    public void setCacheBusting(boolean cacheBusting) {
        this.CACHE_BUSTING = cacheBusting;
    }

    public boolean getCacheBusting() {
        return this.CACHE_BUSTING;
    }

    public String getCurrentlySubscribedChannelNames() {
        String currentChannels = channelSubscriptions.getItemString();
        return currentChannels.equals("") ? "no channels." : currentChannels;
    }

    public void setResumeOnReconnect(boolean resumeOnReconnect) {
        this.resumeOnReconnect = resumeOnReconnect;
    }

    public boolean getResumeOnReconnect() {
        return this.resumeOnReconnect;
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on, String initialization_vector) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on, initialization_vector);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, String cipher_key,
            boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, cipher_key, ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key, boolean ssl_on) {
        super(publish_key, subscribe_key, secret_key, "", ssl_on);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key) {
        super(publish_key, subscribe_key, "", "", false);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, boolean ssl) {
        super(publish_key, subscribe_key, "", "", ssl);
        this.initAsync();
    }

    public PubnubCoreAsync(String publish_key, String subscribe_key, String secret_key) {
        super(publish_key, subscribe_key, secret_key, "", false);
        this.initAsync();
    }

    Random random = new Random();

    private void initAsync() {

        if (channelSubscriptions == null)
            channelSubscriptions = new Subscriptions();

        if (channelGroupSubscriptions == null)
            channelGroupSubscriptions = new Subscriptions();

        if (subscribeManager == null)
            subscribeManager = new SubscribeManager("Subscribe-Manager-" + System.identityHashCode(this), 10000,
                    310000, daemonThreads);

        if (nonSubscribeManager == null)
            nonSubscribeManager = new NonSubscribeManager("Non-Subscribe-Manager-" + System.identityHashCode(this),
                    10000, 15000, daemonThreads);

        if (timedTaskManager == null)
            timedTaskManager = new TimedTaskManager("TimedTaskManager");

        subscribeManager.setHeader("V", VERSION);
        subscribeManager.setHeader("Accept-Encoding", "gzip");
        subscribeManager.setHeader("User-Agent", getUserAgent());

        nonSubscribeManager.setHeader("V", VERSION);
        nonSubscribeManager.setHeader("Accept-Encoding", "gzip");
        nonSubscribeManager.setHeader("User-Agent", getUserAgent());

    }

    public void setSubscribeTimeout(int timeout) {
        subscribeManager.setRequestTimeout(timeout);
        this.disconnectAndResubscribe();
    }

    protected int getSubscribeTimeout() {
        return subscribeManager.requestTimeout;
    }

    public void setNonSubscribeTimeout(int timeout) {
        nonSubscribeManager.setRequestTimeout(timeout);
    }

    protected int getNonSubscribeTimeout() {
        return nonSubscribeManager.requestTimeout;
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, boolean storeInHistory, JSONObject metadata,
            Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, String message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Integer message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, Double message, boolean storeInHistory, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("callback", callback);
        args.put("meta", metadata);
        args.put("storeInHistory", (storeInHistory) ? "" : "0");
        _publish(args, false);
    }

    public void publish(String channel, JSONObject message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, JSONArray message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, String message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Integer message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }

    public void publish(String channel, Double message, JSONObject metadata, Callback callback) {
        Hashtable args = new Hashtable();
        args.put("channel", channel);
        args.put("message", message);
        args.put("meta", metadata);
        args.put("callback", callback);
        _publish(args, false);
    }
    
    protected void publish(Hashtable args, Callback callback) {
        args.put("callback", callback);
        _publish(args, false);
    }

    public void presence(String channel, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("channels", new String[] { channel + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void channelGroupPresence(String group, Callback callback) throws PubnubException {
        Hashtable args = new Hashtable(2);

        args.put("groups", new String[] { group + PRESENCE_SUFFIX });
        args.put("callback", callback);

        subscribe(args);
    }

    public void whereNow(final String uuid, Callback callback) {
        whereNow(uuid, callback);
    }

    public void whereNow(Callback callback) {
        whereNow(this.UUID, callback);
    }

    public void setState(String channel, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, PubnubUtil.urlEncode(channel), null, uuid, state, callback, false);
    }

    public void channelGroupSetState(String group, String uuid, JSONObject state, Callback callback) {
        _setState(channelSubscriptions, ".", group, uuid, state, callback, false);
    }

    protected void setState(Subscriptions sub, String channel, String group, String uuid, JSONObject state,
            Callback callback) {
        _setState(sub, channel, group, uuid, state, callback, true);
    }

    public void getState(String channel, String uuid, Callback callback) {
        _getState(channel, uuid, callback, false);
    }

    public void channelGroupListNamespaces(Callback callback) {
        _channelGroupListNamespaces(callback, false);
    }

    public void channelGroupRemoveNamespace(String namespace, Callback callback) {
        _channelGroupRemoveNamespace(namespace, callback, false);
    }

    public void channelGroupListGroups(String namespace, Callback callback) {
        _channelGroupListGroups(null, callback, false);
    }

    public void channelGroupListGroups(Callback callback) {
        channelGroupListGroups(null, callback);
    }

    public void channelGroupListChannels(String group, Callback callback) {
        _channelGroupListChannels(group, callback, false);
    }

    public void channelGroupAddChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("add", group, new String[] { channel }, callback);
    }

    public void channelGroupAddChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("add", group, channels, callback);
    }

    public void channelGroupRemoveChannel(String group, String channel, Callback callback) {
        channelGroupUpdate("remove", group, new String[] { channel }, callback);
    }

    public void channelGroupRemoveChannel(String group, String[] channels, Callback callback) {
        channelGroupUpdate("remove", group, channels, callback);
    }

    private void channelGroupUpdate(String action, String group, String[] channels, final Callback callback) {
        _channelGroupUpdate(action, group, channels, callback, false);
    }

    public void channelGroupRemoveGroup(String group, Callback callback) {
        _channelGroupRemoveGroup(group, callback, false);
    }

    public void hereNow(final String channel, Callback callback) {
        hereNow(new String[] { channel }, null, false, true, callback);
    }

    public void hereNow(boolean state, boolean uuids, Callback callback) {
        hereNow(null, null, state, uuids, callback);
    }

    public void hereNow(final String channel, boolean state, boolean uuids, Callback callback) {
        hereNow(new String[] { channel }, null, state, uuids, callback);
    }

    public void channelGroupHereNow(String group, Callback callback) {
        channelGroupHereNow(group, false, true, callback);
    }

    public void channelGroupHereNow(String group, boolean state, boolean uuids, Callback callback) {
        channelGroupHereNow(new String[] { group }, state, uuids, callback);
    }

    public void channelGroupHereNow(String[] groups, boolean state, boolean uuids, Callback callback) {
        hereNow(null, groups, state, uuids, callback);
    }

    public void hereNow(String[] channels, String[] channelGroups, boolean state, boolean uuids, Callback callback) {
        _hereNow(channels, channelGroups, state, uuids, callback, false);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse, Callback callback) {
        history(channel, start, end, count, reverse, false, callback);
    }

    public void history(final String channel, long start, long end, int count, boolean reverse,
            boolean includeTimetoken, Callback callback) {
        _history(channel, start, end, count, reverse, includeTimetoken, callback, false);
    }

    public void history(String channel, long start, long end, boolean reverse, Callback callback) {
        history(channel, start, end, -1, reverse, callback);
    }

    public void history(String channel, int count, Callback callback) {
        history(channel, -1, -1, count, false, callback);
    }

    public void history(String channel, boolean includeTimetoken, int count, Callback callback) {
        history(channel, -1, -1, count, false, includeTimetoken, callback);
    }

    public void history(String channel, long start, boolean reverse, Callback callback) {
        history(channel, start, -1, -1, reverse, callback);
    }

    public void history(String channel, long start, long end, Callback callback) {
        history(channel, start, end, -1, false, callback);
    }

    public void history(String channel, long start, long end, int count, Callback callback) {
        history(channel, start, end, count, false, callback);
    }

    public void history(String channel, long start, int count, boolean reverse, Callback callback) {
        history(channel, start, -1, count, reverse, callback);
    }

    public void history(String channel, long start, int count, Callback callback) {
        history(channel, start, -1, count, false, callback);
    }

    public void history(String channel, int count, boolean reverse, Callback callback) {
        history(channel, -1, -1, count, reverse, callback);
    }

    public void history(String channel, boolean reverse, Callback callback) {
        history(channel, -1, -1, -1, reverse, callback);
    }

    public void time(Callback callback) {
        _time(callback, false);
    }

    private void _leave(String channel, Callback callback) {
        _leave(channel, null, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel) {
        _leave(channel, null);
    }

    private void channelGroupLeave(String group) {
        channelGroupLeave(group, null);
    }

    private void channelGroupLeave(String group, Callback callback) {
        _leave(null, group, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params) {
        _leave(channels, channelGroups, params, null);
    }

    private void _leave(String[] channels, String[] channelGroups, Hashtable params, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","), params, callback);
    }

    private void _leave(String[] channels, String[] channelGroups) {
        _leave(channels, channelGroups, PubnubUtil.hashtableClone(this.params), null);
    }

    private void _leave(String[] channels, String[] channelGroups, Callback callback) {
        _leave(PubnubUtil.joinString(channels, ","), PubnubUtil.joinString(channelGroups, ","),
                PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Callback callback) {
        _leave(channel, channelGroup, PubnubUtil.hashtableClone(this.params), callback);
    }

    private void _leave(String channel, String channelGroup, Hashtable params, Callback callback) {

        final Callback cb = getWrappedCallback(callback);

        if (PubnubUtil.isEmptyString(channel) && PubnubUtil.isEmptyString(channelGroup))
            return;

        if (PubnubUtil.isEmptyString(channel))
            channel = ",";

        String[] urlArgs = { getPubnubUrl(), "v2/presence/sub_key", this.SUBSCRIBE_KEY, "channel",
                PubnubUtil.urlEncode(channel), "leave" };

        params.put("uuid", UUID);

        if (!PubnubUtil.isEmptyString(channelGroup))
            params.put("channel-group", channelGroup);

        HttpRequest hreq = new HttpRequest(urlArgs, params, new ResponseHandler() {
            public void handleResponse(HttpRequest hreq, String response) {
                cb.successCallback(null, response);
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                cb.errorCallback(null, error);
            }
        });

        _request(hreq, nonSubscribeManager);
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels, Callback callback) {
        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
            channelSubscriptions.state.remove(channel);
        }
        _leave(channels, null, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from channels.
     *
     * @param channels
     *            String array containing channel names
     */
    public void unsubscribe(String[] channels) {
        unsubscribe(channels, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel) {
        unsubscribe(channel, null);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribe(String channel, Callback callback) {
        unsubscribe(new String[] { channel }, callback);
    }

    /**
     * Unsubscribe/Disconnect from channel.
     *
     * @param args
     *            Hashtable containing channel name.
     */
    protected void unsubscribe(Hashtable args) {
        String[] channelList = (String[]) args.get("channels");
        if (channelList == null) {
            channelList = new String[] { (String) args.get("channel") };
        }
        unsubscribe(channelList);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String group) {
        channelGroupUnsubscribe(group, null);
    }

    /**
     * Unsubscribe from channel group
     *
     * @param group
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String group, Callback callback) {
        channelGroupUnsubscribe(new String[] { group }, callback);
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribe(String[] groups, Callback callback) {
        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);
        resubscribe();
    }

    /**
     * Unsubscribe from multiple channel groups
     *
     * @param groups
     *            to unsubscribe
     */
    public void channelGroupUnsubscribe(String[] groups) {
        channelGroupUnsubscribe(groups, null);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     * @param callback
     *            Callback
     */
    public void unsubscribePresence(String channel, Callback callback) {
        unsubscribe(new String[] { channel + PRESENCE_SUFFIX }, callback);
    }

    /**
     * Unsubscribe from presence channel.
     *
     * @param channel
     *            channel name as String.
     */
    public void unsubscribePresence(String channel) {
        unsubscribePresence(channel, null);
    }

    /**
     * Unsubscribe from all channels and channel groups.
     *
     * @param callback
     */
    public void unsubscribeAll(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(channels, groups, callback);
        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channels and channel groups.
     */
    public void unsubscribeAll() {
        unsubscribeAll(null);
    }

    /**
     * Unsubscribe from all channels.
     */
    public void unsubscribeAllChannels() {
        unsubscribeAllChannels(null);
    }

    /**
     * Unsubscribe from all channels.
     *
     * @param callback
     *            Callback
     */
    public void unsubscribeAllChannels(Callback callback) {
        String[] channels = channelSubscriptions.getItemNames();

        for (int i = 0; i < channels.length; i++) {
            String channel = channels[i];
            channelSubscriptions.removeItem(channel);
        }
        _leave(channels, null, callback);

        disconnectAndResubscribe();
    }

    /**
     * Unsubscribe from all channel groups.
     */
    public void channelGroupUnsubscribeAllGroups() {
        channelGroupUnsubscribeAllGroups(null);
    }

    /**
     * Unsubscribe from all channel groups.
     *
     * @param callback
     *            Callback
     */
    public void channelGroupUnsubscribeAllGroups(Callback callback) {
        String[] groups = channelGroupSubscriptions.getItemNames();

        for (int i = 0; i < groups.length; i++) {
            String group = groups[i];
            channelGroupSubscriptions.removeItem(group);
        }
        _leave(null, groups, callback);

        disconnectAndResubscribe();
    }

    protected void subscribe(Hashtable args, Callback callback) throws PubnubException {
        args.put("callback", callback);

        subscribe(args);
    }

    protected void subscribe(Hashtable args) throws PubnubException {

        keepOnlyPluralSubscriptionItems(args);

        if (!inputsValid(args)) {
            return;
        }

        _subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback) throws PubnubException {
        subscribe(channels, callback, "0");
    }

    public void subscribe(String[] channels, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void subscribe(String[] channels, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, Callback callback) throws PubnubException {
        subscribe(channel, callback, "0");
    }

    public void subscribe(String channel, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, callback, timetoken);
    }

    public void subscribe(String channel, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback) throws PubnubException {
        subscribe(channel, group, callback, "0");
    }

    public void subscribe(String channel, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String[] channels, String group, Callback callback) throws PubnubException {
        subscribe(channels, group, callback, "0");
    }

    public void subscribe(String[] channels, String group, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, group, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String group, Callback callback, String timetoken) throws PubnubException {
        subscribe(channels, new String[] { group }, callback, timetoken);
    }

    public void subscribe(String channel, String[] groups, Callback callback) throws PubnubException {
        subscribe(channel, groups, callback, "0");
    }

    public void subscribe(String channel, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channel, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String channel, String[] groups, Callback callback, String timetoken) throws PubnubException {
        subscribe(new String[] { channel }, groups, callback, timetoken);
    }

    public void subscribe(String[] channels, String[] groups, Callback callback) throws PubnubException {
        subscribe(channels, groups, callback, "0");
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, long timetoken) throws PubnubException {
        subscribe(channels, groups, callback, String.valueOf(timetoken));
    }

    public void subscribe(String[] channels, String[] groups, Callback callback, String timetoken)
            throws PubnubException {
        Hashtable args = new Hashtable();

        args.put("channels", channels);
        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    public void channelGroupSubscribe(String group, Callback callback) throws PubnubException {
        channelGroupSubscribe(group, callback, "0");
    }

    public void channelGroupSubscribe(String[] groups, Callback callback) throws PubnubException {
        channelGroupSubscribe(groups, callback, "0");
    }

    public void channelGroupSubscribe(String group, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(group, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String group, Callback callback, String timetoken) throws PubnubException {
        channelGroupSubscribe(new String[] { group }, callback, timetoken);
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, long timetoken) throws PubnubException {
        channelGroupSubscribe(groups, callback, String.valueOf(timetoken));
    }

    public void channelGroupSubscribe(String[] groups, Callback callback, String timetoken) throws PubnubException {

        Hashtable args = new Hashtable();

        args.put("groups", groups);
        args.put("callback", callback);
        args.put("timetoken", timetoken);

        subscribe(args);
    }

    protected void callErrorCallbacks(String[] channelList, PubnubError error) {
        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];
            Callback cb = channelSubscriptions.getItem(channel).callback;
            cb.errorCallback(channel, error);
        }
    }

    private void _subscribe(Hashtable args) {

        String[] channelList = (String[]) args.get("channels");
        String[] groupList = (String[]) args.get("groups");


        if (channelList == null) {
            channelList = new String[0];
        }

        if (groupList == null) {
            groupList = new String[0];
        }

        Callback callback = (Callback) args.get("callback");
        String timetoken = (String) args.get("timetoken");

        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = (timetoken == null) ? "0" : timetoken;

        /*
         * Scan through the channels array. If a channel does not exist in
         * hashtable create a new item with default values. If already exists
         * and connected, then return
         */

        for (int i = 0; i < channelList.length; i++) {
            String channel = channelList[i];

            if (channel.endsWith(WILDCARD_SUFFIX + PRESENCE_SUFFIX)) {
                String messagesChannel = channel.substring(0, channel.indexOf(PRESENCE_SUFFIX));

                SubscriptionItem wildcardMessagesObj = (SubscriptionItem) channelSubscriptions.getItem(messagesChannel);
                SubscriptionItem wildcardPresenceObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (wildcardMessagesObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(messagesChannel, callback);

                    channelSubscriptions.addItem(ch);
                }

                if (wildcardPresenceObj == null) {
                    SubscriptionItem pr = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(pr);
                }
            } else {
                SubscriptionItem channelObj = (SubscriptionItem) channelSubscriptions.getItem(channel);

                if (channelObj == null) {
                    SubscriptionItem ch = new SubscriptionItem(channel, callback);

                    channelSubscriptions.addItem(ch);
                }
            }
        }

        for (int i = 0; i < groupList.length; i++) {
            String group = groupList[i];
            SubscriptionItem channelGroupObj = (SubscriptionItem) channelGroupSubscriptions.getItem(group);

            if (channelGroupObj == null) {
                SubscriptionItem chg = new SubscriptionItem(group, callback);

                channelGroupSubscriptions.addItem(chg);
            }
        }

        _subscribe_base(true);
    }

    private void _subscribe_base(boolean fresh) {
        _subscribe_base(fresh, false, null);
    }

    private void _subscribe_base(boolean fresh, boolean dar) {
        _subscribe_base(fresh, dar, null);
    }

    private void _subscribe_base(Worker worker) {
        _subscribe_base(false, false, worker);
    }

    private void _subscribe_base(boolean fresh, Worker worker) {
        _subscribe_base(fresh, false, worker);
    }

    private boolean isWorkerDead(HttpRequest hreq) {
        return (hreq == null || hreq.getWorker() == null) ? false : hreq.getWorker()._die;
    }

    private void _subscribe_base(boolean fresh, boolean dar, Worker worker) {
        String channelString = channelSubscriptions.getItemString(WILDCARD_PRESENCE_SUFFIX);
        String groupString = channelGroupSubscriptions.getItemString();
        String[] channelsArray = channelSubscriptions.getItemNames(WILDCARD_PRESENCE_SUFFIX);
        String[] groupsArray = channelGroupSubscriptions.getItemNames();

        if (channelsArray.length <= 0 && groupsArray.length <= 0) {
            subscribeManager.resetHttpManager();
            return;
        }

        if (channelString == null) {
            callErrorCallbacks(channelsArray, PubnubError.PNERROBJ_PARSING_ERROR);
            return;
        }

        if (channelString.equals("")) {
            channelString = ",";
        } else {
            channelString = PubnubUtil.urlEncode(channelString);
        }

        String[] urlComponents = { getPubnubUrl(), ((this.V2) ? "v2/" : "") + "subscribe", this.SUBSCRIBE_KEY,
                channelString, "0" + ((this.V2) ? "" : "/" + _timetoken) };

        Hashtable params = PubnubUtil.hashtableClone(this.params);
        params.put("uuid", UUID);

        
        if (this.V2) {
            params.put("tt", _timetoken);
            if (this._region != null)
                params.put("tr", this._region);
        } else {

        }
        
        if (groupsArray.length > 0) {
            params.put("channel-group", groupString);
        }

        String st = getState();
        if (st != null)
            params.put("state", st);

        if (HEARTBEAT > 5 && HEARTBEAT < 320)
            params.put("heartbeat", String.valueOf(HEARTBEAT));
        log.verbose("Subscribing with timetoken : " + _timetoken);


        if (channelSubscriptions.getFilter() != null && channelSubscriptions.getFilter().length() > 0) {
            params.put("filter-expr", channelSubscriptions.getFilter());
        }
        
        HttpRequest hreq = new HttpRequest(urlComponents, params, new ResponseHandler() {

            void changeKey(JSONObject o, String ok, String nk) throws JSONException {
                if (!o.isNull(ok)) {
                    Object t = o.get(ok);
                    o.put(nk, t);
                    o.remove(ok);
                }
            }

            JSONObject expandV2Keys(JSONObject m) throws JSONException {
                if (!m.isNull("o")) {
                    changeKey(m.getJSONObject("o"), "t", "timetoken");
                    changeKey(m.getJSONObject("o"), "r", "region_code");
                }
                if (!m.isNull("p")) {
                    changeKey(m.getJSONObject("p"), "t", "timetoken");
                    changeKey(m.getJSONObject("p"), "r", "region_code");
                }
                changeKey(m, "a", "shard");
                changeKey(m, "b", "subscription_match");
                changeKey(m, "c", "channel");
                changeKey(m, "d", "payload");
                changeKey(m, "ear", "eat_after_reading");
                changeKey(m, "f", "flags");
                changeKey(m, "i", "issuing_client_id");
                changeKey(m, "k", "subscribe_key");
                changeKey(m, "s", "sequence_number");
                changeKey(m, "o", "origination_timetoken");
                changeKey(m, "p", "publish_timetoken");
                changeKey(m, "r", "replication_map");
                changeKey(m, "u", "user_metadata");
                changeKey(m, "w", "waypoint_list");
                return m;
            }

            void v2Handler(JSONObject jso, HttpRequest hreq) throws JSONException {
                JSONArray messages = jso.getJSONArray("m");
                for (int i = 0; i < messages.length(); i++) {
                    JSONObject messageObj = messages.getJSONObject(i);
                    String channel = messageObj.getString("c");
                    String sub_channel = (messageObj.isNull("b")) ? null : messageObj.getString("b");

                    Object message = messageObj.get("d");

                    SubscriptionItem chobj = null;
                    if (channelSubscriptions != null && sub_channel != null)
                        chobj = channelSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelGroupSubscriptions != null && sub_channel != null)
                        chobj = channelGroupSubscriptions.getItem(sub_channel);

                    if (chobj == null && channelSubscriptions != null)
                        chobj = channelSubscriptions.getItem(channel);

                    if (chobj == null && channel.indexOf("-pnpres") > 0) {
                        chobj = channelSubscriptions.getItem(channel);
                        channel = PubnubUtil.splitString(channel, "-pnpres")[0];

                    }

                    if (chobj != null) {
                        Callback callback = chobj.callback;
                        invokeSubscribeCallbackV2(chobj.name, chobj.callback, message, expandV2Keys(messageObj),
                                _timetoken, hreq);
                    }

                }
            }
            void v1Handler(JSONArray jsa, HttpRequest hreq) throws JSONException {

                JSONArray messages = new JSONArray(jsa.get(0).toString());

                if (jsa.length() == 4) {
                    /*
                     * Response has multiple channels or/and groups
                     */
                    String[] _groups = PubnubUtil.splitString(jsa.getString(2), ",");
                    String[] _channels = PubnubUtil.splitString(jsa.getString(3), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        handleFourElementsSubscribeResponse(_groups[i], _channels[i], messages.get(i), _timetoken, hreq);
                    }
                } else if (jsa.length() == 3) {
                    /*
                     * Response has multiple channels
                     */

                    String[] _channels = PubnubUtil.splitString(jsa.getString(2), ",");

                    for (int i = 0; i < _channels.length; i++) {
                        SubscriptionItem _channel = channelSubscriptions.getItem(_channels[i]);
                        Object message = messages.get(i);

                        if (_channel != null) {
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }
                } else if (jsa.length() < 3) {
                    /*
                     * Response for single channel Callback on single channel
                     */
                    SubscriptionItem _channel = channelSubscriptions.getFirstItem();

                    if (_channel != null) {
                        for (int i = 0; i < messages.length(); i++) {
                            Object message = messages.get(i);
                            invokeSubscribeCallback(_channel.name, _channel.callback, message, _timetoken, hreq);
                        }
                    }

                }

            }

            public void handleResponse(HttpRequest hreq, String response) {

                JSONArray jsa = null;

                JSONObject jso = null;

                String _in_response_timetoken = "";

                boolean handleV2 = false;

                try {
                    jsa = new JSONArray(response);
                    _in_response_timetoken = jsa.get(1).toString();

                } catch (JSONException e) {
                    try {
                        // handle V2 response
                        handleV2 = true;
                        jso = new JSONObject(response);

                        _in_response_timetoken = jso.getJSONObject("t").getString("t");
                        _region = jso.getJSONObject("t").getString("r");

                    } catch (JSONException e1) {
                        if (hreq.isSubzero()) {
                            log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                            _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                        } else
                            _subscribe_base(false);
                        return;
                    }
                }

                /*
                 * Check if response has channel names. A JSON response with
                 * more than 2 items means the response contains the channel
                 * names as well. The channel names are in a comma delimted
                 * string. Call success callback on all he channels passing the
                 * corresponding response message.
                 */

                _timetoken = (!_saved_timetoken.equals("0") && isResumeOnReconnect()) ? _saved_timetoken
                        : _in_response_timetoken;
                log.verbose("Resume On Reconnect is " + isResumeOnReconnect());
                log.verbose("Saved Timetoken : " + _saved_timetoken);
                log.verbose("In Response Timetoken : " + _in_response_timetoken);
                log.verbose("Timetoken value set to " + _timetoken);
                _saved_timetoken = "0";
                log.verbose("Saved Timetoken reset to 0");

                if (!hreq.isDar()) {
                    channelSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeConnectCallbackOnItems(_timetoken);
                } else {
                    channelSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                    channelGroupSubscriptions.invokeReconnectCallbackOnItems(_timetoken);
                }
                try {

                    if (handleV2)
                        v2Handler(jso, hreq);
                    else
                        v1Handler(jsa, hreq);

                } catch (JSONException e) {

                }
                if (hreq.isSubzero()) {
                    log.verbose("Response of subscribe 0 request. Need to do dAr process again");
                    _subscribe_base(false, hreq.isDar(), hreq.getWorker());
                } else
                    _subscribe_base(false);
            }

            public void handleBackFromDar(HttpRequest hreq) {
                _subscribe_base(false, hreq.getWorker());
            }

            public void handleError(HttpRequest hreq, PubnubError error) {
                disconnectAndResubscribe(error);
            }

            public void handleTimeout(HttpRequest hreq) {
                log.verbose("Timeout Occurred, Calling disconnect callbacks on the channels");
                String timeoutTimetoken = (isResumeOnReconnect()) ? (_timetoken.equals("0")) ? _saved_timetoken
                        : _timetoken : "0";
                log.verbose("Timeout Timetoken : " + timeoutTimetoken);
                channelSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelGroupSubscriptions.invokeDisconnectCallbackOnItems(timeoutTimetoken);
                channelSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                channelGroupSubscriptions.invokeErrorCallbackOnItems(PubnubError.getErrorObject(
                        PubnubError.PNERROBJ_TIMEOUT, 1));
                // disconnectAndResubscribe();

                // channelSubscriptions.removeAllItems();
            }

            public String getTimetoken() {
                return _timetoken;
            }
        });
        if (_timetoken.equals("0")) {
            hreq.setSubzero(true);
            log.verbose("This is a subscribe 0 request");
        }
        hreq.setDar(dar);
        if (worker != null && worker instanceof Worker)
            hreq.setWorker(worker);
        _request(hreq, subscribeManager, fresh);
    }

    private void handleFourElementsSubscribeResponse(String thirdString, String fourthString, Object message,
            String timetoken, HttpRequest hreq) throws JSONException {

        SubscriptionItem thirdChannelGroup = channelGroupSubscriptions.getItem(thirdString);
        SubscriptionItem thirdChannel = channelSubscriptions.getItem(thirdString);
        SubscriptionItem fourthChannel = channelSubscriptions.getItem(fourthString);

        if (isWorkerDead(hreq))
            return;

        if (thirdString.equals(fourthString) && fourthChannel != null) {
            invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
        } else if (thirdString.endsWith("*")) {
            if (fourthChannel != null && fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, fourthChannel.callback, message, timetoken, hreq);
            } else if (thirdChannelGroup != null && !fourthString.endsWith(PRESENCE_SUFFIX)) {
                invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
            } else if (thirdChannel != null && thirdString.endsWith(WILDCARD_SUFFIX)
                    && !fourthString.endsWith(PRESENCE_SUFFIX) /*
                                                                * !!! get
                                                                * reviewed by
                                                                * Alex
                                                                */) {
                invokeSubscribeCallback(fourthString, thirdChannel.callback, message, timetoken, hreq);
            } else {
                // !!! This should be handled by error Callback. Or use logging
                // mechanism
                // System.out.println("ERROR: Unable to handle wildcard response: "
                // + message);
            }
        } else if (!thirdString.equals(fourthString) && thirdChannelGroup != null) {
            invokeSubscribeCallback(fourthString, thirdChannelGroup.callback, message, timetoken, hreq);
        } else {
            // !!!! This should be handled in error callback. Or use logging
            // mechanism.
            // System.out.println("ERROR: Unable to handle response: " +
            // message);
        }
    }

    private void invokeSubscribeCallback(String channel, Callback callback, Object message, String timetoken,
            HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallback(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallback(channel, PubnubUtil.parseJSON(message, false), timetoken);
        }
    }

    private void invokeSubscribeCallbackV2(String channel, Callback callback, Object message, JSONObject envelope,
            String timetoken, HttpRequest hreq) throws JSONException {
        if (CIPHER_KEY.length() > 0 && !channel.endsWith(PRESENCE_SUFFIX)) {
            PubnubCrypto pc = new PubnubCrypto(CIPHER_KEY, IV);
            try {
                message = pc.decrypt(message.toString());
                if (!isWorkerDead(hreq))
                    callback.successWrapperCallbackV2(channel,
                            PubnubUtil.parseJSON(PubnubUtil.stringToJSON(message.toString()), true), envelope, timetoken);
            } catch (IllegalStateException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 12, message.toString()));
            } catch (PubnubException e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            getPubnubError(e, PubnubError.PNERROBJ_DECRYPTION_ERROR, 16,
                                    message.toString() + " : " + e.toString()));
            } catch (Exception e) {
                if (!isWorkerDead(hreq))
                    callback.errorCallback(
                            channel,
                            PubnubError.getErrorObject(PubnubError.PNERROBJ_DECRYPTION_ERROR, 15, message.toString()
                                    + " : " + e.toString()));
            }
        } else {
            if (!isWorkerDead(hreq))
                callback.successWrapperCallbackV2(channel, PubnubUtil.parseJSON(message, false), envelope, timetoken);
        }
    }

    private void changeOrigin() {
        this.ORIGIN_STR = null;
        this.HOSTNAME_SUFFIX = getRandom();
    }

    private void resubscribe() {
        changeOrigin();
        if (!_timetoken.equals("0"))
            _saved_timetoken = _timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    private void resubscribe(String timetoken) {
        changeOrigin();
        if (!timetoken.equals("0"))
            _saved_timetoken = timetoken;
        _timetoken = "0";
        log.verbose("Before Resubscribe Timetoken : " + _timetoken);
        log.verbose("Before Resubscribe Saved Timetoken : " + _saved_timetoken);
        _subscribe_base(true, true);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken) {
        disconnectAndResubscribeWithTimetoken(timetoken, PubnubError.PNERROBJ_DISCONN_AND_RESUB);
    }

    public void disconnectAndResubscribeWithTimetoken(String timetoken, PubnubError error) {
        log.verbose("Received disconnectAndResubscribeWithTimetoken");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe(timetoken);
    }

    public void disconnectAndResubscribe() {
        disconnectAndResubscribe(PubnubError.PNERROBJ_DISCONNECT);
    }

    public void disconnectAndResubscribe(PubnubError error) {
        log.verbose("Received disconnectAndResubscribe");
        channelSubscriptions.invokeErrorCallbackOnItems(error);
        channelGroupSubscriptions.invokeErrorCallbackOnItems(error);
        resubscribe();
    }

    public String[] getSubscribedChannelsArray() {
        return channelSubscriptions.getItemNames();
    }

    public void setAuthKey(String authKey) {
        super.setAuthKey(authKey);
        resubscribe();
    }

    public void unsetAuthKey() {
        super.unsetAuthKey();
        resubscribe();
    }


    public String getFilter() {
        return channelSubscriptions.getFilter();
    }

    public void setFilter(String filter) {
        channelSubscriptions.setFilter(filter);
    }
    
}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_09cb418_cab09fa/rev_09cb418-cab09fa/src/main/java/com/pubnub/api/Crypto.java;<<<<<<< MINE
package com.pubnub.api;

import com.pubnub.api.builder.PubNubErrorBuilder;
import com.pubnub.api.utils.Base64;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;



@Slf4j
public class Crypto {

    byte[] keyBytes = null;
    byte[] ivBytes = null;
    String initializationVector = "0123456789012345";
    String cipherKey;
    boolean INIT = false;

    public Crypto(String cipherKey) {
        this.cipherKey = cipherKey;
    }

    public Crypto(String cipherKey, String customInitializationVector) {
        if (customInitializationVector != null) {
            this.initializationVector = customInitializationVector;
        }

        this.cipherKey = cipherKey;
    }

    public void initCiphers() throws PubNubException {
        if (INIT)
            return;
        try {

            keyBytes = new String(hexEncode(sha256(this.cipherKey.getBytes("UTF-8"))), "UTF-8")
                    .substring(0, 32)
                    .toLowerCase().getBytes("UTF-8");
            ivBytes = initializationVector.getBytes("UTF-8");
            INIT = true;
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(11, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    public static byte[] hexEncode(byte[] input) throws PubNubException {
        StringBuffer result = new StringBuffer();
        for (byte byt : input)
            result.append(Integer.toString((byt & 0xff) + 0x100, 16).substring(1));
        try {
            return result.toString().getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(12, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    private static PubNubError newCryptoError(int code, String message) {

        return PubNubErrorBuilder.createCryptoError(code, message);
    }

    public String encrypt(String input) throws PubNubException {
        try {
            initCiphers();
            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES");
            Cipher cipher = null;
            cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
            return new String(Base64.encode(cipher.doFinal(input.getBytes("UTF-8")), 0));
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidAlgorithmParameterException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (IllegalBlockSizeException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (BadPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        }

    }

    /**
     * Decrypt
     *
     * @param cipher_text
     * @return String
     * @throws PubNubException
     */
    public String decrypt(String cipher_text) throws PubNubException {
        try {
            initCiphers();
            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, "AES");
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
            return new String(cipher.doFinal(Base64.decode(cipher_text, 0)), "UTF-8");
        } catch (IllegalArgumentException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (IllegalBlockSizeException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (BadPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidKeyException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (InvalidAlgorithmParameterException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        } catch (NoSuchPaddingException e) {
            throw PubNubException.builder().errormsg(e.toString()).build();
        }
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    /**
     * Get MD5
     *
     * @param input
     * @return byte[]
     * @throws PubNubException
     */
    public static byte[] md5(String input) throws PubNubException {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("MD5");
            byte[] hashedBytes = digest.digest(input.getBytes("UTF-8"));
            return hashedBytes;
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(118, e.toString())).errormsg(e.getMessage()).build();
        } catch (UnsupportedEncodingException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(119, e.toString())).errormsg(e.getMessage()).build();
        }
    }

    /**
     * Get SHA256
     *
     * @param input
     * @return byte[]
     * @throws PubNubException
     */
    public static byte[] sha256(byte[] input) throws PubNubException {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("SHA-256");
            byte[] hashedBytes = digest.digest(input);
            return hashedBytes;
        } catch (NoSuchAlgorithmException e) {
            throw PubNubException.builder().pubnubError(newCryptoError(111, e.toString())).errormsg(e.getMessage()).build();
        }
    }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_9208c65_6c5af23/rev_9208c65-6c5af23/library/src/main/java/com/google/android/exoplayer/hls/parser/TsExtractor.java;<<<<<<< MINE
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.hls.parser;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.SampleHolder;
import com.google.android.exoplayer.upstream.BufferPool;
import com.google.android.exoplayer.upstream.DataSource;
import com.google.android.exoplayer.util.Assertions;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Log;
import android.util.SparseArray;

import java.io.IOException;

/**
 * Facilitates the extraction of data from the MPEG-2 TS container format.
 */
public final class TsExtractor extends HlsExtractor {

  private static final String TAG = "TsExtractor";

  private static final int TS_PACKET_SIZE = 188;
  private static final int TS_SYNC_BYTE = 0x47; // First byte of each TS packet.
  private static final int TS_PAT_PID = 0;

  private static final int TS_STREAM_TYPE_MPA = 0x03;
  private static final int TS_STREAM_TYPE_MPA_LSF = 0x04;
  private static final int TS_STREAM_TYPE_AAC = 0x0F;
  private static final int TS_STREAM_TYPE_H264 = 0x1B;
  private static final int TS_STREAM_TYPE_ID3 = 0x15;
  private static final int TS_STREAM_TYPE_EIA608 = 0x100; // 0xFF + 1

  private static final long MAX_PTS = 0x1FFFFFFFFL;

  private final ParsableByteArray tsPacketBuffer;
  private final SparseArray<SampleQueue> sampleQueues; // Indexed by streamType
  private final SparseArray<TsPayloadReader> tsPayloadReaders; // Indexed by pid
  private final BufferPool bufferPool;
  private final long firstSampleTimestamp;
  private final ParsableBitArray tsScratch;

  // Accessed only by the loading thread.
  private int tsPacketBytesRead;
  private long timestampOffsetUs;
  private long lastPts;

  // Accessed by both the loading and consuming threads.
  private volatile boolean prepared;

  public TsExtractor(boolean shouldSpliceIn, long firstSampleTimestamp, BufferPool bufferPool) {
    super(shouldSpliceIn);
    this.firstSampleTimestamp = firstSampleTimestamp;
    this.bufferPool = bufferPool;
    tsScratch = new ParsableBitArray(new byte[3]);
    tsPacketBuffer = new ParsableByteArray(TS_PACKET_SIZE);
    sampleQueues = new SparseArray<SampleQueue>();
    tsPayloadReaders = new SparseArray<TsPayloadReader>();
    tsPayloadReaders.put(TS_PAT_PID, new PatReader());
    lastPts = Long.MIN_VALUE;
  }

  @Override
  public int getTrackCount() {
    Assertions.checkState(prepared);
    return sampleQueues.size();
  }

  @Override
  public MediaFormat getFormat(int track) {
    Assertions.checkState(prepared);
    return sampleQueues.valueAt(track).getMediaFormat();
  }

  @Override
  public boolean isPrepared() {
    return prepared;
  }

  @Override
  public void release() {
    for (int i = 0; i < sampleQueues.size(); i++) {
      sampleQueues.valueAt(i).release();
    }
  }

  @Override
  public long getLargestSampleTimestamp() {
    long largestParsedTimestampUs = Long.MIN_VALUE;
    for (int i = 0; i < sampleQueues.size(); i++) {
      largestParsedTimestampUs = Math.max(largestParsedTimestampUs,
          sampleQueues.valueAt(i).getLargestParsedTimestampUs());
    }
    return largestParsedTimestampUs;
  }

  @Override
  public boolean getSample(int track, SampleHolder holder) {
    Assertions.checkState(prepared);
    return sampleQueues.valueAt(track).getSample(holder);
  }

  @Override
  public void discardUntil(int track, long timeUs) {
    Assertions.checkState(prepared);
    sampleQueues.valueAt(track).discardUntil(timeUs);
  }

  @Override
  public boolean hasSamples(int track) {
    Assertions.checkState(prepared);
    return !sampleQueues.valueAt(track).isEmpty();
  }

  private boolean checkPrepared() {
    int pesPayloadReaderCount = sampleQueues.size();
    if (pesPayloadReaderCount == 0) {
      return false;
    }
    for (int i = 0; i < pesPayloadReaderCount; i++) {
      if (!sampleQueues.valueAt(i).hasMediaFormat()) {
        return false;
      }
    }
    return true;
  }

  @Override
  public int read(DataSource dataSource) throws IOException {
    int bytesRead = dataSource.read(tsPacketBuffer.data, tsPacketBytesRead,
        TS_PACKET_SIZE - tsPacketBytesRead);
    if (bytesRead == -1) {
      return -1;
    }

    tsPacketBytesRead += bytesRead;
    if (tsPacketBytesRead < TS_PACKET_SIZE) {
      // We haven't read the whole packet yet.
      return bytesRead;
    }

    // Reset before reading the packet.
    tsPacketBytesRead = 0;
    tsPacketBuffer.setPosition(0);
    tsPacketBuffer.setLimit(TS_PACKET_SIZE);

    int syncByte = tsPacketBuffer.readUnsignedByte();
    if (syncByte != TS_SYNC_BYTE) {
      return bytesRead;
    }

    tsPacketBuffer.readBytes(tsScratch, 3);
    tsScratch.skipBits(1); // transport_error_indicator
    boolean payloadUnitStartIndicator = tsScratch.readBit();
    tsScratch.skipBits(1); // transport_priority
    int pid = tsScratch.readBits(13);
    tsScratch.skipBits(2); // transport_scrambling_control
    boolean adaptationFieldExists = tsScratch.readBit();
    boolean payloadExists = tsScratch.readBit();
    // Last 4 bits of scratch are skipped: continuity_counter

    // Skip the adaptation field.
    if (adaptationFieldExists) {
      int adaptationFieldLength = tsPacketBuffer.readUnsignedByte();
      tsPacketBuffer.skip(adaptationFieldLength);
    }

    // Read the payload.
    if (payloadExists) {
      TsPayloadReader payloadReader = tsPayloadReaders.get(pid);
      if (payloadReader != null) {
        payloadReader.consume(tsPacketBuffer, payloadUnitStartIndicator);
      }
    }

    if (!prepared) {
      prepared = checkPrepared();
    }

    return bytesRead;
  }

  @Override
  protected SampleQueue getSampleQueue(int track) {
    return sampleQueues.valueAt(track);
  }

  /**
   * Adjusts a PTS value to the corresponding time in microseconds, accounting for PTS wraparound.
   *
   * @param pts The raw PTS value.
   * @return The corresponding time in microseconds.
   */
  /* package */ long ptsToTimeUs(long pts) {
    if (lastPts != Long.MIN_VALUE) {
      // The wrap count for the current PTS may be closestWrapCount or (closestWrapCount - 1),
      // and we need to snap to the one closest to lastPts.
      long closestWrapCount = (lastPts + (MAX_PTS / 2)) / MAX_PTS;
      long ptsWrapBelow = pts + (MAX_PTS * (closestWrapCount - 1));
      long ptsWrapAbove = pts + (MAX_PTS * closestWrapCount);
      pts = Math.abs(ptsWrapBelow - lastPts) < Math.abs(ptsWrapAbove - lastPts)
          ? ptsWrapBelow : ptsWrapAbove;
    }
    // Calculate the corresponding timestamp.
    long timeUs = (pts * C.MICROS_PER_SECOND) / 90000;
    // If we haven't done the initial timestamp adjustment, do it now.
    if (lastPts == Long.MIN_VALUE) {
      timestampOffsetUs = firstSampleTimestamp - timeUs;
    }
    // Record the adjusted PTS to adjust for wraparound next time.
    lastPts = pts;
    return timeUs + timestampOffsetUs;
  }

  /**
   * Parses TS packet payload data.
   */
  private abstract static class TsPayloadReader {

    public abstract void consume(ParsableByteArray data, boolean payloadUnitStartIndicator);

  }

  /**
   * Parses Program Association Table data.
   */
  private class PatReader extends TsPayloadReader {

    private final ParsableBitArray patScratch;

    public PatReader() {
      patScratch = new ParsableBitArray(new byte[4]);
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      // Skip pointer.
      if (payloadUnitStartIndicator) {
        int pointerField = data.readUnsignedByte();
        data.skip(pointerField);
      }

      data.readBytes(patScratch, 3);
      patScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
      int sectionLength = patScratch.readBits(12);
      // transport_stream_id (16), reserved (2), version_number (5), current_next_indicator (1),
      // section_number (8), last_section_number (8)
      data.skip(5);

      int programCount = (sectionLength - 9) / 4;
      for (int i = 0; i < programCount; i++) {
        data.readBytes(patScratch, 4);
        patScratch.skipBits(19); // program_number (16), reserved (3)
        int pid = patScratch.readBits(13);
        tsPayloadReaders.put(pid, new PmtReader());
      }

      // Skip CRC_32.
    }

  }

  /**
   * Parses Program Map Table.
   */
  private class PmtReader extends TsPayloadReader {

    private final ParsableBitArray pmtScratch;

    public PmtReader() {
      pmtScratch = new ParsableBitArray(new byte[5]);
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      // Skip pointer.
      if (payloadUnitStartIndicator) {
        int pointerField = data.readUnsignedByte();
        data.skip(pointerField);
      }

      data.readBytes(pmtScratch, 3);
      pmtScratch.skipBits(12); // table_id (8), section_syntax_indicator (1), '0' (1), reserved (2)
      int sectionLength = pmtScratch.readBits(12);

      // program_number (16), reserved (2), version_number (5), current_next_indicator (1),
      // section_number (8), last_section_number (8), reserved (3), PCR_PID (13)
      // Skip the rest of the PMT header.
      data.skip(7);

      data.readBytes(pmtScratch, 2);
      pmtScratch.skipBits(4);
      int programInfoLength = pmtScratch.readBits(12);

      // Skip the descriptors.
      data.skip(programInfoLength);

      int entriesSize = sectionLength - 9 /* Size of the rest of the fields before descriptors */
          - programInfoLength - 4 /* CRC size */;
      while (entriesSize > 0) {
        data.readBytes(pmtScratch, 5);
        int streamType = pmtScratch.readBits(8);
        pmtScratch.skipBits(3); // reserved
        int elementaryPid = pmtScratch.readBits(13);
        pmtScratch.skipBits(4); // reserved
        int esInfoLength = pmtScratch.readBits(12);

        // Skip the descriptors.
        data.skip(esInfoLength);
        entriesSize -= esInfoLength + 5;

        if (sampleQueues.get(streamType) != null) {
          continue;
        }

        ElementaryStreamReader pesPayloadReader = null;
        switch (streamType) {
          case TS_STREAM_TYPE_MPA:
          case TS_STREAM_TYPE_MPA_LSF:
            pesPayloadReader = new MpaReader(bufferPool);
            break;
          case TS_STREAM_TYPE_AAC:
            pesPayloadReader = new AdtsReader(bufferPool);
            break;
          case TS_STREAM_TYPE_H264:
            SeiReader seiReader = new SeiReader(bufferPool);
            sampleQueues.put(TS_STREAM_TYPE_EIA608, seiReader);
            pesPayloadReader = new H264Reader(bufferPool, seiReader);
            break;
          case TS_STREAM_TYPE_ID3:
            pesPayloadReader = new Id3Reader(bufferPool);
            break;
        }

        if (pesPayloadReader != null) {
          sampleQueues.put(streamType, pesPayloadReader);
          tsPayloadReaders.put(elementaryPid, new PesReader(pesPayloadReader));
        }
      }

      // Skip CRC_32.
    }

  }

  /**
   * Parses PES packet data and extracts samples.
   */
  private class PesReader extends TsPayloadReader {

    private static final int STATE_FINDING_HEADER = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_HEADER_EXTENSION = 2;
    private static final int STATE_READING_BODY = 3;

    private static final int HEADER_SIZE = 9;
    private static final int MAX_HEADER_EXTENSION_SIZE = 5;

    private final ParsableBitArray pesScratch;
    private final ElementaryStreamReader pesPayloadReader;

    private int state;
    private int bytesRead;
    private boolean bodyStarted;

    private boolean ptsFlag;
    private int extendedHeaderLength;

    private int payloadSize;

    private long timeUs;

    public PesReader(ElementaryStreamReader pesPayloadReader) {
      this.pesPayloadReader = pesPayloadReader;
      pesScratch = new ParsableBitArray(new byte[HEADER_SIZE]);
      state = STATE_FINDING_HEADER;
    }

    @Override
    public void consume(ParsableByteArray data, boolean payloadUnitStartIndicator) {
      if (payloadUnitStartIndicator) {
        switch (state) {
          case STATE_FINDING_HEADER:
          case STATE_READING_HEADER:
            // Expected.
            break;
          case STATE_READING_HEADER_EXTENSION:
            Log.w(TAG, "Unexpected start indicator reading extended header");
            break;
          case STATE_READING_BODY:
            // If payloadSize == -1 then the length of the previous packet was unspecified, and so
            // we only know that it's finished now that we've seen the start of the next one. This
            // is expected. If payloadSize != -1, then the length of the previous packet was known,
            // but we didn't receive that amount of data. This is not expected.
            if (payloadSize != -1) {
              Log.w(TAG, "Unexpected start indicator: expected " + payloadSize + " more bytes");
            }
            // Either way, if the body was started, notify the reader that it has now finished.
            if (bodyStarted) {
              pesPayloadReader.packetFinished();
            }
            break;
        }
        setState(STATE_READING_HEADER);
      }

      while (data.bytesLeft() > 0) {
        switch (state) {
          case STATE_FINDING_HEADER:
            data.skip(data.bytesLeft());
            break;
          case STATE_READING_HEADER:
            if (continueRead(data, pesScratch.getData(), HEADER_SIZE)) {
              setState(parseHeader() ? STATE_READING_HEADER_EXTENSION : STATE_FINDING_HEADER);
            }
            break;
          case STATE_READING_HEADER_EXTENSION:
            int readLength = Math.min(MAX_HEADER_EXTENSION_SIZE, extendedHeaderLength);
            // Read as much of the extended header as we're interested in, and skip the rest.
            if (continueRead(data, pesScratch.getData(), readLength)
                && continueRead(data, null, extendedHeaderLength)) {
              parseHeaderExtension();
              bodyStarted = false;
              setState(STATE_READING_BODY);
            }
            break;
          case STATE_READING_BODY:
            readLength = data.bytesLeft();
            int padding = payloadSize == -1 ? 0 : readLength - payloadSize;
            if (padding > 0) {
              readLength -= padding;
              data.setLimit(data.getPosition() + readLength);
            }
            pesPayloadReader.consume(data, timeUs, !bodyStarted);
            bodyStarted = true;
            if (payloadSize != -1) {
              payloadSize -= readLength;
              if (payloadSize == 0) {
                pesPayloadReader.packetFinished();
                setState(STATE_READING_HEADER);
              }
            }
            break;
        }
      }
    }

    private void setState(int state) {
      this.state = state;
      bytesRead = 0;
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read, or {@code null} to skip.
     * @param targetLength The target length of the read.
     * @return Whether the target length has been reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
      int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
      if (bytesToRead <= 0) {
        return true;
      } else if (target == null) {
        source.skip(bytesToRead);
      } else {
        source.readBytes(target, bytesRead, bytesToRead);
      }
      bytesRead += bytesToRead;
      return bytesRead == targetLength;
    }

    private boolean parseHeader() {
      pesScratch.setPosition(0);
      int startCodePrefix = pesScratch.readBits(24);
      if (startCodePrefix != 0x000001) {
        Log.w(TAG, "Unexpected start code prefix: " + startCodePrefix);
        payloadSize = -1;
        return false;
      }

      pesScratch.skipBits(8); // stream_id.
      int packetLength = pesScratch.readBits(16);
      // First 8 bits are skipped: '10' (2), PES_scrambling_control (2), PES_priority (1),
      // data_alignment_indicator (1), copyright (1), original_or_copy (1)
      pesScratch.skipBits(8);
      ptsFlag = pesScratch.readBit();
      // DTS_flag (1), ESCR_flag (1), ES_rate_flag (1), DSM_trick_mode_flag (1),
      // additional_copy_info_flag (1), PES_CRC_flag (1), PES_extension_flag (1)
      pesScratch.skipBits(7);
      extendedHeaderLength = pesScratch.readBits(8);

      if (packetLength == 0) {
        payloadSize = -1;
      } else {
        payloadSize = packetLength + 6 /* packetLength does not include the first 6 bytes */
            - HEADER_SIZE - extendedHeaderLength;
      }
      return true;
    }

    private void parseHeaderExtension() {
      pesScratch.setPosition(0);
      timeUs = 0;
      if (ptsFlag) {
        pesScratch.skipBits(4); // '0010'
        long pts = pesScratch.readBitsLong(3) << 30;
        pesScratch.skipBits(1); // marker_bit
        pts |= pesScratch.readBitsLong(15) << 15;
        pesScratch.skipBits(1); // marker_bit
        pts |= pesScratch.readBitsLong(15);
        pesScratch.skipBits(1); // marker_bit
        timeUs = ptsToTimeUs(pts);
      }
    }

  }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/util/Ac3Util.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.util;

import com.google.android.exoplayer.MediaFormat;

import java.util.Collections;

/**
 * Utility methods for parsing AC-3 headers.
 */
public final class Ac3Util {

  /** Sample rates, indexed by fscod. */
  private static final int[] SAMPLE_RATES = new int[] {48000, 44100, 32000};
  /** Channel counts, indexed by acmod. */
  private static final int[] CHANNEL_COUNTS = new int[] {2, 1, 2, 3, 3, 4, 4, 5};
  /** Nominal bitrates in kbps, indexed by bit_rate_code. */
  private static final int[] BITRATES = new int[] {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192,
      224, 256, 320, 384, 448, 512, 576, 640};
  /** 16-bit words per sync frame, indexed by frmsizecod / 2. (See ETSI TS 102 366 table 4.13.) */
  private static final int[] FRMSIZECOD_TO_FRAME_SIZE_44_1 = new int[] {69, 87, 104, 121, 139, 174,
    208, 243, 278, 348, 417, 487, 557, 696, 835, 975, 1114, 1253, 1393};

  /**
   * Returns the AC-3 format given {@code data} containing the AC3SpecificBox according to
   * ETSI TS 102 366 Annex F.
   */
  public static MediaFormat parseAnnexFAc3Format(ParsableByteArray data) {
    // fscod (sample rate code)
    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
    int sampleRate = SAMPLE_RATES[fscod];
    int nextByte = data.readUnsignedByte();
    // Map acmod (audio coding mode) onto a channel count.
    int channelCount = CHANNEL_COUNTS[(nextByte & 0x38) >> 3];
    // lfeon (low frequency effects on)
    if ((nextByte & 0x04) != 0) {
      channelCount++;
    }
    // Map bit_rate_code onto a bitrate in bit/s.
    int bitrate = BITRATES[((nextByte & 0x03) << 3) + (data.readUnsignedByte() >> 5)] * 1000;
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
        MediaFormat.NO_VALUE, channelCount, sampleRate, bitrate, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 format given {@code data} containing the EC3SpecificBox according to
   * ETSI TS 102 366 Annex F.
   */
  public static MediaFormat parseAnnexFEAc3Format(ParsableByteArray data) {
    data.skipBytes(2); // Skip data_rate and num_ind_sub.

    // Read only the first substream.
    // TODO: Read later substreams?
    // fscod (sample rate code)
    int fscod = (data.readUnsignedByte() & 0xC0) >> 6;
    int sampleRate = SAMPLE_RATES[fscod];
    int nextByte = data.readUnsignedByte();
    // Map acmod (audio coding mode) onto a channel count.
    int channelCount = CHANNEL_COUNTS[(nextByte & 0x0E) >> 1];
    // lfeon (low frequency effects on)
    if ((nextByte & 0x01) != 0) {
      channelCount++;
    }
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_EC3, MediaFormat.NO_VALUE,
        channelCount, sampleRate, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 format given {@code data} containing the frame header starting from the sync
   * word.
   *
   * @param data Data to parse, positioned at the start of the syncword.
   * @return AC-3 format parsed from data in the header.
   */
  public static MediaFormat parseFrameAc3Format(ParsableBitArray data) {
    // Skip syncword and crc1.
    data.skipBits(4 * 8);

    int fscod = data.readBits(2);
    int frmsizecod = data.readBits(6);
    data.skipBits(8); // bsid (5 bits) + bsmod (3 bits)
    int acmod = data.readBits(3);
    if ((acmod & 0x01) != 0 && acmod != 1) {
      data.skipBits(2); // cmixlev
    }
    if ((acmod & 0x04) != 0) {
      data.skipBits(2); // surmixlev
    }
    if (acmod == 0x02) {
      data.skipBits(2); // dsurmod
    }
    boolean lfeon = data.readBit();
    return MediaFormat.createAudioFormat(MimeTypes.AUDIO_AC3, MediaFormat.NO_VALUE,
        MediaFormat.NO_VALUE, CHANNEL_COUNTS[acmod] + (lfeon ? 1 : 0), SAMPLE_RATES[fscod],
        BITRATES[frmsizecod / 2] * 1000, Collections.<byte[]>emptyList());
  }

  /**
   * Returns the AC-3 frame size in bytes given {@code data} containing the frame header starting
   * from the sync word.
   *
   * @param data Data to parse, positioned at the start of the syncword.
   * @return The frame size parsed from data in the header.
   */
  public static int parseFrameSize(ParsableBitArray data) {
    // Skip syncword and crc1.
    data.skipBits(4 * 8);

    int fscod = data.readBits(2);
    int frmsizecod = data.readBits(6);
    int sampleRate = SAMPLE_RATES[fscod];
    int bitrate = BITRATES[frmsizecod / 2];
    if (sampleRate == 32000) {
      return 6 * bitrate;
    } else if (sampleRate == 44100) {
      return 2 * (FRMSIZECOD_TO_FRAME_SIZE_44_1[frmsizecod / 2] + (frmsizecod % 2));
    } else { // sampleRate == 48000
      return 4 * bitrate;
    }
  }

  private Ac3Util() {
    // Prevent instantiation.
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_aed45bb_39082d1/rev_aed45bb-39082d1/library/src/main/java/com/google/android/exoplayer/extractor/ts/Ac3Reader.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.Ac3Util;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

/**
 * Parses a continuous AC-3 byte stream and extracts individual samples.
 */
/* package */ final class Ac3Reader extends ElementaryStreamReader {

  private static final int STATE_FINDING_SYNC = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_SAMPLE = 2;

  private static final int HEADER_SIZE = 8;

  private final ParsableBitArray headerScratchBits;
  private final ParsableByteArray headerScratchBytes;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWas0B;

  // Used when parsing the header.
  private long frameDurationUs;
  private MediaFormat mediaFormat;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public Ac3Reader(TrackOutput output) {
    super(output);
    headerScratchBits = new ParsableBitArray(new byte[HEADER_SIZE]);
    headerScratchBytes = new ParsableByteArray(headerScratchBits.getData());
    state = STATE_FINDING_SYNC;
  }

  public void seek() {
    state = STATE_FINDING_SYNC;
    bytesRead = 0;
    lastByteWas0B = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_SYNC:
          if (skipToNextSync(data)) {
            state = STATE_READING_HEADER;
            headerScratchBytes.data[0] = 0x0B;
            headerScratchBytes.data[1] = 0x77;
            bytesRead = 2;
          }
          break;
        case STATE_READING_HEADER:
          if (continueRead(data, headerScratchBytes.data, HEADER_SIZE)) {
            parseHeader();
            headerScratchBytes.setPosition(0);
            output.sampleData(headerScratchBytes, HEADER_SIZE);
            state = STATE_READING_SAMPLE;
          }
          break;
        case STATE_READING_SAMPLE:
          int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
          output.sampleData(data, bytesToRead);
          bytesRead += bytesToRead;
          if (bytesRead == sampleSize) {
            output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
            timeUs += frameDurationUs;
            state = STATE_FINDING_SYNC;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
   * that the data should be written into {@code target} starting from an offset of zero.
   *
   * @param source The source from which to read.
   * @param target The target into which data is to be read.
   * @param targetLength The target length of the read.
   * @return Whether the target length was reached.
   */
  private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
    int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
    source.readBytes(target, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    return bytesRead == targetLength;
  }

  /**
   * Locates the next sync word, advancing the position to the byte that immediately follows it.
   * If a sync word was not located, the position is advanced to the limit.
   *
   * @param pesBuffer The buffer whose position should be advanced.
   * @return True if a sync word position was found. False otherwise.
   */
  private boolean skipToNextSync(ParsableByteArray pesBuffer) {
    while (pesBuffer.bytesLeft() > 0) {
      if (!lastByteWas0B) {
        lastByteWas0B = pesBuffer.readUnsignedByte() == 0x0B;
        continue;
      }
      int secondByte = pesBuffer.readUnsignedByte();
      if (secondByte == 0x77) {
        lastByteWas0B = false;
        return true;
      } else {
        lastByteWas0B = secondByte == 0x0B;
      }
    }
    return false;
  }

  /**
   * Parses the sample header.
   */
  private void parseHeader() {
    if (mediaFormat == null) {
      headerScratchBits.setPosition(0);
      mediaFormat = Ac3Util.parseFrameAc3Format(headerScratchBits);
      output.format(mediaFormat);
    }
    headerScratchBits.setPosition(0);
    sampleSize = Ac3Util.parseFrameSize(headerScratchBits);
    frameDurationUs = (int) (1000000L * 8 * sampleSize / mediaFormat.bitrate);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/java/revisions/rev_6a231a5_e0957ee/rev_6a231a5-e0957ee/src/test/java/com/pubnub/api/endpoints/pubsub/TestPojo.java;<<<<<<< MINE
=======
package com.pubnub.api.endpoints.pubsub;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Created by Max on 9/8/16.
 */
@AllArgsConstructor
@Getter
class TestPojo {
    String field1;
    String field2;
}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7fb5b86_c06f844/rev_7fb5b86-c06f844/library/src/main/java/com/google/android/exoplayer/extractor/ts/MpaReader.java;<<<<<<< MINE
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.util.CodecSpecificDataUtil;
import com.google.android.exoplayer.util.MimeTypes;
import com.google.android.exoplayer.util.ParsableBitArray;
import com.google.android.exoplayer.util.ParsableByteArray;

import android.util.Pair;

import java.util.Collections;

/**
   * Parses a continuous MPEG Audio byte stream and extracts individual
   * frames.
   */
/* package */ public class MpaReader extends ElementaryStreamReader {

    private static final int STATE_FINDING_SYNC = 0;
    private static final int STATE_READING_HEADER = 1;
    private static final int STATE_READING_SAMPLE = 2;

    private static final int HEADER_SIZE = 4;
    private static final int CRC_SIZE = 2;

    private final ParsableBitArray mpaScratch;

    private int state;
    private int bytesRead;

    // Used to find the header.
    private boolean hasCrc;

    // Used when parsing the header.
    private boolean hasOutputFormat;
    private long frameDurationUs;
    private int sampleSize;

    // Used when reading the samples.
    private long timeUs;

    //
    /**
     * sampling rates in hertz:
     *
     *     @index MPEG Version ID
     *     @index sampling rate index
     */

    private static final int[][] MPA_SAMPLING_RATES = new int[][] {
            {11025, 12000,  8000},    // MPEG 2.5
            {    0,     0,     0},    // reserved
            {22050, 24000, 16000},    // MPEG 2
            {44100, 48000, 32000}     // MPEG 1
    };

    /**
     * bitrates:
     *
     *     @index LSF
     *     @index Layer
     *     @index bitrate index
     */

    private static final int[][][] MPA_BITRATES = new int[][][] {
            { // MPEG 1
                    // Layer1
                    {  0,  32,  64,  96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448},
                    // Layer2
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384},
                    // Layer3
                    {  0,  32,  40,  48,  56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320}
            },
            { // MPEG 2, 2.5
                    // Layer1
                    {  0,  32,  48,  56,  64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256},
                    // Layer2
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160},
                    // Layer3
                    {  0,   8,  16,  24,  32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160}
            }
    };

    /**
     * Samples per Frame:
     *
     *  @index LSF
     *  @index Layer
     */

    private static final int[][] MPA_SAMPLES_PER_FRAME = new int[][] {
            {           // MPEG 1
                    384,   // Layer1
                    1152,   // Layer2
                    1152    // Layer3
            },
            {           // MPEG 2, 2.5
                    384,   // Layer1
                    1152,   // Layer2
                    576    // Layer3
            }
    };

    /**
     * Coefficients (samples per frame / 8):
     *
     * @index = LSF
     * @index = Layer
     */

    private static final int[][] MPA_COEFFICIENTS = new int[][] {
            {           // MPEG 1
                    12,    // Layer1
                    144,    // Layer2
                    144     // Layer3
            },
            {           // MPEG 2, 2.5
                    12,    // Layer1
                    144,    // Layer2
                    72     // Layer3
            }
    };

    /**
     * slot size per layer:
     *
     * @index = Layer
     */

    private static final int[] MPA_SLOT_SIZE = new int[] {
            4,          // Layer1
            1,          // Layer2
            1           // Layer3
    };

    public MpaReader(TrackOutput output) {
        super(output);
        mpaScratch = new ParsableBitArray(new byte[HEADER_SIZE + CRC_SIZE]);
        state = STATE_FINDING_SYNC;
    }

    @Override
    public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
        if (startOfPacket) {
            timeUs = pesTimeUs;
        }
        while (data.bytesLeft() > 0) {
            switch (state) {
                case STATE_FINDING_SYNC:
                    if (skipToNextSync(data)) {
                        bytesRead = 0;
                        state = STATE_READING_HEADER;
                    }
                    break;
                case STATE_READING_HEADER:
                    int targetLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;
                    if (continueRead(data, mpaScratch.getData(), targetLength)) {
                        parseHeader();
                        bytesRead = targetLength;
                        state = STATE_READING_SAMPLE;
                    }
                    break;
                case STATE_READING_SAMPLE:
                    int bytesToRead = Math.min(data.bytesLeft(), sampleSize - bytesRead);
                    output.sampleData(data, bytesToRead);
                    bytesRead += bytesToRead;
                    if (bytesRead == sampleSize) {
                        output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
                        timeUs += frameDurationUs;
                        bytesRead = 0;
                        state = STATE_FINDING_SYNC;
                    }
                    break;
            }
        }
    }

    @Override
    public void packetFinished() {
        // Do nothing.
    }

    /**
     * Continues a read from the provided {@code source} into a given {@code target}. It's assumed
     * that the data should be written into {@code target} starting from an offset of zero.
     *
     * @param source The source from which to read.
     * @param target The target into which data is to be read.
     * @param targetLength The target length of the read.
     * @return Whether the target length was reached.
     */
    private boolean continueRead(ParsableByteArray source, byte[] target, int targetLength) {
        int bytesToRead = Math.min(source.bytesLeft(), targetLength - bytesRead);
        source.readBytes(target, bytesRead, bytesToRead);
        bytesRead += bytesToRead;
        return bytesRead == targetLength;
    }

    /**
     * Locates the next sync word, advancing the position to the byte that immediately follows it.
     * If a sync word was not located, the position is advanced to the limit.
     *
     * @param pesBuffer The buffer whose position should be advanced.
     * @return True if a sync word position was found. False otherwise.
     */
    private boolean skipToNextSync(ParsableByteArray pesBuffer) {
        byte[] mpaData = pesBuffer.data;
        int startOffset = pesBuffer.getPosition();
        int endOffset = pesBuffer.limit();
        for (int i = startOffset; i < endOffset - 1; i++) {
            int syncBits = ((mpaData[i] & 0xFF) << 8 ) | (mpaData[i + 1] & 0xFF);
            if ((syncBits & 0xFFF0) == 0xFFF0) {
                hasCrc = (mpaData[i + 1] & 0x1) == 0;
                pesBuffer.setPosition(i);
                return true;
            }
        }
        pesBuffer.setPosition(endOffset);
        return false;
    }

    /**
     * Calculates MPEG Audio frame size
     *
     * @param layer The MPEG layer
     * @param LSF Low Sample rate Format (MPEG 2)
     * @param bitrate The bitrate in bits per second
     * @param samplesPerSec The sampling rate in hertz
     * @param -paddingSize
     * @return Frame size in bytes
     */
    private static int CalcMpaFrameSize (int layer, int LSF, int bitrate, int samplesPerSec, int paddingSize) {
        return (int)(Math.floor(MPA_COEFFICIENTS[LSF][layer] * bitrate / samplesPerSec) + paddingSize) * MPA_SLOT_SIZE[layer];
    }

    /**
     * Parses the sample header.
     */
    private void parseHeader() {
        int headerLength = hasCrc ? HEADER_SIZE + CRC_SIZE : HEADER_SIZE;

        if (!hasOutputFormat) {
            mpaScratch.setPosition(0);
            mpaScratch.skipBits(12);
            int isLSF = (!mpaScratch.readBit()) ? 1 : 0;
            int layer = mpaScratch.readBits(2) ^ 3;
            mpaScratch.skipBits(1);
            int audioObjectType = 32 + layer;
            int bitRate = MPA_BITRATES[isLSF][layer][mpaScratch.readBits(4)];
            int sampleRate = MPA_SAMPLING_RATES[3 - isLSF][mpaScratch.readBits(2)];
            int sampleRateIndex = CodecSpecificDataUtil.getSampleRateIndex(sampleRate);
            int paddingBit = (mpaScratch.readBit()) ? 1 : 0;
            mpaScratch.skipBits(1);
            int channelConfig = mpaScratch.readBits(2) == 3 ? 1 : 2;

            byte[] audioSpecificConfig = CodecSpecificDataUtil.buildAudioSpecificConfig(
                    audioObjectType, sampleRateIndex, channelConfig);
            Pair<Integer, Integer> audioParams = CodecSpecificDataUtil.parseAudioSpecificConfig(
                    audioSpecificConfig);

            // need to investigate how to detect if the mpeg decoder supports Layers other than Layer III
            MediaFormat mediaFormat = MediaFormat.createAudioFormat(/*isLSF == 1 ?*/ MimeTypes.AUDIO_MPEG/* : MimeTypes.AUDIO_MP1L2*/,
                    MediaFormat.NO_VALUE, audioParams.second, audioParams.first,
                    Collections.singletonList(audioSpecificConfig));
            output.format(mediaFormat);
            hasOutputFormat = true;
            frameDurationUs = (C.MICROS_PER_SECOND * MPA_SAMPLES_PER_FRAME[isLSF][layer]) / mediaFormat.sampleRate;
            sampleSize = CalcMpaFrameSize(layer, isLSF, bitRate * 1000, sampleRate, paddingBit);
        }

        mpaScratch.setPosition(0);

        ParsableByteArray header = new ParsableByteArray(mpaScratch.getData(),headerLength);
        output.sampleData(header, headerLength);
    }
}=======
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.extractor.ts;

import com.google.android.exoplayer.C;
import com.google.android.exoplayer.MediaFormat;
import com.google.android.exoplayer.extractor.TrackOutput;
import com.google.android.exoplayer.extractor.mp3.Mp3Extractor;
import com.google.android.exoplayer.extractor.mp3.MpegAudioHeader;
import com.google.android.exoplayer.util.ParsableByteArray;

import java.util.Collections;

/**
 * Parses a continuous MPEG Audio byte stream and extracts individual frames.
 */
/* package */ public class MpaReader extends ElementaryStreamReader {

  private static final int STATE_FINDING_HEADER = 0;
  private static final int STATE_READING_HEADER = 1;
  private static final int STATE_READING_FRAME = 2;

  private static final int HEADER_SIZE = 4;

  private final ParsableByteArray headerScratch;

  private int state;
  private int bytesRead;

  // Used to find the header.
  private boolean lastByteWasFF;

  // Used when parsing the header.
  private boolean hasOutputFormat;
  private long frameDurationUs;
  private int sampleSize;

  // Used when reading the samples.
  private long timeUs;

  public MpaReader(TrackOutput output) {
    super(output);
    state = STATE_FINDING_HEADER;
    // The first byte of an MPEG Audio frame header is always 0xFF.
    headerScratch = new ParsableByteArray(4);
    headerScratch.data[0] = (byte) 0xFF;
  }

  @Override
  public void seek() {
    state = STATE_FINDING_HEADER;
    bytesRead = 0;
    lastByteWasFF = false;
  }

  @Override
  public void consume(ParsableByteArray data, long pesTimeUs, boolean startOfPacket) {
    if (startOfPacket) {
      timeUs = pesTimeUs;
    }
    while (data.bytesLeft() > 0) {
      switch (state) {
        case STATE_FINDING_HEADER:
          if (findHeader(data)) {
            state = STATE_READING_HEADER;
          }
          break;
        case STATE_READING_HEADER:
          if (readHeaderRemainder(data)) {
            state = STATE_READING_FRAME;
          }
          break;
        case STATE_READING_FRAME:
          if (readFrame(data)) {
            state = STATE_FINDING_HEADER;
          }
          break;
      }
    }
  }

  @Override
  public void packetFinished() {
    // Do nothing.
  }

  /**
   * Attempts to locate the start of the next frame header.
   * <p>
   * If a frame header is located then true is returned. The first two bytes of the header will have
   * been written into {@link #headerScratch}, and the position of the source will have been
   * advanced to the byte that immediately follows these two bytes.
   * <p>
   * If a frame header is not located then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the search.
   *
   * @param source The source from which to read.
   * @return True if the frame header was located. False otherwise.
   */
  private boolean findHeader(ParsableByteArray source) {
    byte[] mpaData = source.data;
    int startOffset = source.getPosition();
    int endOffset = source.limit();
    for (int i = startOffset; i < endOffset; i++) {
      boolean byteIsFF = (mpaData[i] & 0xFF) == 0xFF;
      boolean found = lastByteWasFF && (mpaData[i] & 0xF0) == 0xF0;
      lastByteWasFF = byteIsFF;
      if (found) {
        source.setPosition(i + 1);
        // Reset lastByteWasFF for next time.
        lastByteWasFF = false;
        headerScratch.data[0] = (byte) 0xFF;
        headerScratch.data[1] = mpaData[i];
        bytesRead = 2;
        return true;
      }
    }
    source.setPosition(endOffset);
    return false;
  }

  /**
   * Attempts to read the remaining two bytes of the frame header.
   * <p>
   * If a frame header is read in full then true is returned. The media format will have been output
   * if this has not previously occurred, the four header bytes will have been output as sample
   * data, and the position of the source will have been advanced to the byte that immediately
   * follows the header.
   * <p>
   * If a frame header is not read in full then the position of the source will have been advanced
   * to the limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame header was read in full. False otherwise.
   */
  private boolean readHeaderRemainder(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), HEADER_SIZE - bytesRead);
    source.readBytes(headerScratch.data, bytesRead, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < HEADER_SIZE) {
      return false;
    }

    if (!hasOutputFormat) {
      headerScratch.setPosition(0);
      int headerInt = headerScratch.readInt();
      MpegAudioHeader synchronizedHeader = new MpegAudioHeader();
      MpegAudioHeader.populateHeader(headerInt, synchronizedHeader);
      MediaFormat mediaFormat = MediaFormat.createAudioFormat(
          Mp3Extractor.MIME_TYPE_BY_LAYER[synchronizedHeader.layerIndex], Mp3Extractor.MAX_FRAME_SIZE_BYTES,
          C.UNKNOWN_TIME_US, synchronizedHeader.channels, synchronizedHeader.sampleRate,
          Collections.<byte[]>emptyList());
      output.format(mediaFormat);
      hasOutputFormat = true;
      frameDurationUs = (C.MICROS_PER_SECOND * synchronizedHeader.samplesPerFrame) / mediaFormat.sampleRate;
      sampleSize = synchronizedHeader.frameSize;
    }

    headerScratch.setPosition(0);
    output.sampleData(headerScratch, HEADER_SIZE);
    return true;
  }

  /**
   * Attempts to read the remainder of the frame.
   * <p>
   * If a frame is read in full then true is returned. The frame will have been output, and the
   * position of the source will have been advanced to the byte that immediately follows the end of
   * the frame.
   * <p>
   * If a frame is not read in full then the position of the source will have been advanced to the
   * limit, and the method should be called again with the next source to continue the read.
   *
   * @param source The source from which to read.
   * @return True if the frame was read in full. False otherwise.
   */
  private boolean readFrame(ParsableByteArray source) {
    int bytesToRead = Math.min(source.bytesLeft(), sampleSize - bytesRead);
    output.sampleData(source, bytesToRead);
    bytesRead += bytesToRead;
    if (bytesRead < sampleSize) {
      return false;
    }

    output.sampleMetadata(timeUs, C.SAMPLE_FLAG_SYNC, sampleSize, 0, null);
    timeUs += frameDurationUs;
    bytesRead = 0;
    return true;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBufferRenderer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.ext.vp9;

/**
 * Renders the {@link VpxOutputBuffer}.
 */
public interface VpxOutputBufferRenderer {

  /**
   * Sets the output buffer to be rendered.
   */
  void setOutputBuffer(VpxOutputBuffer outputBuffer);

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxVideoSurfaceView.java;<<<<<<< MINE
public class VpxVideoSurfaceView extends GLSurfaceView {
=======
public class VpxVideoSurfaceView extends GLSurfaceView implements VpxOutputBufferRenderer {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_a1d5626_d15da1f/rev_a1d5626-d15da1f/extensions/vp9/src/main/java/com/google/android/exoplayer/ext/vp9/VpxOutputBuffer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer.ext.vp9;

import java.nio.ByteBuffer;

/**
 * OutputBuffer for storing the video frame.
 */
public final class VpxOutputBuffer {

  public static final int COLORSPACE_UNKNOWN = 0;
  public static final int COLORSPACE_BT601 = 1;
  public static final int COLORSPACE_BT709 = 2;

  /**
   * RGB buffer for RGB mode.
   */
  public ByteBuffer data;
  public long timestampUs;
  public int width;
  public int height;
  public int flags;
  /**
   * YUV planes for YUV mode.
   */
  public ByteBuffer[] yuvPlanes;
  public int[] yuvStrides;
  public int mode;
  public int colorspace;

  /**
   * This method is called from C++ through JNI after decoding is done. It will resize the
   * buffer based on the given dimensions.
   */
  public void initForRgbFrame(int width, int height) {
    this.width = width;
    this.height = height;
    int minimumRgbSize = width * height * 2;
    if (data == null || data.capacity() < minimumRgbSize) {
      data = ByteBuffer.allocateDirect(minimumRgbSize);
      yuvPlanes = null;
    }
    data.position(0);
    data.limit(minimumRgbSize);
  }

  /**
   * This method is called from C++ through JNI after decoding is done. It will resize the
   * buffer based on the given stride.
   */
  public void initForYuvFrame(int width, int height, int yStride, int uvStride, int colorspace) {
    this.width = width;
    this.height = height;
    this.colorspace = colorspace;
    int yLength = yStride * height;
    int uvLength = uvStride * ((height + 1) / 2);
    int minimumYuvSize = yLength + (uvLength * 2);
    if (data == null || data.capacity() < minimumYuvSize) {
      data = ByteBuffer.allocateDirect(minimumYuvSize);
    }
    data.limit(minimumYuvSize);
    if (yuvPlanes == null) {
      yuvPlanes = new ByteBuffer[3];
    }
    // Rewrapping has to be done on every frame since the stride might have changed.
    data.position(0);
    yuvPlanes[0] = data.slice();
    yuvPlanes[0].limit(yLength);
    data.position(yLength);
    yuvPlanes[1] = data.slice();
    yuvPlanes[1].limit(uvLength);
    data.position(yLength + uvLength);
    yuvPlanes[2] = data.slice();
    yuvPlanes[2].limit(uvLength);
    if (yuvStrides == null) {
      yuvStrides = new int[3];
    }
    yuvStrides[0] = yStride;
    yuvStrides[1] = uvStride;
    yuvStrides[2] = uvStride;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_2e7f9fb_0cacd38/rev_2e7f9fb-0cacd38/library/src/main/java/com/google/android/exoplayer2/source/ClippingMediaPeriod.java;<<<<<<< MINE
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.source;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.FormatHolder;
import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
import com.google.android.exoplayer2.trackselection.TrackSelection;
import com.google.android.exoplayer2.util.Assertions;
import java.io.IOException;

/**
 * Wraps a {@link MediaPeriod} and clips its {@link SampleStream}s to provide a subsequence of their
 * samples.
 */
public final class ClippingMediaPeriod implements MediaPeriod, MediaPeriod.Callback {

  /**
   * The {@link MediaPeriod} wrapped by this clipping media period.
   */
  public final MediaPeriod mediaPeriod;

  private MediaPeriod.Callback callback;
  private long startUs;
  private long endUs;
  private ClippingSampleStream[] sampleStreams;
  private boolean pendingInitialDiscontinuity;

  /**
   * Creates a new clipping media period that provides a clipped view of the specified
   * {@link MediaPeriod}'s sample streams.
   * <p>
   * The clipping start/end positions must be specified by calling {@link #setClipping(long, long)}
   * on the playback thread before preparation completes.
   *
   * @param mediaPeriod The media period to clip.
   */
  public ClippingMediaPeriod(MediaPeriod mediaPeriod) {
    this.mediaPeriod = mediaPeriod;
    startUs = C.TIME_UNSET;
    endUs = C.TIME_UNSET;
    sampleStreams = new ClippingSampleStream[0];
  }

  /**
   * Sets the clipping start/end times for this period, in microseconds.
   *
   * @param startUs The clipping start time, in microseconds.
   * @param endUs The clipping end time, in microseconds, or {@link C#TIME_END_OF_SOURCE} to
   *     indicate the end of the period.
   */
  public void setClipping(long startUs, long endUs) {
    this.startUs = startUs;
    this.endUs = endUs;
  }

  @Override
  public void prepare(MediaPeriod.Callback callback) {
    this.callback = callback;
    mediaPeriod.prepare(this);
  }

  @Override
  public void maybeThrowPrepareError() throws IOException {
    mediaPeriod.maybeThrowPrepareError();
  }

  @Override
  public TrackGroupArray getTrackGroups() {
    return mediaPeriod.getTrackGroups();
  }

  @Override
  public long selectTracks(TrackSelection[] selections, boolean[] mayRetainStreamFlags,
      SampleStream[] streams, boolean[] streamResetFlags, long positionUs) {
    sampleStreams = new ClippingSampleStream[streams.length];
    SampleStream[] internalStreams = new SampleStream[streams.length];
    for (int i = 0; i < streams.length; i++) {
      sampleStreams[i] = (ClippingSampleStream) streams[i];
      internalStreams[i] = sampleStreams[i] != null ? sampleStreams[i].stream : null;
    }
    long enablePositionUs = mediaPeriod.selectTracks(selections, mayRetainStreamFlags,
        internalStreams, streamResetFlags, positionUs + startUs);
    Assertions.checkState(enablePositionUs == positionUs + startUs
        || (enablePositionUs >= startUs
        && (endUs == C.TIME_END_OF_SOURCE || enablePositionUs <= endUs)));
    for (int i = 0; i < streams.length; i++) {
      if (internalStreams[i] == null) {
        sampleStreams[i] = null;
      } else if (streams[i] == null || sampleStreams[i].stream != internalStreams[i]) {
        sampleStreams[i] = new ClippingSampleStream(this, internalStreams[i], startUs, endUs,
            pendingInitialDiscontinuity);
      }
      streams[i] = sampleStreams[i];
    }
    return enablePositionUs - startUs;
  }

  @Override
  public long readDiscontinuity() {
    if (pendingInitialDiscontinuity) {
      for (ClippingSampleStream sampleStream : sampleStreams) {
        if (sampleStream != null) {
          sampleStream.clearPendingDiscontinuity();
        }
      }
      pendingInitialDiscontinuity = false;
      // Always read an initial discontinuity, using mediaPeriod's discontinuity if set.
      long discontinuityUs = readDiscontinuity();
      return discontinuityUs != C.TIME_UNSET ? discontinuityUs : 0;
    }
    long discontinuityUs = mediaPeriod.readDiscontinuity();
    if (discontinuityUs == C.TIME_UNSET) {
      return C.TIME_UNSET;
    }
    Assertions.checkState(discontinuityUs >= startUs);
    Assertions.checkState(endUs == C.TIME_END_OF_SOURCE || discontinuityUs <= endUs);
    return discontinuityUs - startUs;
  }

  @Override
  public long getBufferedPositionUs() {
    long bufferedPositionUs = mediaPeriod.getBufferedPositionUs();
    if (bufferedPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && bufferedPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return Math.max(0, bufferedPositionUs - startUs);
  }

  @Override
  public long seekToUs(long positionUs) {
    for (ClippingSampleStream sampleStream : sampleStreams) {
      if (sampleStream != null) {
        sampleStream.clearSentEos();
      }
    }
    long seekUs = mediaPeriod.seekToUs(positionUs + startUs);
    Assertions.checkState(seekUs == positionUs + startUs
        || (seekUs >= startUs && (endUs == C.TIME_END_OF_SOURCE || seekUs <= endUs)));
    return seekUs - startUs;
  }

  @Override
  public long getNextLoadPositionUs() {
    long nextLoadPositionUs = mediaPeriod.getNextLoadPositionUs();
    if (nextLoadPositionUs == C.TIME_END_OF_SOURCE
        || (endUs != C.TIME_END_OF_SOURCE && nextLoadPositionUs >= endUs)) {
      return C.TIME_END_OF_SOURCE;
    }
    return nextLoadPositionUs - startUs;
  }

  @Override
  public boolean continueLoading(long positionUs) {
    return mediaPeriod.continueLoading(positionUs + startUs);
  }

  // MediaPeriod.Callback implementation.

  @Override
  public void onPrepared(MediaPeriod mediaPeriod) {
    Assertions.checkState(startUs != C.TIME_UNSET && endUs != C.TIME_UNSET);
    // If the clipping start position is non-zero, the clipping sample streams will adjust
    // timestamps on buffers they read from the unclipped sample streams. These adjusted buffer
    // timestamps can be negative, because sample streams provide buffers starting at a key-frame,
    // which may be before the clipping start point. When the renderer reads a buffer with a
    // negative timestamp, its offset timestamp can jump backwards compared to the last timestamp
    // read in the previous period. Renderer implementations may not allow this, so we signal a
    // discontinuity which resets the renderers before they read the clipping sample stream.
    pendingInitialDiscontinuity = startUs != 0;
    callback.onPrepared(this);
  }

  @Override
  public void onContinueLoadingRequested(MediaPeriod source) {
    callback.onContinueLoadingRequested(this);
  }

  /**
   * Wraps a {@link SampleStream} and clips its samples.
   */
  private static final class ClippingSampleStream implements SampleStream {

    private final MediaPeriod mediaPeriod;
    private final SampleStream stream;
    private final long startUs;
    private final long endUs;

    private boolean pendingDiscontinuity;
    private boolean sentEos;

    public ClippingSampleStream(MediaPeriod mediaPeriod, SampleStream stream, long startUs,
        long endUs, boolean pendingDiscontinuity) {
      this.mediaPeriod = mediaPeriod;
      this.stream = stream;
      this.startUs = startUs;
      this.endUs = endUs;
      this.pendingDiscontinuity = pendingDiscontinuity;
    }

    public void clearPendingDiscontinuity() {
      pendingDiscontinuity = false;
    }

    public void clearSentEos() {
      sentEos = false;
    }

    @Override
    public boolean isReady() {
      return stream.isReady();
    }

    @Override
    public void maybeThrowError() throws IOException {
      stream.maybeThrowError();
    }

    @Override
    public int readData(FormatHolder formatHolder, DecoderInputBuffer buffer) {
      if (pendingDiscontinuity) {
        return C.RESULT_NOTHING_READ;
      }
      if (buffer == null) {
        return stream.readData(formatHolder, null);
      }
      if (sentEos) {
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        return C.RESULT_BUFFER_READ;
      }
      int result = stream.readData(formatHolder, buffer);
      // TODO: Clear gapless playback metadata if a format was read (if applicable).
      if (endUs != C.TIME_END_OF_SOURCE && ((result == C.RESULT_BUFFER_READ
          && buffer.timeUs >= endUs) || (result == C.RESULT_NOTHING_READ
          && mediaPeriod.getBufferedPositionUs() == C.TIME_END_OF_SOURCE))) {
        buffer.clear();
        buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
        sentEos = true;
        return C.RESULT_BUFFER_READ;
      }
      if (result == C.RESULT_BUFFER_READ && !buffer.isEndOfStream()) {
        buffer.timeUs -= startUs;
      }
      return result;
    }

    @Override
    public void skipToKeyframeBefore(long timeUs) {
      stream.skipToKeyframeBefore(startUs + timeUs);
    }

  }

}=======
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/source/dash/DefaultDashChunkSource.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.source.dash;

import android.net.Uri;
import android.os.SystemClock;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.extractor.ChunkIndex;
import com.google.android.exoplayer2.extractor.Extractor;
import com.google.android.exoplayer2.extractor.SeekMap;
import com.google.android.exoplayer2.extractor.mkv.MatroskaExtractor;
import com.google.android.exoplayer2.extractor.mp4.FragmentedMp4Extractor;
import com.google.android.exoplayer2.extractor.rawcc.RawCcExtractor;
import com.google.android.exoplayer2.source.BehindLiveWindowException;
import com.google.android.exoplayer2.source.chunk.Chunk;
import com.google.android.exoplayer2.source.chunk.ChunkExtractorWrapper;
import com.google.android.exoplayer2.source.chunk.ChunkHolder;
import com.google.android.exoplayer2.source.chunk.ChunkedTrackBlacklistUtil;
import com.google.android.exoplayer2.source.chunk.ContainerMediaChunk;
import com.google.android.exoplayer2.source.chunk.InitializationChunk;
import com.google.android.exoplayer2.source.chunk.MediaChunk;
import com.google.android.exoplayer2.source.chunk.SingleSampleMediaChunk;
import com.google.android.exoplayer2.source.dash.manifest.AdaptationSet;
import com.google.android.exoplayer2.source.dash.manifest.DashManifest;
import com.google.android.exoplayer2.source.dash.manifest.RangedUri;
import com.google.android.exoplayer2.source.dash.manifest.Representation;
import com.google.android.exoplayer2.trackselection.TrackSelection;
import com.google.android.exoplayer2.upstream.DataSource;
import com.google.android.exoplayer2.upstream.DataSpec;
import com.google.android.exoplayer2.upstream.HttpDataSource.InvalidResponseCodeException;
import com.google.android.exoplayer2.upstream.LoaderErrorThrower;
import com.google.android.exoplayer2.util.MimeTypes;
import com.google.android.exoplayer2.util.Util;
import java.io.IOException;
import java.util.List;

/**
 * A default {@link DashChunkSource} implementation.
 */
public class DefaultDashChunkSource implements DashChunkSource {

  public static final class Factory implements DashChunkSource.Factory {

    private final DataSource.Factory dataSourceFactory;
    private final int maxSegmentsPerLoad;

    public Factory(DataSource.Factory dataSourceFactory) {
      this(dataSourceFactory, 1);
    }

    public Factory(DataSource.Factory dataSourceFactory, int maxSegmentsPerLoad) {
      this.dataSourceFactory = dataSourceFactory;
      this.maxSegmentsPerLoad = maxSegmentsPerLoad;
    }

    @Override
    public DashChunkSource createDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
        DashManifest manifest, int periodIndex, int adaptationSetIndex,
        TrackSelection trackSelection, long elapsedRealtimeOffsetMs,
        boolean enableEventMessageTrack, boolean enableCea608Track) {
      DataSource dataSource = dataSourceFactory.createDataSource();
      return new DefaultDashChunkSource(manifestLoaderErrorThrower, manifest, periodIndex,
          adaptationSetIndex, trackSelection, dataSource, elapsedRealtimeOffsetMs,
          maxSegmentsPerLoad, enableEventMessageTrack, enableCea608Track);
    }

  }

  private final LoaderErrorThrower manifestLoaderErrorThrower;
  private final int adaptationSetIndex;
  private final TrackSelection trackSelection;
  private final RepresentationHolder[] representationHolders;
  private final DataSource dataSource;
  private final long elapsedRealtimeOffsetMs;
  private final int maxSegmentsPerLoad;

  private DashManifest manifest;
  private int periodIndex;

  private IOException fatalError;
  private boolean missingLastSegment;

  /**
   * @param manifestLoaderErrorThrower Throws errors affecting loading of manifests.
   * @param manifest The initial manifest.
   * @param periodIndex The index of the period in the manifest.
   * @param adaptationSetIndex The index of the adaptation set in the period.
   * @param trackSelection The track selection.
   * @param dataSource A {@link DataSource} suitable for loading the media data.
   * @param elapsedRealtimeOffsetMs If known, an estimate of the instantaneous difference between
   *     server-side unix time and {@link SystemClock#elapsedRealtime()} in milliseconds, specified
   *     as the server's unix time minus the local elapsed time. If unknown, set to 0.
   * @param maxSegmentsPerLoad The maximum number of segments to combine into a single request.
   *     Note that segments will only be combined if their {@link Uri}s are the same and if their
   *     data ranges are adjacent.
   * @param enableEventMessageTrack Whether the chunks generated by the source may output an event
   *     message track.
   * @param enableEventMessageTrack Whether the chunks generated by the source may output a CEA-608
   *     track.
   */
  public DefaultDashChunkSource(LoaderErrorThrower manifestLoaderErrorThrower,
      DashManifest manifest, int periodIndex, int adaptationSetIndex, TrackSelection trackSelection,
      DataSource dataSource, long elapsedRealtimeOffsetMs, int maxSegmentsPerLoad,
      boolean enableEventMessageTrack, boolean enableCea608Track) {
    this.manifestLoaderErrorThrower = manifestLoaderErrorThrower;
    this.manifest = manifest;
    this.adaptationSetIndex = adaptationSetIndex;
    this.trackSelection = trackSelection;
    this.dataSource = dataSource;
    this.periodIndex = periodIndex;
    this.elapsedRealtimeOffsetMs = elapsedRealtimeOffsetMs;
    this.maxSegmentsPerLoad = maxSegmentsPerLoad;

    long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
    AdaptationSet adaptationSet = getAdaptationSet();
    List<Representation> representations = adaptationSet.representations;
    representationHolders = new RepresentationHolder[trackSelection.length()];
    for (int i = 0; i < representationHolders.length; i++) {
      Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
      representationHolders[i] = new RepresentationHolder(periodDurationUs, representation,
          enableEventMessageTrack, enableCea608Track, adaptationSet.type);
    }
  }

  @Override
  public void updateManifest(DashManifest newManifest, int newPeriodIndex) {
    try {
      manifest = newManifest;
      periodIndex = newPeriodIndex;
      long periodDurationUs = manifest.getPeriodDurationUs(periodIndex);
      List<Representation> representations = getAdaptationSet().representations;
      for (int i = 0; i < representationHolders.length; i++) {
        Representation representation = representations.get(trackSelection.getIndexInTrackGroup(i));
        representationHolders[i].updateRepresentation(periodDurationUs, representation);
      }
    } catch (BehindLiveWindowException e) {
      fatalError = e;
    }
  }

  @Override
  public void maybeThrowError() throws IOException {
    if (fatalError != null) {
      throw fatalError;
    } else {
      manifestLoaderErrorThrower.maybeThrowError();
    }
  }

  @Override
  public int getPreferredQueueSize(long playbackPositionUs, List<? extends MediaChunk> queue) {
    if (fatalError != null || trackSelection.length() < 2) {
      return queue.size();
    }
    return trackSelection.evaluateQueueSize(playbackPositionUs, queue);
  }

  @Override
  public final void getNextChunk(MediaChunk previous, long playbackPositionUs, ChunkHolder out) {
    if (fatalError != null) {
      return;
    }

    long bufferedDurationUs = previous != null ? (previous.endTimeUs - playbackPositionUs) : 0;
    trackSelection.updateSelectedTrack(bufferedDurationUs);

    RepresentationHolder representationHolder =
        representationHolders[trackSelection.getSelectedIndex()];

    if (representationHolder.extractorWrapper != null) {
      Representation selectedRepresentation = representationHolder.representation;
      RangedUri pendingInitializationUri = null;
      RangedUri pendingIndexUri = null;
      if (representationHolder.extractorWrapper.getSampleFormats() == null) {
        pendingInitializationUri = selectedRepresentation.getInitializationUri();
      }
      if (representationHolder.segmentIndex == null) {
        pendingIndexUri = selectedRepresentation.getIndexUri();
      }
      if (pendingInitializationUri != null || pendingIndexUri != null) {
        // We have initialization and/or index requests to make.
        out.chunk = newInitializationChunk(representationHolder, dataSource,
            trackSelection.getSelectedFormat(), trackSelection.getSelectionReason(),
            trackSelection.getSelectionData(), pendingInitializationUri, pendingIndexUri);
        return;
      }
    }

    long nowUs = getNowUnixTimeUs();
    int availableSegmentCount = representationHolder.getSegmentCount();
    if (availableSegmentCount == 0) {
      // The index doesn't define any segments.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int firstAvailableSegmentNum = representationHolder.getFirstSegmentNum();
    int lastAvailableSegmentNum;
    if (availableSegmentCount == DashSegmentIndex.INDEX_UNBOUNDED) {
      // The index is itself unbounded. We need to use the current time to calculate the range of
      // available segments.
      long liveEdgeTimeUs = nowUs - manifest.availabilityStartTime * 1000;
      long periodStartUs = manifest.getPeriod(periodIndex).startMs * 1000;
      long liveEdgeTimeInPeriodUs = liveEdgeTimeUs - periodStartUs;
      if (manifest.timeShiftBufferDepth != C.TIME_UNSET) {
        long bufferDepthUs = manifest.timeShiftBufferDepth * 1000;
        firstAvailableSegmentNum = Math.max(firstAvailableSegmentNum,
            representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs - bufferDepthUs));
      }
      // getSegmentNum(liveEdgeTimestampUs) will not be completed yet, so subtract one to get the
      // index of the last completed segment.
      lastAvailableSegmentNum = representationHolder.getSegmentNum(liveEdgeTimeInPeriodUs) - 1;
    } else {
      lastAvailableSegmentNum = firstAvailableSegmentNum + availableSegmentCount - 1;
    }

    int segmentNum;
    if (previous == null) {
      segmentNum = Util.constrainValue(representationHolder.getSegmentNum(playbackPositionUs),
          firstAvailableSegmentNum, lastAvailableSegmentNum);
    } else {
      segmentNum = previous.getNextChunkIndex();
      if (segmentNum < firstAvailableSegmentNum) {
        // This is before the first chunk in the current manifest.
        fatalError = new BehindLiveWindowException();
        return;
      }
    }

    if (segmentNum > lastAvailableSegmentNum
        || (missingLastSegment && segmentNum >= lastAvailableSegmentNum)) {
      // This is beyond the last chunk in the current manifest.
      out.endOfStream = !manifest.dynamic || (periodIndex < manifest.getPeriodCount() - 1);
      return;
    }

    int maxSegmentCount = Math.min(maxSegmentsPerLoad, lastAvailableSegmentNum - segmentNum + 1);
    out.chunk = newMediaChunk(representationHolder, dataSource, trackSelection.getSelectedFormat(),
        trackSelection.getSelectionReason(), trackSelection.getSelectionData(), segmentNum,
        maxSegmentCount);
  }

  @Override
  public void onChunkLoadCompleted(Chunk chunk) {
    if (chunk instanceof InitializationChunk) {
      InitializationChunk initializationChunk = (InitializationChunk) chunk;
      RepresentationHolder representationHolder =
          representationHolders[trackSelection.indexOf(initializationChunk.trackFormat)];
      // The null check avoids overwriting an index obtained from the manifest with one obtained
      // from the stream. If the manifest defines an index then the stream shouldn't, but in cases
      // where it does we should ignore it.
      if (representationHolder.segmentIndex == null) {
        SeekMap seekMap = representationHolder.extractorWrapper.getSeekMap();
        if (seekMap != null) {
          representationHolder.segmentIndex = new DashWrappingSegmentIndex((ChunkIndex) seekMap);
        }
      }
    }
  }

  @Override
  public boolean onChunkLoadError(Chunk chunk, boolean cancelable, Exception e) {
    if (!cancelable) {
      return false;
    }
    // Workaround for missing segment at the end of the period
    if (!manifest.dynamic && chunk instanceof MediaChunk
        && e instanceof InvalidResponseCodeException
        && ((InvalidResponseCodeException) e).responseCode == 404) {
      RepresentationHolder representationHolder =
          representationHolders[trackSelection.indexOf(chunk.trackFormat)];
      int segmentCount = representationHolder.getSegmentCount();
      if (segmentCount != DashSegmentIndex.INDEX_UNBOUNDED && segmentCount != 0) {
        int lastAvailableSegmentNum = representationHolder.getFirstSegmentNum() + segmentCount - 1;
        if (((MediaChunk) chunk).getNextChunkIndex() > lastAvailableSegmentNum) {
          missingLastSegment = true;
          return true;
        }
      }
    }
    // Blacklist if appropriate.
    return ChunkedTrackBlacklistUtil.maybeBlacklistTrack(trackSelection,
        trackSelection.indexOf(chunk.trackFormat), e);
  }

  // Private methods.

  private AdaptationSet getAdaptationSet() {
    return manifest.getPeriod(periodIndex).adaptationSets.get(adaptationSetIndex);
  }

  private long getNowUnixTimeUs() {
    if (elapsedRealtimeOffsetMs != 0) {
      return (SystemClock.elapsedRealtime() + elapsedRealtimeOffsetMs) * 1000;
    } else {
      return System.currentTimeMillis() * 1000;
    }
  }

  private static Chunk newInitializationChunk(RepresentationHolder representationHolder,
      DataSource dataSource, Format trackFormat, int trackSelectionReason,
      Object trackSelectionData, RangedUri initializationUri, RangedUri indexUri) {
    RangedUri requestUri;
    String baseUrl = representationHolder.representation.baseUrl;
    if (initializationUri != null) {
      // It's common for initialization and index data to be stored adjacently. Attempt to merge
      // the two requests together to request both at once.
      requestUri = initializationUri.attemptMerge(indexUri, baseUrl);
      if (requestUri == null) {
        requestUri = initializationUri;
      }
    } else {
      requestUri = indexUri;
    }
    DataSpec dataSpec = new DataSpec(requestUri.resolveUri(baseUrl), requestUri.start,
        requestUri.length, representationHolder.representation.getCacheKey());
    return new InitializationChunk(dataSource, dataSpec, trackFormat,
        trackSelectionReason, trackSelectionData, representationHolder.extractorWrapper);
  }

  private static Chunk newMediaChunk(RepresentationHolder representationHolder,
      DataSource dataSource, Format trackFormat, int trackSelectionReason,
      Object trackSelectionData, int firstSegmentNum, int maxSegmentCount) {
    Representation representation = representationHolder.representation;
    long startTimeUs = representationHolder.getSegmentStartTimeUs(firstSegmentNum);
    RangedUri segmentUri = representationHolder.getSegmentUrl(firstSegmentNum);
    String baseUrl = representation.baseUrl;
    if (representationHolder.extractorWrapper == null) {
      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum);
      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
          segmentUri.start, segmentUri.length, representation.getCacheKey());
      return new SingleSampleMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum,
          representationHolder.trackType, trackFormat);
    } else {
      int segmentCount = 1;
      for (int i = 1; i < maxSegmentCount; i++) {
        RangedUri nextSegmentUri = representationHolder.getSegmentUrl(firstSegmentNum + i);
        RangedUri mergedSegmentUri = segmentUri.attemptMerge(nextSegmentUri, baseUrl);
        if (mergedSegmentUri == null) {
          // Unable to merge segment fetches because the URIs do not merge.
          break;
        }
        segmentUri = mergedSegmentUri;
        segmentCount++;
      }
      long endTimeUs = representationHolder.getSegmentEndTimeUs(firstSegmentNum + segmentCount - 1);
      DataSpec dataSpec = new DataSpec(segmentUri.resolveUri(baseUrl),
          segmentUri.start, segmentUri.length, representation.getCacheKey());
      long sampleOffsetUs = -representation.presentationTimeOffsetUs;
      return new ContainerMediaChunk(dataSource, dataSpec, trackFormat, trackSelectionReason,
          trackSelectionData, startTimeUs, endTimeUs, firstSegmentNum, segmentCount,
          sampleOffsetUs, representationHolder.extractorWrapper);
    }
  }

  // Protected classes.

  protected static final class RepresentationHolder {

    public final int trackType;
    public final ChunkExtractorWrapper extractorWrapper;

    public Representation representation;
    public DashSegmentIndex segmentIndex;

    private long periodDurationUs;
    private int segmentNumShift;

    public RepresentationHolder(long periodDurationUs, Representation representation,
        boolean enableEventMessageTrack, boolean enableCea608Track, int trackType) {
      this.periodDurationUs = periodDurationUs;
      this.representation = representation;
      this.trackType = trackType;
      String containerMimeType = representation.format.containerMimeType;
      if (mimeTypeIsRawText(containerMimeType)) {
        extractorWrapper = null;
      } else {
        Extractor extractor;
        if (MimeTypes.APPLICATION_RAWCC.equals(containerMimeType)) {
          extractor = new RawCcExtractor(representation.format);
        } else if (mimeTypeIsWebm(containerMimeType)) {
          extractor = new MatroskaExtractor();
        } else {
          int flags = 0;
          if (enableEventMessageTrack) {
            flags |= FragmentedMp4Extractor.FLAG_ENABLE_EMSG_TRACK;
          }
          if (enableCea608Track) {
            flags |= FragmentedMp4Extractor.FLAG_ENABLE_CEA608_TRACK;
          }
          extractor = new FragmentedMp4Extractor(flags);
        }
        // Prefer drmInitData obtained from the manifest over drmInitData obtained from the stream,
        // as per DASH IF Interoperability Recommendations V3.0, 7.5.3.
        extractorWrapper = new ChunkExtractorWrapper(extractor, representation.format);
      }
      segmentIndex = representation.getIndex();
    }

    public void updateRepresentation(long newPeriodDurationUs, Representation newRepresentation)
        throws BehindLiveWindowException{
      DashSegmentIndex oldIndex = representation.getIndex();
      DashSegmentIndex newIndex = newRepresentation.getIndex();

      periodDurationUs = newPeriodDurationUs;
      representation = newRepresentation;
      if (oldIndex == null) {
        // Segment numbers cannot shift if the index isn't defined by the manifest.
        return;
      }

      segmentIndex = newIndex;
      if (!oldIndex.isExplicit()) {
        // Segment numbers cannot shift if the index isn't explicit.
        return;
      }

      int oldIndexSegmentCount = oldIndex.getSegmentCount(periodDurationUs);
      if (oldIndexSegmentCount == 0) {
        // Segment numbers cannot shift if the old index was empty.
        return;
      }

      int oldIndexLastSegmentNum = oldIndex.getFirstSegmentNum() + oldIndexSegmentCount - 1;
      long oldIndexEndTimeUs = oldIndex.getTimeUs(oldIndexLastSegmentNum)
          + oldIndex.getDurationUs(oldIndexLastSegmentNum, periodDurationUs);
      int newIndexFirstSegmentNum = newIndex.getFirstSegmentNum();
      long newIndexStartTimeUs = newIndex.getTimeUs(newIndexFirstSegmentNum);
      if (oldIndexEndTimeUs == newIndexStartTimeUs) {
        // The new index continues where the old one ended, with no overlap.
        segmentNumShift += oldIndexLastSegmentNum + 1 - newIndexFirstSegmentNum;
      } else if (oldIndexEndTimeUs < newIndexStartTimeUs) {
        // There's a gap between the old index and the new one which means we've slipped behind the
        // live window and can't proceed.
        throw new BehindLiveWindowException();
      } else {
        // The new index overlaps with the old one.
        segmentNumShift += oldIndex.getSegmentNum(newIndexStartTimeUs, periodDurationUs)
            - newIndexFirstSegmentNum;
      }
    }

    public int getFirstSegmentNum() {
      return segmentIndex.getFirstSegmentNum() + segmentNumShift;
    }

    public int getSegmentCount() {
      return segmentIndex.getSegmentCount(periodDurationUs);
    }

    public long getSegmentStartTimeUs(int segmentNum) {
      return segmentIndex.getTimeUs(segmentNum - segmentNumShift);
    }

    public long getSegmentEndTimeUs(int segmentNum) {
      return getSegmentStartTimeUs(segmentNum)
          + segmentIndex.getDurationUs(segmentNum - segmentNumShift, periodDurationUs);
    }

    public int getSegmentNum(long positionUs) {
      return segmentIndex.getSegmentNum(positionUs, periodDurationUs) + segmentNumShift;
    }

    public RangedUri getSegmentUrl(int segmentNum) {
      return segmentIndex.getSegmentUrl(segmentNum - segmentNumShift);
    }

    private static boolean mimeTypeIsWebm(String mimeType) {
      return mimeType.startsWith(MimeTypes.VIDEO_WEBM) || mimeType.startsWith(MimeTypes.AUDIO_WEBM)
          || mimeType.startsWith(MimeTypes.APPLICATION_WEBM);
    }

    private static boolean mimeTypeIsRawText(String mimeType) {
      return MimeTypes.isText(mimeType) || MimeTypes.APPLICATION_TTML.equals(mimeType);
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/ExoPlayerLibraryInfo.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2;

/**
 * Information about the ExoPlayer library.
 */
public interface ExoPlayerLibraryInfo {

  /**
   * The version of the library, expressed as a string.
   */
  String VERSION = "2.3.1";

  /**
   * The version of the library, expressed as an integer.
   * <p>
   * Three digits are used for each component of {@link #VERSION}. For example "1.2.3" has the
   * corresponding integer version 1002003 (001-002-003), and "123.45.6" has the corresponding
   * integer version 123045006 (123-045-006).
   */
  int VERSION_INT = 2003001;

  /**
   * Whether the library was compiled with {@link com.google.android.exoplayer2.util.Assertions}
   * checks enabled.
   */
  boolean ASSERTIONS_ENABLED = true;

  /**
   * Whether the library was compiled with {@link com.google.android.exoplayer2.util.TraceUtil}
   * trace enabled.
   */
  boolean TRACE_ENABLED = true;

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_7761cdc_6577013/rev_7761cdc-6577013/library/src/main/java/com/google/android/exoplayer2/BaseRenderer.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2;

import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
import com.google.android.exoplayer2.source.SampleStream;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.MediaClock;
import java.io.IOException;

/**
 * An abstract base class suitable for most {@link Renderer} implementations.
 */
public abstract class BaseRenderer implements Renderer, RendererCapabilities {

  private final int trackType;

  private RendererConfiguration configuration;
  private int index;
  private int state;
  private SampleStream stream;
  private long streamOffsetUs;
  private boolean readEndOfStream;
  private boolean streamIsFinal;

  /**
   * @param trackType The track type that the renderer handles. One of the {@link C}
   * {@code TRACK_TYPE_*} constants.
   */
  public BaseRenderer(int trackType) {
    this.trackType = trackType;
    readEndOfStream = true;
  }

  @Override
  public final int getTrackType() {
    return trackType;
  }

  @Override
  public final RendererCapabilities getCapabilities() {
    return this;
  }

  @Override
  public final void setIndex(int index) {
    this.index = index;
  }

  @Override
  public MediaClock getMediaClock() {
    return null;
  }

  @Override
  public final int getState() {
    return state;
  }

  @Override
  public final void enable(RendererConfiguration configuration, Format[] formats,
      SampleStream stream, long positionUs, boolean joining, long offsetUs)
      throws ExoPlaybackException {
    Assertions.checkState(state == STATE_DISABLED);
    this.configuration = configuration;
    state = STATE_ENABLED;
    onEnabled(joining);
    replaceStream(formats, stream, offsetUs);
    onPositionReset(positionUs, joining);
  }

  @Override
  public final void start() throws ExoPlaybackException {
    Assertions.checkState(state == STATE_ENABLED);
    state = STATE_STARTED;
    onStarted();
  }

  @Override
  public final void replaceStream(Format[] formats, SampleStream stream, long offsetUs)
      throws ExoPlaybackException {
    Assertions.checkState(!streamIsFinal);
    this.stream = stream;
    readEndOfStream = false;
    streamOffsetUs = offsetUs;
    onStreamChanged(formats);
  }

  @Override
  public final SampleStream getStream() {
    return stream;
  }

  @Override
  public final boolean hasReadStreamToEnd() {
    return readEndOfStream;
  }

  @Override
  public final void setCurrentStreamFinal() {
    streamIsFinal = true;
  }

  @Override
  public final boolean isCurrentStreamFinal() {
    return streamIsFinal;
  }

  @Override
  public final void maybeThrowStreamError() throws IOException {
    stream.maybeThrowError();
  }

  @Override
  public final void resetPosition(long positionUs) throws ExoPlaybackException {
    streamIsFinal = false;
    readEndOfStream = false;
    onPositionReset(positionUs, false);
  }

  @Override
  public final void stop() throws ExoPlaybackException {
    Assertions.checkState(state == STATE_STARTED);
    state = STATE_ENABLED;
    onStopped();
  }

  @Override
  public final void disable() {
    Assertions.checkState(state == STATE_ENABLED);
    state = STATE_DISABLED;
    onDisabled();
    stream = null;
    streamIsFinal = false;
  }

  // RendererCapabilities implementation.

  @Override
  public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
    return ADAPTIVE_NOT_SUPPORTED;
  }

  // ExoPlayerComponent implementation.

  @Override
  public void handleMessage(int what, Object object) throws ExoPlaybackException {
    // Do nothing.
  }

  // Methods to be overridden by subclasses.

  /**
   * Called when the renderer is enabled.
   * <p>
   * The default implementation is a no-op.
   *
   * @param joining Whether this renderer is being enabled to join an ongoing playback.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onEnabled(boolean joining) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer's stream has changed. This occurs when the renderer is enabled after
   * {@link #onEnabled(boolean)} has been called, and also when the stream has been replaced whilst
   * the renderer is enabled or started.
   * <p>
   * The default implementation is a no-op.
   *
   * @param formats The enabled formats.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStreamChanged(Format[] formats) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the position is reset. This occurs when the renderer is enabled after
   * {@link #onStreamChanged(Format[])} has been called, and also when a position discontinuity
   * is encountered.
   * <p>
   * After a position reset, the renderer's {@link SampleStream} is guaranteed to provide samples
   * starting from a key frame.
   * <p>
   * The default implementation is a no-op.
   *
   * @param positionUs The new playback position in microseconds.
   * @param joining Whether this renderer is being enabled to join an ongoing playback.
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is started.
   * <p>
   * The default implementation is a no-op.
   *
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStarted() throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is stopped.
   * <p>
   * The default implementation is a no-op.
   *
   * @throws ExoPlaybackException If an error occurs.
   */
  protected void onStopped() throws ExoPlaybackException {
    // Do nothing.
  }

  /**
   * Called when the renderer is disabled.
   * <p>
   * The default implementation is a no-op.
   */
  protected void onDisabled() {
    // Do nothing.
  }

  // Methods to be called by subclasses.

  /**
   * Returns the configuration set when the renderer was most recently enabled.
   */
  protected final RendererConfiguration getConfiguration() {
    return configuration;
  }

  /**
   * Returns the index of the renderer within the player.
   */
  protected final int getIndex() {
    return index;
  }

  /**
   * Use {@link #readSource(FormatHolder, DecoderInputBuffer, boolean)} instead.
   */
  @Deprecated
  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer) {
    return readSource(formatHolder, buffer, false);
  }

  /**
   * Reads from the enabled upstream source. If the upstream source has been read to the end then
   * {@link C#RESULT_BUFFER_READ} is only returned if {@link #setCurrentStreamFinal()} has been
   * called. {@link C#RESULT_NOTHING_READ} is returned otherwise.
   *
   * @param formatHolder A {@link FormatHolder} to populate in the case of reading a format.
   * @param buffer A {@link DecoderInputBuffer} to populate in the case of reading a sample or the
   *     end of the stream. If the end of the stream has been reached, the
   *     {@link C#BUFFER_FLAG_END_OF_STREAM} flag will be set on the buffer.
   * @param formatRequired Whether the caller requires that the format of the stream be read even if
   *     it's not changing. A sample will never be read if set to true, however it is still possible
   *     for the end of stream or nothing to be read.
   * @return The result, which can be {@link C#RESULT_NOTHING_READ}, {@link C#RESULT_FORMAT_READ} or
   *     {@link C#RESULT_BUFFER_READ}.
   */
  protected final int readSource(FormatHolder formatHolder, DecoderInputBuffer buffer,
      boolean formatRequired) {
    int result = stream.readData(formatHolder, buffer, formatRequired);
    if (result == C.RESULT_BUFFER_READ) {
      if (buffer.isEndOfStream()) {
        readEndOfStream = true;
        return streamIsFinal ? C.RESULT_BUFFER_READ : C.RESULT_NOTHING_READ;
      }
      buffer.timeUs += streamOffsetUs;
    } else if (result == C.RESULT_FORMAT_READ) {
      Format format = formatHolder.format;
      if (format.subsampleOffsetUs != Format.OFFSET_SAMPLE_RELATIVE) {
        format = format.copyWithSubsampleOffsetUs(format.subsampleOffsetUs + streamOffsetUs);
        formatHolder.format = format;
      }
    }
    return result;
  }

  /**
   * Returns whether the upstream source is ready.
   *
   * @return Whether the source is ready.
   */
  protected final boolean isSourceReady() {
    return readEndOfStream ? streamIsFinal : stream.isReady();
  }

  /**
   * Attempts to skip to the keyframe before the specified time.
   *
   * @param timeUs The specified time.
   */
  protected void skipToKeyframeBefore(long timeUs) {
    stream.skipToKeyframeBefore(timeUs - streamOffsetUs);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/androidTest/java/com/google/android/exoplayer2/extractor/mkv/MatroskaExtractorTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.extractor.mkv;

import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.extractor.Extractor;
import com.google.android.exoplayer2.testutil.TestUtil;

/**
 * Tests for {@link MatroskaExtractor}.
 */
public final class MatroskaExtractorTest extends InstrumentationTestCase {

  public void testMkvSample() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/sample.mkv", getInstrumentation());
  }
/*
  public void testMkvSSASample() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/ssasample.mkv", getInstrumentation());
  }
*/
  public void testWebmSubsampleEncryption() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/subsample_encrypted_noaltref.webm", getInstrumentation());
  }

  public void testWebmSubsampleEncryptionWithAltrefFrames() throws Exception {
    TestUtil.assertOutput(new TestUtil.ExtractorFactory() {
      @Override
      public Extractor create() {
        return new MatroskaExtractor();
      }
    }, "mkv/subsample_encrypted_altref.webm", getInstrumentation());
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/main/java/com/google/android/exoplayer2/text/SubtitleDecoderFactory.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.text;

import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.text.cea.Cea608Decoder;
import com.google.android.exoplayer2.text.cea.Cea708Decoder;
import com.google.android.exoplayer2.text.ssa.SSADecoder;
import com.google.android.exoplayer2.text.subrip.SubripDecoder;
import com.google.android.exoplayer2.text.ttml.TtmlDecoder;
import com.google.android.exoplayer2.text.tx3g.Tx3gDecoder;
import com.google.android.exoplayer2.text.webvtt.Mp4WebvttDecoder;
import com.google.android.exoplayer2.text.webvtt.WebvttDecoder;
import com.google.android.exoplayer2.util.MimeTypes;

/**
 * A factory for {@link SubtitleDecoder} instances.
 */
public interface SubtitleDecoderFactory {

  /**
   * Returns whether the factory is able to instantiate a {@link SubtitleDecoder} for the given
   * {@link Format}.
   *
   * @param format The {@link Format}.
   * @return Whether the factory can instantiate a suitable {@link SubtitleDecoder}.
   */
  boolean supportsFormat(Format format);

  /**
   * Creates a {@link SubtitleDecoder} for the given {@link Format}.
   *
   * @param format The {@link Format}.
   * @return A new {@link SubtitleDecoder}.
   * @throws IllegalArgumentException If the {@link Format} is not supported.
   */
  SubtitleDecoder createDecoder(Format format);

  /**
   * Default {@link SubtitleDecoderFactory} implementation.
   * <p>
   * The formats supported by this factory are:
   * <ul>
   * <li>WebVTT ({@link WebvttDecoder})</li>
   * <li>WebVTT (MP4) ({@link Mp4WebvttDecoder})</li>
   * <li>TTML ({@link TtmlDecoder})</li>
   * <li>SubRip ({@link SubripDecoder})</li>
   * <li>AAS/SSA ({@link SSADecoder})</li>
   * <li>TX3G ({@link Tx3gDecoder})</li>
   * <li>Cea608 ({@link Cea608Decoder})</li>
   * <li>Cea708 ({@link Cea708Decoder})</li>
   * </ul>
   */
  SubtitleDecoderFactory DEFAULT = new SubtitleDecoderFactory() {

    @Override
    public boolean supportsFormat(Format format) {
      return getDecoderClass(format.sampleMimeType) != null;
    }

    @Override
    public SubtitleDecoder createDecoder(Format format) {
      try {
        Class<?> clazz = getDecoderClass(format.sampleMimeType);
        if (clazz == null) {
          throw new IllegalArgumentException("Attempted to create decoder for unsupported format");
        }
        if (format.sampleMimeType.equals(MimeTypes.TEXT_SSA)) {
          byte[] header = format.initializationData.get(1);
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(byte[].class, String.class)
                  .newInstance(header, new String(format.initializationData.get(0), "UTF-8"));
        }
        else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA608)
            || format.sampleMimeType.equals(MimeTypes.APPLICATION_MP4CEA608)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(String.class, Integer.TYPE)
              .newInstance(format.sampleMimeType, format.accessibilityChannel);
        } else if (format.sampleMimeType.equals(MimeTypes.APPLICATION_CEA708)) {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor(Integer.TYPE)
              .newInstance(format.accessibilityChannel);
        } else {
          return clazz.asSubclass(SubtitleDecoder.class).getConstructor().newInstance();
        }
      } catch (Exception e) {
        throw new IllegalStateException("Unexpected error instantiating decoder", e);
      }
    }

    private Class<?> getDecoderClass(String mimeType) {
      if (mimeType == null) {
        return null;
      }
      try {
        switch (mimeType) {
          case MimeTypes.TEXT_VTT:
            return Class.forName("com.google.android.exoplayer2.text.webvtt.WebvttDecoder");
          case MimeTypes.APPLICATION_TTML:
            return Class.forName("com.google.android.exoplayer2.text.ttml.TtmlDecoder");
          case MimeTypes.APPLICATION_MP4VTT:
            return Class.forName("com.google.android.exoplayer2.text.webvtt.Mp4WebvttDecoder");
          case MimeTypes.APPLICATION_SUBRIP:
            return Class.forName("com.google.android.exoplayer2.text.subrip.SubripDecoder");
          case MimeTypes.TEXT_SSA:
            return Class.forName("com.google.android.exoplayer2.text.ssa.SSADecoder");
          case MimeTypes.APPLICATION_TX3G:
            return Class.forName("com.google.android.exoplayer2.text.tx3g.Tx3gDecoder");
          case MimeTypes.APPLICATION_CEA608:
          case MimeTypes.APPLICATION_MP4CEA608:
            return Class.forName("com.google.android.exoplayer2.text.cea.Cea608Decoder");
          case MimeTypes.APPLICATION_CEA708:
            return Class.forName("com.google.android.exoplayer2.text.cea.Cea708Decoder");
          default:
            return null;
        }
      } catch (ClassNotFoundException e) {
        return null;
      }
    }

  };

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_78e0545_402c985/rev_78e0545-402c985/library/src/main/java/com/google/android/exoplayer2/util/MimeTypes.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.util;

import android.text.TextUtils;
import com.google.android.exoplayer2.C;

/**
 * Defines common MIME types and helper methods.
 */
public final class MimeTypes {

  public static final String BASE_TYPE_VIDEO = "video";
  public static final String BASE_TYPE_AUDIO = "audio";
  public static final String BASE_TYPE_TEXT = "text";
  public static final String BASE_TYPE_APPLICATION = "application";

  public static final String VIDEO_MP4 = BASE_TYPE_VIDEO + "/mp4";
  public static final String VIDEO_WEBM = BASE_TYPE_VIDEO + "/webm";
  public static final String VIDEO_H263 = BASE_TYPE_VIDEO + "/3gpp";
  public static final String VIDEO_H264 = BASE_TYPE_VIDEO + "/avc";
  public static final String VIDEO_H265 = BASE_TYPE_VIDEO + "/hevc";
  public static final String VIDEO_VP8 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp8";
  public static final String VIDEO_VP9 = BASE_TYPE_VIDEO + "/x-vnd.on2.vp9";
  public static final String VIDEO_MP4V = BASE_TYPE_VIDEO + "/mp4v-es";
  public static final String VIDEO_MPEG2 = BASE_TYPE_VIDEO + "/mpeg2";
  public static final String VIDEO_VC1 = BASE_TYPE_VIDEO + "/wvc1";
  public static final String VIDEO_UNKNOWN = BASE_TYPE_VIDEO + "/x-unknown";

  public static final String AUDIO_MP4 = BASE_TYPE_AUDIO + "/mp4";
  public static final String AUDIO_AAC = BASE_TYPE_AUDIO + "/mp4a-latm";
  public static final String AUDIO_WEBM = BASE_TYPE_AUDIO + "/webm";
  public static final String AUDIO_MPEG = BASE_TYPE_AUDIO + "/mpeg";
  public static final String AUDIO_MPEG_L1 = BASE_TYPE_AUDIO + "/mpeg-L1";
  public static final String AUDIO_MPEG_L2 = BASE_TYPE_AUDIO + "/mpeg-L2";
  public static final String AUDIO_RAW = BASE_TYPE_AUDIO + "/raw";
  public static final String AUDIO_ALAW = BASE_TYPE_AUDIO + "/g711-alaw";
  public static final String AUDIO_ULAW = BASE_TYPE_AUDIO + "/g711-mlaw";
  public static final String AUDIO_AC3 = BASE_TYPE_AUDIO + "/ac3";
  public static final String AUDIO_E_AC3 = BASE_TYPE_AUDIO + "/eac3";
  public static final String AUDIO_TRUEHD = BASE_TYPE_AUDIO + "/true-hd";
  public static final String AUDIO_DTS = BASE_TYPE_AUDIO + "/vnd.dts";
  public static final String AUDIO_DTS_HD = BASE_TYPE_AUDIO + "/vnd.dts.hd";
  public static final String AUDIO_DTS_EXPRESS = BASE_TYPE_AUDIO + "/vnd.dts.hd;profile=lbr";
  public static final String AUDIO_VORBIS = BASE_TYPE_AUDIO + "/vorbis";
  public static final String AUDIO_OPUS = BASE_TYPE_AUDIO + "/opus";
  public static final String AUDIO_AMR_NB = BASE_TYPE_AUDIO + "/3gpp";
  public static final String AUDIO_AMR_WB = BASE_TYPE_AUDIO + "/amr-wb";
  public static final String AUDIO_FLAC = BASE_TYPE_AUDIO + "/x-flac";
  public static final String AUDIO_ALAC = BASE_TYPE_AUDIO + "/alac";

  public static final String TEXT_VTT = BASE_TYPE_TEXT + "/vtt";
  public static final String TEXT_SSA = BASE_TYPE_TEXT + "/x-ssa";

  public static final String APPLICATION_MP4 = BASE_TYPE_APPLICATION + "/mp4";
  public static final String APPLICATION_WEBM = BASE_TYPE_APPLICATION + "/webm";
  public static final String APPLICATION_M3U8 = BASE_TYPE_APPLICATION + "/x-mpegURL";
  public static final String APPLICATION_ID3 = BASE_TYPE_APPLICATION + "/id3";
  public static final String APPLICATION_CEA608 = BASE_TYPE_APPLICATION + "/cea-608";
  public static final String APPLICATION_CEA708 = BASE_TYPE_APPLICATION + "/cea-708";
  public static final String APPLICATION_SUBRIP = BASE_TYPE_APPLICATION + "/x-subrip";
  public static final String APPLICATION_TTML = BASE_TYPE_APPLICATION + "/ttml+xml";
  public static final String APPLICATION_TX3G = BASE_TYPE_APPLICATION + "/x-quicktime-tx3g";
  public static final String APPLICATION_MP4VTT = BASE_TYPE_APPLICATION + "/x-mp4-vtt";
  public static final String APPLICATION_MP4CEA608 = BASE_TYPE_APPLICATION + "/x-mp4-cea-608";
  public static final String APPLICATION_RAWCC = BASE_TYPE_APPLICATION + "/x-rawcc";
  public static final String APPLICATION_VOBSUB = BASE_TYPE_APPLICATION + "/vobsub";
  public static final String APPLICATION_PGS = BASE_TYPE_APPLICATION + "/pgs";
  public static final String APPLICATION_SCTE35 = BASE_TYPE_APPLICATION + "/x-scte35";
  public static final String APPLICATION_CAMERA_MOTION = BASE_TYPE_APPLICATION + "/x-camera-motion";
  public static final String APPLICATION_EMSG = BASE_TYPE_APPLICATION + "/x-emsg";

  private MimeTypes() {}

  /**
   * Whether the top-level type of {@code mimeType} is audio.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is audio.
   */
  public static boolean isAudio(String mimeType) {
    return BASE_TYPE_AUDIO.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is video.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is video.
   */
  public static boolean isVideo(String mimeType) {
    return BASE_TYPE_VIDEO.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is text.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is text.
   */
  public static boolean isText(String mimeType) {
    return BASE_TYPE_TEXT.equals(getTopLevelType(mimeType));
  }

  /**
   * Whether the top-level type of {@code mimeType} is application.
   *
   * @param mimeType The mimeType to test.
   * @return Whether the top level type is application.
   */
  public static boolean isApplication(String mimeType) {
    return BASE_TYPE_APPLICATION.equals(getTopLevelType(mimeType));
  }


  /**
   * Derives a video sample mimeType from a codecs attribute.
   *
   * @param codecs The codecs attribute.
   * @return The derived video mimeType, or null if it could not be derived.
   */
  public static String getVideoMediaMimeType(String codecs) {
    if (codecs == null) {
      return null;
    }
    String[] codecList = codecs.split(",");
    for (String codec : codecList) {
      String mimeType = getMediaMimeType(codec);
      if (mimeType != null && isVideo(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }

  /**
   * Derives a audio sample mimeType from a codecs attribute.
   *
   * @param codecs The codecs attribute.
   * @return The derived audio mimeType, or null if it could not be derived.
   */
  public static String getAudioMediaMimeType(String codecs) {
    if (codecs == null) {
      return null;
    }
    String[] codecList = codecs.split(",");
    for (String codec : codecList) {
      String mimeType = getMediaMimeType(codec);
      if (mimeType != null && isAudio(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }

  /**
   * Derives a mimeType from a codec identifier, as defined in RFC 6381.
   *
   * @param codec The codec identifier to derive.
   * @return The mimeType, or null if it could not be derived.
   */
  public static String getMediaMimeType(String codec) {
    if (codec == null) {
      return null;
    }
    codec = codec.trim();
    if (codec.startsWith("avc1") || codec.startsWith("avc3")) {
      return MimeTypes.VIDEO_H264;
    } else if (codec.startsWith("hev1") || codec.startsWith("hvc1")) {
      return MimeTypes.VIDEO_H265;
    } else if (codec.startsWith("vp9")) {
      return MimeTypes.VIDEO_VP9;
    } else if (codec.startsWith("vp8")) {
      return MimeTypes.VIDEO_VP8;
    } else if (codec.startsWith("mp4a")) {
      return MimeTypes.AUDIO_AAC;
    } else if (codec.startsWith("ac-3") || codec.startsWith("dac3")) {
      return MimeTypes.AUDIO_AC3;
    } else if (codec.startsWith("ec-3") || codec.startsWith("dec3")) {
      return MimeTypes.AUDIO_E_AC3;
    } else if (codec.startsWith("dtsc") || codec.startsWith("dtse")) {
      return MimeTypes.AUDIO_DTS;
    } else if (codec.startsWith("dtsh") || codec.startsWith("dtsl")) {
      return MimeTypes.AUDIO_DTS_HD;
    } else if (codec.startsWith("opus")) {
      return MimeTypes.AUDIO_OPUS;
    } else if (codec.startsWith("vorbis")) {
      return MimeTypes.AUDIO_VORBIS;
    }
    return null;
  }

  /**
   * Returns the {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
   * {@link C#TRACK_TYPE_UNKNOWN} if the mime type is not known or the mapping cannot be
   * established.
   *
   * @param mimeType The mimeType.
   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified mime type.
   */
  public static int getTrackType(String mimeType) {
    if (TextUtils.isEmpty(mimeType)) {
      return C.TRACK_TYPE_UNKNOWN;
    } else if (isAudio(mimeType)) {
      return C.TRACK_TYPE_AUDIO;
    } else if (isVideo(mimeType)) {
      return C.TRACK_TYPE_VIDEO;
    } else if (isText(mimeType) || APPLICATION_CEA608.equals(mimeType)
        || APPLICATION_CEA708.equals(mimeType) || APPLICATION_MP4CEA608.equals(mimeType)
        || APPLICATION_SUBRIP.equals(mimeType) || APPLICATION_TTML.equals(mimeType)
        || APPLICATION_TX3G.equals(mimeType) || APPLICATION_MP4VTT.equals(mimeType)
        || APPLICATION_RAWCC.equals(mimeType) || APPLICATION_VOBSUB.equals(mimeType)
        || APPLICATION_PGS.equals(mimeType)) {
      return C.TRACK_TYPE_TEXT;
    } else if (APPLICATION_ID3.equals(mimeType)
        || APPLICATION_EMSG.equals(mimeType)
        || APPLICATION_SCTE35.equals(mimeType)
        || APPLICATION_CAMERA_MOTION.equals(mimeType)) {
      return C.TRACK_TYPE_METADATA;
    } else {
      return C.TRACK_TYPE_UNKNOWN;
    }
  }

  /**
   * Equivalent to {@code getTrackType(getMediaMimeType(codec))}.
   *
   * @param codec The codec.
   * @return The {@link C}{@code .TRACK_TYPE_*} constant that corresponds to a specified codec.
   */
  public static int getTrackTypeOfCodec(String codec) {
    return getTrackType(getMediaMimeType(codec));
  }

  /**
   * Returns the top-level type of {@code mimeType}.
   *
   * @param mimeType The mimeType whose top-level type is required.
   * @return The top-level type, or null if the mimeType is null.
   */
  private static String getTopLevelType(String mimeType) {
    if (mimeType == null) {
      return null;
    }
    int indexOfSlash = mimeType.indexOf('/');
    if (indexOfSlash == -1) {
      throw new IllegalArgumentException("Invalid mime type: " + mimeType);
    }
    return mimeType.substring(0, indexOfSlash);
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/AssetDataSourceTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.upstream;

import android.net.Uri;
import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.testutil.TestUtil;

/**
 * Unit tests for {@link AssetDataSource}.
 */
public final class AssetDataSourceTest extends InstrumentationTestCase {

  private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";

  public void testReadFileUri() throws Exception {
    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
    DataSpec dataSpec = new DataSpec(Uri.parse("file:///android_asset/" + DATA_PATH));
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

  public void testReadAssetUri() throws Exception {
    AssetDataSource dataSource = new AssetDataSource(getInstrumentation().getContext());
    DataSpec dataSpec = new DataSpec(Uri.parse("asset:///" + DATA_PATH));
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/upstream/ContentDataSourceTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.upstream;

import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.net.Uri;
import android.support.annotation.NonNull;
import android.test.InstrumentationTestCase;
import com.google.android.exoplayer2.testutil.TestUtil;
import java.io.FileNotFoundException;
import java.io.IOException;

/**
 * Unit tests for {@link ContentDataSource}.
 */
public final class ContentDataSourceTest extends InstrumentationTestCase {

  private static final String AUTHORITY = "com.google.android.exoplayer2.core.test";
  private static final String DATA_PATH = "binary/1024_incrementing_bytes.mp3";

  public void testReadValidUri() throws Exception {
    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
    Uri contentUri = new Uri.Builder()
        .scheme(ContentResolver.SCHEME_CONTENT)
        .authority(AUTHORITY)
        .path(DATA_PATH).build();
    DataSpec dataSpec = new DataSpec(contentUri);
    TestUtil.assertDataSourceContent(dataSource, dataSpec,
        TestUtil.getByteArray(getInstrumentation(), DATA_PATH));
  }

  public void testReadInvalidUri() throws Exception {
    ContentDataSource dataSource = new ContentDataSource(getInstrumentation().getContext());
    Uri contentUri = new Uri.Builder()
        .scheme(ContentResolver.SCHEME_CONTENT)
        .authority(AUTHORITY)
        .build();
    DataSpec dataSpec = new DataSpec(contentUri);
    try {
      dataSource.open(dataSpec);
      fail();
    } catch (ContentDataSource.ContentDataSourceException e) {
      // Expected.
      assertTrue(e.getCause() instanceof FileNotFoundException);
    } finally {
      dataSource.close();
    }
  }

  /**
   * A {@link ContentProvider} for the test.
   */
  public static final class TestContentProvider extends ContentProvider {

    @Override
    public boolean onCreate() {
      return true;
    }

    @Override
    public Cursor query(@NonNull Uri uri, String[] projection, String selection,
        String[] selectionArgs, String sortOrder) {
      throw new UnsupportedOperationException();
    }

    @Override
    public AssetFileDescriptor openAssetFile(@NonNull Uri uri, @NonNull String mode)
        throws FileNotFoundException {
      if (uri.getPath() == null) {
        return null;
      }
      try {
        return getContext().getAssets().openFd(uri.getPath().replaceFirst("/", ""));
      } catch (IOException e) {
        FileNotFoundException exception = new FileNotFoundException(e.getMessage());
        exception.initCause(e);
        throw exception;
      }
    }

    @Override
    public String getType(@NonNull Uri uri) {
      throw new UnsupportedOperationException();
    }

    @Override
    public Uri insert(@NonNull Uri uri, ContentValues values) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int delete(@NonNull Uri uri, String selection,
        String[] selectionArgs) {
      throw new UnsupportedOperationException();
    }

    @Override
    public int update(@NonNull Uri uri, ContentValues values,
        String selection, String[] selectionArgs) {
      throw new UnsupportedOperationException();
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/util/ParsableBitArrayTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.util;

import android.test.MoreAsserts;

import junit.framework.TestCase;

/**
 * Tests for {@link ParsableBitArray}.
 */
public final class ParsableBitArrayTest extends TestCase {

  private static final byte[] TEST_DATA = new byte[] {0x3C, (byte) 0xD2, (byte) 0x5F, (byte) 0x01,
      (byte) 0xFF, (byte) 0x14, (byte) 0x60, (byte) 0x99};

  public void testReadAllBytes() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    byte[] bytesRead = new byte[TEST_DATA.length];
    testArray.readBytes(bytesRead, 0, TEST_DATA.length);
    MoreAsserts.assertEquals(TEST_DATA, bytesRead);
    assertEquals(TEST_DATA.length * 8, testArray.getPosition());
    assertEquals(TEST_DATA.length, testArray.getBytePosition());
  }

  public void testReadBit() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertReadBitsToEnd(0, testArray);
  }

  public void testReadBits() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(5, 3), testArray.readBits(3));
    assertEquals(getTestDataBits(8, 16), testArray.readBits(16));
    assertEquals(getTestDataBits(24, 3), testArray.readBits(3));
    assertEquals(getTestDataBits(27, 18), testArray.readBits(18));
    assertEquals(getTestDataBits(45, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(50, 14), testArray.readBits(14));
  }

  public void testRead32BitsByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 32), testArray.readBits(32));
    assertEquals(getTestDataBits(32, 32), testArray.readBits(32));
  }

  public void testRead32BitsNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    assertEquals(getTestDataBits(0, 5), testArray.readBits(5));
    assertEquals(getTestDataBits(5, 32), testArray.readBits(32));
  }

  public void testSkipBytes() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBytes(2);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSkipBitsByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBits(16);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSkipBitsNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.skipBits(5);
    assertReadBitsToEnd(5, testArray);
  }

  public void testSetPositionByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(16);
    assertReadBitsToEnd(16, testArray);
  }

  public void testSetPositionNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(5);
    assertReadBitsToEnd(5, testArray);
  }

  public void testByteAlignFromNonByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(11);
    testArray.byteAlign();
    assertEquals(2, testArray.getBytePosition());
    assertEquals(16, testArray.getPosition());
    assertReadBitsToEnd(16, testArray);
  }

  public void testByteAlignFromByteAligned() {
    ParsableBitArray testArray = new ParsableBitArray(TEST_DATA);
    testArray.setPosition(16);
    testArray.byteAlign(); // Should be a no-op.
    assertEquals(2, testArray.getBytePosition());
    assertEquals(16, testArray.getPosition());
    assertReadBitsToEnd(16, testArray);
  }

  private static void assertReadBitsToEnd(int expectedStartPosition, ParsableBitArray testArray) {
    int position = testArray.getPosition();
    assertEquals(expectedStartPosition, position);
    for (int i = position; i < TEST_DATA.length * 8; i++) {
      assertEquals(getTestDataBit(i), testArray.readBit());
      assertEquals(i + 1, testArray.getPosition());
    }
  }

  private static int getTestDataBits(int bitPosition, int length) {
    int result = 0;
    for (int i = 0; i < length; i++) {
      result = result << 1;
      if (getTestDataBit(bitPosition++)) {
        result |= 0x1;
      }
    }
    return result;
  }

  private static boolean getTestDataBit(int bitPosition) {
    return (TEST_DATA[bitPosition / 8] & (0x80 >>> (bitPosition % 8))) != 0;
  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/androidTest/java/com/google/android/exoplayer2/trackselection/MappingTrackSelectorTest.java;<<<<<<< MINE
=======
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.trackselection;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.ExoPlaybackException;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.RendererCapabilities;
import com.google.android.exoplayer2.source.TrackGroup;
import com.google.android.exoplayer2.source.TrackGroupArray;
import com.google.android.exoplayer2.util.MimeTypes;
import junit.framework.TestCase;

/**
 * Unit tests for {@link MappingTrackSelector}.
 */
public final class MappingTrackSelectorTest extends TestCase {

  private static final RendererCapabilities VIDEO_CAPABILITIES =
      new FakeRendererCapabilities(C.TRACK_TYPE_VIDEO);
  private static final RendererCapabilities AUDIO_CAPABILITIES =
      new FakeRendererCapabilities(C.TRACK_TYPE_AUDIO);
  private static final RendererCapabilities[] RENDERER_CAPABILITIES = new RendererCapabilities[] {
      VIDEO_CAPABILITIES, AUDIO_CAPABILITIES
  };

  private static final TrackGroup VIDEO_TRACK_GROUP = new TrackGroup(
      Format.createVideoSampleFormat("video", MimeTypes.VIDEO_H264, null, Format.NO_VALUE,
          Format.NO_VALUE, 1024, 768, Format.NO_VALUE, null, null));
  private static final TrackGroup AUDIO_TRACK_GROUP = new TrackGroup(
      Format.createAudioSampleFormat("audio", MimeTypes.AUDIO_AAC, null, Format.NO_VALUE,
          Format.NO_VALUE, 2, 44100, null, null, 0, null));
  private static final TrackGroupArray TRACK_GROUPS = new TrackGroupArray(
      VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP);

  private static final TrackSelection[] TRACK_SELECTIONS = new TrackSelection[] {
      new FixedTrackSelection(VIDEO_TRACK_GROUP, 0),
      new FixedTrackSelection(AUDIO_TRACK_GROUP, 0)
  };

  /**
   * Tests that the video and audio track groups are mapped onto the correct renderers.
   */
  public void testMapping() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
  }

  /**
   * Tests that the video and audio track groups are mapped onto the correct renderers when the
   * renderer ordering is reversed.
   */
  public void testMappingReverseOrder() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    RendererCapabilities[] reverseOrderRendererCapabilities = new RendererCapabilities[] {
        AUDIO_CAPABILITIES, VIDEO_CAPABILITIES};
    trackSelector.selectTracks(reverseOrderRendererCapabilities, TRACK_GROUPS);
    trackSelector.assertMappedTrackGroups(0, AUDIO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, VIDEO_TRACK_GROUP);
  }

  /**
   * Tests video and audio track groups are mapped onto the correct renderers when there are
   * multiple track groups of the same type.
   */
  public void testMappingMulti() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector();
    TrackGroupArray multiTrackGroups = new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP,
        VIDEO_TRACK_GROUP);
    trackSelector.selectTracks(RENDERER_CAPABILITIES, multiTrackGroups);
    trackSelector.assertMappedTrackGroups(0, VIDEO_TRACK_GROUP, VIDEO_TRACK_GROUP);
    trackSelector.assertMappedTrackGroups(1, AUDIO_TRACK_GROUP);
  }

  /**
   * Tests the result of {@link MappingTrackSelector#selectTracks(RendererCapabilities[],
   * TrackGroupArray[], int[][][])} is propagated correctly to the result of
   * {@link MappingTrackSelector#selectTracks(RendererCapabilities[], TrackGroupArray)}.
   */
  public void testSelectTracks() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that a null override clears a track selection.
   */
  public void testSelectTracksWithNullOverride() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertNull(result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that a null override can be cleared.
   */
  public void testSelectTracksWithClearedNullOverride() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    trackSelector.clearSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP));
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES, TRACK_GROUPS);
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * Tests that an override is not applied for a different set of available track groups.
   */
  public void testSelectTracksWithNullOverrideForDifferentTracks() throws ExoPlaybackException {
    FakeMappingTrackSelector trackSelector = new FakeMappingTrackSelector(TRACK_SELECTIONS);
    trackSelector.setSelectionOverride(0, new TrackGroupArray(VIDEO_TRACK_GROUP), null);
    TrackSelectorResult result = trackSelector.selectTracks(RENDERER_CAPABILITIES,
        new TrackGroupArray(VIDEO_TRACK_GROUP, AUDIO_TRACK_GROUP, VIDEO_TRACK_GROUP));
    assertEquals(TRACK_SELECTIONS[0], result.selections.get(0));
    assertEquals(TRACK_SELECTIONS[1], result.selections.get(1));
  }

  /**
   * A {@link MappingTrackSelector} that returns a fixed result from
   * {@link #selectTracks(RendererCapabilities[], TrackGroupArray[], int[][][])}.
   */
  private static final class FakeMappingTrackSelector extends MappingTrackSelector {

    private final TrackSelection[] result;
    private TrackGroupArray[] lastRendererTrackGroupArrays;

    public FakeMappingTrackSelector(TrackSelection... result) {
      this.result = result.length == 0 ? null : result;
    }

    @Override
    protected TrackSelection[] selectTracks(RendererCapabilities[] rendererCapabilities,
        TrackGroupArray[] rendererTrackGroupArrays, int[][][] rendererFormatSupports)
        throws ExoPlaybackException {
      lastRendererTrackGroupArrays = rendererTrackGroupArrays;
      return result == null ? new TrackSelection[rendererCapabilities.length] : result;
    }

    public void assertMappedTrackGroups(int rendererIndex, TrackGroup... expected) {
      assertEquals(expected.length, lastRendererTrackGroupArrays[rendererIndex].length);
      for (int i = 0; i < expected.length; i++) {
        assertEquals(expected[i], lastRendererTrackGroupArrays[rendererIndex].get(i));
      }
    }

  }

  /**
   * A {@link RendererCapabilities} that advertises adaptive support for all tracks of a given type.
   */
  private static final class FakeRendererCapabilities implements RendererCapabilities {

    private final int trackType;

    public FakeRendererCapabilities(int trackType) {
      this.trackType = trackType;
    }

    @Override
    public int getTrackType() {
      return trackType;
    }

    @Override
    public int supportsFormat(Format format) throws ExoPlaybackException {
      return MimeTypes.getTrackType(format.sampleMimeType) == trackType
          ? (FORMAT_HANDLED | ADAPTIVE_SEAMLESS) : FORMAT_UNSUPPORTED_TYPE;
    }

    @Override
    public int supportsMixedMimeTypeAdaptation() throws ExoPlaybackException {
      return ADAPTIVE_SEAMLESS;
    }

  }

}>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/ExoPlayer.java;<<<<<<< MINE
  @Deprecated
  interface EventListener extends Player.EventListener {}
=======
  interface EventListener {

    /**
     * Called when the timeline and/or manifest has been refreshed.
     * <p>
     * Note that if the timeline has changed then a position discontinuity may also have occurred.
     * For example, the current period index may have changed as a result of periods being added or
     * removed from the timeline. This will <em>not</em> be reported via a separate call to
     * {@link #onPositionDiscontinuity()}.
     *
     * @param timeline The latest timeline. Never null, but may be empty.
     * @param manifest The latest manifest. May be null.
     */
    void onTimelineChanged(Timeline timeline, Object manifest);

    /**
     * Called when the available or selected tracks change.
     *
     * @param trackGroups The available tracks. Never null, but may be of length zero.
     * @param trackSelections The track selections for each {@link Renderer}. Never null and always
     *     of length {@link #getRendererCount()}, but may contain null elements.
     */
    void onTracksChanged(TrackGroupArray trackGroups, TrackSelectionArray trackSelections);

    /**
     * Called when the player starts or stops loading the source.
     *
     * @param isLoading Whether the source is currently being loaded.
     */
    void onLoadingChanged(boolean isLoading);

    /**
     * Called when the value returned from either {@link #getPlayWhenReady()} or
     * {@link #getPlaybackState()} changes.
     *
     * @param playWhenReady Whether playback will proceed when ready.
     * @param playbackState One of the {@code STATE} constants defined in the {@link ExoPlayer}
     *     interface.
     */
    void onPlayerStateChanged(boolean playWhenReady, int playbackState);

    /**
     * Called when an error occurs. The playback state will transition to {@link #STATE_IDLE}
     * immediately after this method is called. The player instance can still be used, and
     * {@link #release()} must still be called on the player should it no longer be required.
     *
     * @param error The error.
     */
    void onPlayerError(ExoPlaybackException error);

    /**
     * Called when a position discontinuity occurs without a change to the timeline. A position
     * discontinuity occurs when the current window or period index changes (as a result of playback
     * transitioning from one period in the timeline to the next), or when the playback position
     * jumps within the period currently being played (as a result of a seek being performed, or
     * when the source introduces a discontinuity internally).
     * <p>
     * When a position discontinuity occurs as a result of a change to the timeline this method is
     * <em>not</em> called. {@link #onTimelineChanged(Timeline, Object)} is called in this case.
     */
    void onPositionDiscontinuity();

    /**
     * Called when the current playback parameters change. The playback parameters may change due to
     * a call to {@link ExoPlayer#setPlaybackParameters(PlaybackParameters)}, or the player itself
     * may change them (for example, if audio playback switches to passthrough mode, where speed
     * adjustment is no longer possible).
     *
     * @param playbackParameters The playback parameters.
     */
    void onPlaybackParametersChanged(PlaybackParameters playbackParameters);

  }
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/MediaCodecVideoRenderer.java;<<<<<<< MINE
  private static final class CodecMaxValues {
=======
  protected static final class CodecMaxValues {
>>>>>>> YOURS
/home/arthur/analysis/projects/ExoPlayer/revisions/rev_e713ddc_cbffc14/rev_e713ddc-cbffc14/library/core/src/main/java/com/google/android/exoplayer2/video/DummySurface.java;<<<<<<< MINE
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  private static boolean secureSupported;
  private static boolean secureSupportedInitialized;

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns whether the device supports secure dummy surfaces.
   *
   * @param context Any {@link Context}.
   * @return Whether the device supports secure dummy surfaces.
   */
  public static synchronized boolean isSecureSupported(Context context) {
    if (!secureSupportedInitialized) {
      if (Util.SDK_INT >= 17) {
        EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
        String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
        secureSupported = extensions != null && extensions.contains("EGL_EXT_protected_content")
            && !deviceNeedsSecureDummySurfaceWorkaround(context);
      }
      secureSupportedInitialized = true;
    }
    return secureSupported;
  }

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param context Any {@link Context}.
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #isSecureSupported(Context)} returns {@code true}.
   * @throws IllegalStateException If a secure surface is requested on a device for which
   *     {@link #isSecureSupported(Context)} returns {@code false}.
   */
  public static DummySurface newInstanceV17(Context context, boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || isSecureSupported(context));
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  /**
   * Returns whether the device is known to advertise secure surface textures but not implement them
   * correctly.
   *
   * @param context Any {@link Context}.
   */
  private static boolean deviceNeedsSecureDummySurfaceWorkaround(Context context) {
    return Util.SDK_INT == 24
        && (Util.MODEL.startsWith("SM-G950") || Util.MODEL.startsWith("SM-G955"))
        && !hasVrModeHighPerformanceSystemFeatureV24(context.getPackageManager());
  }

  @TargetApi(24)
  private static boolean hasVrModeHighPerformanceSystemFeatureV24(PackageManager packageManager) {
    return packageManager.hasSystemFeature(PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}=======
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.video;

import static android.opengl.EGL14.EGL_ALPHA_SIZE;
import static android.opengl.EGL14.EGL_BLUE_SIZE;
import static android.opengl.EGL14.EGL_CONFIG_CAVEAT;
import static android.opengl.EGL14.EGL_CONTEXT_CLIENT_VERSION;
import static android.opengl.EGL14.EGL_DEFAULT_DISPLAY;
import static android.opengl.EGL14.EGL_DEPTH_SIZE;
import static android.opengl.EGL14.EGL_GREEN_SIZE;
import static android.opengl.EGL14.EGL_HEIGHT;
import static android.opengl.EGL14.EGL_NONE;
import static android.opengl.EGL14.EGL_OPENGL_ES2_BIT;
import static android.opengl.EGL14.EGL_RED_SIZE;
import static android.opengl.EGL14.EGL_RENDERABLE_TYPE;
import static android.opengl.EGL14.EGL_SURFACE_TYPE;
import static android.opengl.EGL14.EGL_TRUE;
import static android.opengl.EGL14.EGL_WIDTH;
import static android.opengl.EGL14.EGL_WINDOW_BIT;
import static android.opengl.EGL14.eglChooseConfig;
import static android.opengl.EGL14.eglCreateContext;
import static android.opengl.EGL14.eglCreatePbufferSurface;
import static android.opengl.EGL14.eglGetDisplay;
import static android.opengl.EGL14.eglInitialize;
import static android.opengl.EGL14.eglMakeCurrent;
import static android.opengl.GLES20.glDeleteTextures;
import static android.opengl.GLES20.glGenTextures;

import android.annotation.TargetApi;
import android.graphics.SurfaceTexture;
import android.graphics.SurfaceTexture.OnFrameAvailableListener;
import android.opengl.EGL14;
import android.opengl.EGLConfig;
import android.opengl.EGLContext;
import android.opengl.EGLDisplay;
import android.opengl.EGLSurface;
import android.os.Handler;
import android.os.Handler.Callback;
import android.os.HandlerThread;
import android.os.Message;
import android.util.Log;
import android.view.Surface;
import com.google.android.exoplayer2.util.Assertions;
import com.google.android.exoplayer2.util.Util;
import javax.microedition.khronos.egl.EGL10;

/**
 * A dummy {@link Surface}.
 */
@TargetApi(17)
public final class DummySurface extends Surface {

  private static final String TAG = "DummySurface";

  private static final int EGL_PROTECTED_CONTENT_EXT = 0x32C0;

  /**
   * Whether the device supports secure dummy surfaces.
   */
  public static final boolean SECURE_SUPPORTED;
  static {
    if (Util.SDK_INT >= 17) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      String extensions = EGL14.eglQueryString(display, EGL10.EGL_EXTENSIONS);
      SECURE_SUPPORTED = extensions != null && extensions.contains("EGL_EXT_protected_content");
    } else {
      SECURE_SUPPORTED = false;
    }
  }

  /**
   * Whether the surface is secure.
   */
  public final boolean secure;

  private final DummySurfaceThread thread;
  private boolean threadReleased;

  /**
   * Returns a newly created dummy surface. The surface must be released by calling {@link #release}
   * when it's no longer required.
   * <p>
   * Must only be called if {@link Util#SDK_INT} is 17 or higher.
   *
   * @param secure Whether a secure surface is required. Must only be requested if
   *     {@link #SECURE_SUPPORTED} is {@code true}.
   */
  public static DummySurface newInstanceV17(boolean secure) {
    assertApiLevel17OrHigher();
    Assertions.checkState(!secure || SECURE_SUPPORTED);
    DummySurfaceThread thread = new DummySurfaceThread();
    return thread.init(secure);
  }

  private DummySurface(DummySurfaceThread thread, SurfaceTexture surfaceTexture, boolean secure) {
    super(surfaceTexture);
    this.thread = thread;
    this.secure = secure;
  }

  @Override
  public void release() {
    super.release();
    // The Surface may be released multiple times (explicitly and by Surface.finalize()). The
    // implementation of super.release() has its own deduplication logic. Below we need to
    // deduplicate ourselves. Synchronization is required as we don't control the thread on which
    // Surface.finalize() is called.
    synchronized (thread) {
      if (!threadReleased) {
        thread.release();
        threadReleased = true;
      }
    }
  }

  private static void assertApiLevel17OrHigher() {
    if (Util.SDK_INT < 17) {
      throw new UnsupportedOperationException("Unsupported prior to API level 17");
    }
  }

  private static class DummySurfaceThread extends HandlerThread implements OnFrameAvailableListener,
      Callback {

    private static final int MSG_INIT = 1;
    private static final int MSG_UPDATE_TEXTURE = 2;
    private static final int MSG_RELEASE = 3;

    private final int[] textureIdHolder;
    private Handler handler;
    private SurfaceTexture surfaceTexture;

    private Error initError;
    private RuntimeException initException;
    private DummySurface surface;

    public DummySurfaceThread() {
      super("dummySurface");
      textureIdHolder = new int[1];
    }

    public DummySurface init(boolean secure) {
      start();
      handler = new Handler(getLooper(), this);
      boolean wasInterrupted = false;
      synchronized (this) {
        handler.obtainMessage(MSG_INIT, secure ? 1 : 0, 0).sendToTarget();
        while (surface == null && initException == null && initError == null) {
          try {
            wait();
          } catch (InterruptedException e) {
            wasInterrupted = true;
          }
        }
      }
      if (wasInterrupted) {
        // Restore the interrupted status.
        Thread.currentThread().interrupt();
      }
      if (initException != null) {
        throw initException;
      } else if (initError != null) {
        throw initError;
      } else {
        return surface;
      }
    }

    public void release() {
      handler.sendEmptyMessage(MSG_RELEASE);
    }

    @Override
    public void onFrameAvailable(SurfaceTexture surfaceTexture) {
      handler.sendEmptyMessage(MSG_UPDATE_TEXTURE);
    }

    @Override
    public boolean handleMessage(Message msg) {
      switch (msg.what) {
        case MSG_INIT:
          try {
            initInternal(msg.arg1 != 0);
          } catch (RuntimeException e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initException = e;
          } catch (Error e) {
            Log.e(TAG, "Failed to initialize dummy surface", e);
            initError = e;
          } finally {
            synchronized (this) {
              notify();
            }
          }
          return true;
        case MSG_UPDATE_TEXTURE:
          surfaceTexture.updateTexImage();
          return true;
        case MSG_RELEASE:
          try {
            releaseInternal();
          } catch (Throwable e) {
            Log.e(TAG, "Failed to release dummy surface", e);
          } finally {
            quit();
          }
          return true;
        default:
          return true;
      }
    }

    private void initInternal(boolean secure) {
      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
      Assertions.checkState(display != null, "eglGetDisplay failed");

      int[] version = new int[2];
      boolean eglInitialized = eglInitialize(display, version, 0, version, 1);
      Assertions.checkState(eglInitialized, "eglInitialize failed");

      int[] eglAttributes = new int[] {
          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
          EGL_RED_SIZE, 8,
          EGL_GREEN_SIZE, 8,
          EGL_BLUE_SIZE, 8,
          EGL_ALPHA_SIZE, 8,
          EGL_DEPTH_SIZE, 0,
          EGL_CONFIG_CAVEAT, EGL_NONE,
          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
          EGL_NONE
      };
      EGLConfig[] configs = new EGLConfig[1];
      int[] numConfigs = new int[1];
      boolean eglChooseConfigSuccess = eglChooseConfig(display, eglAttributes, 0, configs, 0, 1,
          numConfigs, 0);
      Assertions.checkState(eglChooseConfigSuccess && numConfigs[0] > 0 && configs[0] != null,
          "eglChooseConfig failed");

      EGLConfig config = configs[0];
      int[] glAttributes;
      if (secure) {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_PROTECTED_CONTENT_EXT,
            EGL_TRUE, EGL_NONE};
      } else {
        glAttributes = new int[] {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE};
      }
      EGLContext context = eglCreateContext(display, config, android.opengl.EGL14.EGL_NO_CONTEXT,
          glAttributes, 0);
      Assertions.checkState(context != null, "eglCreateContext failed");

      int[] pbufferAttributes;
      if (secure) {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_PROTECTED_CONTENT_EXT, EGL_TRUE,
            EGL_NONE};
      } else {
        pbufferAttributes = new int[] {
            EGL_WIDTH, 1,
            EGL_HEIGHT, 1,
            EGL_NONE};
      }
      EGLSurface pbuffer = eglCreatePbufferSurface(display, config, pbufferAttributes, 0);
      Assertions.checkState(pbuffer != null, "eglCreatePbufferSurface failed");

      boolean eglMadeCurrent = eglMakeCurrent(display, pbuffer, pbuffer, context);
      Assertions.checkState(eglMadeCurrent, "eglMakeCurrent failed");

      glGenTextures(1, textureIdHolder, 0);
      surfaceTexture = new SurfaceTexture(textureIdHolder[0]);
      surfaceTexture.setOnFrameAvailableListener(this);
      surface = new DummySurface(this, surfaceTexture, secure);
    }

    private void releaseInternal() {
      try {
        surfaceTexture.release();
      } finally {
        surface = null;
        surfaceTexture = null;
        glDeleteTextures(1, textureIdHolder, 0);
      }
    }

  }

}>>>>>>> YOURS
